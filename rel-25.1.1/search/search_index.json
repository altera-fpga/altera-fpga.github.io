{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Altera FPGA Developer Site  <p>Welcome to the Altera FPGA Developer Site!</p> <p>This site provides key developer information for the Agilex\u2122, Stratix 10\u00ae, Cyclone\u00ae, and Arria\u00ae device families including:</p> <ul> <li>Documentation that explains how to use example designs and tutorials found in our altera-fpga GitHub site.</li> </ul> <ul> <li>Comprehensive software development resources including information on Linux, Zephyr, Baremetal drivers and software utilities.</li> </ul> <p> <p>Use the table below to help you get started.</p>    Software Developer FPGA Developer Application Developer          Take advantage of our software resources to develop a full stack solution for your applications:* Linux Drivers * Zephyr Drivers  * Baremetal Drivers  * Virtualization  * Host Attach Utilities Use our example design resources as a starting point for your own custom design or to learn more about a specific topic: * Example Designs Review our software utilities and higher level stack offerings:* Host Attach Utilities","text":""},{"location":"baremetal-embedded/agilex-5/e-series/premium/ug-baremetal-agx5e-premium/","title":"Baremetal Hello World Example for Agilex\u2122 5 Premium Development Kit","text":"<p>Note: This example is not availble in this release. Refer to https://altera-fpga.github.io/rel-25.1/baremetal-embedded/agilex-5/e-series/premium/ug-baremetal-agx5e-premium/ for the latest available version.</p>"},{"location":"common/templates/linux_driver_template/","title":"Host Attach DFL FPGA Management Engine IP Driver","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"common/templates/linux_driver_template/#introduction","title":"Introduction","text":"<p>This set of drivers is designed to support FME functionality, as implemented under FPGA Device Feature List (DFL) framework. It is used to expose FME capabilities.</p> Driver Mapping Source(s) Required for DFL dfl-fme.ko FPGA Management Engine IP drivers/fpga/ - dfl-fme.h, dfl-fme-main.c, dfl-fme-pr.c, dfl-fme-error.c, dfl-fme-perf.c Y dfl-fme-mgr.ko PR IP drivers/fpga/dfl-fme-mgr.c N dfl-fme-br.ko SW Dependency drivers/fpga/dfl-fme-br.c N dfl-fme-region.ko SW Dependency drivers/fpga/dfl-fme-region.c N <pre><code>graph TD;\n    A[dfl-fme]--&gt;B[dfl-fme-mgr];\n    A[dfl-fme]--&gt;C[dfl-fme-br];\n    A[dfl-fme]--&gt;D[dfl-fme-region]; </code></pre>"},{"location":"common/templates/linux_driver_template/#fpga-management-engine-ip","title":"FPGA Management Engine IP","text":"<p>The FPGA Management Engine IP provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA. Implementation of a PR region is optional.</p> <p>Each FME feature exposes its capability to host software drivers through a device feature header (DFH) register found at the beginning of its control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link. For more information about DFHs, refer to the Device Feature Header (DFH) structure.</p>"},{"location":"common/templates/linux_driver_template/#driver-sources","title":"Driver Sources","text":"<p>The source code for these drivers can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga, where branches labelled fpga-ofs-dev-*-lts correspond with the latest developmental versions of the DFL driver suite on that specific kernel version.</p>"},{"location":"common/templates/linux_driver_template/#driver-capabilities","title":"Driver Capabilities","text":"<p>This driver set is a DFL specific implementation of generic FPGA drivers available in the kernel. <code>dfl-fme-mgr</code> is a DFL specific instantiation of the generic FPGA manager (drivers/linux/fpga/fpga-mgr.c), <code>dfl-fme-br</code> builds on top of a generic FPGA bridge (drivers/fpga/fpga-bridge.c), and <code>dfl-fme-region</code> instantiates an FPGA region. All three supplementary DFL Drivers depend on <code>dfl-fme</code>.</p> <p>The DFL FME driver is a feature device implemented under the Device Feature List (DFL) framework. It enables the platform driver for the FME IP and implements all FPGA platform level management features. Only one FME is created per DFL based FPGA device. The DFL Bridge, Manager, and Region drivers are only required when attempting to configure a PR region in the FIM.</p>"},{"location":"common/templates/linux_driver_template/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_FME</p> <p></p> <p>FPGA_DFL_FME_MGR</p> <p></p> <p>FPGA_DFL_FME_BRIDGE</p> <p></p> <p>FPGA_DFL_FME_REGION</p> <p></p>"},{"location":"common/templates/linux_driver_template/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"common/templates/linux_driver_template/#example-designs","title":"Example Designs","text":"<p>The FPGA Management Engine IP is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"demos/agilex-3/c-series/armds-debug-linux/ug-armds-debug-linux-agx3/","title":"Debugging Linux with Arm Development Studio Tutorial Example Design: Agilex\u2122 3 FPGA and SoC C-Series Development Kit","text":""},{"location":"demos/agilex-3/c-series/armds-debug-linux/ug-armds-debug-linux-agx3/#introduction","title":"Introduction","text":"<p>Arm* Development Studio for Altera\u00ae SoC FPGAs is an Eclipse based tool suite enabling Arm* software development and debugging for Altera\u00ae FPGAs.</p> <p>This page demonstrates how to use Arm* Development Studio to debug the Linux kernel. For further information about the tool, go to Arm* Development Studio.</p>"},{"location":"demos/agilex-3/c-series/armds-debug-linux/ug-armds-debug-linux-agx3/#prerequisites","title":"Prerequisites","text":"<p>The following are needed:</p> <ul> <li>Altera\u00ae Agilex\u2122 3 FPGA and SoC C-Series Development Kit, ordering code DK-A3W135BM16AEA. Refer to board documentation for more information about the development kit.</li> </ul> <ul> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>Arm* Development Studio 2025.0-1</li> </ul> </li> </ul>"},{"location":"demos/agilex-3/c-series/armds-debug-linux/ug-armds-debug-linux-agx3/#build-linux","title":"Build Linux","text":"<p>For this example you need to build the Agilex\u2122 5 GHRD Linux Boot Example targeting the HPS Enablement board, as described here. </p> <p>The kernel compilation part of the boot example needs to be modified as follows:</p> <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake clean\nmake defconfig\n./scripts/config --set-val CONFIG_DEBUG_INFO y\n./scripts/config --set-val CONFIG_DEBUG_INFO_COMPRESSED_NONE y\n./scripts/config --set-val CONFIG_GDB_SCRIPTS y\n./scripts/config --disable CONFIG_DEBUG_INFO_REDUCED\n./scripts/config --disable CONFIG_DEBUG_INFO_BTF\nmake oldconfig\nmake -j 48 Image &amp;&amp; make intel/socfpga_agilex3_socdk.dtb\n</code></pre> <p>The changes achieve the following:</p> <ul> <li>Enabling the kernel debugging features required by the debugger.</li> <li>Build the kernel module used to demonstrate debugging modules.</li> </ul> <p>You also need to change the SD card build instructions to add the compiled kernel module null_blk.ko to the /home/root/ folder:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex3/core-image-minimal-agilex3.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\n</code></pre>"},{"location":"demos/agilex-3/c-series/armds-debug-linux/ug-armds-debug-linux-agx3/#debug-linux","title":"Debug Linux","text":"<p>1. Build the example. As mentioned above, only Linux kernel instructions need to be updated, the rest remains the same.</p> <p>2. Write the SD card and QSPI flash images and boot to Linux prompt</p> <p>3. Go to the folder where the example was built, add the Quartus\u00ae tools in the path:</p> <pre><code>cd $TOP_FOLDER\nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>4. Start Arm* DS Eclipse using a new workspace in the current folder:</p> <pre><code>cd $TOP_FOLDER\n/opt/arm/developmentstudio-2025.0-1/bin/suite_exec -t \"Arm Compiler for Embedded 6\" bash\narmds_ide -data workspace &amp;\n</code></pre> <p>5. Go to Run &gt; Debug Configurations</p> <p>6. Right click Generic Arm C/C++ Application and select New Configuration</p> <p></p> <p>7. Select the target as Intel SoC FPGA &gt; Agilex 3 &gt; Linux Kernel Debug &gt; Cortext-A76\\Cortex-A55 Multi-Cluster SMP. Select Target Connection as Intel FPGA Download Cable.</p> <p></p> <p>8. Click on the Connections Browse button, select your board connection, and click Select</p> <p></p> <p>9. Go to the Debugger tab, select Connect only, check Execute Debugger Commands and add the commands shown below. Also uncheck the Use default for the host working directory, and add the text shown below indicating working folder is the parent folder of the workspace folder:</p> <p></p> <p>10. Click the Debug button on the bottom of the Debug Configuration window. The debugger will connect to the board, stop the cores, add the symbols from the vmlinux elf file and you can start debugging the kernel:</p> <p></p> <p>11. Right-click on a CPU core and select Display Threads from the menu to see the threads:</p> <p></p> <p>12. Click on a thread and the context will update to show the source code of that thread with current PC highlighted in green, also local variables etc:</p> <p></p> <p>13. Go to Window &gt; Show View &gt; Functions to see all the functions:</p> <p></p> <p>14. The above were only examples of what you can do with the debugger. The tool offers a lot of other powerful capabilities to enable you to debug the Linux kernel. For more information refer to Arm* Development Studio.</p> <p>Important Note: The list of kernel versions fully validated with Arm DS can be found at this address: https://developer.arm.com/AboutOSAwareness. Using a kernel version which has not been validated with Arm DS may lead to reduced functionality, such as not being able to switch from core viewing mode to thread list.</p>"},{"location":"demos/agilex-3/c-series/armds-debug-u-boot/ug-armds-debug-uboot-agx3/","title":"Debugging U-Boot with Arm Development Studio Tutorial Example Design: Agilex\u2122 3 FPGA and SoC C-Series Development Kit","text":""},{"location":"demos/agilex-3/c-series/armds-debug-u-boot/ug-armds-debug-uboot-agx3/#introduction","title":"Introduction","text":"<p>Arm* Development Studio for Altera\u00ae SoC FPGAs is an Eclipse based tool suite enabling Arm* software development and debugging for Altera\u00ae FPGAs.</p> <p>This page demonstrates how to use Arm* Development Studio to debug U-Boot SPL and U-Boot. For further information about the tool, go to Arm Development Studio.</p>"},{"location":"demos/agilex-3/c-series/armds-debug-u-boot/ug-armds-debug-uboot-agx3/#prerequisites","title":"Prerequisites","text":"<p>The following are needed:</p> <ul> <li>Altera\u00ae Agilex\u2122 3 FPGA and SoC C-Series Development Kit, ordering code DK-A3W135BM16AEA. Refer to board documentation for more information about the development kit.</li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>Arm* Development Studio 2025.0-1</li> </ul> </li> </ul> <p>You will also need to compile the Agilex 3 GHRD Linux Boot Example targeting the HPS Enablement board, as described here. </p>"},{"location":"demos/agilex-3/c-series/armds-debug-u-boot/ug-armds-debug-uboot-agx3/#debug-u-boot","title":"Debug U-Boot","text":"<p>1. Build the example design specified in the Prerequisites section.</p> <p>2. Write the SD card image $TOP_FOLDER/sd_card/sdcard.img to the micro SD card and insert it on the slot on the HPS Enablement Board.</p> <p>3. Set MSEL dipswitch to JTAG, as specified in the design from the Prerequisites section, then power cycle the board. That will ensure the device is not configured from QSPI.</p> <p>4. Go to the folder where the example was built, add the Quartus\u00ae tools in the path:</p> <p><pre><code>cd $TOP_FOLDER\nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin\n</code></pre> 5. Configure the device with the 'debug' SOF, which contains an empty loop HPS FSBL, designed specifically for a debugger to connect afterwards:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"p;agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof@2\"\n</code></pre> <p>6. Start Arm* DS Eclipse using a new workspace in the current folder:</p> <pre><code>cd $TOP_FOLDER\n/opt/arm/developmentstudio-2025.0-1/bin/suite_exec -t \"Arm Compiler for Embedded 6\" bash\narmds_ide -data workspace &amp;\n</code></pre> <p>7. In Eclipse go to Run &gt; Debug Configurations then select the Generic Arm/C++ Application and select New launch configuration: </p> <p></p> <p>8. Change the Name of the configuration as Debug U-Boot. Select target as Altera SoC FPGA &gt; Agilex 3 &gt; Bare Metal Debug &gt; Cortex-A55_0. Select target connection as Altera FPGA Download Cable:</p> <p></p> <p>9. Click on the Connections &gt; Browse button and select the board connection, then click the Select button:</p> <p></p> <p>10. In the Debugger tab, select Connect Only, click Execute debugger commands and enter the desired debugging commands shown below. Also uncheck Use default for the Host working directory and enter the parent folder of the workspace: \"${workspace_loc}/../\" :</p> <p></p> <p>If you want to just load U-Boot SPL and start debugging it, enter the following debugging commands:</p> <pre><code>interrupt\nrestore \"u-boot-socfpga_sd/spl/u-boot-spl-dtb.bin\" binary 0x0\nloadfile \"u-boot-socfpga_sd/spl/u-boot-spl\"\nset $PC = 0x0\n</code></pre> <p>If you want to run U-Boot SPL to completion, up to the point where it decides what to load as next boot stage, add the following commands:</p> <pre><code>thb board_boot_order\ncontinue\nwait 60s\n</code></pre> <p>If after running U-Boot SPL to completion you want to load and run U-Boot, add the following commands:</p> <pre><code>set var $AARCH64::$Core::$X1 = 0\nset spl_boot_list[0]=0\nset $PC=$LR\nrestore \"u-boot-socfpga_sd/u-boot.itb\" binary 0x82000000\ncontinue\n</code></pre> <p>Instead, if you want to load U-Boot and start debugging it, replace the previous continue command with the following:</p> <pre><code>symbol-file \"u-boot-socfpga_sd/u-boot\" thb el2:relocate_code\ncontinue\nwait 60s\nsymbol-file \"u-boot-socfpga_sd/u-boot\" ((gd_t*)$x18)-&gt;reloc_off\nthb board_init_r\ncontinue\nwait 60s\n</code></pre> <p>11. Click on the Debug button at the bottom of the Debug Configurations window. Eclipse Arm* DS will connect to the board and execute the debugger instructions.</p> <p>If you opted to debug U-Boot SPL the window will look as below, showing U-Boot SPL stopped at its entry point:</p> <p></p> <p>If you opted to debug U-Boot, it will show it stopped at board_init_r, after the symbol relocation:</p> <p></p> <p>At this point, all the debugging features of Eclipse are available, such as:</p> <ul> <li>Viewing and editing variables and registers</li> <li>Setting breakpoints</li> </ul>"},{"location":"demos/agilex-3/c-series/riscfree-debug-linux/ug-riscfree-debug-linux-agx3/","title":"Debugging Linux with Ashling RiscFree Tutorial Example Design: Agilex\u2122 3 FPGA and SoC C-Series Development Kit","text":""},{"location":"demos/agilex-3/c-series/riscfree-debug-linux/ug-riscfree-debug-linux-agx3/#introduction","title":"Introduction","text":"<p>RiscFree* is Ashling\u2019s Eclipse* C/C++ Development Toolkit (CDT) based integrated development environment (IDE) for Altera\u00ae FPGAs Arm*-based HPS and RISC-V based Nios\u00ae V processors.</p> <p>This page demonstrates how to use RiscFree* to debug the Linux kernel, including a kernel module. For further information about RiscFree*, consult Ashling RiscFree* IDE for Altera\u00ae FPGAs User Guide.</p>"},{"location":"demos/agilex-3/c-series/riscfree-debug-linux/ug-riscfree-debug-linux-agx3/#prerequisites","title":"Prerequisites","text":"<p>The following are needed:</p> <ul> <li>Altera\u00ae Agilex\u2122 3 FPGA and SoC C-Series Development Kit, ordering code DK-A3W135BM16AEA. Refer to board documentation for more information about the development kit.</li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> </ul>"},{"location":"demos/agilex-3/c-series/riscfree-debug-linux/ug-riscfree-debug-linux-agx3/#build-linux","title":"Build Linux","text":"<p>For this example you need to build the Agilex 3 GHRD Linux Boot Example targeting the HPS Enablement board, as described here. </p> <p>The kernel compilation part of the boot example needs to be modified as follows:</p> <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake clean\nmake defconfig\n./scripts/config --set-val CONFIG_DEBUG_INFO y\n./scripts/config --set-val CONFIG_DEBUG_INFO_COMPRESSED_NONE y\n./scripts/config --set-val CONFIG_GDB_SCRIPTS y\n./scripts/config --disable CONFIG_DEBUG_INFO_REDUCED\n./scripts/config --disable CONFIG_DEBUG_INFO_BTF\n./scripts/config --set-val CONFIG_BLK_DEV_NULL_BLK m\nmake oldconfig\nmake -j 48 Image &amp;&amp; make intel/socfpga_agilex3_socdk.dtb\nmake -j 64 modules\n</code></pre> <p>The changes achieve the following:</p> <ul> <li>Enabling the kernel debugging features required by RiscFree*.</li> <li>Build the kernel module used to demonstrate debugging modules.</li> </ul> <p>You also need to change the SD card build instructions to add the compiled kernel module null_blk.ko to the /home/root/ folder:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex3/core-image-minimal-agilex3.rootfs.tar.gz\nsudo cp $TOP_FOLDER/linux-socfpga/drivers/block/null_blk/null_blk.ko home/root/\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\n</code></pre>"},{"location":"demos/agilex-3/c-series/riscfree-debug-linux/ug-riscfree-debug-linux-agx3/#debug-linux","title":"Debug Linux","text":"<p>1. Build the example. As mentioned above, only Linux kernel instructions need to be updated, the rest remains the same.</p> <p>2. Write the SD card and QSPI flash images and boot to Linux prompt</p> <p>3. Go to the folder where the example was built, add the Quartus\u00ae and RiscFree* tools in the path:</p> <pre><code>cd $TOP_FOLDER\nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$QUARTUS_ROOTDIR/../riscfree/RiscFree:$PATH\n</code></pre> <p>4. Start RiscFree* Eclipse using a new workspace in the current folder:</p> <pre><code>cd $TOP_FOLDER\nRiscFree -data workspace &amp;\n</code></pre> <p>7.  In Eclipse, go to File &gt; Import &gt; C/C++ Executable, then click Next.</p> <p></p> <p>8. Click Browse to select the vmlinux executable from where it was built in the project, then click Next</p> <p></p> <p>9. Change the New project name and Launch Configuration as \"Linux Kernel Debug\", select Ashling Heterogeneous Multicore Hardware Debug  from the drop down box, and click Finish:</p> <p></p> <p>10. The Debug Configurations window will be opened, with the Linux Kernel Debug configuration selected. If not automatically selected, select the Debug probe from the drop down list, then Auto-detect Scan Chain. Then check all the four Arm cores, to enable debugging for them. The window should look like this:</p> <p> </p> <p>11. Make sure just the A55 cores are marked as enabled, as the A76's are not available on Agilex 3.  Click on 0-Cortex-A55 core, and enter the following commands in the Commands section:</p> <pre><code>set remotetimeout 10\nset mem inaccessible-by-default on\nmem 0xffff000000000000 0xffff0003ffffffff rw\nmem 0xffff800000000000 0xffff802effffffff rw\n</code></pre> <p>The above are needed to specify a proper memory access attributes to avoid unwanted or illegal memory access during the debug session. </p> <p>z</p> <p>12. Go to Target Application tab. Click Add. The Browse Executable window appears. For Project, click Browse... and select the current project. For C/C ++ Application, click Browse... and select vmlinux as the executable. Click OK.</p> <p></p> <p>13. After adding the executable, ensure you turn off Load image as the image is already loaded to the target:</p> <p></p> <p>14. Go to Startup tab and ensure the configuration is as shown below:</p> <p></p> <p>If you have watchdog(s) enabled, you need to add the following instructions in the \"Run Commands\" section, in order to disable watchdog while debugging:</p> <pre><code>monitor memwrite APB:0x15c20140 0x03\nmonitor memwrite APB:0x15c20020 0x01\nmonitor memwrite APB:0x1580d000 0x01\nmonitor memwrite APB:0x1580d0b8 0x01\nmonitor memwrite APB:0x1580d0bc 0x01\nmonitor memwrite APB:0x1580d0c0 0x01\nmonitor memwrite APB:0x1580d0c4 0x01\nmonitor memwrite APB:0x1580d0c8 0x02\nmonitor memwrite APB:0x1580d0cc 0x02\nmonitor memwrite APB:0x1580d0d0 0x02\nmonitor memwrite APB:0x1580d0d4 0x02\nmonitor memwrite APB:0x1580d140 0x03\n</code></pre> <p>Note: The above commands will be performed automatically in a future version of RiscFree.</p> <p>15. Go to OS Awareness tab, and check Enable OS Aware Debugging, then select OS to be Linux and version to be 6.1.20 as shown below:</p> <p></p> <p>16. Click the Apply settings to other cores to apply the same settings to all the cores.</p> <p>17. Click Debug button at the bottom of the Debug Configurations window.</p> <p>18.  Eclipse will suggest to move to the debug perspective. Click Switch to accept: </p> <p></p> <p>19. Eclipse will show the Linux kernel stopped in the debugger:</p> <p></p> <p>20. Step through the code with F5 a few times, look at variables etc. You are now debugging the Linux kernel!</p> <p>21. Go to Linux &gt; Processes &gt; List Running Processes, and then the debugger shows the processes. You may need to click the Refresh view button on the window for the processes to show up.</p> <p></p> <p>22. Right-click a process in the list, then select the Watch option. </p> <p></p> <p>23. The debugger opens the process in the Expressions window. You can now inspect and modify its properties:</p> <p></p> <p>23. Let the code run by clicking on the root debug task on the left panel, then pressing F8. Then go to the board serial console and load the driver:</p> <pre><code>root@agilex3:~# insmod null_blk.ko [  962.062224] null_blk: disk nullb0 created\n[  962.066388] null_blk: module loaded\n</code></pre> <p>24. Break the execution in the debugger, by clicking the Suspend button. Then go to Linux &gt; Modules &gt; List loaded modules to see the module that was loaded:</p> <p></p> <p>25. Right click the module, and select the Watch option. This will open the module in the Expressions window, where it can be inspected:</p> <p></p> <p>26. Right click the module, and select Load module symbol</p> <p></p> <p>Then browse for the module object and click OK:</p> <p></p> <p>Now the module symbols are available, for example for setting breakpoints.</p>"},{"location":"demos/agilex-3/c-series/riscfree-debug-u-boot/ug-riscfree-debug-uboot-agx3/","title":"Debugging U-Boot with Ashling RiscFree Tutorial Example Design: Agilex\u2122 3 FPGA and SoC C-Series Development Kit","text":""},{"location":"demos/agilex-3/c-series/riscfree-debug-u-boot/ug-riscfree-debug-uboot-agx3/#introduction","title":"Introduction","text":"<p>RiscFree* is Ashling\u2019s Eclipse* C/C++ Development Toolkit (CDT) based integrated development environment (IDE) for Altera\u00ae FPGAs Arm*-based HPS and RISC-V based Nios\u00ae V processors.</p> <p>This page demonstrates how to use RiscFree* to debug U-Boot SPL and U-Boot.</p> <p>For further information about RiscFree*, consult Ashling RiscFree* IDE for Altera\u00ae FPGAs User Guide.</p>"},{"location":"demos/agilex-3/c-series/riscfree-debug-u-boot/ug-riscfree-debug-uboot-agx3/#prerequisites","title":"Prerequisites","text":"<p>The following are needed:</p> <ul> <li>Altera\u00ae Agilex\u2122 3 FPGA and SoC C-Series Development Kit, ordering code DK-A3W135BM16AEA. Refer to board documentation for more information about the development kit.</li> </ul> <ul> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> </ul> <p>You will also need to compile the Agilex 3 GHRD Linux Boot Example targeting the HPS Enablement board, as described here.</p>"},{"location":"demos/agilex-3/c-series/riscfree-debug-u-boot/ug-riscfree-debug-uboot-agx3/#debug-u-boot","title":"Debug U-Boot","text":"<p>1. Build the example design specified in the Prerequisites section.</p> <p>2. Write the SD card image $TOP_FOLDER/sd_card/sdcard.img to the micro SD card and insert it on the slot on the HPS Enablement Board.</p> <p>3. Set MSEL dipswitch to JTAG, as specified in the design from the Prerequisites section, then power cycle the board. That will ensure the device is not configured from QSPI.</p> <p>4. Go to the folder where the example was built, add the Quartus and RiscFree* tools in the path:</p> <p><pre><code>cd $TOP_FOLDER\nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$QUARTUS_ROOTDIR/../riscfree/RiscFree:$PATH\n</code></pre> 5. Configure the device with the 'debug' SOF, which contains an empty loop HPS FSBL, designed specifically for a debugger to connect afterwards:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"p;agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof@2\"\n</code></pre> <p>6. Start RiscFree* Eclipse using a new workspace in the current folder:</p> <pre><code>cd $TOP_FOLDER\nRiscFree -data workspace &amp;\n</code></pre> <p>7.  In Eclipse, go to Run &gt; Debug Configurations, this will open the Debug Configurations window.</p> <p>8. In the Debug Configurations window, select Ashling Arm Hardware Debugging on the left panel, right-click it then select New Configuration from the menu.</p> <p></p> <p>9. Edit the configuration as follows</p> <ul> <li>Change the Name to \"Debug U-Boot\"</li> <li>Go to the Debugger tab</li> <li>Select the Debug Probe from the drop down to match your board</li> <li>Click on the Auto-detect Scan Chain to discover the Arm cores</li> <li>Check the first Cortex-A55 in the list to enable debugging for it</li> </ul> <p>Note: Make sure not to target the A76 core(s) as they are not actually present in the Agilex 3 devices.</p> <p>The window will look similar to this:</p> <p></p> <p>10. Go to the Startup tab, and change the configuration as follows:</p> <ul> <li>Uncheck Load image</li> <li>Uncheck Load symbols</li> <li>Uncheck Set breakpoint at</li> <li>Uncheck Resume</li> </ul> <p>The window will look similar to this:</p> <p></p> <p>Then add in the Run Commands box the following commands that will enable you to load U-Boot SPL and start debugging it:</p> <pre><code>interrupt\ndelete breakpoints\nset breakpoint always-inserted on\nset mem inaccessible-by-default on\nmem 0x00000000 0x0007FFFF rw\nmem 0x80000000 0xFFFFFFFF rw\nmem 0x880000000 0xFFFFFFFFFF rw\nset confirm off\nrestore u-boot-socfpga_sd/spl/u-boot-spl-dtb.bin binary 0x0\nsymbol-file u-boot-socfpga_sd/spl/u-boot-spl\nset $pc=0x0\nstep\n</code></pre> <p>If you have watchdog(s) enabled, you also need to add the following instructions in the above sequence, between 'interrupt' and 'delete breakpoints' commands, in order to disable watchdog while debugging:</p> <pre><code>monitor memwrite APB:0x15c20140 0x03\nmonitor memwrite APB:0x15c20020 0x01\nmonitor memwrite APB:0x1580d000 0x01\nmonitor memwrite APB:0x1580d0b8 0x01\nmonitor memwrite APB:0x1580d0bc 0x01\nmonitor memwrite APB:0x1580d0c0 0x01\nmonitor memwrite APB:0x1580d0c4 0x01\nmonitor memwrite APB:0x1580d0c8 0x02\nmonitor memwrite APB:0x1580d0cc 0x02\nmonitor memwrite APB:0x1580d0d0 0x02\nmonitor memwrite APB:0x1580d0d4 0x02\nmonitor memwrite APB:0x1580d140 0x03\n</code></pre> <p>Note: The above commands will be performed automatically in a future version of RiscFree.</p> <p>If you want to run U-Boot SPL up to where it decides which image to load next, add the following lines to the previous step:</p> <pre><code>thb board_boot_order\ncontinue\n</code></pre> <p>If then you want to load U-Boot and start debugging it, add the following lines to the previous step, which will load U-Boot, run it until the memory is relocated, perform the relocation, then drop to debugging mode</p> <pre><code>delete breakpoints\nset spl_boot_list[0]=0\nset $pc=$lr\nset $x0=0\nrestore u-boot-socfpga_sd/u-boot.itb binary 0x82000000\nsymbol-file \"u-boot-socfpga_sd/u-boot\" thb relocate_code\ncontinue\ndelete breakpoints\nset $offset = ((gd_t*)$x18)-&gt;reloc_off\nsymbol-file\nadd-symbol-file u-boot-socfpga_sd/u-boot -o $offset\nthb board_init_r\ncontinue\n</code></pre> <p>If you only want to run U-Boot, without debugging it, then remove the \"thb board_init_r\" from the above script, so it would not stop at the beginning of U-Boot, and instead continue running it.</p> <p>11. Click the Debug button on the bottom of the window. Eclipse will warn that the program file was not specified. Click Yes to proceed with the launch.</p> <p></p> <p>12. Eclipse will suggest to move to the debug perspective. Click Switch to accept:</p> <p></p> <p>13. Eclipse will then run the specified sequence of instructions. </p> <p>When the instructions for debugging U-Boot SPL were used, after running them, Eclipse will show the U-Boot SPL started:</p> <p></p> <p>When the instructions for debugging U-Boot were used, after running them, Eclipse will show the U-Boot started:</p> <p></p> <p>At this point, all the debugging features of Eclipse are available, such as:</p> <ul> <li>Viewing and editing variables and registers</li> <li>Setting breakpoints</li> <li>Controlling execution: run step by step, step into functions </li> </ul>"},{"location":"demos/agilex-5/e-series/premium/armds-debug-linux/ug-armds-debug-linux-agx5e-premium/","title":"Debugging Linux with Arm Development Studio Tutorial Example Design: Agilex\u2122 5 Premium Development Kit","text":""},{"location":"demos/agilex-5/e-series/premium/armds-debug-linux/ug-armds-debug-linux-agx5e-premium/#introduction","title":"Introduction","text":"<p>Arm* Development Studio for Altera\u00ae SoC FPGAs is an Eclipse based tool suite enabling Arm* software development and debugging for Altera\u00ae FPGAs.</p> <p>This page demonstrates how to use Arm* Development Studio to debug the Linux kernel. For further information about the tool, go to Arm* Development Studio.</p>"},{"location":"demos/agilex-5/e-series/premium/armds-debug-linux/ug-armds-debug-linux-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are needed:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK A5E065BB32AES1, with the HPS Enablement Board. Refer to Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit for information about the development kit.</li> </ul> <ul> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>Arm* Development Studio 2024.1 or 2024.1-1</li> </ul> </li> </ul>"},{"location":"demos/agilex-5/e-series/premium/armds-debug-linux/ug-armds-debug-linux-agx5e-premium/#build-linux","title":"Build Linux","text":"<p>For this example you need to build the Agilex\u2122 5 GHRD Linux Boot Example targeting the HPS Enablement board, as described here. </p> <p>The kernel compilation part of the boot example needs to be modified as follows:</p> <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake clean\nmake defconfig\n./scripts/config --set-val CONFIG_DEBUG_INFO y\n./scripts/config --set-val CONFIG_DEBUG_INFO_COMPRESSED_NONE y\n./scripts/config --set-val CONFIG_GDB_SCRIPTS y\n./scripts/config --disable CONFIG_DEBUG_INFO_REDUCED\n./scripts/config --disable CONFIG_DEBUG_INFO_BTF\n./scripts/config --set-val CONFIG_BLK_DEV_NULL_BLK m\nmake oldconfig\nmake -j 48 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb\nmake -j 64 modules\n</code></pre> <p>The changes achieve the following:</p> <ul> <li>Enabling the kernel debugging features required by the debugger.</li> <li>Build the kernel module used to demonstrate debugging modules.</li> </ul> <p>You also need to change the SD card build instructions to add the compiled kernel module null_blk.ko to the /home/root/ folder:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\nsudo cp $TOP_FOLDER/linux-socfpga/drivers/block/null_blk/null_blk.ko home/root/\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\n</code></pre>"},{"location":"demos/agilex-5/e-series/premium/armds-debug-linux/ug-armds-debug-linux-agx5e-premium/#debug-linux","title":"Debug Linux","text":"<p>1. Build the example. As mentioned above, only Linux kernel instructions need to be updated, the rest remains the same.</p> <p>2. Write the SD card and QSPI flash images and boot to Linux prompt</p> <p>3. Go to the folder where the example was built, add the Quartus\u00ae tools in the path:</p> <pre><code>cd $TOP_FOLDER\nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>4. Start Arm* DS Eclipse using a new workspace in the current folder:</p> <pre><code>cd $TOP_FOLDER\n/opt/arm/developmentstudio-2024.1/bin/suite_exec -t \"Arm Compiler for Embedded 6\" bash\narmds_ide -data workspace &amp;\n</code></pre> <p>5. Go to Run &gt; Debug Configurations</p> <p>6. Right click Generic Arm C/C++ Application and select New Configuration</p> <p></p> <p>7. Select the target as Intel SoC FPGA &gt; Agilex 5 &gt; Linux Kernel Debug &gt; Cortext-A76\\Cortex-A55 Multi-Cluster SMP. Select Target Connection as Intel FPGA Download Cable.</p> <p></p> <p>8. Click on the Connections Browse button, select your board connection, and click Select</p> <p></p> <p>9. Go to the Debugger tab, select Connect only, check Execute Debugger Commands and add the commands shown below. Also uncheck the Use default for the host working directory, and add the text shown below indicating working folder is the parent folder of the workspace folder:</p> <p></p> <p>10. Click the Debug button on the bottom of the Debug Configuration window. The debugger will connect to the board, stop the cores, add the symbols from the vmlinux elf file and you can start debugging the kernel:</p> <p></p> <p>11. Right-click on a CPU core and select Display Threads from the menu to see the threads:</p> <p></p> <p>12. Click on a thread and the context will update to show the source code of that thread with current PC highlighted in green, also local variables etc:</p> <p></p> <p>13. Go to Window &gt; Show View &gt; Functions to see all the functions:</p> <p></p> <p>14. The above were only examples of what you can do with the debugger. The tool offers a lot of other powerful capabilities to enable you to debug the Linux kernel. For more information refer to Arm* Development Studio.</p> <p>Important Note: The list of kernel versions fully validated with Arm DS can be found at this address: https://developer.arm.com/AboutOSAwareness. Using a kernel version which has not been validated with Arm DS may lead to reduced functionality, such as not being able to switch from core viewing mode to thread list.</p>"},{"location":"demos/agilex-5/e-series/premium/armds-debug-uboot/ug-armds-debug-uboot-agx5e-premium/","title":"Debugging U-Boot with Arm Development Studio Tutorial Example Design: Agilex\u2122 5 Premium Development Kit","text":""},{"location":"demos/agilex-5/e-series/premium/armds-debug-uboot/ug-armds-debug-uboot-agx5e-premium/#introduction","title":"Introduction","text":"<p>Arm* Development Studio for Altera\u00ae SoC FPGAs is an Eclipse based tool suite enabling Arm* software development and debugging for Altera\u00ae FPGAs.</p> <p>This page demonstrates how to use Arm* Development Studio to debug U-Boot SPL and U-Boot. For further information about the tool, go to Arm Development Studio.</p>"},{"location":"demos/agilex-5/e-series/premium/armds-debug-uboot/ug-armds-debug-uboot-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are needed:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK A5E065BB32AES1, with the HPS Enablement Board. Refer to Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit for information about the development kit.</li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>Arm Development Studio 2024.1 or 2024.1-1</li> </ul> </li> </ul> <p>You will also need to compile the Agilex 5 GHRD Linux Boot Example targeting the HPS Enablement board, as described here. </p>"},{"location":"demos/agilex-5/e-series/premium/armds-debug-uboot/ug-armds-debug-uboot-agx5e-premium/#debug-u-boot","title":"Debug U-Boot","text":"<p>1. Build the example design specified in the Prerequisites section.</p> <p>2. Write the SD card image $TOP_FOLDER/sd_card/sdcard.img to the micro SD card and insert it on the slot on the HPS Enablement Board.</p> <p>3. Set MSEL dipswitch to JTAG, as specified in the design from the Prerequisites section, then power cycle the board. That will ensure the device is not configured from QSPI.</p> <p>4. Go to the folder where the example was built, add the Quartus\u00ae tools in the path:</p> <p><pre><code>cd $TOP_FOLDER\nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin\n</code></pre> 5. Configure the device with the 'debug' SOF, which contains an empty loop HPS FSBL, designed specifically for a debugger to connect afterwards:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"p;agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof\"\n</code></pre> <p>6. Start Arm* DS Eclipse using a new workspace in the current folder:</p> <pre><code>cd $TOP_FOLDER\n/opt/arm/developmentstudio-2024.1/bin/suite_exec -t \"Arm Compiler for Embedded 6\" bash\narmds_ide -data workspace &amp;\n</code></pre> <p>7. In Eclipse go to Run &gt; Debug Configurations then select the Generic Arm/C++ Application and select New launch configuration: </p> <p></p> <p>8. Change the Name of the configuration as Debug U-Boot. Select target as Intel SoC FPGA &gt; Agilex 5 &gt; Bare Metal Debug &gt; Cortex-A55_0. Select target connection as Intel FPGA Download Cable:</p> <p></p> <p>9. Click on the Connections &gt; Browse button and select the board connection, then click the Select button:</p> <p></p> <p>10. In the Debugger tab, select Connect Only, click Execute debugger commands and enter the desired debugging commands shown below. Also uncheck Use default for the Host working directory and enter the parent folder of the workspace: \"${workspace_loc}/../\" :</p> <p></p> <p>If you want to just load U-Boot SPL and start debugging it, enter the following debugging commands:</p> <pre><code>interrupt\nrestore \"u-boot-socfpga/spl/u-boot-spl-dtb.bin\" binary 0x0\nloadfile \"u-boot-socfpga/spl/u-boot-spl\"\nset $PC = 0x0\n</code></pre> <p>If you want to run U-Boot SPL to completion, up to the point where it decides what to load as next boot stage, add the following commands:</p> <pre><code>thb board_boot_order\ncontinue\nwait 60s\n</code></pre> <p>If after running U-Boot SPL to completion you want to load and run U-Boot, add the following commands:</p> <pre><code>set var $AARCH64::$Core::$X1 = 0\nset spl_boot_list[0]=0\nset $PC=$LR\nrestore \"u-boot-socfpga/u-boot.itb\" binary 0x82000000\ncontinue\n</code></pre> <p>Instead, if you want to load U-Boot and start debugging it, replace the previous continue command with the following:</p> <pre><code>symbol-file \"u-boot-socfpga/u-boot\" thb el2:relocate_code\ncontinue\nwait 60s\nsymbol-file \"u-boot-socfpga/u-boot\" ((gd_t*)$x18)-&gt;reloc_off\nthb board_init_r\ncontinue\nwait 60s\n</code></pre> <p>11. Click on the Debug button at the bottom of the Debug Configurations window. Eclipse Arm* DS will connect to the board and execute the debugger instructions.</p> <p>If you opted to debug U-Boot SPL the window will look as below, showing U-Boot SPL stopped at its entry point:</p> <p></p> <p>If you opted to debug U-Boot, it will show it stopped at board_init_r, after the symbol relocation:</p> <p></p> <p>At this point, all the debugging features of Eclipse are available, such as:</p> <ul> <li>Viewing and editing variables and registers</li> <li>Setting breakpoints</li> </ul> <p>Note: Current Arm* DS 2024.1 release has an issue in that stepping through U-Boot code leads to an U-Boot exception and crash. You can set breakpoints, run up to them, look at variables, resume execution etc. Just stepping through the code causes the error. The issue does not happen when stepping through the U-Boot SPL.</p>"},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-linux/ug-riscfree-debug-linux-agx5e-premium/","title":"Debugging Linux with Ashling RiscFree Tutorial Example Design: Agilex\u2122 5 Premium Development Kit","text":""},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-linux/ug-riscfree-debug-linux-agx5e-premium/#introduction","title":"Introduction","text":"<p>RiscFree* is Ashling\u2019s Eclipse* C/C++ Development Toolkit (CDT) based integrated development environment (IDE) for Altera\u00ae FPGAs Arm*-based HPS and RISC-V based Nios\u00ae V processors.</p> <p>This page demonstrates how to use RiscFree* to debug the Linux kernel.</p> <p>For further information about RiscFree*, consult Ashling RiscFree* IDE for Altera\u00ae FPGAs User Guide.</p>"},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-linux/ug-riscfree-debug-linux-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are needed:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK A5E065BB32AES1, with the HPS Enablement Board. Refer to Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit for information about the development kit.</li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> </ul>"},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-linux/ug-riscfree-debug-linux-agx5e-premium/#build-linux","title":"Build Linux","text":"<p>For this example you need to build the Agilex 5 GHRD Linux Boot Example targeting the HPS Enablement board, as described here. </p> <p>The kernel compilation part of the boot example needs to be modified as follows:</p> <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake clean\nmake defconfig\n./scripts/config --set-val CONFIG_DEBUG_INFO y\n./scripts/config --set-val CONFIG_DEBUG_INFO_COMPRESSED_NONE y\n./scripts/config --set-val CONFIG_GDB_SCRIPTS y\n./scripts/config --disable CONFIG_DEBUG_INFO_REDUCED\n./scripts/config --disable CONFIG_DEBUG_INFO_BTF\n./scripts/config --set-val CONFIG_BLK_DEV_NULL_BLK m\nmake oldconfig\nmake -j 48 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb\nmake -j 64 modules\n</code></pre> <p>The changes achieve the following:</p> <ul> <li>Enabling the kernel debugging features required by RiscFree*.</li> <li>Build the kernel module used to demonstrate debugging modules.</li> </ul> <p>You also need to change the SD card build instructions to add the compiled kernel module null_blk.ko to the /home/root/ folder:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\nsudo cp $TOP_FOLDER/linux-socfpga/drivers/block/null_blk/null_blk.ko home/root/\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\n</code></pre>"},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-linux/ug-riscfree-debug-linux-agx5e-premium/#debug-linux","title":"Debug Linux","text":"<p>1. Build the example. As mentioned above, only Linux kernel instructions need to be updated, the rest remains the same.</p> <p>2. Write the SD card and QSPI flash images and boot to Linux prompt</p> <p>3. Go to the folder where the example was built, add the Quartus\u00ae and RiscFree* tools in the path:</p> <pre><code>cd $TOP_FOLDER\nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$QUARTUS_ROOTDIR/../riscfree/RiscFree:$PATH\n</code></pre> <p>4. Start RiscFree* Eclipse using a new workspace in the current folder:</p> <pre><code>cd $TOP_FOLDER\nRiscFree -data workspace &amp;\n</code></pre> <p>7.  In Eclipse, go to File &gt; Import &gt; C/C++ Executable, then click Next.</p> <p></p> <p>8. Click Browse to select the vmlinux executable from where it was built in the project, then click Next</p> <p></p> <p>9. Change the New project name and Launch Configuration as \"Linux Kernel Debug\", select Ashling Heterogeneous Multicore Hardware Debug  from the drop down box, and click Finish:</p> <p></p> <p>10. The Debug Configurations window will be opened, with the Linux Kernel Debug configuration selected. If not automatically selected, select the Debug probe from the drop down list, then Auto-detect Scan Chain. Then check all the four Arm cores, to enable debugging for them. The window should look like this:</p> <p> </p> <p>11. Click on 0-Cortex-A55 core, and enter the following commands in the Commands section:</p> <pre><code>set remotetimeout 10\nset mem inaccessible-by-default on\nmem 0xffff000000000000 0xffff0003ffffffff rw\nmem 0xffff800000000000 0xffff802effffffff rw\n</code></pre> <p>The above are needed to specify a proper memory access attributes to avoid unwanted or illegal memory access during the debug session. </p> <p>z</p> <p>12. Go to Target Application tab. Click Add. The Browse Executable window appears. For Project, click Browse... and select the current project. For C/C ++ Application, click Browse... and select vmlinux as the executable. Click OK.</p> <p></p> <p>13. After adding the executable, ensure you turn off Load image as the image is already loaded to the target:</p> <p></p> <p>14. Go to Startup tab and ensure the configuration is as shown below:</p> <p></p> <p>If you have watchdog(s) enabled, you need to add the following instructions in the \"Run Commands\" section, in order to disable watchdog while debugging:</p> <pre><code>monitor memwrite APB:0x15c20140 0x03\nmonitor memwrite APB:0x15c20020 0x01\nmonitor memwrite APB:0x1580d000 0x01\nmonitor memwrite APB:0x1580d0b8 0x01\nmonitor memwrite APB:0x1580d0bc 0x01\nmonitor memwrite APB:0x1580d0c0 0x01\nmonitor memwrite APB:0x1580d0c4 0x01\nmonitor memwrite APB:0x1580d0c8 0x02\nmonitor memwrite APB:0x1580d0cc 0x02\nmonitor memwrite APB:0x1580d0d0 0x02\nmonitor memwrite APB:0x1580d0d4 0x02\nmonitor memwrite APB:0x1580d140 0x03\n</code></pre> <p>Note: The above commands will be performed automatically in a future version of RiscFree.</p> <p>15. Go to OS Awareness tab, and check Enable OS Aware Debugging, then select OS to be Linux and version to be 6.1.20 as shown below:</p> <p></p> <p>16. Click the Apply settings to other cores to apply the same settings to all the cores.</p> <p>17. Click Debug button at the bottom of the Debug Configurations window.</p> <p>18.  Eclipse will suggest to move to the debug perspective. Click Switch to accept: </p> <p></p> <p>19. Eclipse will show the Linux kernel stopped in the debugger:</p> <p></p> <p>20. Step through the code with F5 a few times, look at variables etc. You are now debugging the Linux kernel!</p> <p>21. Go to Linux &gt; Processes &gt; List Running Processes, and then the debugger shows the processes. You may need to click the Refresh view button on the window for the processes to show up.</p> <p></p> <p>22. Right-click a process in the list, then select the Watch option. </p> <p></p> <p>23. The debugger opens the process in the Expressions window. You can now inspect and modify its properties:</p> <p></p> <p>23. Let the code run by clicking on the root debug task on the left panel, then pressing F8. Then go to the board serial console and load the driver:</p> <pre><code>root@agilex5_dk_a5e065bb32aes1:~# insmod null_blk.ko [  962.062224] null_blk: disk nullb0 created\n[  962.066388] null_blk: module loaded\n</code></pre> <p>24. Break the execution in the debugger, by clicking the Suspend button. Then go to Linux &gt; Modules &gt; List loaded modules to see the module that was loaded:</p> <p></p> <p>25. Right click the module, and select the Watch option. This will open the module in the Expressions window, where it can be inspected:</p> <p></p> <p>26. Right click the module, and select Load module symbol</p> <p></p> <p>Then browse for the module object and click OK:</p> <p></p> <p>Now the module symbols are available, for example for setting breakpoints.</p>"},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-u-boot/ug-riscfree-debug-uboot-agx5e-premium/","title":"Debugging U-Boot with Ashling RiscFree Tutorial Example Design: Agilex\u2122 5 Premium Development Kit","text":""},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-u-boot/ug-riscfree-debug-uboot-agx5e-premium/#introduction","title":"Introduction","text":"<p>RiscFree* is Ashling\u2019s Eclipse* C/C++ Development Toolkit (CDT) based integrated development environment (IDE) for Altera\u00ae FPGAs Arm*-based HPS and RISC-V based Nios\u00ae V processors.</p> <p>This page demonstrates how to use RiscFree* to debug U-Boot SPL and U-Boot.</p> <p>For further information about RiscFree*, consult Ashling RiscFree* IDE for Altera\u00ae FPGAs User Guide.</p>"},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-u-boot/ug-riscfree-debug-uboot-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are needed:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK A5E065BB32AES1, with the HPS Enablement Board. Refer to Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit for information about the development kit.</li> </ul> <ul> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> </ul> <p>You will also need to compile the Agilex 5 GHRD Linux Boot Example targeting the HPS Enablement board, as described here. </p>"},{"location":"demos/agilex-5/e-series/premium/riscfree-debug-u-boot/ug-riscfree-debug-uboot-agx5e-premium/#debug-u-boot","title":"Debug U-Boot","text":"<p>1. Build the example design specified in the Prerequisites section.</p> <p>2. Write the SD card image $TOP_FOLDER/sd_card/sdcard.img to the micro SD card and insert it on the slot on the HPS Enablement Board.</p> <p>3. Set MSEL dipswitch to JTAG, as specified in the design from the Prerequisites section, then power cycle the board. That will ensure the device is not configured from QSPI.</p> <p>4. Go to the folder where the example was built, add the Quartus and RiscFree* tools in the path:</p> <p><pre><code>cd $TOP_FOLDER\nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$QUARTUS_ROOTDIR/../riscfree/RiscFree:$PATH\n</code></pre> 5. Configure the device with the 'debug' SOF, which contains an empty loop HPS FSBL, designed specifically for a debugger to connect afterwards:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"p;agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof\"\n</code></pre> <p>6. Start RiscFree* Eclipse using a new workspace in the current folder:</p> <pre><code>cd $TOP_FOLDER\nRiscFree -data workspace &amp;\n</code></pre> <p>7.  In Eclipse, go to Run &gt; Debug Configurations, this will open the Debug Configurations window.</p> <p>8. In the Debug Configurations window, select Ashling Arm Hardware Debugging on the left panel, right-click it then select New Configuration from the menu.</p> <p></p> <p>9. Edit the configuration as follows</p> <ul> <li>Change the Name to \"Debug U-Boot\"</li> <li>Go to the Debugger tab</li> <li>Select the Debug Probe from the drop down to match your board</li> <li>Click on the Auto-detect Scan Chain to discover the Arm cores</li> <li>Check the first Cortex-A55 in the list to enable debugging for it</li> </ul> <p>The window will look similar to this:</p> <p></p> <p>10. Go to the Startup tab, and change the configuration as follows:</p> <ul> <li>Uncheck Load image</li> <li>Uncheck Load symbols</li> <li>Uncheck Set breakpoint at</li> <li>Uncheck Resume</li> </ul> <p>The window will look similar to this:</p> <p></p> <p>Then add in the Run Commands box the following commands that will enable you to load U-Boot SPL and start debugging it:</p> <pre><code>interrupt\ndelete breakpoints\nset breakpoint always-inserted on\nset mem inaccessible-by-default on\nmem 0x00000000 0x0007FFFF rw\nmem 0x80000000 0xFFFFFFFF rw\nmem 0x880000000 0xFFFFFFFFFF rw\nset confirm off\nrestore u-boot-socfpga/spl/u-boot-spl-dtb.bin binary 0x0\nsymbol-file u-boot-socfpga/spl/u-boot-spl\nset $pc=0x0\nstep\n</code></pre> <p>If you have watchdog(s) enabled, you also need to add the following instructions in the above sequence, between 'interrupt' and 'delete breakpoints' commands, in order to disable watchdog while debugging:</p> <pre><code>monitor memwrite APB:0x15c20140 0x03\nmonitor memwrite APB:0x15c20020 0x01\nmonitor memwrite APB:0x1580d000 0x01\nmonitor memwrite APB:0x1580d0b8 0x01\nmonitor memwrite APB:0x1580d0bc 0x01\nmonitor memwrite APB:0x1580d0c0 0x01\nmonitor memwrite APB:0x1580d0c4 0x01\nmonitor memwrite APB:0x1580d0c8 0x02\nmonitor memwrite APB:0x1580d0cc 0x02\nmonitor memwrite APB:0x1580d0d0 0x02\nmonitor memwrite APB:0x1580d0d4 0x02\nmonitor memwrite APB:0x1580d140 0x03\n</code></pre> <p>Note: The above commands will be performed automatically in a future version of RiscFree.</p> <p>If you want to run U-Boot SPL up to where it decides which image to load next, add the following lines to the previous step:</p> <pre><code>thb board_boot_order\ncontinue\n</code></pre> <p>If then you want to load U-Boot and start debugging it, add the following lines to the previous step, which will load U-Boot, run it until the memory is relocated, perform the relocation, then drop to debugging mode</p> <pre><code>delete breakpoints\nset spl_boot_list[0]=0\nset $pc=$lr\nset $x0=0\nrestore u-boot-socfpga/u-boot.itb binary 0x82000000\nsymbol-file \"u-boot-socfpga/u-boot\" thb relocate_code\ncontinue\ndelete breakpoints\nset $offset = ((gd_t*)$x18)-&gt;reloc_off\nsymbol-file\nadd-symbol-file u-boot-socfpga/u-boot -o $offset\nthb board_init_r\ncontinue\n</code></pre> <p>If you only want to run U-Boot, without debugging it, then remove the \"thb board_init_r\" from the above script, so it would not stop at the beginning of U-Boot, and instead continue running it.</p> <p>11. Click the Debug button on the bottom of the window. Eclipse will warn that the program file was not specified. Click Yes to proceed with the launch.</p> <p></p> <p>12. Eclipse will suggest to move to the debug perspective. Click Switch to accept:</p> <p></p> <p>13. Eclipse will then run the specified sequence of instructions. </p> <p>When the instructions for debugging U-Boot SPL were used, after running them, Eclipse will show the U-Boot SPL started:</p> <p></p> <p>When the instructions for debugging U-Boot were used, after running them, Eclipse will show the U-Boot started:</p> <p></p> <p>At this point, all the debugging features of Eclipse are available, such as:</p> <ul> <li>Viewing and editing variables and registers</li> <li>Setting breakpoints</li> <li>Controlling execution: run step by step, step into functions </li> </ul>"},{"location":"doc_modules/Notices_%26_Disclaimers/","title":"Notices & Disclaimers","text":""},{"location":"doc_modules/Notices_%26_Disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"driver-list/driver-list-all/","title":"All Drivers, Altera Driver","text":"<p>This table comprehensively lists all Altera drivers available for Agilex 3, Agilex 5 and Agilex 7. </p> <p>You can filter your search by entering your query into any number of available columns.</p> <ul> <li>The Name column indicate the name of the IP that the driver supports.</li> <li>If a driver exists then a link to a driver page is provided for more details. N/A means driver support \"Not Available\" for the particular IP.</li> </ul> IP Name Linux Driver Zephyr Driver Altera 16550 Compatible UART Core Linux Zephyr Altera Hardware Monitor Linux N/A Clock Manager Linux Zephyr Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) N/A PSCI Device Feature List (DFL) Capability Linux N/A DFL Accelerator Functional Unit (AFU workload) Linux N/A DFL FPGA Management Engine IP Linux N/A DFL Memory Interface/Subsystem Linux N/A DFL Time of Day Clock Intel FPGA IP Linux: Host Attach TOD Linux: Embedded TOD N/A Direct Memory Access Controller (DMAC) Linux Zephyr Error Detection and Correction (EDAC) Linux N/A Ethernet Media Access Controller Linux N/A Ethernet Subsystem (HSSI SS) Linux N/A Ethernet Subsystem Intel FPGA IP (HSSI xTile) Linux N/A Ethernet 1588 PTP Time of Day Clock Linux N/A General Purpose Timers Linux N/A Generic Serial Flash Interface Intel FPGA IP Linux N/A GPIO Linux Zephyr I2C Linux N/A I3C Linux N/A Interrupt Controller (GICv3) Linux Agilex 5   Agilex 7 Microchip\u00ae Zarlink ZL30793 Network Synchronizer Linux N/A MSGDMA Linux N/A NAND Controller Linux N/A PCIe Subsystem Linux N/A QSPI Linux Zephyr QSFP Linux N/A Reset Manager Linux Zephyr Single Error Upset (SEU) N/A Zephyr SD/eMMC Controller Linux N/A SMMU Linux N/A SPI Linux N/A System Manager Linux N/A Timer N/A Zephyr UART Linux N/A USB 2.0 OTG Linux N/A Watchdog Timer Linux Zephyr"},{"location":"driver-list/driver-list-baremetal/","title":"Baremetal Drivers","text":"<p>Note: This page is not availble in this release. Refer to https://altera-fpga.github.io/rel-25.1/driver-list_baremetal/ for the latest available version.</p>"},{"location":"driver-list/driver-list-linux/","title":"Linux Drivers","text":"<p>The table below provides a comprehensive list of the drivers available for Agilex\u2122  3, Agilex\u2122  5 and Agilex\u2122  7.</p> <ul> <li>IP Name column indicates what type of IP the driver targets.  </li> <li>HPS or PCIe column indicates if the driver is targeting the embedded Host Processor System found on our devices or a server host or both.</li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) HPS or PCIe Host Documentation Upstream Status Kernel Source Altera 16550 Compatible UART Core Agilex 7 PCIe UART Yes 8250_dfl Altera Hardware Monitor Agilex 3Agilex 5Agilex 7 HPS Hardware Monitor No Hwmon driver Clock Manager Agilex 3Agilex 5 HPS Clock Manager No clk_agilex5 Device Feature List (DFL) Capability Agilex 7Stratix 10 PCIe dfl Yes dfl DFL Accelerator Functional Unit (AFU workload) Agilex 7Stratix 10 PCIe dfl-afu Yes dfl-afu-dma-region dfl-afu-error dfl-afu-region dfl-afu-main DFL FPGA Management Engine IP Agilex 7Stratix 10 PCIe dfl-fme Yes dfl-fme-mgr dfl-fme-br dfl-fme-region DFL Memory Interface/Subsystem Agilex 7Stratix 10 PCIe Memory Yes dfl-emif Direct Memory Access Controller (DMAC) Agilex 3Agilex 5 HPS DMAC Yes dmac Error Detection and Correction (EDAC) Agilex 3Agilex 5 HPS EDAC Yes altera_edac Ethernet 1588 PTP Time of Day Clock Agilex 7 HPS/PCIe PCIe Attach ToD Embedded ToD Yes ToD PCIe-Attach driver ToD Embedded driver Ethernet Media Access Controller Agilex 3Agilex 5 HPS EMAC No dwxgmac2_core Ethernet Subsystem Intel FPGA IP (MAC-Specific) Agilex 7 HPS HSSI No intel_fpga_hssiss Ethernet Subsystem Intel FPGA IP (Tile-Specific) Agilex 7 HPS hssi_xtile No eth_main etile_fec etile_driver etile_ethtool ftile_ethtool ftile_fec ftile_driver General Purpose Timers Agilex 3Agilex 5Agilex 7 HPS GP Timers Yes dw_apb_timer Generic Serial Flash Interface Intel FPGA IP Agilex 7Stratix 10 PCIe Generic Serial Flash Yes spi General Purpose I/O (GPIO) Agilex 3Agilex 5Agilex 7 HPS gpio Yes gpio-dwapb I2C Agilex 3Agilex 5Agilex 7 HPS I2C Yes I2c driver I3C Agilex 3Agilex 5 HPS I3C Yes I3c driver Interrupt Controller (GICv3) Agilex 3Agilex 5 HPS GICv3 Yes GICv3 driver Microchip\u00ae Zarlink ZL30793 Network Synchronizer Agilex 7 HPS Zarlink No Zarlink driver MSGDMA Agilex 7 HPS MSGDMA No MSGDMA driver NAND Controller Agilex 3Agilex 5 HPS NAND Yes cadence-nand-controller PCIe Subsystem Agilex 7 PCIe PCIe Subsystem Yes dfl-pcie QSFP Agilex 7 HPS QSFP No qsfp QSPI Agilex 3Agilex 5 HPS QSPI No spi-cadence-quadspi Reset Manager Agilex 3Agilex 5 HPS Reset Manager No Reset Manager driver SD/eMMC Controller Agilex 3Agilex 5 HPS SD/eMMC Yes SD/eMMC driver SPI Agilex 3Agilex 5Agilex 7 HPS SPI Yes SPI driver System Manager Agilex 3Agilex 5 HPS System manager Yes sysmgr System Memory Management Unit Agilex 3Agilex 5 HPS SMMU Yes SMMU driver UART Agilex 3Agilex 5Agilex 7 HPS UART Yes UART driver USB 2.0 OTG Agilex 3Agilex 5Agilex 7 HPS USB2.0 Yes USB 2.0 driver USB 3.1 Gen-1 Agilex 3Agilex 5 HPS USB3.1 Yes USB 3.1 Gen-1 driver Userspace I/O (UIO) Agilex 7Stratix 10 PCIe UIO Yes UIO driver Watchdog Timer Agilex 3Agilex 5 HPS Watchdog Timer Yes dw_wdt"},{"location":"driver-list/driver-list-zephyr/","title":"Zephyr Drivers","text":"<p>The table below provides a comprehensive list of embedded Zephyr drivers available for the HPS and Nios V on Agilex 5 FPGA devices.</p> <ul> <li>IP Name column indicates what type of IP the driver targets. </li> <li>Target is </li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) Target Documentation Upstream Status Kernel Source Clock Manager Agilex 5 HPS Clock Manager Yes clock_control_agilex5 Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS PSCI Yes pm_cpu_ops_psci DMA Controller Agilex 5 HPS DMAC Yes dma General Purpose Timer Agilex 5 HPS Timer Yes counter_dw_timer GPIO Agilex 5 HPS gpio No gpio_intel_socfpga QSPI Agilex 5 HPS QSPI Yes flash_cadence_qspi_nor Reset Manager Agilex 5 HPS Reset Manager Yes reset_intel_socfpga Single Event Upset (SEU) Agilex 5 HPS SEU In Progress pull/67097 SMP Agilex 5 HPS SMP Yes smp UART Agilex 5 HPS UART Yes uart_ns16550 Watchdog Timer Agilex 5 HPS Watchdog Timer Yes wdt_dw"},{"location":"driver-list_all/","title":"All Drivers, Altera Driver","text":"<p>This table comprehensively lists all Altera drivers available for Agilex 3, Agilex 5 and Agilex 7. </p> <p>You can filter your search by entering your query into any number of available columns.</p> <ul> <li>The Name column indicate the name of the IP that the driver supports.</li> <li>If a driver exists then a link to a driver page is provided for more details. N/A means driver support \"Not Available\" for the particular IP.</li> </ul> IP Name Linux Driver Zephyr Driver Altera 16550 Compatible UART Core Linux Zephyr Altera Hardware Monitor Linux N/A Clock Manager Linux Zephyr Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) N/A PSCI Device Feature List (DFL) Capability Linux N/A DFL Accelerator Functional Unit (AFU workload) Linux N/A DFL FPGA Management Engine IP Linux N/A DFL Memory Interface/Subsystem Linux N/A DFL Time of Day Clock Intel FPGA IP Linux: Host Attach TOD Linux: Embedded TOD N/A Direct Memory Access Controller (DMAC) Linux Zephyr Error Detection and Correction (EDAC) Linux N/A Ethernet Media Access Controller Linux N/A Ethernet Subsystem (HSSI SS) Linux N/A Ethernet Subsystem Intel FPGA IP (HSSI xTile) Linux N/A Ethernet 1588 PTP Time of Day Clock Linux N/A General Purpose Timers Linux N/A Generic Serial Flash Interface Intel FPGA IP Linux N/A GPIO Linux Zephyr I2C Linux N/A I3C Linux N/A Interrupt Controller (GICv3) Linux Agilex 5   Agilex 7 Microchip\u00ae Zarlink ZL30793 Network Synchronizer Linux N/A MSGDMA Linux N/A NAND Controller Linux N/A PCIe Subsystem Linux N/A QSPI Linux Zephyr QSFP Linux N/A Reset Manager Linux Zephyr Single Error Upset (SEU) N/A Zephyr SD/eMMC Controller Linux N/A SMMU Linux N/A SPI Linux N/A System Manager Linux N/A Timer N/A Zephyr UART Linux N/A USB 2.0 OTG Linux N/A Watchdog Timer Linux Zephyr"},{"location":"driver-list_baremetal/","title":"Baremetal Drivers","text":"<p>Note: This page is not availble in this release. Refer to https://altera-fpga.github.io/rel-25.1/driver-list_baremetal/ for the latest available version.</p>"},{"location":"driver-list_linux/","title":"Linux Drivers","text":"<p>The table below provides a comprehensive list of the drivers available for Agilex\u2122  3, Agilex\u2122  5 and Agilex\u2122  7.</p> <ul> <li>IP Name column indicates what type of IP the driver targets.  </li> <li>HPS or PCIe column indicates if the driver is targeting the embedded Host Processor System found on our devices or a server host or both.</li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) HPS or PCIe Host Documentation Upstream Status Kernel Source Altera 16550 Compatible UART Core Agilex 7 PCIe UART Yes 8250_dfl Altera Hardware Monitor Agilex 3Agilex 5Agilex 7 HPS Hardware Monitor No Hwmon driver Clock Manager Agilex 3Agilex 5 HPS Clock Manager No clk_agilex5 Device Feature List (DFL) Capability Agilex 7Stratix 10 PCIe dfl Yes dfl DFL Accelerator Functional Unit (AFU workload) Agilex 7Stratix 10 PCIe dfl-afu Yes dfl-afu-dma-region dfl-afu-error dfl-afu-region dfl-afu-main DFL FPGA Management Engine IP Agilex 7Stratix 10 PCIe dfl-fme Yes dfl-fme-mgr dfl-fme-br dfl-fme-region DFL Memory Interface/Subsystem Agilex 7Stratix 10 PCIe Memory Yes dfl-emif Direct Memory Access Controller (DMAC) Agilex 3Agilex 5 HPS DMAC Yes dmac Error Detection and Correction (EDAC) Agilex 3Agilex 5 HPS EDAC Yes altera_edac Ethernet 1588 PTP Time of Day Clock Agilex 7 HPS/PCIe PCIe Attach ToD Embedded ToD Yes ToD PCIe-Attach driver ToD Embedded driver Ethernet Media Access Controller Agilex 3Agilex 5 HPS EMAC No dwxgmac2_core Ethernet Subsystem Intel FPGA IP (MAC-Specific) Agilex 7 HPS HSSI No intel_fpga_hssiss Ethernet Subsystem Intel FPGA IP (Tile-Specific) Agilex 7 HPS hssi_xtile No eth_main etile_fec etile_driver etile_ethtool ftile_ethtool ftile_fec ftile_driver General Purpose Timers Agilex 3Agilex 5Agilex 7 HPS GP Timers Yes dw_apb_timer Generic Serial Flash Interface Intel FPGA IP Agilex 7Stratix 10 PCIe Generic Serial Flash Yes spi General Purpose I/O (GPIO) Agilex 3Agilex 5Agilex 7 HPS gpio Yes gpio-dwapb I2C Agilex 3Agilex 5Agilex 7 HPS I2C Yes I2c driver I3C Agilex 3Agilex 5 HPS I3C Yes I3c driver Interrupt Controller (GICv3) Agilex 3Agilex 5 HPS GICv3 Yes GICv3 driver Microchip\u00ae Zarlink ZL30793 Network Synchronizer Agilex 7 HPS Zarlink No Zarlink driver MSGDMA Agilex 7 HPS MSGDMA No MSGDMA driver NAND Controller Agilex 3Agilex 5 HPS NAND Yes cadence-nand-controller PCIe Subsystem Agilex 7 PCIe PCIe Subsystem Yes dfl-pcie QSFP Agilex 7 HPS QSFP No qsfp QSPI Agilex 3Agilex 5 HPS QSPI No spi-cadence-quadspi Reset Manager Agilex 3Agilex 5 HPS Reset Manager No Reset Manager driver SD/eMMC Controller Agilex 3Agilex 5 HPS SD/eMMC Yes SD/eMMC driver SPI Agilex 3Agilex 5Agilex 7 HPS SPI Yes SPI driver System Manager Agilex 3Agilex 5 HPS System manager Yes sysmgr System Memory Management Unit Agilex 3Agilex 5 HPS SMMU Yes SMMU driver UART Agilex 3Agilex 5Agilex 7 HPS UART Yes UART driver USB 2.0 OTG Agilex 3Agilex 5Agilex 7 HPS USB2.0 Yes USB 2.0 driver USB 3.1 Gen-1 Agilex 3Agilex 5 HPS USB3.1 Yes USB 3.1 Gen-1 driver Userspace I/O (UIO) Agilex 7Stratix 10 PCIe UIO Yes UIO driver Watchdog Timer Agilex 3Agilex 5 HPS Watchdog Timer Yes dw_wdt"},{"location":"driver-list_zephyr/","title":"Zephyr Drivers","text":"<p>The table below provides a comprehensive list of embedded Zephyr drivers available for the HPS and Nios V on Agilex 5 FPGA devices.</p> <ul> <li>IP Name column indicates what type of IP the driver targets. </li> <li>Target is </li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) Target Documentation Upstream Status Kernel Source Clock Manager Agilex 5 HPS Clock Manager Yes clock_control_agilex5 Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS PSCI Yes pm_cpu_ops_psci DMA Controller Agilex 5 HPS DMAC Yes dma General Purpose Timer Agilex 5 HPS Timer Yes counter_dw_timer GPIO Agilex 5 HPS gpio No gpio_intel_socfpga QSPI Agilex 5 HPS QSPI Yes flash_cadence_qspi_nor Reset Manager Agilex 5 HPS Reset Manager Yes reset_intel_socfpga Single Event Upset (SEU) Agilex 5 HPS SEU In Progress pull/67097 SMP Agilex 5 HPS SMP Yes smp UART Agilex 5 HPS UART Yes uart_ns16550 Watchdog Timer Agilex 5 HPS Watchdog Timer Yes wdt_dw"},{"location":"ed-ai-suite/agilex5/modular_jtag/modular_jtag/","title":"Agilex 5 Hostless JTAG Example Design","text":"<p>Demonstrate inference over JTAG and target FPGA AI Suite IP on the Agilex 5E Modular Development Kit</p>"},{"location":"ed-ai-suite/agilex5/modular_jtag/modular_jtag/#description","title":"Description","text":"<p>This example design has its own repository modular_jtag.</p> <p>This example design demonstrates how to run the AI Suite on an Altera Agilex 5 E-Series 065B Modular Development Kit in a hostless configuration.  The example design supports sending inference requests via JTAG in order to demonstrate how commands can be sent to the AI Suite IP.</p> <p>The example design uses the <code>AGX5_Generic.arch</code> architecture.</p>"},{"location":"ed-ai-suite/agilex5/modular_jtag/modular_jtag/#requirements","title":"Requirements","text":"<p>[!NOTE] Please refer to the [HL-JTAG] Prerequisites section of the Design Examples User Guide for the setup instructions.</p> <ul> <li>AI Suite 2025.1</li> <li>Quartus Prime 25.1     * Agilex 5 device support     * Agilex common files</li> <li>OpenVINO 2024.6.0 Runtime</li> </ul>"},{"location":"ed-ai-suite/agilex5/modular_jtag/modular_jtag/#compiling-optional","title":"Compiling (Optional)","text":"<p>[!TIP] You can skip compilation by downloading the pre-compiled bitstream file from the latest release.</p> <p>Compile the Quartus project with</p> <pre><code># Enable the OpenVINO and the AI Suite environments\nsource /opt/intel/openvino_2024.6.0/setupvars.sh\nsource /opt/altera/fpga_ai_suite_2025.1/dla/setupvars.sh\n\n# Prepare and compile the Quartus project.\ncd $EXAMPLES_PATH/agilex5/modular_jtag\nquartus_sh -t generate_sof.tcl\n</code></pre> <p><code>$EXAMPLES_PATH</code> is the location where this git repo was cloned to.</p> <p>The <code>generate_sof.tcl</code> script can also be run through the Quartus GUI directly. The bitstream file, <code>top.sof</code>, will be located in <code>$EXAMPLES_PATH/agilex5/modular_jtag/output_files/top.sof</code>.</p>"},{"location":"ed-ai-suite/agilex5/modular_jtag/modular_jtag/#running-inference","title":"Running Inference","text":"<p>[!NOTE] The hostless example designs provide some extra options that affect inferencing beyond what is described in this section.  Please refer to [HL-JTAG] Performing Inference on the Agilex 5 FPGA E-Series 065B Modular Development Kit for details.</p> <p>[!NOTE] This is a condensed version of the FPGA AI Suite Quick Start Tutorial. If you're using a pre-compiled bitstream then replace any paths to <code>top.sof</code> with the location where you saved <code>agx5e_modular_jtag.sof</code>.</p> <p>Running inference requires that you first build the AI Suite runtime and program the FPGA device.  This example will assume you are using <code>~/ai_suite_example</code> as your working directory but you can use any path of your choice.</p> <p>The first thing we will do is setup the working directory.  For convenience, the steps to setup the Open Model Zoo are included below.  More details can be found in Using the OpenVINO Open Model Zoo.  We will then download the ResNet-50 TF model to use for inferencing.</p> <pre><code># Initialize the working directory\nmkdir ai_suite_example\ncd ai_suite_example\nsource dla_init_local_directory.sh\n\n# Clone the OMZ repo and checkout the version associated with the latest\n# supported OpenVINO release.\ncd demo\ngit clone https://github.com/openvinotoolkit/open_model_zoo.git\n\ncd open_model_zoo\ngit switch --detach 2024.6.0\n\n# Download and convert the ResNet-50 TF model into OpenVINO's internal format\npython3 -m venv venv\nsource ./venv/bin/activate\npip install \"openvino-dev[caffe, pytorch, tensorflow]==2024.6.0\"\nomz_downloader --name resnet-50-tf --output_dir ../models\nomz_converter --name resnet-50-tf --download_dir ../models --output_dir ../models\n</code></pre> <p>[!TIP] If <code>source dla_init_local_directory.sh</code> fails then you need to reinitialize your local environment again with:</p> <pre><code>source /opt/intel/openvino_2024.6.0/setupvars.sh\nsource /opt/altera/fpga_ai_suite_2025.1/dla/setupvars.sh\n</code></pre> <p>We will now run inference with this model.  It is located in <code>$COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml</code>.  The <code>$COREDLA_WORK</code> environment variable is set by <code>dla_init_local_directory.sh</code> and will point to <code>~/ai_suite_example</code>.</p> <p>You will now need to build the AI Suite runtime to program your FPGA device and run inference with <code>dla_benchmark</code>.</p> <pre><code>cd $COREDLA_WORK/runtime\n\n# Build the runtime\n./build_runtime.sh -target_system_console\n\n# Reprogram the FPGA\nquartus_pgm -c 1 -m jtag -o \"p;$EXAMPLES_PATH/agilex5/modular_jtag/output_files/top.sof\"\n# Run inference with the Just-in-Time (JIT) compile flow\n./build_Release/dla_benchmark/dla_benchmark \\\n-b=1 \\\n-m $COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml \\\n-d=HETERO:FPGA,CPU \\\n-niter=8 \\\n-plugins $COREDLA_WORK/runtime/build_Release/plugins.xml \\\n-arch_file $COREDLA_ROOT/example_architectures/AGX5_Generic.arch \\\n-api=async \\\n-perf_est \\\n-nireq=1 \\\n-bgr \\\n-i $COREDLA_WORK/demo/sample_images \\\n-groundtruth_loc $COREDLA_WORK/demo/sample_images/TF_ground_truth.txt\n</code></pre>"},{"location":"ed-ai-suite/agilex5/modular_jtag/modular_jtag/#ahead-of-time-compile-flow","title":"Ahead-of-Time Compile Flow","text":"<p>The Ahead-of-Time (AOT) compile flow is broadly similar to the JIT flow. However, the main difference, beyond running <code>dla_compiler</code> to compile the graph, is to ensure the runtime is build with <code>-disable_jit</code>.  This is so that <code>dla_benchmark</code> does not require an architecture file to be provided along with the compiled model.  The steps are summarized below.</p> <pre><code># Note: You only need to do this if the 'build_Release' directory already\n# exists.\ncd $COREDLA_WORK/runtime\nrm -rf build_Release\n\n# Build the runtime\n./build_runtime.sh -disable_jit -target_system_console\n\n# Compile the model with 'dla_compiler'\ndla_compiler \\\n--march $COREDLA_ROOT/example_architectures/AGX5_Generic.arch \\\n--foutput-format open_vino_hetero \\\n--network-file $COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml \\\n--o $COREDLA_WORK/demo/RN50_Generic_b1.bin \\\n--batch-size=1 \\\n--fanalyze-performance\n\n# Reprogram the FPGA (optional if it was already programmed)\nquartus_pgm -c 1 -m jtag -o \"p;$EXAMPLES_PATH/agilex5/modular_jtag/output_files/top.sof\"\n# Run inference in AOT mode\n./build_Release/dla_benchmark/dla_benchmark \\\n-b=1 \\\n-cm $COREDLA_WORK/demo/RN50_Generic_b1.bin \\\n-d=HETERO:FPGA,CPU \\\n-niter=8 \\\n-plugins $COREDLA_WORK/runtime/build_Release/plugins.xml \\\n-api=async \\\n-nireq=1 \\\n-bgr \\\n-i $COREDLA_WORK/demo/sample_images \\\n-groundtruth_loc $COREDLA_WORK/demo/sample_images/TF_ground_truth.txt\n</code></pre>"},{"location":"ed-ai-suite/agilex7/de10_pcie/de10_pcie/","title":"Agilex 7 PCIe-Attached Example Design","text":"<p>Demonstrates ML inference using the Terasic DE10-Agilex Development Board</p>"},{"location":"ed-ai-suite/agilex7/de10_pcie/de10_pcie/#description","title":"Description","text":"<p>This example design has its own repository de10_pcie.</p> <p>This example design demonstrates how to run the AI Suite on a Terasic DE10-Agilex Development Board connected to a host via PCIe.  The example design uses the <code>AGX7_Generic.arch</code> architecture.</p>"},{"location":"ed-ai-suite/agilex7/de10_pcie/de10_pcie/#requirements","title":"Requirements","text":"<p>[!NOTE] Use of the Terasic DE10-Agilex Development board requires some AI Suite-specific setup.  You will encounter errors, such as the <code>AOCL_BOARD_PACKAGE_ROOT</code> environment variable not being set, if this setup is not done.</p> <p>Please refer to the Installing the FPGA AI Suite PCIe-Based Design Example Prerequisites of the Getting Started Guide for the setup instructions.</p> <ul> <li>AI Suite 2025.1</li> <li>Quartus Prime 25.1     * Agilex 7 device support     * Agilex common files</li> <li>OpenVINO 2024.6.0 Runtime</li> <li>Terasic BSP</li> </ul>"},{"location":"ed-ai-suite/agilex7/de10_pcie/de10_pcie/#compiling-optional","title":"Compiling (Optional)","text":"<p>[!TIP] You can skip compilation by downloading the pre-compiled bitstream file from the latest release.</p> <p>Compile the Quartus project with</p> <pre><code># Enable the OpenVINO and the AI Suite environments\nsource /opt/intel/openvino_2024.6.0/setupvars.sh\nsource /opt/altera/fpga_ai_suite_2025.1/dla/setupvars.sh\n\n# Prepare and compile the Quartus project.\ncd $EXAMPLES_PATH/agilex7/de10_pcie\n./setup_project.sh\nquartus_sh -t generate_sof.tcl\n</code></pre> <p><code>$EXAMPLES_PATH</code> is the location where this git repo was cloned to.</p> <p>The <code>generate_sof.tcl</code> script can also be run through the Quartus GUI directly. The bitstream file, <code>flat.sof</code>, will be located in <code>$EXAMPLES_PATH/agilex7/de10_pcie/flat.sof</code>.</p>"},{"location":"ed-ai-suite/agilex7/de10_pcie/de10_pcie/#running-inference","title":"Running Inference","text":"<p>[!NOTE] This is a condensed version of the FPGA AI Suite Quick Start Tutorial. If you're using a pre-compiled bitstream then replace any paths to <code>flat.sof</code> with the location where you saved <code>agx7_de10_pcie.sof</code>.</p> <p>Running inference requires that you first build the AI Suite runtime and program the FPGA device.  This example will assume you are using <code>~/ai_suite_example</code> as your working directory but you can use any path of your choice.</p> <p>The first thing we will do is setup the working directory.  For convenience, the steps to setup the Open Model Zoo are included below.  More details can be found in Using the OpenVINO Open Model Zoo.  We will then download the ResNet-50 TF model to use for inferencing.</p> <pre><code># Initialize the working directory\nmkdir ai_suite_example\ncd ai_suite_example\nsource dla_init_local_directory.sh\n\n# Clone the OMZ repo and checkout the version associated with the latest\n# supported OpenVINO release.\ncd demo\ngit clone https://github.com/openvinotoolkit/open_model_zoo.git\n\ncd open_model_zoo\ngit switch --detach 2024.6.0\n\n# Download and convert the ResNet-50 TF model into OpenVINO's internal format\npython3 -m venv venv\nsource ./venv/bin/activate\npip install \"openvino-dev[caffe, pytorch, tensorflow]==2024.6.0\"\nomz_downloader --name resnet-50-tf --output_dir ../models\nomz_converter --name resnet-50-tf --download_dir ../models --output_dir ../models\n</code></pre> <p>[!TIP] If <code>source dla_init_local_directory.sh</code> fails then you need to reinitialize your local environment again with:</p> <pre><code>source /opt/intel/openvino_2024.6.0/setupvars.sh\nsource /opt/altera/fpga_ai_suite_2025.1/dla/setupvars.sh\n</code></pre> <p>We will now run inference with this model.  It is located in <code>$COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml</code>.  The <code>$COREDLA_WORK</code> environment variable is set by <code>dla_init_local_directory.sh</code> and will point to <code>~/ai_suite_example</code>.</p> <p>You will now need to build the AI Suite runtime to program your FPGA device and run inference with <code>dla_benchmark</code>.</p> <pre><code>cd $COREDLA_WORK/runtime\n\n# Build the runtime\n./build_runtime.sh -target_de10_agilex\n\n# Reprogram the FPGA\n./build_Release/fpga_jtag_reprogram/fpga_jtag_reprogram $EXAMPLES_PATH/agilex7/de10_pcie/flat.sof\n\n# Run inference with the Just-in-Time (JIT) compile flow\n./build_Release/dla_benchmark/dla_benchmark \\\n-b=1 \\\n-m $COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml \\\n-d=HETERO:FPGA,CPU \\\n-niter=8 \\\n-plugins $COREDLA_WORK/runtime/build_Release/plugins.xml \\\n-arch_file $COREDLA_ROOT/example_architectures/AGX7_Generic.arch \\\n-api=async \\\n-perf_est \\\n-nireq=4 \\\n-bgr \\\n-i $COREDLA_WORK/demo/sample_images \\\n-groundtruth_loc $COREDLA_WORK/demo/sample_images/TF_ground_truth.txt\n</code></pre>"},{"location":"ed-ai-suite/agilex7/de10_pcie/de10_pcie/#ahead-of-time-compile-flow","title":"Ahead-of-Time Compile Flow","text":"<p>The Ahead-of-Time (AOT) compile flow is broadly similar to the JIT flow. However, the main difference, beyond running <code>dla_compiler</code> to compile the graph, is to ensure the runtime is build with <code>-disable_jit</code>.  This is so that <code>dla_benchmark</code> does not require an architecture file to be provided along with the compiled model.  The steps are summarized below.</p> <pre><code># Note: You only need to do this if the 'build_Release' directory already\n# exists.\ncd $COREDLA_WORK/runtime\nrm -rf build_Release\n\n# Build the runtime\n./build_runtime.sh -disable_jit -target_de10_agilex\n\n# Compile the model with 'dla_compiler'\ndla_compiler \\\n--march $COREDLA_ROOT/example_architectures/AGX7_Generic.arch \\\n--foutput-format open_vino_hetero \\\n--network-file $COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml \\\n--o $COREDLA_WORK/demo/RN50_Generic_b1.bin \\\n--batch-size=1 \\\n--fanalyze-performance\n\n# Reprogram the FPGA (optional if it was already programmed)\n./build_Release/fpga_jtag_reprogram/fpga_jtag_reprogram $EXAMPLES_PATH/agilex7/de10_pcie/flat.sof\n\n# Run inference in AOT mode\n./build_Release/dla_benchmark/dla_benchmark \\\n-b=1 \\\n-cm $COREDLA_WORK/demo/RN50_Generic_b1.bin \\\n-d=HETERO:FPGA,CPU \\\n-niter=8 \\\n-plugins $COREDLA_WORK/runtime/build_Release/plugins.xml \\\n-api=async \\\n-nireq=4 \\\n-bgr \\\n-i $COREDLA_WORK/demo/sample_images \\\n-groundtruth_loc $COREDLA_WORK/demo/sample_images/TF_ground_truth.txt\n</code></pre>"},{"location":"ed-ai-suite/agilex7/iseries_ofs_pcie/iseries_ofs_pcie/","title":"Agilex 7 PCIe-Attached Example Design with OFS","text":"<p>Demonstrates ML inference using the Agilex 7 FPGA I-Series Development Kit (2x R-Tile and 1x F-Tile)</p>"},{"location":"ed-ai-suite/agilex7/iseries_ofs_pcie/iseries_ofs_pcie/#description","title":"Description","text":"<p>This example design has its own repository iseries_ofs_pcie.</p> <p>This example design demonstrates how to run the AI Suite on an Agilex 7 Intel I-Series Development Kit (2x R-Tile and 1x F-Tile) connected to a host via PCIe. The example design uses the <code>AGX7_Generic.arch</code> architecture.</p>"},{"location":"ed-ai-suite/agilex7/iseries_ofs_pcie/iseries_ofs_pcie/#requirements","title":"Requirements","text":"<p>[!NOTE] All OFS-based AI Suite example designs use an Out-of-Tree PR FIM.</p> <p>Please refer to [OFS-PCIE] Getting Started with Open FPGA Stack (OFS) for PCIe Attach Design Examples in the Design Examples User Guide for more details.</p> <ul> <li>AI Suite 2025.1</li> <li>Quartus Prime 24.3     * Agilex 7 device support     * Agilex common files</li> <li>OpenVINO 2024.6.0 Runtime</li> <li>OFS 2024.3-1 I-Series Development Kit Slim FIM</li> <li>OPAE 2.13.0-2 Driver</li> </ul>"},{"location":"ed-ai-suite/agilex7/iseries_ofs_pcie/iseries_ofs_pcie/#compiling-optional","title":"Compiling (Optional)","text":"<p>[!TIP] You can skip compilation by downloading the pre-compiled bitstream file from the latest release.</p> <p>Compile the Quartus project with</p> <pre><code># Enable the OpenVINO and the AI Suite environments\nsource /opt/intel/openvino_2024.6.0/setupvars.sh\nsource /opt/altera/fpga_ai_suite_2025.1/dla/setupvars.sh\n\n# If OPAE has been installed into the default location, use:\nexport OPAE_SDK_ROOT=/usr\n\n# Prepare the OFS setup\nexport OPAE_PLATFORM_ROOT=\"$HOME/OFS/iseries-dk-slimfim-images_ofs-2024-3-1/pr_build_template\"\n# Prepare and compile the Quartus project.\ncd $EXAMPLES_PATH/agilex7/iseries_ofs_pcie\n./setup_project.sh\n./build_project.sh\n</code></pre> <p><code>$EXAMPLES_PATH</code> is the location where this git repo was cloned to.</p> <p>The <code>dla_afu.gbs</code> bitstream file will be located in the <code>$EXAMPLES_PATH/agilex7/iseries_ofs_pcie/ofs/</code> directory.</p>"},{"location":"ed-ai-suite/agilex7/iseries_ofs_pcie/iseries_ofs_pcie/#running-inference","title":"Running Inference","text":"<p>[!NOTE] This is a condensed version of the FPGA AI Suite Quick Start Tutorial. If you're using a pre-compiled bitstream then replace any paths to <code>dla_afu.gbs</code> with the location where you saved <code>agx7_iseries_ofs_pcie.gbs</code>.</p> <p>Running inference requires that you first build the AI Suite runtime and program the FPGA device.  This example will assume you are using <code>~/ai_suite_example</code> as your working directory but you can use any path of your choice.</p> <p>The first thing we will do is setup the working directory.  For convenience, the steps to setup the Open Model Zoo are included below.  More details can be found in Using the OpenVINO Open Model Zoo.  We will then download the ResNet-50 TF model to use for inferencing.</p> <pre><code># Initialize the working directory\nmkdir ai_suite_example\ncd ai_suite_example\nsource dla_init_local_directory.sh\n\n# Clone the OMZ repo and checkout the version associated with the latest\n# supported OpenVINO release.\ncd demo\ngit clone https://github.com/openvinotoolkit/open_model_zoo.git\n\ncd open_model_zoo\ngit switch --detach 2024.6.0\n\n# Download and convert the ResNet-50 TF model into OpenVINO's internal format\npython3 -m venv venv\nsource ./venv/bin/activate\npip install \"openvino-dev[caffe, pytorch, tensorflow]==2024.6.0\"\nomz_downloader --name resnet-50-tf --output_dir ../models\nomz_converter --name resnet-50-tf --download_dir ../models --output_dir ../models\n</code></pre> <p>[!TIP] If <code>source dla_init_local_directory.sh</code> fails then you need to reinitialize your local environment again with:</p> <pre><code>source /opt/intel/openvino_2024.6.0/setupvars.sh\nsource /opt/altera/fpga_ai_suite_2025.1/dla/setupvars.sh\n</code></pre> <p>We will now run inference with this model.  It is located in <code>$COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml</code>.  The <code>$COREDLA_WORK</code> environment variable is set by <code>dla_init_local_directory.sh</code> and will point to <code>~/ai_suite_example</code>.</p> <p>You will now need to build the AI Suite runtime to program your FPGA device and run inference with <code>dla_benchmark</code>.</p> <pre><code>cd $COREDLA_WORK/runtime\n# If OPAE has been installed into the default location, use:\nexport OPAE_SDK_ROOT=/usr\n\n# Build the runtime\n./build_runtime.sh -target_agx7_i_dk\n\n# Reprogram the FPGA\nfpgaconf -V $EXAMPLES_PATH/agilex7/iseries_ofs_pcie/ofs/dla_afu.gbs\n\n# Run inference with the Just-in-Time (JIT) compile flow\n./build_Release/dla_benchmark/dla_benchmark \\\n-b=1 \\\n-m $COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml \\\n-d=HETERO:FPGA,CPU \\\n-niter=8 \\\n-plugins $COREDLA_WORK/runtime/build_Release/plugins.xml \\\n-arch_file $COREDLA_ROOT/example_architectures/AGX7_Generic.arch \\\n-api=async \\\n-perf_est \\\n-nireq=4 \\\n-bgr \\\n-i $COREDLA_WORK/demo/sample_images \\\n-groundtruth_loc $COREDLA_WORK/demo/sample_images/TF_ground_truth.txt\n</code></pre>"},{"location":"ed-ai-suite/agilex7/iseries_ofs_pcie/iseries_ofs_pcie/#ahead-of-time-compile-flow","title":"Ahead-of-Time Compile Flow","text":"<p>The Ahead-of-Time (AOT) compile flow is broadly similar to the JIT flow. However, the main difference, beyond running <code>dla_compiler</code> to compile the graph, is to ensure the runtime is build with <code>-disable_jit</code>.  This is so that <code>dla_benchmark</code> does not require an architecture file to be provided along with the compiled model.  The steps are summarized below.</p> <pre><code># Note: You only need to do this if the 'build_Release' directory already\n# exists.\ncd $COREDLA_WORK/runtime\nrm -rf build_Release\n# If OPAE has been installed into the default location, use:\nexport OPAE_SDK_ROOT=/usr\n\n# Build the runtime\n./build_runtime.sh -disable_jit -target_agx7_i_dk\n\n# Compile the model with 'dla_compiler'\ndla_compiler \\\n--march $COREDLA_ROOT/example_architectures/AGX7_Generic.arch \\\n--foutput-format open_vino_hetero \\\n--network-file $COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml \\\n--o $COREDLA_WORK/demo/RN50_Generic_b1.bin \\\n--batch-size=1 \\\n--fanalyze-performance\n\n# Reprogram the FPGA (optional if it was already programmed)\nfpgaconf -V $EXAMPLES_PATH/agilex7/iseries_ofs_pcie/ofs/dla_afu.gbs\n\n# Run inference in AOT mode\n./build_Release/dla_benchmark/dla_benchmark \\\n-b=1 \\\n-cm $COREDLA_WORK/demo/RN50_Generic_b1.bin \\\n-d=HETERO:FPGA,CPU \\\n-niter=8 \\\n-plugins $COREDLA_WORK/runtime/build_Release/plugins.xml \\\n-api=async \\\n-nireq=4 \\\n-bgr \\\n-i $COREDLA_WORK/demo/sample_images \\\n-groundtruth_loc $COREDLA_WORK/demo/sample_images/TF_ground_truth.txt\n</code></pre>"},{"location":"ed-ai-suite/agilex7/n6001_ofs_pcie/n6001_ofs_pcie/","title":"Agilex 7 PCIe-Attached Example Design with OFS","text":"<p>Demonstrates ML inference using the Intel FPGA SmartNIC N6001-PL Platform (without an Ethernet controller)</p>"},{"location":"ed-ai-suite/agilex7/n6001_ofs_pcie/n6001_ofs_pcie/#description","title":"Description","text":"<p>This example design has its own repository n6001_ofs_pcie.</p> <p>This example design demonstrates how to run the AI Suite on an Intel FPGA SmartNIC N6001-PL connected to a host via PCIe. The example design uses the <code>AGX7_Generic.arch</code> architecture.</p>"},{"location":"ed-ai-suite/agilex7/n6001_ofs_pcie/n6001_ofs_pcie/#requirements","title":"Requirements","text":"<p>[!NOTE] All OFS-based AI Suite example designs use an Out-of-Tree PR FIM.</p> <p>Please refer to [OFS-PCIE] Getting Started with Open FPGA Stack (OFS) for PCIe Attach Design Examples in the Design Examples User Guide for more details.</p> <ul> <li>AI Suite 2025.1</li> <li>Quartus Prime 24.3     * Agilex 7 device support     * Agilex common files</li> <li>OpenVINO 2024.6.0 Runtime</li> <li>OFS 2024.3-1 N6001 Slim FIM</li> <li>OPAE 2.13.0-2 Driver</li> </ul>"},{"location":"ed-ai-suite/agilex7/n6001_ofs_pcie/n6001_ofs_pcie/#compiling-optional","title":"Compiling (Optional)","text":"<p>[!TIP] You can skip compilation by downloading the pre-compiled bitstream file from the latest release.</p> <p>Compile the Quartus project with</p> <pre><code># Enable the OpenVINO and the AI Suite environments\nsource /opt/intel/openvino_2024.6.0/setupvars.sh\nsource /opt/altera/fpga_ai_suite_2025.1/dla/setupvars.sh\n\n# If OPAE has been installed into the default location, use:\nexport OPAE_SDK_ROOT=/usr\n\n# Prepare the OFS setup\nexport OPAE_PLATFORM_ROOT=\"$HOME/OFS/n6001-slimfim-images_ofs-2024-3-1/pr_build_template\"\n# Prepare and compile the Quartus project.\ncd $EXAMPLES_PATH/agilex7/n6001_ofs_pcie\n./setup_project.sh\n./build_project.sh\n</code></pre> <p><code>$EXAMPLES_PATH</code> is the location where this git repo was cloned to.</p> <p>The <code>dla_afu.gbs</code> bitstream file will be located in the <code>$EXAMPLES_PATH/agilex7/n6001_ofs_pcie/ofs/</code> directory.</p>"},{"location":"ed-ai-suite/agilex7/n6001_ofs_pcie/n6001_ofs_pcie/#running-inference","title":"Running Inference","text":"<p>[!NOTE] This is a condensed version of the FPGA AI Suite Quick Start Tutorial. If you're using a pre-compiled bitstream then replace any paths to <code>dla_afu.gbs</code> with the location where you saved <code>agx7_n6001_ofs_pcie.gbs</code>.</p> <p>Running inference requires that you first build the AI Suite runtime and program the FPGA device.  This example will assume you are using <code>~/ai_suite_example</code> as your working directory but you can use any path of your choice.</p> <p>The first thing we will do is setup the working directory.  For convenience, the steps to setup the Open Model Zoo are included below.  More details can be found in Using the OpenVINO Open Model Zoo.  We will then download the ResNet-50 TF model to use for inferencing.</p> <pre><code># Initialize the working directory\nmkdir ai_suite_example\ncd ai_suite_example\nsource dla_init_local_directory.sh\n\n# Clone the OMZ repo and checkout the version associated with the latest\n# supported OpenVINO release.\ncd demo\ngit clone https://github.com/openvinotoolkit/open_model_zoo.git\n\ncd open_model_zoo\ngit switch --detach 2024.6.0\n\n# Download and convert the ResNet-50 TF model into OpenVINO's internal format\npython3 -m venv venv\nsource ./venv/bin/activate\npip install \"openvino-dev[caffe, pytorch, tensorflow]==2024.6.0\"\nomz_downloader --name resnet-50-tf --output_dir ../models\nomz_converter --name resnet-50-tf --download_dir ../models --output_dir ../models\n</code></pre> <p>[!TIP] If <code>source dla_init_local_directory.sh</code> fails then you need to reinitialize your local environment again with:</p> <pre><code>source /opt/intel/openvino_2024.6.0/setupvars.sh\nsource /opt/altera/fpga_ai_suite_2025.1/dla/setupvars.sh\n</code></pre> <p>We will now run inference with this model.  It is located in <code>$COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml</code>.  The <code>$COREDLA_WORK</code> environment variable is set by <code>dla_init_local_directory.sh</code> and will point to <code>~/ai_suite_example</code>.</p> <p>You will now need to build the AI Suite runtime to program your FPGA device and run inference with <code>dla_benchmark</code>.</p> <pre><code>cd $COREDLA_WORK/runtime\n# If OPAE has been installed into the default location, use:\nexport OPAE_SDK_ROOT=/usr\n\n# Build the runtime\n./build_runtime.sh -target_agx7_n6001\n\n# Reprogram the FPGA\nfpgaconf -V $EXAMPLES_PATH/agilex7/n6001_ofs_pcie/ofs/dla_afu.gbs\n\n# Run inference with the Just-in-Time (JIT) compile flow\n./build_Release/dla_benchmark/dla_benchmark \\\n-b=1 \\\n-m $COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml \\\n-d=HETERO:FPGA,CPU \\\n-niter=8 \\\n-plugins $COREDLA_WORK/runtime/build_Release/plugins.xml \\\n-arch_file $COREDLA_ROOT/example_architectures/AGX7_Generic.arch \\\n-api=async \\\n-perf_est \\\n-nireq=4 \\\n-bgr \\\n-i $COREDLA_WORK/demo/sample_images \\\n-groundtruth_loc $COREDLA_WORK/demo/sample_images/TF_ground_truth.txt\n</code></pre>"},{"location":"ed-ai-suite/agilex7/n6001_ofs_pcie/n6001_ofs_pcie/#ahead-of-time-compile-flow","title":"Ahead-of-Time Compile Flow","text":"<p>The Ahead-of-Time (AOT) compile flow is broadly similar to the JIT flow. However, the main difference, beyond running <code>dla_compiler</code> to compile the graph, is to ensure the runtime is build with <code>-disable_jit</code>.  This is so that <code>dla_benchmark</code> does not require an architecture file to be provided along with the compiled model.  The steps are summarized below.</p> <pre><code># Note: You only need to do this if the 'build_Release' directory already\n# exists.\ncd $COREDLA_WORK/runtime\nrm -rf build_Release\n# If OPAE has been installed into the default location, use:\nexport OPAE_SDK_ROOT=/usr\n\n# Build the runtime\n./build_runtime.sh -disable_jit -target_agx7_n6001\n\n# Compile the model with 'dla_compiler'\ndla_compiler \\\n--march $COREDLA_ROOT/example_architectures/AGX7_Generic.arch \\\n--foutput-format open_vino_hetero \\\n--network-file $COREDLA_WORK/demo/models/public/resnet-50-tf/FP32/resnet-50-tf.xml \\\n--o $COREDLA_WORK/demo/RN50_Generic_b1.bin \\\n--batch-size=1 \\\n--fanalyze-performance\n\n# Reprogram the FPGA (optional if it was already programmed)\nfpgaconf -V $EXAMPLES_PATH/agilex7/n6001_ofs_pcie/ofs/dla_afu.gbs\n\n# Run inference in AOT mode\n./build_Release/dla_benchmark/dla_benchmark \\\n-b=1 \\\n-cm $COREDLA_WORK/demo/RN50_Generic_b1.bin \\\n-d=HETERO:FPGA,CPU \\\n-niter=8 \\\n-plugins $COREDLA_WORK/runtime/build_Release/plugins.xml \\\n-api=async \\\n-nireq=4 \\\n-bgr \\\n-i $COREDLA_WORK/demo/sample_images \\\n-groundtruth_loc $COREDLA_WORK/demo/sample_images/TF_ground_truth.txt\n</code></pre>"},{"location":"ed-ai-suite/common/","title":"FPGA AI Suite Example Designs","text":"<p>The table below contains a comprehensive list of example designs which have been developed to showcase the FPGA AI Suite that are available in the FPGA AI Suite Example Design repository:</p> Design Name Device Family Repository Link Agilex 5 Hostless JTAG Example Design Agilex 5 Repo Link Agilex 7 PCIe-Attached Example Design (DE10) Agilex 7 Repo Link Agilex 7 PCIe-Attached Example Design with OFS (I-Series, 2x R-Tile and 1x F-Tile) Agilex 7 Repo Link Agilex 7 PCIe-Attached Example Design with OFS (N6001) Agilex 7 Repo Link <p>The FPGA AI Suite Example Design repo contains a set of configured example designs that demonstrate different features of the FPGA AI Suite. The FPGA AI Suite is a collection of tools for efficiently running AI inference on Altera FPGAs.  The examples in this repo cover the different development boards, connectivity types, and FPGA families that the AI Suite supports.</p> <p>This repository does not contain the totality of FPGA AI Suite Documentation; other topics of interest include building Yocto images for SoC designs, an explanation of the various components of the FPGA AI Suite, architectural overviews, a generalized Getting Started flow and more. This comprehensive document can be downloaded from the web at FPGA AI Suite: Design Examples User Guide. You can also browse the FPGA AI Suite web page for more information.</p> <p>Each example will walk you through a standard workflow to demonstrate how to use to the AI Suite to:</p> <ul> <li>Compile the AI Suite IP into an FPGA bitstream.</li> <li>Program an FPGA with the AI Suite IP bitstream.</li> <li>Prepare an AI model graph for inference.</li> <li>Run inference on an FPGA using a benchmark dataset.</li> </ul> <p>You may obtain a copy of the FPGA AI Suite from the official downloads page.</p> <p>[!IMPORTANT] All examples have a hard limit of 10'000 inference requests.  Please refer to the documentation on \"--licensed/--unlicensed\" IP generation for details about this limitation.</p> <p>Full details on how to install the FPGA AI Suite, including all software and hardware requirements, are available in Chapter 4 of the Getting Started Guide. The individual READMEs for each example also contain any additional requirements and setup instructions that are particular to that example.</p>"},{"location":"ed-ai-suite/common/#example-designs","title":"Example Designs","text":""},{"location":"ed-ai-suite/common/#hostless","title":"Hostless","text":"<p>Hostless example designs demonstrate how to directly control the FPGA AI Suite IP over JTAG.</p> Family Development Board Agilex 5 Agilex 5E Modular Development Kit"},{"location":"ed-ai-suite/common/#pcie-attach","title":"PCIe-attach","text":"<p>PCIe-attach example designs demonstrate how a host computer can use the FPGA AI Suite to offload AI workloads onto an FPGA via PCIe.</p> Family Development Board Agilex 7 Terasic DE10-Agilex Development Board Agilex 7 Agilex 7 FPGA I-Series Development Kit (2x R-Tile and 1x F-Tile) Agilex 7 Intel FPGA SmartNIC N6001-PL Platform (without an Ethernet controller)"},{"location":"ed-ai-suite/common/#documentation","title":"Documentation","text":"<ul> <li>Using the OpenVINO Open Model Zoo</li> </ul>"},{"location":"ed-ai-suite/common/using-model-zoo/","title":"Using the OpenVINO Open Model Zoo","text":"<p>The example graphs used for testing inferencing with the AI Suite can be obtained through the Open Model Zoo (OMZ).  This process is the same, regardless of example design.</p> <p>[!TIP] You can find an up-to-date list of supported OMZ models in the FPGA AI Suite: IP Reference Manual</p>"},{"location":"ed-ai-suite/common/using-model-zoo/#model-zoo-setup","title":"Model Zoo Setup","text":"<p>The first time setup requires cloning the OMZ GitHub repo and installing the required Python dependencies.</p> <pre><code># Clone the OMZ repo and switch to the currently supported OpenVINO LTS release\ngit clone https://github.com/openvinotoolkit/open_model_zoo.git\ncd open_model_zoo\ngit switch --detach 2024.6.0\n\n# Install the necessary OpenVINO utilities\npython3 -m venv .venv\nsource .venv/bin/activate\npip install \"openvino-dev[caffe, pytorch, tensorflow]==2024.6.0\"\n</code></pre>"},{"location":"ed-ai-suite/common/using-model-zoo/#downloading-a-model","title":"Downloading a Model","text":"<p>Downloading a model and converting it into OpenVINO intermediate representation (IR) is done the with the following two commands:</p> <pre><code># Download and convert ResNet-50 TensorFlow\n#\n# NOTE: Make sure that the virtualenv is activated!  If not, run\n#   source .venv/bin/activate\nomz_downloader --name resnet-50-tf --output_dir ./model_downloads\nomz_converter --name resnet-50-tf --download_dir ./model_downloads --output_dir ./model_downloads\n</code></pre> <p>The models will be downloaded to <code>./model_downloads</code> and then converted into OpenVINO IR.  In this case, the results will be in <code>./model_downloads/public/resnet-50-tf/FP32/</code>.</p> <p>You can change the download location from <code>./model_downloads</code>, which will be in your current working directory, to wherever is most convenient.</p>"},{"location":"ed-ai-suite/common/agx5_board_install/agx5_board_install/","title":"BKMs for AGX5 Modular Development Kit Setup with OFS 2025.1","text":"<p>The following instructions are intended to enable users in using an Agilex 5 Modular Development Kit with the OFS 2025.1 release. </p>"},{"location":"ed-ai-suite/common/agx5_board_install/agx5_board_install/#10-host-machine-settings","title":"1.0 Host Machine  Settings","text":"<p>The following BIOS settings will need to be changed to support the Agilex 5 Modular Development Kit on an HP server running ILO 5+. The location of specific settings in the BIOS menu may change depending on the server manufacturer and BIOS revision.</p> <ol> <li>BIOS Setting: System Security.<p>1.a. Enable Virtualization Technology for Directed I/O (VTd) </p> </li> </ol> <p></p> <ol> <li>BIOS Setting: PCIe Slot Setting (Everything default) </li> </ol> <p></p>"},{"location":"ed-ai-suite/common/agx5_board_install/agx5_board_install/#20-agx5-e-series-modular-development-kit-installation","title":"2.0 AGX5 E-Series Modular Development Kit Installation","text":""},{"location":"ed-ai-suite/common/agx5_board_install/agx5_board_install/#21-switch-settings","title":"2.1 Switch Settings","text":"<ol> <li> <p>Enable the following switch settings for JTAG programming:</p> <p>#### Table 1: SW for Jtag Programming</p> Switch Position Description S2 (carrier board) POS-1 POS-1 - for PCIe EF 12V input for system power, POS-3 - Enable ATX 12V input for system power S4.1 &amp; S4.2 (modular board) OFF / OFF ON \u2014 MSEL 1 Low, OFF \u2014 MSEL 1 High, Note: If you want to control the configuration over BTS, set this switch to OFF state S13.1 (carrier board) ON ON \u2014 PCIe edge clock, OFF \u2014 Clock from onboard Si52202 <p>Every other switch should be in its default position, as per the Agilex 5 FPGA E-Series 065B Modular Development Kit User Guide, section 3.1 Default Settings.</p> </li> <li> <p>Connect the development kit to host machine via PCIe Gen3 (or higher) slot.</p> </li> <li> <p>Connect the development kit to ATX power supply between it and the host.</p> </li> </ol>"},{"location":"ed-ai-suite/common/agx5_board_install/agx5_board_install/#30-software-requirements","title":"3.0 Software Requirements","text":"<ul> <li>RHEL 9.4 (Supports OFS 2025.1 and FPGA AI Suite 2025.1.1) <ul> <li>Can also use RHEL 8.10 if preferred</li> </ul> </li> <li>A valid Quartus Prime Pro 25.1 installation<ul> <li>If just programming the card, only the Quartus Programmer is required</li> </ul> </li> <li>Install the OFS (Open FPGA Stack) SDK and relevant DFL drivers</li> </ul>"},{"location":"ed-ai-suite/common/agx5_board_install/agx5_board_install/#40-how-to-program-the-fim","title":"4.0 How to Program the FIM","text":"<ol> <li>Download the OFS 2025.1 FIM from https://github.com/OFS/ofs-agx5-pcie-attach/releases/download/ofs-2025.1-1/eseries-mdk-images_ofs-2025-1-1.tar.gz. </li> <li> <p>If you haven't already, add the Quartus Programmer binaries to PATH. </p> <p><code>bash session   export PATH=\"$PATH:\"/&lt;quartus_install_path&gt;/intelFPGA_pro/25.1/qprogrammer/quartus/bin</code></p> </li> <li> <p>List FPGA connected via JTAG. </p> <p><code>bash session   jtagconfig -D</code></p> <p></p> </li> <li> <p>Program the FIM  onto FPGA. (Note the device_number from <code>jtagconfig</code>).  </p> <p><code>bash session   quartus_pgm -c 1 -m jtag -o \"p;/&lt;path_to_image&gt;/eseries-mdk-images_ofs-2025-1-1/ofs_top.sof@1\"</code></p> </li> <li> <p>Warm reboot the server. </p> <p><code>bash session   sudo reboot</code></p> </li> <li> <p>After programming FIM and reboot, the host machine should be able to detect the new FPGA via its PCIe connection. </p> <p><code>bash session   lspci | grep acc</code></p> <p></p> <p>In this case, the PCI-address of AGX5E Modular Development Kit is 5e:00.0 </p> </li> </ol>"},{"location":"ed-demo-list/ed-list/","title":"Example Designs","text":"<p>The table below provides a comprehensive list of example designs for Altera's FPGA families.  You can filter the table by applying search criteria in the entry boxes above the table. Use the \"Clear\" button on the right to clear your search criteria.  Some suggested search options are:</p> <ul> <li>Supported Devices:  Agilex\u2122 3, Agilex\u2122 5, Agilex\u2122 7, Stratix\u00ae 10, Arria\u00ae 10 and Cyclone\u00ae V.</li> <li>Category: Nios V, PCIe, Memory, HPS, Networking, TSN, 1588PTP, Robotics, Video/Vision, AI, Transceiver</li> <li>Design Type: Both System Example Designs and Tutorial Example Designs are provided in this site.  <ul> <li>System Example Designs contain multiple IPs in a broadly applicable design including software and drivers.  </li> <li>Tutorial Example Designs teach how to use a feature, function or device capability with a simple example.</li> </ul> </li> <li>Development Kit Target: Search by Device name to narrow down the development targets.</li> <li>Quartus Version: Enter \"Pro\" or \"Std\" and then your Quartus version number.</li> <li>Description: You can review the description to identify if the Example Design meets your needs.</li> <li>Documentation: This link takes you to the appropriate documentation so you can get started with your design.</li> </ul> <p>You can use the filter fields to narrow your search.</p> Example Design Supported Device(s) Category Design Type Development Kit Target Quartus Version Description Documentation Debugging Linux with Arm Development Studio Agilex 3 HPS Tutorial Example Design * Agilex\u2122 3 FPGA and SoC C-Series Development Kit Pro 25.1.1 Demonstrates how to use Arm Development Studio to debug the Linux kernel. Debugging Linux with Arm Development Studio Debugging U-Boot with Ashling RiscFree Agilex 3 HPS Tutorial Example Design * Agilex\u2122 3 FPGA and SoC C-Series Development Kit Pro 25.1.1 Demonstrates how to use Ashling RiscFree to debug U-Boot SPL and U-Boot. Debugging U-Boot with Ashling RiscFree Debugging U-Boot with Arm Development Studio Agilex 3 HPS Tutorial Example Design * Agilex\u2122 3 FPGA and SoC C-Series Development Kit Pro 25.1.1 Demonstrates how to use Arm Development Studio to debug U-Boot SPL and U-Boot. Debugging U-Boot with Arm Development Studio Debugging Linux with Ashling RiscFree Agilex 3 HPS Tutorial Example Design * Agilex\u2122 3 FPGA and SoC C-Series Development Kit Pro 25.1.1 Demonstrates how to use Ashling RiscFree to debug the Linux kernel. Debugging Linux with Ashling RiscFree Debugging U-Boot with Arm Development Studio Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Demonstrates how to use Arm Development Studio to debug U-Boot SPL and U-Boot. Debugging U-Boot with Arm Development Studio Debugging Linux with Arm Development Studio Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Demonstrates how to use Arm Development Studio to debug the Linux kernel. Debugging Linux with Arm Development Studio Debugging U-Boot with Ashling RiscFree Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Demonstrates how to use Ashling RiscFree to debug U-Boot SPL and U-Boot. Debugging U-Boot with Ashling RiscFree Debugging Linux with Ashling RiscFree Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Demonstrates how to use Ashling RiscFree to debug the Linux kernel. Debugging Linux with Ashling RiscFree HPS Simics Zephyr Golden System Reference Design Agilex 5 HPS System Example Design * Agilex\u2122 5 E-Series Universal Virtual Platform Pro 24.3 Demonstrate how to exercise several use cases in which HPS software is running on the Simics simulator using virtual platforms Simics Zephyr GSRD HPS Simics Linux Golden System Reference Design Agilex 5 HPS System Example Design * Agilex\u2122 5 E-Series Universal Virtual Platform Pro 25.1.1 Demonstrate how to exercise several use cases in which HPS software is running on the Simics simulator using virtual platforms Simics Linux GSRD Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices Agilex 5 Robotics System Example Design * Agilex 5 FPGA E-Series 065B Modular Development Kit MK-A5E065BB32AES1 Pro 25.1 Drive-On Chip with FUSA User Guide for Modular Development kit. Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices Agilex 3, Agilex 5 Robotics System Example Design * Agilex\u2122 3 FPGA and SoC C-Series Development Kit* Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit MK-A5E065BB32AES1 Pro 25.1,Pro 25.1.1 Drive-On Chip with PLC User Guide for Modular Development kit. Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices ROS Consolidated Robot Controller Example Design for Agilex\u2122 5 Devices Agilex 5 Robotics System Example Design * Agilex 5 FPGA E-Series 065B Modular Development Kit MK-A5E065BB32AES1 Pro 25.1 ROS 2 based robot controller example with Drive-on-Chip motor control integration. ROS Consolidated Robot Controller Example Design for Agilex\u2122 5 Devices HPS Xen Hypervisor GSRD Agilex 5 HPS System Example Design * Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit Pro 25.1.1 Demonstrates the use of HPS Xen Hypervisor including the build of binaries to exercise this. HPS Xen Hypervisor GSRD HPS GHRD Linux Boot Examples Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit Pro 25.1.1 Provides instructions on how to build Linux systems from separate HPS software components HPS GHRD Linux Boot Examples HPS TSN SGMII XCVR 3x2.5G System Example Design User Guide Agilex 5 HPS System Example Design N/A Pro 25.1.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS TSN SGMII XCVR System 3x2.5G Example Design User Guide Agilex\u2122 5 FPGA E-Series Modular Development Kit 1x10G Ethernet System Example Design Agilex 5 Ethernet System Example Design * Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit Pro 25.1 Demonstrates a Single Port 10G Ethernet running on Agilex 5 E-Series Modular  Development Kit Agilex\u2122 5 FPGA E-Series Modular Development Kit 1x10G Ethernet System Example Design HPS Linux Golden System Reference Design Agilex 5 HPS System Example Design * Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit Pro 25.1.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS GSRD User Guide 4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices Agilex 5 Video/Vision System Example Design * Agilex 5 FPGA E-Series 065B Modular Development Kit MK-A5E065BB32AES1 Pro 25.1 4Kp60 Multi-Sensor HDR Camera Solution System Example Design User Guide for Modular Development kit. 4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices HPS GHRD Linux Boot Examples Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Provides instructions on how to build Linux systems from separate HPS software components HPS GHRD Linux Boot Examples HPS Zephyr Golden System Reference Design Agilex 5 HPS System Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 24.3 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS Zephyr GSRD User Guide Nios\u00ae V/g TinyML LiteRT Agilex 5 NIOS V Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1 Pro 25.1 Demonstrates the TinyML application using LiteRT for microcontrollers software with Nios\u00ae V/g processor Nios\u00ae V/g TinyML LiteRT for Microcontroller Design Nios V/m Baseline Golden Hardware Reference Design Agilex 5 NIOS V Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1 Pro 25.1 Demonstrates the baseline GHRD for a Nios V/m processor with basic bare minimum peripherals Nios\u00ae V/m Processor Baseline GHRD Design Nios V/c Helloworld OCM Memory Test Agilex 5 NIOS V Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1 Pro 25.1 Prints a simple Hello World message and performs a simple OCM memory test Helloworld and OCM memory test design on Nios\u00ae V/c Processor HPS Xen Hypervisor GSRD Agilex 5 HPS System Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Demonstrates the use of HPS Xen Hypervisor including the build of binaries to exercise this. HPS Xen Hypervisor GSRD SoC FPGA Remote Debug Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Demonstrates how to use the remote FPGA debug through HPS feature including instructions to build binaries for this SoC FPGA Remote Debug HPS TSN SGMII XCVR System Example Design User Guide Agilex 5 HPS System Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 24.3 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS TSN SGMII XCVR System Example Design User Guide HPS TSN RGMII System Example Design User Guide Agilex 5 HPS System Example Design * Agilex\u2122 5 E-Series Premium Development Kit Pro 25.1.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS TSN RGMII System Example Design User Guide HPS TSN RGMII HVIO System Example Design User Guide Agilex 5 HPS System Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 24.3.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS TSN RGMII HVIO System Example Design User Guide Agilex\u2122 5E HPS Enhanced System Example Design Overview Agilex 5 HPS System Example Design * DK-A5E065BB32AES1 Pro 25.1 Ethernet and Memory (DDR4,LPDDR4) Interface added on top of base GSRD and verified the HPS to Ethernet and Memory data path using HE_HSSI and MEM_TG respectively. Enhanced HPS User Guide HPS Remote System Update Example Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Provides a complete Remote System Update example including build instruction and execution for U-Boot and Linux HPS Remote System Update Agilex 5 PCIe Root Port System Example Design Agilex 5 PCIe System Example Design * Agilex\u2122 5 E-Series Premium Development Kit Pro 25.1 Demonstrates a PCIe root port running on Agilex 5 E-Series Premium  Development Kit PCIe Root Port HPS Linux Golden System Reference Design Agilex 5 HPS System Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS GSRD User Guide Agilex 5 USB 3.1 Gen-1 Controller Tutorial Example Design User Guide Agilex 5 HPS Tutorial Example Design User Guide * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1.1 Provides instructions on how to enable the USB 3.1 Gen-1 Controller in Host Mode, Device Mode, and Dual Role Device (DRD) Mode. USB 3.1 Example HPS GHRD Linux Boot Examples Stratix 10 HPS Tutorial Example Design * Stratix\u00ae 10 SX SoC Development Kit Pro 25.1.1 Provides instructions on how to build Linux systems from separate HPS software components HPS GHRD Linux Boot Examples HPS eMMC Boot Example Stratix 10 HPS Tutorial Example Design * Stratix\u00ae 10 SX SoC Development Kit Pro 24.3.1 Demonstrates how to boot HPS from eMMC HPS eMMC Boot HPS Linux Golden System Reference Design Stratix 10 HPS System Example Design * Stratix\u00ae 10 SX SoC Development Kit Pro 25.1.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS GSRD User Guide HPS Remote System Update Stratix 10 HPS Tutorial Example Design * Stratix\u00ae 10 SX SoC Development Kit Pro 25.1.1 Provides a complete Remote System Update example including build instruction and execution for U-Boot and Linux HPS Remote System Update SoC FPGA Remote Debug Stratix 10 HPS Tutorial Example Design * Stratix\u00ae 10 SX SoC Development Kit Pro 25.1.1 Demonstrates how to use the remote FPGA debug through HPS feature including instructions to build binaries for this SoC FPGA Remote Debug SoC Fabric Configuration from Linux Example Stratix 10 HPS Tutorial Example Design * Stratix\u00ae 10 SX SoC Development Kit Pro 25.1.1 Demonstrates how to configure the FPGA fabric from Linux running on HPS SoC Fabric Configuration from Linux Arria 10 HPS Golden Hardware Reference Design (GHRD) Boot Examples Arria 10 HPS Tutorial Example Design * Arria\u00ae 10 SX SoC Development Kit Pro 25.1.1 Provides instructions on how to build Linux systems from separate HPS software components HPS GHRD Linux Boot Examples HPS GSRD User Guide for the Arria\u00ae 10 SX SoC Development Kit Arria 10 HPS Tutorial Example Design * Arria\u00ae 10 SX SoC Development Kit Quartus\u00ae Prime Pro Edition Version 25.1.1 Complete reference design with GHRD, U-Boot, Linux Kernel, drivers, and sample applications for Arria\u00ae 10 SX SoC Development Kit. Supports multiple boot sources, including SD card, QSPI, NAND. GSRD User Guide HPS Linux Golden System Reference Design Cyclone\u00ae V HPS System Example Design * Cyclone\u00ae V E FPGA Development Kit Std 25.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries GSRD User Guide HPS GHRD Linux Boot Examples Cyclone\u00ae V HPS System Example Design * Cyclone\u00ae V E FPGA Development Kit Std 25.1 Complete bootloader building instruction with GHRD, Arm Trusted Firmware, U-Boot, Linux Kernel, drivers, and sample applications for Cyclone\u00ae V E FPGA Development Kit. Supports multiple boot sources, including SD card and QSPI. HPS GHRD Linux Boot Examples HPS GHRD Linux Boot Examples Agilex 3 HPS Tutorial Example Design * Agilex\u2122 3 FPGA and SoC C-Series Development Kit Pro 25.1.1 Provides instructions on how to build Linux systems from separate HPS software components HPS GHRD Linux Boot Examples SoC FPGA Remote Debug Agilex 3 HPS Tutorial Example Design * Agilex\u2122 3 FPGA and SoC C-Series Development Kit Pro 25.1.1 Demonstrates how to use the remote FPGA debug through HPS feature including instructions to build binaries for this SoC FPGA Remote Debug HPS GSRD User Guide for the Agilex\u2122 3 C-Series Development Kit Agilex 3 HPS System Example Design * Agilex\u2122 3 FPGA and SoC C-Series Development Kit Pro 25.1.1 Complete reference design with GHRD, Arm Trusted Firmware, U-Boot, Linux Kernel, drivers, and sample applications for Agilex 5 Premium Development Kit. Supports multiple boot sources, including SD card and QSPI. HPS GSRD User Guide HPS Remote System Update Agilex 3 HPS Tutorial Example Design * Agilex\u2122 3 FPGA C-Series Development Kit Pro 25.1.1 Provides a complete Remote System Update example including build instruction and execution for U-Boot and Linux HPS Remote System Update HPS Linux Golden System Reference Design Agilex 7 HPS System Example Design * Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (4x F-Tile) Pro 25.1.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS GSRD User Guide Agilex\u2122 7 I-Series Transceiver-SoC Development Kit PCIe Root Port System Example Design Agilex 7 PCIe System Example Design * Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (4x F-Tile) Pro 25.1.1 Demonstrates a PCIe root port running on Agilex 7 I-Series Premium  Development Kit HPS PCIe Root Port Example Design Agilex 7 R-Tile AVST PCIe Configuration Intercept Interface (CII) example design Agilex 7 PCIe System Example Design * Agilex\u2122 7 FPGA I-Series Development Kit (2x R-Tile and 1x F-Tile) Pro 25.1.1 Intended for FPGA and system developers to use as a guide for evaluating the R-Tile AVST PCIe IP and CII interface on Agilex 7 I-Series FPGA Development Kit board CII Example Design Multi-Channel 25GbE Precision Time Protocol System Example Design Agilex 7 PTP System Example Design * Agilex 7 FPGA I-Series Transceiver-SoC Development Kit (4x F-Tile) Pro 25.1.1 This System Example Design includes the required hardware, drivers, and user applications to validate a complete Precision Time Protocol (PTP) stack between two Agilex 7 development kits. Agilex 7 Multi-Channel 25GbE Time Precision Protocol System Example Design (I-Series, 4x F-Tile) HPS GHRD Linux Boot Examples Agilex 7 HPS Tutorial Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) Pro 25.1.1 Provides instructions on how to build Linux systems from separate HPS software components HPS GHRD Linux Boot Examples Setting up and Using Bridges HPS Linux Example Agilex 7 HPS Tutorial Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) Pro 25.1 Demonstrates how to configure FPGA2HPS bridges to move data to/from SDRAM from Linux Setting up and Using Bridges HPS Linux Example HPS eMMC Boot Example Agilex 7 HPS Tutorial Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) Pro 24.3.1 Demonstrates how to boot HPS from eMMC HPS eMMC Boot HPS Xen Hypervisor GSRD Agilex 7 HPS System Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) Pro 25.1.1 Demonstrates the use of HPS Xen Hypervisor including the build of binaries to exercise this. HPS Xen Hypervisor GSRD Nios V/g Processor Floating Point Unit Agilex 7 NIOS V Tutorial Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tile and E-Tile), ordering code DK-SI-AGF014EB Pro 25.1 Applying Linpack benchmark on Nios V/g floating point unit Nios\u00ae V/g Processor Floating Point Unit (FPU) Design HPS Linux Golden System Reference Design Agilex 7 HPS System Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) Pro 25.1.1 Demonstrates how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS GSRD User Guide SoC FPGA Remote Debug Agilex 7 HPS Tutorial Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) Pro 25.1.1 Demonstrates how to use the remote FPGA debug through HPS feature including instructions to build binaries for this SoC FPGA Remote Debug HPS Multi-QSPI Remote System Update Agilex 7 HPS Tutorial Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) Pro 25.1.1 Provides a complete Multi-QSPI Remote System Update example including build instruction and execution for U-Boot and Linux HPS Multi-QSPI Remote System Update HPS Remote System Update Agilex 7 HPS Tutorial Example Design * Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) Pro 25.1.1 Provides a complete Remote System Update example including build instruction and execution for U-Boot and Linux HPS Remote System Update SoC Fabric Configuration from Linux Example Agilex 7 HPS Tutorial Example Design * Agilex\u2122 7 FPGA F-Series Development Kit (2x F-Tile) Pro 25.1.1 Demonstrates how to configure the FPGA fabric from Linux running on HPS SoC Fabric Configuration from Linux Example Nios V/g TinyML LiteRT Agilex 7 NIOS V Tutorial Example Design * Agilex\u00ae 7 FPGA F-Series Development Kit, ordering code DK-DEV-AGF014EA Pro 25.1 Demonstrates the TinyML application using LiteRT for microcontrollers software with Nios V/g processor Nios\u00ae V/g TinyML LiteRT for Microcontroller Design HPS Linux Golden System Reference Design Agilex 7 HPS System Example Design * Agilex\u2122 7 FPGA F-Series Development Kit (2x F-Tile) Pro 25.1.1 Demonstrates how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS GSRD User Guide HPS Linux Golden System Reference Design Agilex 7 HPS System Example Design * Agilex\u2122 7 FPGA M-Series Development Kit - HBM2e Edition (3x F-Tile &amp; 1x R-Tile) Pro 25.1.1 Demonstrate how to exercise a set of basic HPS examples in the development kit. Also provides instructions on how to build the GHRD and HPS binaries HPS GSRD User Guide Baremetal Hello World Example Agilex 5 HPS Tutorial Example Design * Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit Pro 25.1 Provides instructions on how to build an HPS baremetal Hello World application to boot from QSPI and DDRAM. Baremetal Hello World Example Agilex 7 PCIe-Attached Example Design with OFS Agilex 7 AI System Example Design * Intel FPGA SmartNIC N6001-PL Platform Pro 25.1 Demonstrates ML inference using the Intel FPGA SmartNIC N6001-PL Platform (without an Ethernet controller). Agilex 7 PCIe-Attached Example Design with OFS (N6001) Agilex 7 PCIe-Attached Example Design Agilex 7 AI System Example Design * Terasic* DE10-Agilex Development Board Pro 25.1 Demonstrates ML inference using the Terasic DE10-Agilex Development Board. Agilex 7 PCIe-Attached Example Design (DE10) Agilex 7 PCIe-Attached Example Design with OFS (I-Series) Agilex 7 AI System Example Design * Agilex 7 FPGA I-Series Development Kit 2xR-Tile and 1xF-Tile DK-DEV-AGI027-RA Pro 25.1 Demonstrates ML inference using the Agilex 7 FPGA I-Series Development Kit (2x R-Tile and 1x F-Tile). Agilex 7 PCIe-Attached Example Design with OFS (I-Series, 2x R-Tile and 1x F-Tile) Using the OpenVINO Open Model Zoo Agilex 7, Agilex 5 AI Tutorial Example Design N/A Pro 25.1 Enable users in using the OpenVINO model zoo for testing inference. Using the OpenVINO Open Model Zoo AGX5 Modular Development Kit Setup with OFS 2025.1 Agilex 5 AI Tutorial Example Design * Agilex 5 FPGA E-Series 065B Modular Development Kit MK-A5E065BB32AES1 Pro 25.1 Enable users in using an Agilex 5 Modular Development Kit with the OFS 2025.1 release. AGX5 Modular Development Kit Setup with OFS 2025.1 Agilex 5 Hostless JTAG Example Design Agilex 5 AI System Example Design * Agilex 5 FPGA E-Series 065B Modular Development Kit MK-A5E065BB32AES1 Pro 25.1 Demonstrate inference over JTAG and target FPGA AI Suite IP on the Agilex 5E Modular Development Kit. Hostless JTAG Example Design"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/","title":"HPS GHRD Linux Boot Tutorial Example Design: Agilex\u2122 3 FPGA and SoC C-Series Development Kit","text":""},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#overview","title":"Overview","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The key differences versus the GSRD are:</p> <ul> <li>Fabric is configured from U-Boot directly with the rbf file, with <code>fpga load</code> command, instead of using the <code>bootm</code> command with the core.rbf part of the kernel.itb file</li> <li>Single image boot is disabled in U-Boot, and it boots directly with the slected boot source, not trying them all</li> <li>The applications and drivers form <code>meta-intel-fpga-refdes</code> are not included. That includes accessing GPIOs in the fabric for LEDs, push buttons, dip switches, the webserver running on the board, etc.</li> </ul> <p>The following scenarios are covered:</p> <ul> <li>Boot from SD card</li> <li>Boot from QSPI</li> </ul> <p>The instructions on this page are based on the GSRD.</p>"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the guides from this page:</p> <ul> <li>Altera\u00ae Agilex\u2122 3 FPGA C-Series Development Kit, ordering code DK-A3Y135BM16AEA.<ul> <li>Type-C USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer. Included with the development kit</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files.</li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#development-kit","title":"Development Kit","text":"<p>Refer to Development Kit for details about the board.</p>"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#release-notes","title":"Release Notes","text":"<p>Refer to Release Notes for release readiness information and known issues.</p>"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#hps-enablement-board","title":"HPS Enablement Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS Enablement Board. Both booting from SD card and booting from QSPI are covered.</p>"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#boot-from-sd-card","title":"Boot from SD Card","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex3_boot.sdcard_qspi\nmkdir agilex3_boot.sdcard_qspi\ncd agilex3_boot.sdcard_qspi\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex3_soc_devkit_ghrd &amp;&amp; mkdir agilex3_soc_devkit_ghrd &amp;&amp; cd agilex3_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex3c-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a3cw135-devkit-oobe-legacy-baseline.zip\nunzip a3cw135-devkit-oobe-legacy-baseline.zip\nrm -f a3cw135-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex3 bl31\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex3/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga_sd\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga u-boot-socfpga_sd\ncd u-boot-socfpga_sd # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex3_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex3/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex3_socdk.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex3_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga_sd/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga_sd/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_sd.jic \\\n-o device=QSPI512 \\\n-o flash_loader=A3CW135BM16AE6S \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga_sd/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_sd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_sd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga_sd/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd_sd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\ncat &lt;&lt; EOF &gt; config-fragment-agilex3\n# Enable Ethernet connectivity so we can get an IP address\nCONFIG_MARVELL_PHY=y\nEOF\nmake defconfig\n# Apply custom Configs in file\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex3\nmake oldconfig\nmake -j 64 Image &amp;&amp; make intel/socfpga_agilex3_socdk.dtb\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Install Yocto Dependencies <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex3\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex3/core-image-minimal-agilex3.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd_sd.core.rbf ghrd.core.rbf\ncp $TOP_FOLDER/u-boot-socfpga_sd/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex3/core-image-minimal-agilex3.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power cycle the board</p> <p>2. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power cycle the board</p> <p>2. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from QSPI.</p> <p>NOTE:  This section assumes that the Boot from SD Card section has been already built and the environment setup in that section is still available.</p> <p>This section presents how to build the binaries and boot from QSPI with the HPS Enablement Board. While the example is based on the GSRD, it contains the following differences:</p> <ul> <li>U-Boot tries to boot only from QSPI flash, does not try SD card</li> <li>U-Boot does not use a script to boot, instead it used the <code>BOOTCMD</code> environment variable directly</li> <li>kernel.itb file contains only one set of core.rbf, kernel and device tree files, targeted for this scenario</li> </ul> <p>1. Prepare the top folder</p> <pre><code>rm -rf $TOP_FOLDER/qspi-boot\nmkdir $TOP_FOLDER/qspi-boot\n</code></pre> <p>2. Build U-Boot for QSPI:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -rf u-boot-socfpga_qspi\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga u-boot-socfpga_qspi\ncd u-boot-socfpga_qspi # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from QSPI\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex3_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex3/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# mtd info\nCONFIG_MTDIDS_DEFAULT=\"nor0=nor0\"\nCONFIG_MTDPARTS_DEFAULT=\"mtdparts=nor0:6m(u-boot),58m(root)\"\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# do not keep env on sd card\nCONFIG_ENV_IS_IN_FAT=n\n# disable NAND related settings from defconfig\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"mtdparts;ubi part root;ubi readvol \\${loadaddr} kernel;ubi detach;setenv bootargs earlycon panic=-1 ubi.mtd=1 root=ubi0:rootfs rootfstype=ubifs rw rootwait;bootm \\${loadaddr}#board-0;\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex3_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga_qspi/u-boot.itb</code></li> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga_qspi/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build <code>kernel.itb</code> FIT file containing kernel, device tree and fpga fabric configuration file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -f core.rbf devicetree.dtb Image.lzma kernel.its kernel.itb\nln -s $TOP_FOLDER/ghrd_sd.core.rbf core.rbf\nln -s $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dtb devicetree.dtb\nxz --format=lzma --extreme -k -c ../linux-socfpga/arch/arm64/boot/Image &gt; Image.lzma\ncat &lt;&lt; EOF &gt; kernel.its\n// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2024 Intel Corporation\n *\n */\n/dts-v1/;\n/ {\n    description = \"FIT image with kernel, DTB and FPGA core binary\";\n    #address-cells = &lt;1&gt;;\n    images {\n        kernel {\n            description = \"Linux Kernel\";\n            data = /incbin/(\"./Image.lzma\");\n            type = \"kernel\";\n            arch = \"arm64\";\n            os = \"linux\";\n            compression = \"lzma\";\n            load = &lt;0x86000000&gt;;\n            entry = &lt;0x86000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fdt-0 {\n            description = \"Device Tree\";\n            data = /incbin/(\"./devicetree.dtb\");\n            type = \"flat_dt\";\n            arch = \"arm64\";\n            compression = \"none\";\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fpga-0 {\n            description = \"FPGA bitstream\";\n            data = /incbin/(\"./core.rbf\");\n            type = \"fpga\";\n            arch = \"arm64\";\n            compression = \"none\";\n            load = &lt;0x8A000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n    };\n    configurations {\n        default = \"board-0\";\n        board-0 {\n            description = \"board_0\";\n            kernel = \"kernel\";\n            fdt = \"fdt-0\";\n            fpga = \"fpga-0\";\n            signature {\n                algo = \"crc32\";\n                key-name-hint = \"dev\";\n                sign-images = \"fdt-0\", \"kernel\", \"fpga-0\";\n            };\n        };\n    };\n};\nEOF\n./u-boot-socfpga_qspi/tools/mkimage -f kernel.its kernel.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/kernel.itb</code></li> </ul> <p>4. Truncate U-Boot binary <code>u-boot.bin</code> with a size of exactly 2MB:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncp u-boot-socfpga_qspi/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/u-boot.bin</code></li> </ul> <p>5. Build the <code>rootfs.ubifs</code> file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -rf rootfs rootfs.ubifs\nmkdir rootfs tar -xzvf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex3/core-image-minimal-agilex3.rootfs.tar.gz -C rootfs mkfs.ubifs -r rootfs -F -e 65408 -m 1 -c 6500 -o rootfs.ubifs </code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/rootfs.ubifs</code></li> </ul> <p>6. Build the <code>root.ubi</code> file:</p> <pre><code>cat &lt;&lt; EOF &gt; ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nvol_id=1\nvol_name=script\nvol_size=128KiB \nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=14MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3    \nvol_name=dtb   \nvol_size=256KiB \nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=42MiB\nvol_flag=autoresize\nEOF\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/root.ubi</code></li> </ul> <p>7. Build the QSPI flash image:</p> <pre><code>ln -s $TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof fpga.sof\nln -s u-boot-socfpga_qspi/spl/u-boot-spl-dtb.hex spl.hex\nln -s root.ubi hps.bin\ncat &lt;&lt; EOF &gt; flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n    &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_loader&gt;A3CW135BM16AR0&lt;/flash_loader&gt;\n        &lt;flash_device type=\"QSPI512\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x0400000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"UBOOT\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x0600000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"HPS\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"UBOOT\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash_image.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/flash_image.hps.jic</code></li> </ul> Write QSPI Flash <p>1. Power cycle the board</p> <p>2. Write JIC image to QSPI:</p> <p><pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"qspi-boot/flash_image.hps.jic\"\n</code></pre> Note: You need to wipe the micro SD card or remove it from the board before start running.</p> Boot Linux <p>1. Power cycle the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-3/c-series/boot-examples/ug-linux-boot-agx3/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/","title":"HPS GSRD User Guide for the Agilex\u2122 3 C-Series Development Kit","text":""},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#gsrd-overview","title":"GSRD Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex\u2122 3 C-Series Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 3 FPGA and SoC C-Series Development Kit GSRD:</p> <ul> <li>Altera\u00ae Agilex\u2122 3 FPGA and SoC C-Series Development Kit, ordering code DK-A3W135BM16AEA. Refer to board documentation for more information about the development kit.</li> </ul> <ul> <li> <p>Host PC with:</p> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> </ul> <ul> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex\u2122 3 FPGA and SoC C-Series Development Kit GSRD binaries are located at https://releases.rocketboards.org/2025.08/:</p> Boot Source Link SD Card https://releases.rocketboards.org/2025.08/gsrd/agilex3_gsrd QSPI https://releases.rocketboards.org/2025.08/qspi/agilex3_qspi"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#development-kit","title":"Development Kit","text":"<p>This release targets the Agilex 3 FPGA and SoC C-Series Development Kit. Refer to board documentation for more information about the development kit.</p> <p></p> MSEL Setting <p>The default configuration is AS x4 (Fast) using a 512 Mb QSPI flash device.</p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Dual core Arm Cortex-A55 processor</li> <li>HPS Peripheral and I/O:<ul> <li>Micro SD Card</li> <li>EMAC</li> <li>MDIO</li> <li>JTAG</li> <li>I2C</li> <li>UART</li> <li>USB</li> <li>GPIO</li> </ul> </li> </ul> </li> <li>Multi-Ported Front End (MPFE) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>Two user LED outputs</li> <li>Four user DIP switch inputs</li> <li>Two user push-button inputs</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <p> </p>  MPU Address Maps <p>This section presents the address maps as seen from the MPU side.  </p>  HPS-to-FPGA Address Map <p>The three FPGA windows in the MPU address map provide access to 256 GB of FPGA space. First window is 1 GB from 00_4000_0000, second window is 15 GB from 04_4000_0000, third window is 240 GB from 44_0000_0000. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU, which starts at the lightweight HPS-to-FPGA base address of 0x00_2000_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0001_0000 32 Unique system ID led_pio 0x0001_0080 16 LED outputs button_pio 0x0001_0060 16 Push button inputs JTAG Master Address Map <p>There are three JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface and another for FPGA fabric to SDRAM.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0001_0000 32 Unique system ID led_pio 0x0001_0080 16 LED outputs button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs  Interrupt Routing <p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute button_pio f2h_irq0[1] 2 Push button inputs"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#exercising-prebuilt-binaries","title":"Exercising Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Connect Type-C USB cable from Type-C USB connector to host PC. This is used for the HPS serial console and JTAG communication.</p> <p>3. Connect Ethernet cable from HPS Board to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p> <p>Note: Please refer to Powering Up the Development Board  for instructions about how to powering up correctly the development kit.</p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>1. Install a serial terminal emulator application on your host PC:  </p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Power down your board if powered up. This is important, as once powered up, with the Type-C USB cable connected, a couple more USB serial ports will enumerate, and you may choose the wrong port.</p> <p>3. Connect Type-C USB cable from the Type-C USB connector on the development board to the host PC</p> <p>4. On the host PC, an USB serial port will enumerate. On Windows machines it will be something like <code>COM&lt;number&gt;</code>, while on Linux machines it will be something like <code>/dev/tty/USB0</code>.</p> <p>5. Configure your serial terminal emulator to use the following settings:  </p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>6. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#booting-from-sd-card","title":"Booting from SD Card","text":""},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#write-sd-card-image","title":"Write SD CardWrite QSPI FlashBoot LinuxRun Sample ApplicationsControl LEDsConnect to Board Using SSHVisit Board Web Page","text":"<p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2025.08/gsrd/agilex3_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex3_devkit.wic</code>.</p> <p>2. Write the gsrd-console-image-agilex3_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex3_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. For this, first rename the gsrd-console-image-agilex3_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p> </p> <p>1. Power down board</p> <p>2. Power up the board</p> <p>3. Download and extract the JIC image, then write it to QSPI <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/agilex3_gsrd/ghrd_a3cw135bm16ae6s.hps.jic.tar.gz\ntar xf ghrd_a3cw135bm16ae6s.hps.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a3cw135bm16ae6s.hps.jic\"\n</code></pre></p> <p>1. Power down board</p> <p>2. Power up the board</p> <p>3. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>1. Boot to Linux</p> <p>2. Change current folder to <code>intelFPGA</code> folder <pre><code>cd intelFPGA\n</code></pre> 3. Run the hello world application <pre><code>./hello\n</code></pre> 4. Run the <code>syscheck</code> application <pre><code>./syscheck\n</code></pre> Press <code>q</code> to exit the <code>syscheck</code> application.</p> <p>1. Boot to Linux</p> <p>2. Control LEDs by using the following sysfs entries:</p> <ul> <li>/sys/class/leds/fpga_led0/brightness</li> <li>/sys/class/leds/fpga_led1/brightness</li> <li>/sys/class/leds/fpga_led2/brightness</li> <li>/sys/class/leds/hps_led1/brightness</li> </ul> <p>using commands such as: <pre><code>cat /sys/class/leds/fpga_led0/brightness\necho 0 &gt; /sys/class/leds/fpga_led0/brightness\necho 1 &gt; /sys/class/leds/fpga_led1/brightness\n</code></pre></p> <p>Because of how the LEDs are connected, for the above commands <code>0</code> means LED is turned on, <code>1</code> means LED is turned off.</p> <p>1. Boot to Linux  </p> <p>2. Determine the board IP address using the <code>ifconfig</code> command: <pre><code>root@agilex3:~# ifconfig\neth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\ninet 10.244.216.217  netmask 255.255.255.224  broadcast 10.244.216.223\n        inet6 fe80::305b:c2ff:fee5:f2ec  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 32:5b:c2:e5:f2:ec  txqueuelen 1000  (Ethernet)\nRX packets 8  bytes 1371 (1.3 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 29  bytes 5734 (5.5 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 23  base 0x8000\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 252  bytes 17530 (17.1 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 252  bytes 17530 (17.1 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> 3. Connect to the board over SSH using <code>root</code> username, no password will be requested: <pre><code>ssh root@10.244.216.217\n</code></pre> Note: Make sure to replace the above IP address to the one matching the output of running <code>ifconfig</code> on youir board.</p> <p>1. Boot to Linux  </p> <p>2. Determine board IP address using <code>ifconfig</code> like in the previous scenario  </p> <p>3. Start a web browser and enter the IP address in the address bar  </p> <p>4. The web browser will display a page served by the web server running on the board.  </p> <p></p> <ul> <li>You will able to see which LED are ON and OFF in LED Status.</li> <li>You can Start and Stop the LED from scrolling. Set the delay(ms) in the LED Lightshow box. </li> <li>You can controll each LED with ON and OFF button.</li> <li>Blink each LED by entering the delay(ms) and click on the BLINK button.</li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#booting-from-qspi","title":"Booting from QSPI","text":"<p>This section presents how to boot from QSPI. One notable aspect is that you need to wipe the SD card partitioning information, as otherwise U-Boot SPL could find a valid SD card image, and try to boot from that first.</p> Wipe SD Card <p>Either write 1MB of zeroes at the beginning of the SD card, or remove the SD card from the HPS Daughter Card. You can use <code>dd</code> on Linux, or <code>Win32DiskImager</code> on Windows to achieve this.</p> Write QSPI Flash <p>1. Power down board</p> <p>2. Power up the board</p> <p>3. Download and extract the JIC image, then write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2025.08/qspi/agilex3_qspi/ghrd_a3cw135bm16ae6s.hps.jic.tar.gz\ntar xf ghrd_a3cw135bm16ae6s.hps.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;agilex_flash_image.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Power up the board</p> <p>3. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>Note: On first boot, the UBIFS rootfilesystem is initialized, and that takes a few minutes. This will not happen on next reboots. See a sample log below:</p> <pre><code>[   12.837281] UBIFS (ubi0:4): Mounting in unauthenticated mode\n[   12.843233] UBIFS (ubi0:4): background thread \"ubifs_bgt0_4\" started, PID 77\n[   12.854642] UBIFS (ubi0:4): start fixing up free space\n[   20.692155] random: crng init done\n[   42.087027] UBIFS (ubi0:4): free space fixup complete\n[   42.210248] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[   42.217667] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[   42.227062] UBIFS (ubi0:4): FS size: 43365504 bytes (41 MiB, 663 LEBs), max 8600 LEBs, journal size 8650240 bytes (8 MiB, 133 LEBs)\n[   42.238870] UBIFS (ubi0:4): reserved for root: 0 bytes (0 KiB)\n[   42.244702] UBIFS (ubi0:4): media format: w4/r0 (latest is w5/r0), UUID 86831E0C-2E6F-439D-99EB-139B00E31D93, small LPT model\n[   42.321834] VFS: Mounted root (ubifs filesystem) on device 0:22.\n</code></pre>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#rebuilding-the-gsrd","title":"Rebuilding the GSRD","text":""},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#yocto-build-prerequisites","title":"Yocto Build Prerequisites","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#build-sd-card-boot-binaries","title":"Build SD Card Boot Binaries","text":"<p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex3_gsrd\nmkdir agilex3_gsrd\ncd agilex3_gsrd\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex3_soc_devkit_ghrd &amp;&amp; mkdir agilex3_soc_devkit_ghrd &amp;&amp; cd agilex3_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex3c-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a3cw135-devkit-oobe-legacy-baseline.zip\nunzip a3cw135-devkit-oobe-legacy-baseline.zip\nrm -f a3cw135-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a3cw135bm16ae6s.rbf\nquartus_pfg -c agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a3cw135bm16ae6s.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a3cw135bm16ae6s.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n . agilex3-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex3_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex3_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex3_gsrd_core</code> with <code>file://agilex3_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex3_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex3_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a3cw135bm16ae6s.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex3_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex3_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex3_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex3_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-gsrd-images/u-boot-agilex3-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a3cw135bm16ae6s.hps.jic ghrd_a3cw135bm16ae6s.core.rbf\nquartus_pfg \\\n-c agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a3cw135bm16ae6s.jic \\\n-o device=QSPI512 \\\n-o flash_loader=A3CW135BM16AE6S \\\n-o hps_path=gsrd-socfpga/agilex3-gsrd-images/u-boot-agilex3-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a3cw135bm16ae6s.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a3cw135bm16ae6s.hps.rbf\nquartus_pfg \\\n-c agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a3cw135bm16ae6s.rbf \\\n-o hps_path=gsrd-socfpga/agilex3-gsrd-images/u-boot-agilex3-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a3cw135bm16ae6s.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#build-qspi-boot-binaries","title":"Build QSPI Boot Binaries","text":"<p>In the Agilex 3 C-Series Development Kit, the size of the QSPI memory device is very small (64 MB), so it is required to create a UBI file system with a reduced size. This file system does not include the regular GSRD applications and the functionality demonstrated only allow you to boot to Linux. To create this reduced size file system, it is needed to rebuild Yocto using agilex3-qspi-build.sh setup script. </p> <p>The diagram below shows how booting from QSPI JIC is built. The hardware project compilation and Yocto build remain the same, and the QSPI JIC is built based on the resulted files:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex3_gsrd-qspi\nmkdir agilex3_gsrd-qspi\ncd agilex3_gsrd-qspi\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex3_soc_devkit_ghrd &amp;&amp; mkdir agilex3_soc_devkit_ghrd &amp;&amp; cd agilex3_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex3c-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a3cw135-devkit-oobe-legacy-baseline.zip\nunzip a3cw135-devkit-oobe-legacy-baseline.zip\nrm -f a3cw135-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a3cw135bm16ae6s.rbf\nquartus_pfg -c agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a3cw135bm16ae6s.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a3cw135bm16ae6s.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n . agilex3-qspi-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex3_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex3_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex3_gsrd_core</code> with <code>file://agilex3_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex3_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code>   The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex3_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a3cw135bm16ae6s.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex3_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex3_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex3_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex3_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/u-boot-agilex3-socdk-qspi-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/core-image-minimal-agilex3_nor.ubifs</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/u-boot-agilex3-socdk-qspi-atf/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/u-boot-agilex3-socdk-qspi-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/kernel.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/u-boot-agilex3-socdk-qspi-atf/boot.scr.uimg</code></li> </ul> Create QSPI Image <p>1. Get the <code>ubinize.cfg</code> file which contains the details on how to build the <code>root.ubi</code> volume, and <code>agilex3_devkit_flash_image_hps.pfg</code> which contains the instructions for Programming File Generator on how to create the .jic file:</p> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2025.08/qspi/agilex3_qspi/ubinize.cfg\nwget https://releases.rocketboards.org/2025.08/qspi/agilex3_qspi/agilex3_flash_image_hps.pfg sed -i 's/ghrd_a3cw135bm16ae6s\\.sof/legacy_baseline.sof/g' agilex3_flash_image_hps.pfg    </code></pre> <p>2. Link to the files that are needed from building the hardware design, and yocto:</p> <pre><code>cd $TOP_FOLDER\nln -s $TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/core-image-minimal-agilex3_nor.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/u-boot-agilex3-socdk-qspi-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/u-boot-agilex3-socdk-qspi-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof .\n</code></pre> <p>3. Process the u-boot.itb file to be exactly 2MB in size:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex3-qspi-images/u-boot-agilex3-socdk-qspi-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>4. Create the <code>root.ubi</code> file and rename it to <code>hps.bin</code> as Programming File Generator needs the <code>.bin</code> extension:</p> <pre><code>ubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>5. Create the JIC file:</p> <pre><code>quartus_pfg -c agilex3_flash_image_hps.pfg    </code></pre> <p>The following file is generated:</p> <ul> <li><code>$TOP_FOLDER/agilex_flash_image.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/agilex-3/c-series/gsrd/ug-gsrd-agx3/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/","title":"SoC FPGA Remote Debug Tutorial Example Design: Agilex\u2122 3 FPGA and SoC C-Series Development Kit","text":""},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#introduction","title":"Introduction","text":"<p>Altera offers an integrated set of System Level Debug (SLD) tools, including:</p> <ul> <li>SignalTap II Logic Analyzer</li> <li>In-System Sources and Probes (ISSP),</li> <li>In-System Memory Content Editor)</li> </ul> <p>Typically, the System-Level Debugging (SLD) communication solution was interfacing with the outside world through the JTAG. Then either an USB or Ethernet Blaster could be used to interface JTAG to the host PC.</p> <p></p> <p></p> <p>Another alternative approach is also available, to interface the SLD to the outside world directly through Ethernet, without requiring either an USB or Ethernet Blaster.</p> <p></p> <p>This page presents an example on how enable this remote debug feature on top of the GSRD.</p>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#architecture","title":"Architecture","text":"<p>In the traditional approach the SLD communication solution was based on the Altera JTAG Interface (AJI) which interfaced with the JTAG TAP controller (hard atom in Altera devices which implements the JTAG protocol). The SLD tools used the JTAG channel for communication between software and hardware.</p> <p></p> <p>The remote FPGA debugging solution consists of the following:</p> <ul> <li>JTAG-Over Protocol (JOP) Component: Platform Designer component which enables access to debug information through an Avalon\u00ae-MM slave bus</li> <li>Etherlink: HPS application exporting debug information over Ethernet, available on github: https://github.com/altera-fpga/remote-debug-for-intel-fpga</li> </ul> <p></p> <p>The JOP component requires reset and clocking and also provides an Avalon\u00ae-MM slave bus through which is configured and debug information is accessed.</p> <p>Th Etherlink application runs on HPS, accesses the JOP component slave bus to access the debug information, and provides a TCP/IP link from the host PC running the Quartus Pro debug tools to the board.</p> <p>The etherlink works with the standard UIO Linux kernel driver.</p>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#example","title":"Example","text":"<p>This section shows an example of how to use the Remote Debug feature. Communication is established from the board to the host PC through Ethernet, so that the board appears as another JTAG device, listed by jtagconfig utility.</p> <p>The example is based on the GSRD, with the following changes:</p> <ul> <li>Adding JOP component to the GHRD</li> <li>Adding JOP to the Linux device tree</li> </ul> <p>Notes:</p> <ul> <li>UIO driver is enabled as module in the default kernel configuration file</li> <li>etherlink is already part of the rootfs, built by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Altera\u00ae Agilex\u2122 3 FPGA and SoC C-Series Development Kit, ordering code DK-A3W135BM16AEA. Refer to board documentation for more information about the development kit.</li> </ul> <ul> <li> <p>Host PC with:</p> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> </ul> <ul> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex3.remote_debug\nmkdir agilex3.remote_debug\ncd agilex3.remote_debug\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#build-hardware-design","title":"Build Hardware Design","text":"<p>1. Generate the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex3_soc_devkit_ghrd &amp;&amp; mkdir agilex3_soc_devkit_ghrd &amp;&amp; cd agilex3_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex3c-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a3cw135-devkit-oobe-legacy-baseline.zip\nunzip a3cw135-devkit-oobe-legacy-baseline.zip\nrm -f a3cw135-devkit-oobe-legacy-baseline.zip\n</code></pre> <p>2. Open the project in Quartus, open the <code>qsys_top.qsys</code> file in Platform Designer.</p> <p>3. In the IP Catalog search for jop and double-click the component to add it to the system:</p> <p></p> <p>4. Configure the JOP component as follows:</p> <p></p> <p>5. Connect the reset and clock to JOP component, also connect it's slave bus to the HPS LW bridge, and map it at offset 0x0002_0000:</p> <p></p> <p>6. Alternatively, steps 2-6 can be peformed from command line, using the provided tcl script:</p> <pre><code>cd $TOP_FOLDER\nrm -f agilex3-ghrd-add-jop.tcl\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-3/c-series/remote-debug/collateral/agilex3-ghrd-add-jop.tcl\ncd agilex3_soc_devkit_ghrd\nqsys-script --qpf=top.qpf --script=../agilex3-ghrd-add-jop.tcl --system-file=qsys_top.qsys\n</code></pre> <p>7. Finish compilation of the GHRD from command line:</p> <pre><code>cd $TOP_FOLDER/agilex3_soc_devkit_ghrd\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#build-corerbf-file","title":"Build Core.RBF File","text":"<p>This section shows how to create the core RBF file, which is needed by the Yocto recipes:</p> <pre><code>cd $TOP_FOLDER rm -f ghrd_a3cw135bm16ae6s.rbf\nquartus_pfg -c agilex3_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a3cw135bm16ae6s.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a3cw135bm16ae6s.core.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#build-yocto","title":"Build Yocto","text":"<p>Perform the following steps to build Yocto:</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex3-gsrd-build.sh\nbuild_setup\n</code></pre> <p>3. Enable the JOP UIO driver in the Linux device tree, by editing the file <code>meta-intel-fpga-refdes</code> to inlcude the changes shown below:</p> <pre><code>diff --git a/recipes-bsp/device-tree/files/socfpga_agilex3_ghrd.dtsi b/recipes-bsp/device-tree/files/socfpga_agilex3_ghrd.dtsi\nindex 9e043ef..ceac3aa 100644\n--- a/recipes-bsp/device-tree/files/socfpga_agilex3_ghrd.dtsi\n+++ b/recipes-bsp/device-tree/files/socfpga_agilex3_ghrd.dtsi\n@@ -49,6 +49,11 @@\n                                resetvalue = &lt;0&gt;;\n                };\n */\n+               jop@20020000 {\n+                       compatible = \"generic-uio\";\n+                       reg = &lt;0x20020000 0x4000&gt;;\n+                       reg-names = \"jop\";\n+               };\n                soc_leds: leds {\n                        compatible = \"gpio-leds\";\n</code></pre> <p>Note that the range of memory where the JOP is located is <code>0x20020000</code> .. <code>0x20023fff</code>.</p> <p>This can be done with the provided patch file:</p> <pre><code>rm -f agilex3-dts-add-jop.patch\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-3/c-series/remote-debug/collateral/agilex3-dts-add-jop.patch\npushd meta-intel-fpga-refdes\npatch -p1 &lt; ../agilex3-dts-add-jop.patch\npopd\n</code></pre> <p>4. Update the recipe to not use a broken version of =etherlink=:</p> <pre><code>sed -i 's/3a3eb126321429c0845276ef9c200df7786dbf74/b6a13b03fe7e9566063eae65d99bd8bc1190ce62/g' meta-intel-fpga-refdes/recipes-tools/remote-debug-app/remote-debug-app_1.0.bb\n</code></pre> <p>5. Update your Yocto recipes to use the core RBF file you have built, similar to how the GSRD does it:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex3_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a3cw135bm16ae6s.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex3_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex3_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex3_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex3_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>6. Build the Yocto recipes:</p> <pre><code>bitbake_image\n</code></pre> <p>7. Gather the Yocto binaries:</p> <pre><code>package\n</code></pre> <p>The following relevant files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-gsrd-images/u-boot-agilex3-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex3-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#build-qspi-image","title":"Build QSPI Image","text":"<p>Run the following commands to build the QSPI image:</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a3cw135bm16ae6s.hps.jic ghrd_a3cw135bm16ae6s.core.rbf\nquartus_pfg \\\n-c agilex3_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a3cw135bm16ae6s.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A3CW135BM16AE6S \\\n-o hps_path=gsrd-socfpga/agilex3-gsrd-images/u-boot-agilex3-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a3cw135bm16ae6s.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#run-example","title":"Run Example","text":"<p>The instructions from this section present how to run the remote debug example. Refer to the GSRD for more detailed instructions on how to set up the board, serial port, and write the binaries.</p> <p>1. Write the QSPI image <code>$TOP_FOLDER/ghrd_a3cw135bm16ae6s.hps.jic</code> to flash.</p> <p>2. Extract and write the SD card image <code>$TOP_FOLDER/gsrd-socfpga/agilex3-gsrd-images/sdimage.tar.gz</code> to the SD card</p> <p>3. Boot board and log into Linux.</p> <p>4. Determine board IP address by running the <code>ifconfig</code> command:</p> <pre><code>root@agilex3:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 10.122.105.175  netmask 255.255.255.0  broadcast 10.122.105.255\n        inet6 fe80::7097:4bff:fe41:b7c2  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 72:97:4b:41:b7:c2  txqueuelen 1000  (Ethernet)\nRX packets 218  bytes 23619 (23.0 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 78  bytes 11072 (10.8 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 22  </code></pre> <p>5. Remove pre-existing instances of the driver, and load it again:</p> <pre><code>root@agilex3:~# rmmod uio_pdrv_genirq\nroot@agilex3:~# modprobe uio_pdrv_genirq of_id=\"generic-uio\"\n</code></pre> <p>6. Start the etherlink application, specifying which port to accept connections on as shown below:</p> <pre><code>root@agilex3:~# etherlink --port=33301\nINFO: Etherlink Server Configuration:\nINFO:    H2T/T2H Memory Size  : 4096\nINFO:    Listening Port       : 33301\nINFO:    IP Address           : 0.0.0.0\nINFO: UIO Platform Configuration:\nINFO:    Driver Path: /dev/uio0\nINFO:    Address Span: 16384\nINFO:    Start Address: 0x0\nINFO: Server socket is listening on port: 33301\n</code></pre> <p>7. On the host, establish the JTAG communication to the board through Ethernet, using the board IP and the selected port number:</p> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0\n</code></pre> <p>8. Also on the host, run the 'jtagconfig' command to show the newly added connection:</p> <pre><code>$ jtagconfig\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0]\n020D10DD   VTAP10\n</code></pre> <p>At this point, the connection can be used by the tools which need a JTAG connection, like SignalTap.</p>"},{"location":"embedded-designs/agilex-3/c-series/remote-debug/ug-remote-debug-agx3/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/","title":"HPS Remote System Update Tutorial Example Design: Agilex\u2122 3 FPGA C-Series Development Kit","text":""},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on the Agilex\u2122 3 C-Series Development Kit (DK-A3Y135BM16AEA), including the following:</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>For now, you can refer to the  Hard Processor System Remote System Update User Guide: Agilex\u2122 5 SoCs document for details about the Remote System Update. A document version for Agilex\u2122 3 FPGA's will be released soon.</p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p> <p>Note: librsu uses main branch.</p> <p>Note: RSU functionality for Agilex 3 device was first enabled in 25.1.1 release.</p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus\u00ae Prime Pro Edition Version 25.1.1  for compiling the hardware projects, generating the flash images and writing to flash </li> <li>cmake/3.24.0  (build configuration tool) or above to build LibRSU library.</li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li>Agilex\u2122 3 C-Series Development Kit (DK-A3Y135BM16AEA)  for running the example. </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are these.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#installing-cmake","title":"Installing cmake","text":"<p>In case that you have installed a cmake version earlier than 3.24.0, you need to unistall this and install a new version. Here are the steps to achieve that. Note that this only need to performed once in your PC:</p> <pre><code>sudo apt remove cmake\nDownload cmake-x.y.z-linux-x86_64.sh from https://cmake.org/download\nsudo cp ~/Downloads/cmake-x.y.z-linux-x86_64.sh /opt/\nsudo chmod +x /opt/cmake-x.y.z-linux-x86_64.sh\nmkdir ~/cmake_install/  &amp;&amp; cd ~/cmake_install/\nsudo bash /opt/cmake-x.y.z-linux-x86_64.sh\nsudo ln -s ~/cmake_install/cmake-x.y.z-linux-x86_64/bin/* /usr/local/bin/\n</code></pre>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex3-rsu mkdir agilex3-rsu cd agilex3-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next.</p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below.</p> <pre><code>cd $TOP_FOLDER # Build 4 versions of the hardware design\nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw rm -rf agilex3_soc_devkit_ghrd &amp;&amp; mkdir agilex3_soc_devkit_ghrd &amp;&amp; cd agilex3_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex3c-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a3cw135-devkit-oobe-legacy-baseline.zip\nunzip a3cw135-devkit-oobe-legacy-baseline.zip\nrm -f a3cw135-devkit-oobe-legacy-baseline.zip\ncd ..\n# Crteate script to update project settings\ncat &lt;&lt;EOT &gt; update-qsf.tcl\nproject_open top -revision legacy_baseline\nset_global_assignment -name RSU_MAX_RETRY_COUNT 3\nset_global_assignment -name HPS_INITIALIZATION \"AFTER INIT_DONE\"\nproject_close\nEOT\n# Create script to update wdog configuration\ncat &lt;&lt;EOT &gt; update-wdog.tcl\npackage require qsys\nload_component agilex_hps\nset_component_parameter_value Rst_sdm_wd_config {2}\nset_component_parameter_value Rst_watchdog_en {1}\nsave_component\nsave_system hps_subsys.qsys\nEOT\nfor version in {0..3}\ndo\nrm -rf ghrd.$version\ncp -r agilex3_soc_devkit_ghrd ghrd.$version\ncd ghrd.$version\n# Customizing to the current copy of the GHRD\nquartus_sh -t ../update-qsf.tcl\n# Customize WDT \nqsys-script --qpf=top.qpf --script=../update-wdog.tcl --system-file=hps_subsys.qsys\n# update sysid with the loop iterator 'value'\ncat &lt;&lt;EOT &gt; update-sysid.tcl\npackage require -exact qsys 25.1.1\nload_component sysid\nset_component_parameter_value id {0xABAB000$version}\nsave_component\nsave_system peripheral_subsys.qsys\nEOT\nqsys-script --qpf=top.qpf --script=update-sysid.tcl --system-file=peripheral_subsys.qsys\n# Finsish customization and now building the hardware design\nmake legacy_baseline-build\ncd ..\ndone\nrm -rf agilex3_soc_devkit_ghrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created.</p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/output_files/legacy_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/output_files/legacy_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/output_files/legacy_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/output_files/legacy_baseline.sof </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\n# checkout the branch used for this document, comment out to use default\ngit checkout -b test -t origin/socfpga_v2.12.1\nmake -j 48 PLAT=agilex3 bl31\ncd ..\n</code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex3/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone https://github.com/altera-fpga/u-boot-socfpga cd u-boot-socfpga # comment out next line to use the latest default branch \ngit checkout -b test -t origin/socfpga_v2025.04 # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex3_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex3_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex3/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\n# Enabling Watchdog automatically if it's not done already. Increased the timeout to 30 sec to prevent expiration (Removed for now after HSD: 14025895197)\n#CONFIG_WATCHDOG_AUTOSTART=y\n#CONFIG_WATCHDOG_TIMEOUT_MSECS=30000\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex3_socdk.dtb; run linux_qspi_enable; run rsu_status; setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait; booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\n# Change prompt\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex3_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul> <p>Note: You can control the U-Boot erase granularity to be 4 KB or 64 KB with the CONFIG_SPI_FLASH_USE_4K_SECTORS configuration. A value of y implies an erase granularity of 4 KB otherwise the erase granularity will be 64 KB.</p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone https://github.com/altera-fpga/linux-socfpga cd linux-socfpga # checkout the branch used for this document, comment out to use default \ngit checkout -b test -t origin/socfpga-6.12.19-lts # configure the RSU driver to be built into the kernel \n# Update the device tree to create the correct partitioning based on the QSPI layout\nsed -i 's/reg = &lt;0x0 0x00600000&gt;;/reg = &lt;0x0 0x00c00000&gt;;/g' arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dts\nsed -i 's/reg = &lt;0x00600000 0x03a00000&gt;;/reg = &lt;0x00c00000 0x03400000&gt;;/g' arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dts\nmake clean &amp;&amp; make mrproper make defconfig ./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y\n./scripts/config --set-val CONFIG_MARVELL_PHY y make oldconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex3_socdk.dtb cd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dtb - kernel device tree </li> </ul> <p>Note: You can control the Linux erase granularity to be 4 KB or 64 KB with the CONFIG_MTD_SPI_NOR_USE_4K_SECTORS configuration. A value of y implies an erase granularity of 4 KB otherwise the erase granularity will be 64 KB.</p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is being included in this page. You can see it below. </p> <pre><code>&lt;pfg version=\"1\"&gt;\n&lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n&lt;output_files&gt;\n&lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n&lt;file_options/&gt;\n&lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n&lt;file_options bitswap=\"1\"/&gt;\n&lt;/secondary_file&gt;\n&lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n&lt;/output_file&gt;\n&lt;/output_files&gt;\n&lt;bitstreams&gt;\n&lt;bitstream id=\"Bitstream_1\"&gt;\n&lt;path hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.0/output_files/legacy_baseline.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;bitstream id=\"Bitstream_2\"&gt;\n&lt;path hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.1/output_files/legacy_baseline.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;/bitstreams&gt;\n&lt;flash_devices&gt;\n&lt;flash_device type=\"QSPI512\" id=\"Flash_Device_1\"&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0020FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n&lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00210000\" e_addr=\"0x40FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00600000\" e_addr=\"0x007FFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00800000\" e_addr=\"0x009FFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00A00000\" e_addr=\"0x00BFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n&lt;/flash_device&gt;\n&lt;flash_loader&gt;A3CY135BM16A&lt;/flash_loader&gt;\n&lt;/flash_devices&gt;\n&lt;assignments&gt;\n&lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n&lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n&lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;/assignments&gt;\n&lt;/pfg&gt;\n</code></pre> <p>You can also downloaded and use it to generate the flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER # Get the .pfg file\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-3/c-series/rsu/collateral/initial_image.pfg\n\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/altera_pro/25.1/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg </code></pre> <p>Here are the complete instructions on how to manually create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER qpfgw &amp; </code></pre> </li> <li> <p>Select the Device family as Agilex 3, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bit swap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file legacy_baseline.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/output_files/legacy_baseline.sof image. This is the initial application image. The tab now looks like below.</p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. </p> <p> </p> </li> <li> <p>Click the Bootloader  (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the QSPI512 in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (legacy_baseline.sof). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0040FFFF in order to reserve 2MB for the factory image. This end address was calculated by adding 2MB to the end of the BOOT_INFO partition. Click OK. </p> <p>Note: There is a requirement that the starting address of the SPT0 partition is aligned to 64KB. In order to warranty this, the End Address of the FACTORY_IMAGE must finish at an address ending with 0xXXXXFFFF.</p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be tried after all the application images failed. </p> </li> <li> <p>Select the QSPI512 flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(legacy_baseline.sof). This becomes the initial application image. Select the Page as 1. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x00600000 and End Address = 0x007FFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.    The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image</p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions), select the Address Mode as Block and set the start and end addresses as follows. </p> <p>* P2: Start Address = 0x00800000 and End Address = 0x009FFFFF.     * P3: Start Address = 0x00A00000 and End Address = 0x00BFFFFF. </p> <p>Note: Make sure that all the partitions created for the applications fit in the appropriate QSPI partition or partitions defined in device corresponding device tree in U-Boot and Linux. In the case of Linux, also make sure that the QSPI partition or partitions defined in the device tree to store the applications partitions are also defined in the qspi.rc file in LIBRSU.</p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER quartus_pfg -c initial_image.pfg </code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -rf images/application2.rpd\nquartus_pfg -c hw/ghrd.2/output_files/legacy_baseline.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON\n</code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/factory_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/legacy_baseline.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created. </p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/decision_firmware_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/legacy_baseline.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decision firmware update image is created. </p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/output_files/legacy_baseline.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/output_files/legacy_baseline.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul> <p>Notes:</p> <ul> <li>The first SOF file contains the factory image, from which data is taken to fill out the new decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from this SOF file is not used.</li> <li>The app_image parameter contains the SOF that is used for the application image section of the combined image.</li> <li>The hps_path parameter is unused, and may be removed in the future.</li> <li>The app_image_hps_path parameter contains the HPS FSBL hex file to be used for the application imge section of the combined image.</li> <li>When using HPS first, the additional parameter \"-o hps=1\" needs to be added, and the following files are created combined_application.hps.rpd (combined application image)  and combined_application.core.rbf (corresponding fabric configuration file).</li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b walnascar https://git.yoctoproject.org/poky git clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga git clone -b walnascar   https://github.com/openembedded/meta-openembedded # work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build echo 'MACHINE = \"agilex3\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver devmem2 net-tools\"' &gt;&gt; conf/local.conf  bitbake core-image-minimal </code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex3/core-image-minimal-agilex3.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf zlib-1.3.1 wget http://zlib.net/zlib-1.3.1.tar.gz tar xf zlib-1.3.1.tar.gz rm zlib-1.3.1.tar.gz cd zlib-1.3.1/ export CROSS_PREFIX=${CROSS_COMPILE} ./configure make export ZLIB_PATH=`pwd` cd .. </code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.3.1/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.3.1/libz.so* - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application. </p> <pre><code>cd $TOP_FOLDER rm -rf librsu git clone https://github.com/altera-fpga/librsu cd librsu # checkout the branch used for this document, comment out to use default \ngit checkout -b test -t origin/main cmake -S . -B build -G\"Ninja\" -DPLATFORM=linux-aarch64 &amp;&amp; cmake --build build\ncd .. </code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/librsu/build/lib/libuniLibRSU.so.1 - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/librsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/librsu/build/bin/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example. The rsu_client application requires to be linked with the libuniLibRSU.so.1 library. This can be performed from Linux running in the Agilex 3 device using the ldconfig command. In this example, we are accomplishing this by adding the S99linkRSULib.sh script into the /etc/rcS.d/ directoyy in the file system. This script will be executed automatically at boot time. Notice that this only needs to be done once, after the SD card gets programmed.</p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2021.04/gsrd/\\\ntools/make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n# Creating  initial script to execute it during Linux boot up so we can link rsu_client with \ncat &lt;&lt; EOF &gt; S99linkRSULib.sh\n#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-only\n### BEGIN INIT INFO\n# Provides: banner\n# Required-Start:\n# Required-Stop:\n# Default-Start:     S\n# Default-Stop:\n### END INIT INFO\necho \"Calling ldconfig to Lin rsu_client with libuniLibRSU.so.1\"\nldconfig\nEOF\n# prepare the fat contents \nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex3_socdk.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex3/core-image-minimal-agilex3.rootfs.tar.gz sudo sed -i 's/agilex3/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\n# This also could be copy to /usr/bin/ so it can be accessed from anywhere\nsudo cp $TOP_FOLDER/librsu/build/bin/rsu_client home/root/\nsudo cp $TOP_FOLDER/librsu/build/lib/libuniLibRSU.so.1 usr/lib/\nsudo cp $TOP_FOLDER/librsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\n# We need to link rsu_client with libuniLibRSU.so.1. So we do it during Linux bootup\nsudo cp ../S99linkRSULib.sh etc/rcS.d/\nsudo chmod +x etc/rcS.d/S99linkRSULib.sh\ncd ..\n# create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_agilex3_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_agilex3_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card. </p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Agilex SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to JTAG. </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer.</p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\" </code></pre> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to QSPI. </p> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_agilex3_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Agilex SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <ol> <li> <p>Power up the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2025.04-35102-g135e53726d-dirty (Sep 09 2025 - 13:23:54 -0600)\nReset state: Cold\nMPU           800000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nis_ddr_csr_clkgen_locked: ddr csr io96b_0 clkgenA is successfully locked\nio96b_cal_status: Calibration for IO96B instance 0x18400400 done at 0 msec!\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\nLPDDR4: 1792 MiB\n:\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 0\nNOTICE:  BL31: v2.12.1(release): QPDS25.1.1_REL_GSRD_PR\nNOTICE:  BL31: Built : 13:23:25, Sep 9 2025\n\nU-Boot 2025.04-35102-g135e53726d-dirty (Sep 09 2025 - 13:23:54 -0600)socfpga_agilex3\n\nCPU:   Altera FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex3 SoCDK\nDRAM:  1.8 GiB\nCore:  49 devices, 25 uclasses, devicetree: separate\nWDT:   Not starting watchdog@10d00200\nWDT:   Not starting watchdog@10d00300\nWDT:   Not starting watchdog@10d00400\nWDT:   Not starting watchdog@10d00500\nWDT:   Not starting watchdog@10d00600\nMMC:   mmc0@10808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@10c02000\nOut:   serial0@10c02000\nErr:   serial0@10c02000\n:\nHit any key to stop autoboot:  0 \nSOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options. </p> <pre><code>SOCFPGA # rsu \nrsu - Agilex SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name &lt;name&gt; - find slot by name and display the slot number slot_count - display the slot count slot_disable &lt;slot&gt; - remove slot from CPB slot_enable &lt;slot&gt; - make slot the highest priority slot_erase &lt;slot&gt; - erase slot slot_get_info &lt;slot&gt; - display slot information slot_load &lt;slot&gt; - load slot immediately slot_load_factory - load factory immediately slot_priority &lt;slot&gt; - display slot priority slot_program_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program buffer into slot, and make it highest priority slot_program_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program raw buffer into slot slot_program_factory_update_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program factory update buffer into slot, and make it highest priority slot_rename &lt;slot&gt; &lt;name&gt; - rename slot slot_delete &lt;slot&gt; - delete slot slot_create &lt;name&gt; &lt;address&gt; &lt;size&gt; - create slot slot_size &lt;slot&gt; - display slot size slot_verify_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against buffer slot_verify_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against raw buffer status_log - display RSU status update &lt;flash_offset&gt; - Initiate firmware to load bitstream as specified by flash_offset notify &lt;value&gt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt &lt;address&gt; - restore SPT from an address save_spt &lt;address&gt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb &lt;address&gt; - restore CPB from an address save_cpb &lt;address&gt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status\nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\nRSU: Sub-partition table 0 offset 0x00410000\nRSU: Sub-partition table 1 offset 0x00420000\nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB\nRSU: Sub-partition table content\n       BOOT_INFO    Offset: 0x0000000000000000  Length: 0x00210000  Flag : 0x00000003\n   FACTORY_IMAGE    Offset: 0x0000000000210000  Length: 0x00200000  Flag : 0x00000003\n              P1    Offset: 0x0000000000600000  Length: 0x00200000  Flag : 0x00000000\n            SPT0    Offset: 0x0000000000410000  Length: 0x00010000  Flag : 0x00000001\n            SPT1    Offset: 0x0000000000420000  Length: 0x00010000  Flag : 0x00000001\n            CPB0    Offset: 0x0000000000430000  Length: 0x00010000  Flag : 0x00000001\n            CPB1    Offset: 0x0000000000440000  Length: 0x00010000  Flag : 0x00000001\n              P2    Offset: 0x0000000000800000  Length: 0x00200000  Flag : 0x00000000\n              P3    Offset: 0x0000000000a00000  Length: 0x00200000  Flag : 0x00000000\nRSU: CMF pointer block offset 0x00430000\nRSU: CMF pointer block's image pointer list\nPriority 1 Offset: 0x0000000000600000 nslot: 0\n</code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code> SOCFPGA # rsu status_log \nSPTs are GOOD!!!\n CPBs are GOOD!!!\n Current Image  : 0x00600000\n Last Fail Image    : 0x00000000\n State      : 0x00000000\n Version        : 0x00000202\n Error location : 0x00000000\n Error details  : 0x00000000\n Retry counter  : 0x00000000\n</code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\nSOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000000600000 SIZE: 0x00200000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000000800000 SIZE: 0x00200000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000000a00000 SIZE: 0x00200000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 2097152. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 2097152. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 2097152. </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased. SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n1564672 bytes read in 103 ms (20.8 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000082000000 size=1564672. SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000082000000 size=1564672. SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: 1 </code></pre> </li> <li> <p>Power cycle the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting the specific image to be loaded, in this case using the following command.</p> <pre><code>SOCFPGA # rsu slot_load 1 \n</code></pre> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands. </p> <pre><code>SOCFPGA # rsu update 0x00600000 \nRSU: RSU update to 0x0000000000600000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log to confirm it.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00800000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202:  both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report.</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code># Remove 2nd line to enable WDT after fix of HSD: 14025895197\nSOCFPGA # mw.l 10D00204 0 \nSOCFPGA # mw.l 10D00200 1 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00800000\nLast Fail Image : 0x00800000\nState       : 0xf0060001\nVersion     : 0x0acf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000001\n</code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image   : 0x00800000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000001\n</code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00800000\nLast Fail Image : 0x00800000\nState       : 0xf0060001\nVersion     : 0x0acf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value. </p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00800000\nState       : 0xf0061234\nVersion     : 0x0acf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00600000\nState       : 0xf0060001\nVersion     : 0x0acf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000001\n</code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it. </p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00600000\nState       : 0xf0060001\nVersion     : 0x0acf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00800000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3\nOFFSET: 0x0000000000A00000\nSIZE: 0x00200000\nPRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n1769472 bytes read in 113 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nSlot 2 was programmed with buffer=0x0000000002000000 size=1769472. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=1769472. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000000A00000\nSIZE: 0x00200000 PRIORITY: 1\n</code></pre> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2. </p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00800000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\nSOCFPGA # rsu slot_get_info 2 \nNAME: P3\nOFFSET: 0x0000000000A00000\nSIZE: 0x00200000\nPRIORITY: [disabled]\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00800000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x00800000 0x10000 \nSF: 65536 bytes @ 0x0800000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00800000\nState       : 0xf004d003\nVersion     : 0x0dcf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status. </p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 512 KB). </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 65536 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 65536 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x10000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\nSOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n204800 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 1 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000082000000 size=204800. SOCFPGA # rsu slot_verify_buf 1 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000082000000 size=204800. SOCFPGA # rsu slot_get_info 1 \nNAME: P2\nOFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: 1\n</code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 1 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\nSOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 1 \nOFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 65536 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00210000\nLast Fail Image : 0x00200000\nState       : 0xf004d00f\nVersion     : 0x0dcf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00200000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot. </p> <p><pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n204800 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 1 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000082000000 size=204800. SOCFPGA # rsu slot_verify_buf 2 1{loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000082000000 size=204800. SOCFPGA # rsu slot_get_info 1 \nNAME: P2\nOFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: 1\n</code></pre> 6. Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 1 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\nSOCFPGA # rsu slot_get_info 1 \nNAME: P2\nOFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: [disabled]\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\nRSU: Sub-partition table 0 offset 0x00410000\nRSU: Sub-partition table 1 offset 0x00420000\nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB\nRSU: Sub-partition table content\n       BOOT_INFO    Offset: 0x0000000000000000  Length: 0x00210000  Flag : 0x00000003\n   FACTORY_IMAGE    Offset: 0x0000000000210000  Length: 0x00200000  Flag : 0x00000003\n              P1    Offset: 0x0000000000600000  Length: 0x00200000  Flag : 0x00000000\n            SPT0    Offset: 0x0000000000410000  Length: 0x00010000  Flag : 0x00000001\n            SPT1    Offset: 0x0000000000420000  Length: 0x00010000  Flag : 0x00000001\n            CPB0    Offset: 0x0000000000430000  Length: 0x00010000  Flag : 0x00000001\n            CPB1    Offset: 0x0000000000440000  Length: 0x00010000  Flag : 0x00000001\n              P2    Offset: 0x0000000000800000  Length: 0x00200000  Flag : 0x00000000\n              P3    Offset: 0x0000000000a00000  Length: 0x00200000  Flag : 0x00000000\nRSU: CMF pointer block offset 0x00430000\nRSU: CMF pointer block's image pointer list\nPriority 1 Offset: 0x0000000000600000 nslot: 0\n</code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x00430000 0x00010000 \nSF: 65536 bytes @ 0x930000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0xf004d010\nVersion     : 0x0dcf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre>   The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x00430000 0x00010000 \nSF: 65536 bytes @ 0x430000 Erased: OK\nSOCFPGA # sf erase 0x00440000 0x00010000 \nSF: 65536 bytes @ 0x440000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted\nCurrent Image   : 0x00210000\nLast Fail Image : 0x00000000\nState       : 0xf004d011\nVersion     : 0x0dcf0202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000 </code></pre>   The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected. </p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created. </p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <p><pre><code>SOCFPGA # rsu clear_error_status \n</code></pre>   Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds. </p> <pre><code>SOCFPGA # rsu slot_get_info 0 \nNAME: P1\nOFFSET: 0x0000000000600000\nSIZE: 0x00200000\nPRIORITY: 1\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x00410000 0x00010000 \nSF: 65536 bytes @ 0x410000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB Bad SPT0 magic number 0xFFFFFFFF\nRestoring SPT0CPBs are GOOD!!!\nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. </p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x00410000 0x00010000 \nSF: 65536 bytes @ 0x410000 Erased: OK\nSOCFPGA # sf erase 0x00420000 0x00010000 \nSF: 65536 bytes @ 0x420000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF\nBad SPT0 magic number 0xFFFFFFFF\nno valid SPT0 and SPT1 found\nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\n</code></pre> <p>The decision firmware loads the highest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails. </p> <pre><code>SOCFPGA # rsu slot_count \nBad SPT1 magic number 0xFFFFFFFF\nBad SPT0 magic number 0xFFFFFFFF\nno valid SPT0 and SPT1 found\ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image   : 0x00600000\nLast Fail Image : 0x00000000\nState       : 0x00000000\nVersion     : 0x00000202\nError location  : 0x00000000\nError details   : 0x00000000\nRetry counter   : 0x00000000\nSOCFPGA # rsu slot_count    \nSPTs are GOOD!!!\nCPBs are GOOD!!!\nNumber of slots = 3\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#using-the-combined-application-image","title":"Using the Combined Application Image","text":"<p>This section shows an example of using a combined application image, from U-Boot. Similar commands can be used from Linux.</p> <p>The combined application images are used the exact same way as regular application images, just that they first update the decision firmware and decision firmware data if necessary, before the device is configured with the functionality from the application SOF.</p> <p>Note: The combined application images do not have absolute pointers inside like the regular application images, the factory update images, or the decision firmware update images. Because of this, they can be written to flash with any of the U-Boot and LibRSU APIs that write to slots.</p> <ol> <li> <p>Program the RSU initial image created with the previous version ($TOP_FOLDER/initial_image_prev.jic).</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_prev.jic\"\n</code></pre> </li> <li> <p>Power cyle the board, stop to U-Boot prompt and query the decision firmware information from U-Boot, this should be a previous version.</p> <pre><code>SOCFPGA # rsu display_dcmf_version\nDCMF0 version = 25.1.0\nDCMF1 version = 25.1.0\nDCMF2 version = 25.1.0\nDCMF3 version = 25.1.0\n</code></pre> </li> <li> <p>Find an unused slot (slot 1, P2), erase it, write the combined application image to it, verify that it was programmed successfully  and check it is now the highest priority.</p> <pre><code>SOCFPGA # rsu slot_erase 1\nSlot 1 erased.\nSOCFPGA # fatload mmc 0:1 ${loadaddr} combined_application.rpd\n1769472 bytes read in 9 ms (16.1 MiB/s)\nSOCFPGA # rsu slot_program_buf 1 ${loadaddr} ${filesize}\nSlot 1 was programmed with buffer=0x0000000082000000 size=1769472.\nSOCFPGA # rsu slot_verify_buf 1 ${loadaddr} ${filesize}\nSlot 1 was verified with buffer=0x0000000082000000 size=1769472.\nSOCFPGA # rsu slot_get_info 1\nNAME: P2\nOFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: 1\n</code></pre> </li> <li> <p>Pass control to the combined application update image.</p> <pre><code>SOCFPGA # rsu slot_load 1\n</code></pre> </li> <li> <p>The combined application image checks the currently used decision firmware copy, it sees that it is older, then it updates the decision firmware and decision firmware data, then it loads the actual application image section. Everything takes a few seconds.</p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware is updated, and the   application image is running fine.</p> <pre><code>SOCFPGA # rsu status_log\nCurrent Image    : 0x00800000\nLast Fail Image  : 0x00000000\nState        : 0x00000000\nVersion      : 0x00000202\nError location   : 0x00000000\nError details    : 0x00000000\nRetry counter    : 0x00000000\nSOCFPGA # rsu display_dcmf_version\nDCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\n</code></pre> </li> <li> <p>Power cycle the board, the same combined application image is loaded, as it is the highest priority. But it takes a couple of seconds less, as the decision firmware does not need to be updated.</p> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <p>Note: RSU functionality in Linux is enabled starting on 24.2 release.</p> <ol> <li> <p>Power up the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message. </p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202\nSTATE: 0x00000000\nCURRENT IMAGE: 0x0000000000600000\nFAIL IMAGE: 0x0000000000000000\nERROR LOC: 0x00000000\nERROR DETAILS: 0x00000000\nRETRY COUNTER: 0x00000000\nOperation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1\nOFFSET: 0x0000000000600000\nSIZE: 0x00200000\nPRIORITY: 1\nOperation completed root@linux:~# ./rsu_client --list 1 NAME: P2\nOFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000000A00000\nSIZE: 0x00200000\nPRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\nOperation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1\nOFFSET: 0x0000000000600000\nSIZE: 0x00200000\nPRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2\nOFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3\nOFFSET: 0x0000000000A00000\nSIZE: 0x00200000\nPRIORITY: [disabled]\nOperation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status.  It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000800000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting a specific image to be loaded, using the following commands.</p> <pre><code>./rsu_client --request 1 reboot </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000800000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202:both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report .</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux.</p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000000800000 FAIL IMAGE: 0x0000000000800000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000800000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# root\nVERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000000800000 FAIL IMAGE: 0x0000000000800000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number. </p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000000600000\nFAIL IMAGE: 0x0000000000800000\nERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000000600000\nFAIL IMAGE: 0x0000000000600000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000000600000\nFAIL IMAGE: 0x0000000000600000\nERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000800000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000000A00000 SIZE: 0x00200000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3\nOFFSET: 0x0000000000A00000\nSIZE: 0x00200000\nPRIORITY: 1\nOperation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202\nSTATE: 0x00000000\nCURRENT IMAGE: 0x0000000000800000\nFAIL IMAGE: 0x0000000000000000\nERROR LOC: 0x00000000\nERROR DETAILS: 0x00000000\nRETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000000A00000\nSIZE: 0x00200000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux and display the status:  It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000800000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB. </p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot.</p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB. </p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000000800000\nSIZE: 0x00200000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000800000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is required to have the status available in Linux. </p> <ol> <li> <p>Power up the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions. </p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 65536 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 65536 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 1\nOperation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 1 Operation completed root@linux:~# ./rsu_client --list 1\nNAME: P2 OFFSET: 0x0000000000800000\nSIZE: 0x00200000\nPRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 1\nOperation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 65536 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000210000 FAIL IMAGE: 0x0000000000200000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x200000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 1 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 1\nOperation completed root@linux:~# ./rsu_client --list 1\nNAME: P3 OFFSET: 0x0000000000800000\nSIZE: 0x00200000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>root@linux:~# ./rsu_client --request 1\nOperation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 1\nNAME: P2\n    OFFSET: 0x0000000000800000\n      SIZE: 0x00200000\n  PRIORITY: [disabled]\nOperation completed\n</code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x430000 0x00010000 \nSF: 65536 bytes @ 0x430000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted.  The Version field indicates that the error was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x00430000 0x10000 \nSF: 65536 bytes @ 0x430000 Erased: OK SOCFPGA # sf erase 0x00440000 0x10000 \nSF: 65536 bytes @ 0x440000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000210000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. . The Version field indicates that the error was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000210000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000210000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is not rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000000800000 SIZE: 0x00200000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x00410000 0x10000 \nSF: 65536 bytes @ 0x410000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status: </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash.</p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu512a with page size 256 Bytes, erase size 64 KiB, total 64 MiB SOCFPGA # sf erase 0x00410000 0x10000 \nSF: 65536 bytes @ 0x410000 Erased: OK SOCFPGA # sf erase 0x00420000 0x10000 \nSF: 65536 bytes @ 0x420000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status. </p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000600000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> </li> </ol> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.  Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> <ol> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails. </p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created. </p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine. </p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5, Agilex\u2122 3 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p> <p>Note:  Agilex\u2122 3 HPS Remote System Update User Guide will be released soon.</p>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/agilex-3/c-series/rsu/ug-rsu-agx3c-fpga/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/","title":"Simics Linux GSRD for Agilex\u2122 5 E-Series Devices","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#overview","title":"Overview","text":"<p>Agilex\u2122 5 E-Series and D-Series devices provide the next-generation hard processor system (HPS) after those provided with the Agilex\u2122 7 and  Stratix\u00ae 10 SoC FPGA devices. Agilex\u2122 5 E-Series devices support new features, such as TSN, USB 3.1 Gen 1, and I3C, SPI.</p> <p>The Agilex\u2122 5 HPS application processors can run Linux or an RTOS, such as Zephyr*, with a scalable performance using one to four Arm* Cortex*-A cores with variable frequencies that allow for a wide range of applications.</p> <p>The Agilex\u2122 5 Simics virtual platform models the HPS processor with two Arm Cortex-A55 cores, two Arm Cortex-A76 cores, and HPS peripherals. The Agilex\u2122 5 E-Series HPS virtual platform is released as part of the Simics\u00ae Simulator for Intel\u00ae FPGAs software, which also includes a virtual platforms where the Agilex\u2122 5 device is instantiated, emulating the concept of having different versions of a development kit or daughter cards.</p> <p>The Agilex\u2122 5 E-Series device has the following supported virtual platforms:</p> <ul> <li>Agilex\u2122 5  Universal Virtual Platform - Used to simulate E-Series and D-Series devices.</li> </ul> <p>The following sections describe the prerequisites for the Intel Simics Simulator for Intel\u00ae FPGA and the available virtual platforms, including prebuilt binaries, and instructions for building these binaries. It also covers some common use cases that you can exercise on the virtual platforms.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#prerequisites","title":"Prerequisites","text":"<p>To exercise the instructions presented on this page (build your binaries and exercise the use cases), your system must satisfy the following prerequisites:</p> <ul> <li>Host PC with Linux OS. (Note: Instructions on this page use Ubuntu 22.04 LTS.)</li> <li>The following packages are needed to deploy the Simics project:<ul> <li>GCC 6.3 compiler or higher</li> <li>g++ 9.4 or higher</li> <li>GNU make 4.1 or higher</li> </ul> </li> <li>Local Ethernet network with DHCP server (provides IP address to the board).</li> <li>Intel Simics Simulator for Intel FPGAs installed.</li> <li>Intel Agilex\u2122 5 Virtual Platform components available to be deployed.</li> </ul> <p>Notes:</p> <ul> <li>For binaries building instructions, see Build Instructions.</li> <li>For installation instructions for the Intel Simics Simulator for Intel FPGAs and the Agilex\u2122 5 E-Series virtual platforms, refer to the following documents:<ul> <li>Intel\u00ae Simics\u00ae Simulator Landing Page </li> <li>Intel\u00ae Simics\u00ae Simulator for Intel\u00ae FPGAs User Guide</li> <li>Agilex\u2122 5 E-Series Virtual Platform User Guide</li> </ul> </li> <li>U-Boot, Linux compilation, Yocto compilation, and the creation of an SD card image require a Linux host PC.   To create these binaries, the toolchain and other software required need to be downloaded. This is described as part of the instructions in each section.</li> <li>The Intel Simics Simulator for Intel\u00ae FPGAs is available only for Linux systems.</li> <li>In case any use case requires additional prerequisites, these are listed as part of the use case description.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#release-content","title":"Release Content","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions are used to build the binaries presented in this page: </p> Component Location Branch Commit ID/Tag Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p> <p>Note: For information prior 24.2 release, please refer to Linux GSRD Intel Simics Virtual Platform for Intel Agilex\u00ae 5 E-Series. </p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>You can find the prebuilt binaries from the GSRD prebuilt at the following URL: https://releases.rocketboards.org/2025.08/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/. The files in this folder allow you to boot directly from SDCard. It also contains some of the files that are used to generate the final images used to boot from QSPI. The following folder contains the remaining files used by the recipes to create the binaries to boot from QSPI.</p> <ul> <li>QSPI: QSPI boot complement files. Here is the link to obtain the uboot_script.its file which is also needed.</li> </ul> <p>Note: The final images used to boot from QSPI  are not provided, but the binaries used to generate these are provided, so you can generate the final images following the instructions in Build QSPI Boot Image section.</p> <p>Note:  Starting from 24.2 release, the binaries targeted for silicon can also be used with Simics simulator.</p> <p>Note: In  25.1.1 release the GSRD scripts used to  build  NAND Boot binaries were removed, so at this time it is not possible to generate these binaries and therefore the use case related to NAND Boot  were removed. If you need to generate NAND binaries to be used in the Simics model,  you can do it with the build instructions provided in the 25.1 version of this page. The NAND Boot will be supported in a future release.</p> HPS Peripheral Supported eMMC/SDCard &amp; Combo Phy Controllers Yes DMA Controller Yes XGMAC Ethernet Controller Yes USB 3.1 Gen1 Controller Yes USB 2.0 Controller Yes GPIO Controller Yes I2C Controller Initiator/Target Yes SPI Controller Initiator/Target Yes I3C Controller Initiator Yes I3C Controller Target Yes NAND Controller &amp; Combo PHY Controller Yes APB Timer Yes QSPI Controller Yes GICv3 Interrupt controller Yes EDAC RAS Driver Yes Clock manager Yes Reset manager Yes UART Yes WatchDog timer Yes System manager Yes SVC SOC FPGA manager Yes SVC FPGA firmware Yes SMMU Yes SVC FCS Crypto Yes SVC HWMON Yes SVC RSU Yes CVP Yes PMU Yes"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-instructions","title":"Build Instructions","text":"<p>The following diagram illustrates the full-build flow for the binaries used with the Intel Simics simulator. The build flow utilizes the source code placed in GitHub in repositories and uses a flow based on Yocto.</p> <p></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#set-up-the-environment","title":"Set Up the Environment","text":"<pre><code>sudo rm -rf agilex5_gsrd\nmkdir agilex5_gsrd\ncd agilex5_gsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#get-sof-from-hardware-design","title":"Get SOF from Hardware Design","text":"<p>In Simics, the SOF file generated as result of the build of the hardware design is not used at all in the simulation, but this is needed to create the RPD file to exercise the QSPI boot. This is the reason why we provide the steps to build the hardware desgin here.</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd_a5ed065bb32ae6sr0.sof\nwget https://releases.rocketboards.org/2025.08/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0.sof </code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#set-up-the-yocto-build-system","title":"Set Up the Yocto Build System","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <ol> <li> <p>Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b walnascar https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up the yocto build environments again, if you closed the current window (for example, when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex5_devkit-gsrd-rootfs/\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#customize-the-yocto-build","title":"Customize the Yocto Build","text":"<ol> <li> <p>(Optional) Change the following files in gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/:</p> <ul> <li>distroboot script:uboot.txt</li> <li>its file for creating FIT image fromthe above script: uboot_script.its </li> </ul> </li> <li> <p>(Optional) Change the following file in gsrd-socfpga/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts:</p> <ul> <li>its file for creating the kernel.itb image: fit_kernel_agilex5.its , which by default contains the following:<ul> <li>Kernel </li> <li>Distroboot boot script</li> <li>Device tree configurations</li> <li>Board configurations </li> </ul> </li> </ul> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package </code></pre> <p>After the build is completed successfully, the following two folders are created:</p> <ul> <li><code>agilex5_devkit-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. For the description of the build directory structure, refer to https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build.</li> <li><code>agilex5_devkit-gsrd-images</code>: the build script copies here are relevant files built by Yocto from the <code>agilex5_devkit-gsrd-rootfs/tmp/deploy/images/agilex5</code> folder. It also includes other relevant files.</li> </ul> <p>Note: If you want to build binaries creating each one of the binaries independently, you could refer to Agilex\u2122 5 E-Series GHRD Linux Boot Examples.</p> <p>The most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex5_devkit-gsrd-images</code> folder are:</p> File Description SD Card Boot QSPI Boot ghrd_a5ed065bb32ae6sr0.sof SOF file from the hardware design * u-boot-spl-dtb.bin U-Boot SPL binary file * * u-boot.itb U-Boot (SSBL) * * boot.scr.uimg Distroboot boot script * kernel.itb Linux kernel fit image * * console-image-minimal-agilex5_nor.ubifs File system for QSPI boot * gsrd-console-image-agilex5.wic SD Card Image * uboot.txt U-Boot Distroboot script * uboot_script.its ITS file to create FIT binary of U-Boot Distroboot script *"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-qspi-boot-image","title":"Build QSPI Boot Image","text":"<p>The next step consists of creating the QSPI image with UBIFS format that will be used by in the simulation that exercises this use case. To build this image the same binaries generated from the GSRD build are used.</p> <p>The layout of the QSPI image is shown in the following table:</p> Partition MTD Partition UBI Volume Volume Name Type Image/Individual File Group File Start Addr Size BOOT_INFO 0 (u-boot) N/A N/A RAW Bootinfo (Empty) N/A 0x0 2MB P1 0 (u-boot) N/A N/A RAW bitstream (FPGA image, SDM firmware) N/A 0x00200000 ~1 MB U_BOOT 0 (u-boot) N/A N/A RAW u-boot.itb N/A 0x04000000 AUTO HPS 1 (root) 01234 envscriptkerneldtbrootfs UBIUBIUBIUBIUBIFS u-boot.envu-boot.scrkernel.itbkernel.dtbrootfs.ubifs root.ubi 0x04200000AutoAutoAutoAuto 256KB128KB24MB256KB160MB <ol> <li> <p>Gather the required files.</p> <pre><code># Gattering files\ncd $TOP_FOLDER\nrm -rf qspi-bin &amp;&amp; mkdir qspi-bin &amp;&amp; cd qspi-bin mv $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.sof agilex5_factory.sof\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb u-boot-itb.bin\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex u-boot-spl.hex\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/kernel.itb kernel-image\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nor.ubifs  rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg boot.scr.uimg\n</code></pre> </li> <li> <p>Create the PFG file that describes the format of the QSPI image: </p> <pre><code>cd $TOP_FOLDER/qspi-bin\ncat &lt;&lt; EOF &gt; agilex5_flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" directory=\".\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"flash_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"./u-boot-spl.hex\"&gt;./agilex5_factory.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot-itb.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00200000\" e_addr=\"0x0030FFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"U-Boot\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_e_addr=\"1\" e_addr=\"0xFFFFFFF\" id=\"HPS\" s_addr=\"0x4200000\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"U-Boot\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n</code></pre> </li> <li> <p>Create UBI configuration file for the rootfs partition:</p> <pre><code># Creating UBI Configuration file\ncd $TOP_FOLDER/qspi-bin\ncat &lt;&lt; EOT &gt;ubinize_nor.cfg \n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel-image     \nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOT\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/qspi-bin/ubinize_nor.cfg</li> </ul> </li> <li> <p>Generate the root.ubi file for root partition. For this, the ubinize_nor.cfg is used with the files obtained from the previous steps. This file defines the components to be included in the root.ubi file as indicated in the table above. The ubinize executable is available as part of the mtd-tools package.      The parameters for ubinize command are:</p> <p>-p: physical erase block size of the flash -m: minimum input/output unit size of the flash -s: sub-pages and sub-page size </p> <p>Once the root.ubi files is created this is renamed as hps.bin.  Required files for this step: ubinize_nor.cfg,  boot.scr.uimg,  kernel-image,  rootfs.ubifs</p> <pre><code># Generate hps.bin file with UBI format\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize_nor.cfg\nmv root.ubi hps.bin\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/qspi-bin/hps.bin</li> </ul> </li> <li> <p>Using Quartus Programming File Generator to compile an RPD file by using the configuration specified in the PFG file.</p> <p>Required files for this step: u-boot-spl.hex,  agilex5_factory.sof, u-boot-itb.bin and hps.bin   Note: Make sure the filenames are specified correctly in agilex5_flash_image.pfg</p> <p>Run the Quartus File Generator command below to generate an RPD file:</p> <pre><code># Creating QSPI image\nquartus_pfg -c agilex5_flash_image.pfg\n</code></pre> </li> </ol> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/qspi-bin/flash_image_jic.rpd</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#known-issues-with-the-release","title":"Known Issues with the Release","text":"<p>For known issues in this release please refer to the Intel Simics Simulator for FPGA Release page.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#agilextm-5-simics-virtual-platform-universal","title":"Agilex\u2122 5  Simics Virtual Platform - Universal","text":"<p>Note: The Agilex 5 Simics Virtual Platform - Universal was initially developed to support the Agilex 5 E-Series device, but it also supports the Agilex 5 D-Series device which matches the B0 steping of the E-Series device. In this page we refer to Agilex 5 E-Series,  but it also applies for the Agilex 5 D-Series, unless other thing is indicated.</p> <p>This virtual platform is associated with the agilex5e-universal.simics target script. The following figure shows a high-level block diagram of this virtual platform. In this diagram, you can observe the main components that can be exercised during the execution of the use cases described later on this page. The implementation of this virtual platform allows all the peripherals in the HPS to be enabled at the same time, which is not possible in physical hardware implementations. The pinmux and Combo PHY impose restrictions on the physical hardware. In the case of the pinmux in the physical hardware, you can enable only a subset of peripherals simultaneously because there are not enough pins if all pins are enabled simultaneously. This limitation does not exist in the Agilex\u2122 5 E-Series Universal Virtual Platform. For the Combo PHY, the physical hardware allows only one flash controller (NAND or SDMMC) to be enabled at a time. However, the virtual platform allows both to be enabled simultaneously.</p> <p></p> <p>In this block diagram:</p> <ul> <li>The architecture of the virtual platform follows a hierarchy that goes from target script \u2192 system \u2192 board \u2192 fpga \u2192 qsys_top \u2192 hps_subsystem \u2192 agilex_hps, which is aligned with the Simics virtual platform development philosophy that tries to match with the real golden hardware reference design (GHRD) architecture.</li> <li>The target script instantiates the system component, provides the CLI run time commands, and creates the network configuration. This script also defines the parameters that configure other components.</li> <li>The system component represents the complete virtual platform system and instantiates the board component. This component is implemented in a Python file.</li> <li>The board component represents the model of a PCB (analogous to a development kit). It includes the instance of the FPGA component and all board components connected to the FPGA (for example, flash devices, ethernet PHY). The GPIO loopback connection is implemented here. This component is implemented in a Python file.</li> <li>The FPGA component represents the top-level hardware design model in the Quartus Prime software project design that targets the Agilex\u2122 5 E-Series SoC FPGA device. It matches the logical hierarchy of the fictitious GHRD that the Agilex\u2122 5 E-Series Universal Virtual Platform models. This component only instantiates the qsys_top component and is implemented as a Python script.</li> <li>The qsys_top component matches the design's top view being modeled and corresponds to the system seen from the Platform Designer under the GHRD (soc_inst instance). The HPS subsystem component and the components included as part of the FPGA fabric design are instantiated under the qsys_top component. The qsys_top component is modeled as a Python script.</li> <li>The FPGA fabric design corresponds to the logic model implemented in the FPGA fabric.</li> <li>The HPS subsystem component corresponds to the model of the module that integrates all components associated with the HPS in the Agilex\u2122 5 E-Series device. It includes the HPS models, SDM mailbox, and EMIF model.</li> <li>The Agilex\u2122 5 HPS component in the virtual platform is an Intel Simics model that corresponds to the Hard Processor System Agilex\u2122 5 FPGA IP in the  Quartus Prime software.</li> <li>The embedded software running in the HPS component is expected to be the same that can be run in the real silicon. Exercising the HPS-embedded software in this virtual platform allows you to debug the software using the Simics debug capabilities.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#main-features-supported-by-the-intel-agilextm-5-e-series-universal-virtual-platform","title":"Main Features Supported by the Intel Agilex\u2122 5 E-Series Universal Virtual Platform","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#boot-an-operative-system","title":"Boot an Operative System","text":"<p>The Agilex\u2122 5 E-Series Virtual Platform allows exercising the HPS software in all parts of the boot flow for Linux* and Zephyr* operating systems. You can exercise the boot flow from a flash device such as an SD Card, NAND flash, or QSPI flash. Booting from an SD Card is the default boot mode.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#basic-ethernet","title":"Basic Ethernet","text":"<p>The basic ethernet functionality is configured from the agilex5e-universal.simics target script. The virtual platform simulates a network switch and a router in the simulated environment using the service node component referred to as service_node_cmp0. This provides a TFTP server to transfer files from the host PC to the target system and a DHCP server to assign an IP to the target system dynamically.</p> <p>The service node acts as a simulated environment router configured with the 10.10.0.1 IP address. The DHCP service is configured to assign an IP in the range of 10.10.0.100 and 10.10.0.199. The service node is also configured to provide Network Address Port Translation (NAPT) for outgoing traffic, allowing it to interact with the host PC enabling TFTP, SCP, and SSH services.</p> <p>The target device provides ethernet functionality using the XGMAC/TSN devices, enabling an ethX ethernet link. This link connects with an ethernet switch instantiated in the target script. Only the TSN0 instance is connected to this switch using the Marvell ethernet Phy instantiated at the board level.</p> <p>Basic ethernet support in the virtual platform allows the target software to set a MAC address locally to allow communication over the network. This supports all key transport layers of a protocol, such as TCP, UDP, and ICMP. Basic ethernet allows communication over IPv4 and IP6 protocols while supporting different hardware offloading features. The virtual platform supports L2, L3, and L4 filtering and can show network statistics.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#cpu-power-on-and-boot-core-selection","title":"CPU Power-On and Boot Core Selection","text":"<p>The virtual platform supports setting the CPU power-on settings and the CPU boot core selection. This configuration is defined at the target script level (agilex5e-universal.simics) for this virtual platform. Based on the configuration, the virtual platform exposes only the appropriate number of cores available to the target software. When multiple CPUs are enabled, the virtual platform is configured to support symmetric multiprocessing (SMP).</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#reset-flow","title":"Reset Flow","text":"<p>The virtual platform is designed to support all key reset flows described in the Agilex\u2122 5 E-Series Technical Reference Manual. Reset flows initiated by the CPU are simulated through the same mechanism in which the CPU writes to the appropriate addresses (reset manager device). Resets triggered by the external hardware signaling are simulated with Simics' commands.</p> Reset Type Recipe Notes Power-on reset Not supported The power-on reset is not supported as its effect is equivalent to restarting the simulation in a virtual platform simulation. However, if this is required for some exceptional use cases, you can trigger the cold reset instead, as this resets most domains. HPS cold reset system.board.hps-cold-reset Simulates toggling the HPS_COLD_nRESET pin using the command registered in the board component. HPS warm reset system.board.fpga.soc_inst.hps_subsys.agilex_hps.hps-warm-reset Simulates a warm reset of the HPS without triggering any other event. This type of reset is not enabled through external means in hardware. The command is registered in the HPS component. Watchdog reset Software-based The watchdog timer peripheral in the HPS can be configured and enabled through software. When the watchdog expires, the HPS resets (only the trigger of warm reset is supported)."},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#gpio-loopback-connection","title":"GPIO Loopback Connection","text":"<p>The virtual platform supports the feature that allows creating a loopback connection in certain pins in GPIO0 and GPIO1 ports. This is implemented at the board component level. The loopback implementation directly connects GPIO in and out pins of the GPIO ports in both directions to reflect the same state on those pins. In each GPIO port, the pair of pins that are connected are shown in the following table:</p> Pin Source Pin Destination 0 1 5 6 18 19 20 21 <p>The Simics command to activate the GPIO loop-back connection is <code>system.board.create-gpio-loopback</code>.</p> <p>Note: The loopback connection is activated by default from the target script.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#usb-disks-hot-plug-support","title":"USB Disks Hot-Plug Support","text":"<p>The virtual platform instantiates three USB disks that support hot-plugging by using Simics CLI commands to emulate plugging and unplugging the USB disks.</p> <p>The current connection of the USB disks in this virtual platform is indicated in the following table:</p> Disk Type Slot USB Controller usb3_disk SuperSpeed (SS) usb3 USB 3.1 Gen 1 usb3_hs_disk High Speed (HS) usb2 USB 3.1 Gen 1 usbotg_disk High Speed (HS) otg USB 2.0 OTG"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#fpga-fabric-example-design","title":"FPGA Fabric Example Design","text":"<p>The FPGA Fabric example design includes one instance of a On-Chip memory design exist in the FGPA fabric model. This is located directly under the qsys_top component. This On-Chip memory instance has a size of 1 MB and is connected to the HPS2FPGA bridge. This On-Chip memory model supports reading and writing to any memory location. You can access the memory designs using direct memory access to the memory locations in which these are mapped under the HPS2FPGA bridge memory space or by accessing the memories example design as a memory space or by accessing the memories example design as a memory space.</p> <p>The mapping of the memory instance is defined as follows:</p> Example Design Name Bridge Size Start address End Address example_design hps2fpga 1 MB 0x0040000000 0x00400FFFFF <p>The memory instance in the FPGA fabric example design receives a parameter named base_addr. The description of this parameter is described as follows:</p> Parameter Description Range Default Value base_addr An offset value that indicates the mapping of the instance taking as reference the Start Address value defined in the previous table. Integer 0x00000000 <p>The FPGA fabric example design also includes a Peripheral subsystem which is integrated by 3 I/O IP components, each one to access or allow to control a set of LEDs, a Dip switch and a push button. The peripheral subsystem is mapped into the lwhps2pga bridge starting at a base address of 0x20000000. These components includes some internal registers that allow to control the state of the output (for LED component) and also to read state of the input of push button and dip-switch components. The mapping of these components and their registers are shown next:</p> Component Mapping Address Range Register Information button_pio 0x00010060 0x10 [0x0] - DATA[0:0]: Read state of the button. Read Only. [0x8] - INTERRUPTMASK[0:0]- Enable('1\u2019)/Disable('0\u2019) the interrupt trigger. When dsiable, the interrupt is cleared. Read/Write dipsw_pio 0x00010070 0x10 [0x0] - DATA[0:0]: Read state of the button. Read Only. [0x8] - INTERRUPTMASK[0:0]- Enable('1\u2019)/Disable('0\u2019) the interrupt trigger. When dsiable, the interrupt is cleared. Read/Write led_pio 0x00010080 0x10 [0x0] - DATA[31:0]: Set and read the state of the LEDs. Read/Write <p>The DIP switch and push button component can trigger an interrupt to the HPS on the assertion of the corresponding input signal.</p> Component Interrupt HPS Interrupt Connection button_pio periph_button_irq f2s_fpga_irq[0] \u2013 SIP 49 dipsw_pio periph_dipsw_irq f2s_fpga_irq[1] \u2013 SIP 50 <p></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#fpga-to-hps-bridges","title":"FPGA-to-HPS Bridges","text":"<p>The FPGA-To-HPS bridges provide a way in which the FPGA fabric IPs can interact with the HPS subsystem and the SDRAM. The bridge implementation includes two new memory spaces in the FPGA logic model that are used to send read and write transactions to the HPS or SDRAM component from the FPGA logic passing through the FPGA-to-HPS bridges.</p> <ul> <li>FPGA to HPS bridge (FPGA2HPS): Connects the FPGA2HPS memory space with the HPS component.</li> <li>FPGA to SDRAM bridge (FPGA2SDRAM): Connects the F2SDRAM memory space with the HPS component.</li> </ul> <p>You can send read and write transactions through each one of the bridges from the Intel Simics CLI.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#b0-silicon-features-selection","title":"B0 Silicon Features Selection","text":"<p>The Agilex 5 E-Series Universal Virtual Platform allows you to select the stepping silicon features that the Agilex 5 Simics model supports by stepping the target script parameter accepting the value of A0 or B0. The B0 stepping corresponds to the HPS model of the Agilex 5 D-Series.</p> <p>Note: Agilex 5 E-Series Universal Virtual Platform stepping features support is released in the 24.1 Intel Simics Simulator for Intel FPGAs release although the default stepping during the project deployment remains being A0. You can override the default stepping using the stepping parameter from the target script. In this case, the B0 features are enabled in the Agilex 5 E-Series model.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#uart1uart2-serial-console-selection","title":"UART1/UART2 Serial Console Selection","text":"<p>The Agilex 5 Universal virtual platform supports creating a serial console that could be connected to UART0 (default one) or UART1. This feature provides more flexibility to the virtual platform allowing you to match your board. The selection of the serial console to be displayed is controlled by the $create_hps_serial0_console and $create_hps_serial1_console configuration parameters. These 2 parameters allow you to enable creating the corresponding serial console. A serial console object is created and connected when the corresponding parameter is set to TRUE. Note that is possible to have both serial consoles enabled or both disabled.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#configurable-parameters-in-the-intel-agilextm-5-e-series-universal-virtual-platform","title":"Configurable Parameters in the Intel Agilex\u2122 5 E-Series Universal Virtual Platform","text":"<p>The parameters that you can configure are shown in the following table:</p> Parameter Description Range Default Value sd_image_filename Name of the SD image to load into the SD memory model of the board component. Supported formats are <code>.img</code> and <code>.wic</code>. Filename string \"\" fsbl_image_filename First-stage boot loader file. The supported format is <code>.bin</code>. Filename string \"\" hps_boot_core The CPU to use as the boot core. Integer [0,2] 0 hps_core0_1_power_on The power-on states of CPU 0/1. Boolean True hps_core2_power_on The power-on states of CPU 2. Boolean True hps_core3_power_on The power-on states of CPU 3. Boolean True create_hps_serial0_console Choose whether to create or not a console component and connect it to the <code>serial0</code> peripheral of the HPS IP. Boolean True create_hps_eth0_network Choose whether to create or not a basic ethernet network and connect the <code>ethX</code> peripheral of the HPS IP to this. Boolean True create_hps_sd_card Create the SD card in the board component and connect it to the SD/eMMC controller. You can set either the create_hps_sd_card or create_hps_mmc parameter to true at a time. Boolean True create_hps_mmc Create the eMMC card in the board component and connect it to the SD/eMMC controller. You can set either the create_hps_sd_card or create_hps_mmc parameter to true at a time. Boolean False nand_data_image_filename Name of the NAND image to load into the NAND memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" nand_spare_image_filename Name of the NAND spare image to load into the NAND memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" qspi_image_filename Name of the QSPI image to load into the QSPI memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" usb3_image_filename Name of the USB disk image corresponding to the SuperSpeed disk in the board component connected to the USB 3.1 controller. Filename string \"\" usb3_hs_image_filename Name of the USB disk image corresponding to the high-speed disk in the board component connected to the USB 3.1 controller. Filename string \"\" usb_otg_image_filename Name of the USB disk image corresponding to the high-speed disk in the board component connected to the USB 2.0 OTG controller. Filename string \"\" hps_cpu_freq_mhz ARM cores frequency in Megahertz (MHz). Integer [400 - 1500] 400 stepping Select the silicon features that the Agilex 5 Simics model supports. A0 or B0. D-Series corresponds to B0 device. A0 create_hps_serial0_consolecreate_hps_serial1_console Create a console component (serial console) and connect it to the corresponding UART controller peripheral in the Hard Processor System Agilex 5 FPGA IP.create_hps_serial0_console is for UART0 create_hps_serial1_console is for UART1. Boolean serial0: Trueserial1: False"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-cases-supported-by-the-agilextm-5-e-series-universal-virtual-platform","title":"Use Cases Supported by the Agilex\u2122 5 E-Series Universal Virtual Platform","text":"<p>The following sections explain some supported use cases using the Agilex\u2122 5 E-Series Universal virtual platform. The preconditions required to execute them are listed in the following section:</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#simulation-setup","title":"Simulation Setup","text":"<p>Consider that the Intel Simics Simulator for Intel FPGAs Simulator has been installed on a Linux System and the output binaries generated from Build Instructions section are already available.</p> <ol> <li> <p>Create a project directory under the Intel Simics Simulator installation directory (Assuming it is SimicsInstallDir):</p> <pre><code>$ mkdir project-1\n$ cd project-1\n</code></pre> </li> <li> <p>Under the new project directory created, deploy the agilex5e-universal virtual platform:</p> <pre><code>$&lt;Simics installation dir&gt;/simics/bin/simics_intelfpga_cli --deploy agilex5e-universal\nSimics(R) Simulator for Intel(R) FPGA CLI:\nINFO: Preparing to initialize /home/simicsUser/SimicsInstallDir/project-1 as a\nSimics workspace\nProject created successfully\n# Observe that the directory has been initialized and the simics and simics-gui\n# commands appear in the project directory. Also, the target directory is\n# created. This includes the target script corresponding to the deployed\n# platform.\n</code></pre> </li> <li> <p>Build the virtual platform components:</p> <pre><code>$ make\n=== Environment Check ===\n'/home/simicsUser/SimicsInstallDir/project-1' is up-to-date\ngcc version 9\n=== Building module agilex5e-universal-board-comp ===\n:\n=== Building module agilex5e-universal-fpga-comp ===\n:\n=== Building module agilex5e-universal-system-comp ===\n:\nCopying agilex5_icon_84x84.png\n</code></pre> </li> <li> <p>Copy the following binaries created in Build Instructions section to the Simics project directory:</p> <ul> <li>gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/gsrd-console-image-agilex5.wic</li> </ul> <ul> <li>gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.bin</li> </ul> <ul> <li>qspi-bin/flash_image_jic.rpd</li> </ul> </li> <li> <p>Customize the configuration of the Agilex\u2122 5 E-Series Universal virtual platform, according to the setup required to exercise any specific use case. Set up the fsbl_image_filename parameter with the first-stage bootloader. If the boot implies booting from an SD Card device, configure sd_image_filename and create_hps_sd_card parameters (this image should include the main bootloader and the OS and/or application images). As part of the configuration, select the core used to boot using the hps_boot_core parameter, which could be core 0 (A55) or core 2 (A76).</p> <p>You can configure the virtual platform either by updating the agilex5e-universal.simics target script or creating a separate top-level target script (named based on the simulation purpose) that is expected to be run with this (example: uboot-linux_sdcard.simics used to boot from U-Boot to Linux from an SD Card device). You become the owner of this new target script, in which, you can set the required parameters and call the original virtual platform target script (targets/agilex5e-universal/agilex5e-universal.simics path). An example of the setup required to run a simulation that exercises the boot flow going from U-Boot to Linux, booting from an SD Card is shown in the following:</p> <pre><code>#uboot-linux_sdcard.simics\n$sd_image_filename = \"gsrd-console-image-agilex5.wic\"\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$hps_boot_core = 0\n$create_hps_sd_card = TRUE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> <p>Note: The uboot-linux_sdcard.simics file must be created under the Intel Simics project directory.</p> <p>Tip: Any specific configuration needed for a use case is indicated under the Setup section of that use case.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-sdcard-boot-flow-from-fsbl-to-linux","title":"Use Case: Exercise SDCard Boot Flow from FSBL to Linux","text":"<p>This use case consists of booting from an SDCard device going from U-Boot to Linux prompt passing through U-Boot SPL \u2192 ATF \u2192 U-Boot \u2192 Linux.</p> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <p>To exercise this use case, follow the below steps once the Simulation setup is complete:</p> <ol> <li> <p>From the project directory, launch the simulation using the uboot-linux_sdcard.simics target script. This script launches the simulator and the current terminal becomes the Simics CLI:</p> <pre><code>$ ./simics uboot-linux_sdcard.simics </code></pre> </li> <li> <p>From the Simics CLI, start running the simulation with the run command.</p> <pre><code>simics&gt;  run\n</code></pre> </li> <li> <p>Wait to get to the Linux prompt in the target serial console. </p> </li> <li> <p>Login into the Linux prompt using the root user without a password.</p> <p><pre><code># Target Serial console\nU-Boot SPL 2024.04 (Oct 16 2024 - 02:54:45 +0000)\nReset state: Cold\nMPU           875000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nio96b_cal_status: Calibration for IO96B instance 0x18400400 done at 0 msec!\n\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\nio96b_mb_init: num_instance 1\nio96b_mb_init: get memory interface IO96B 0\n:\nDDR: size check success\nDDR: firewall init success\nDDR: init success\nQSPI: Reference clock at 400000 kHz\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 0\nNOTICE:  BL31: v2.11.0(release):QPDS24.3_REL_GSRD_PR\nNOTICE:  BL31: Built : 07:09:49, Oct 15 2024\nU-Boot 2024.04 (Oct 16 2024 - 02:54:45 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  51 devices, 26 uclasses, devicetree: separate\nWDT:   Not starting watchdog@10d00200\nWDT:   Not starting watchdog@10d00300\nWDT:   Not starting watchdog@10d00400\nWDT:   Not starting watchdog@10d00500\nWDT:   Not starting watchdog@10d00600\nNAND:  4096 MiB\nMMC:   mmc0@10808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nLoading Environment from UBI... SF: Detected mt25qu02g with page size   256 Bytes, erase size 64 KiB, total 256 MiB\n:\nScanning mmc 0:1...\nFound U-Boot script /boot.scr.uimg\n2411 bytes read in 12 ms (195.3 KiB/s)\n## Executing script at 81000000\ncrc32+ Trying to boot Linux from device mmc0\nFound kernel in mmc0\n17685575 bytes read in 33 ms (511.1 MiB/s)\n## Loading kernel from FIT Image at 82000000 ...\n:\nSF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\nEnabling QSPI at Linux DTB...\nWorking FDT set to ffad6000\nQSPI clock frequency updated\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\n\nStarting kernel ...\n\nDeasserting all peripheral resets\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.37-altera-g978b3d90f408 (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240723) #1 SMP PREEMPT Mon Oct 14 01:56:39 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n:\nPoky (Yocto Project Reference Distro) 5.0.5 dhcp0 ttyS0\n\ndhcp0 login: [   37.881580] kauditd_printk_skb: 15 callbacks suppressed\n[   37.881588] audit: type=1334 audit(1709054800.748:33): prog-id=27 op=UNLOAD\n[   37.882865] audit: type=1334 audit(1709054800.748:34): prog-id=26 op=UNLOAD\n[   37.883602] audit: type=1334 audit(1709054800.748:35): prog-id=25 op=UNLOAD\n\ndhcp0 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for testing and development purposes only. It is recommended that you create your own distribution for production use.\n\nroot@dhcp0:~# </code></pre> This finishes the main scenario of this use case, but there are some extensions that are described next.</p> <p>Note: You can speed-up the boot process by skipping the U-Boot autoboot countdown by pressing any key and then typing the boot command:</p> <pre><code>U-Boot 2024.01 (Jun 25 2024 - 09:28:56 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\n\n:\nNet:   No ethernet found.\nHit any key to stop autoboot:  0 SOCFPGA_AGILEX5 # boot\nswitch to partitions #0, OK\nmmc0 is current device\nScanning mmc 0:1...\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-hello-application","title":"Use Case: Exercise Hello Application","text":"<p>This is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes executing the hello application from the Linux prompt.</p> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Execute the hello application located in the intelFPGA directory. After executing this application, the Hello SoC FPGA! message is displayed on the command prompt:</p> <pre><code># Target Serial console \nroot@dhcp0:~#  ./intelFPGA/hello Hello SoC FPGA!\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-system-check-application-with-hps-led-turn-onoff-control","title":"Use Case: Exercise System Check Application with HPS LED Turn On/Off control","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes executing the System Check Application to observe the state of the HPS LEDs. The execution of this use case works under the assumption that the LEDs are connected to the corresponding GPIOs in the virtual platform.</p> Setup <p>Same setup as the parent use case.</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>From the target system serial console, execute the System Check application (syschk) located under the intelFPGA directory. This shows some system information, such as the target system IP address and the state of the HPS LEDs. Observe that the initial state of the three HPS LEDs is OFF.</p> <p>Note:  When using device tree targeted for OOB card, only hps_led1 is available, so the System Check application only shows this led.</p> <pre><code># Target Serial console \nroot@dhcp0:~#  ./intelFPGA/syschk # Target Serial console \nActual changes:\n                              ALTERA SYSTEM CHECK                              lo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                      usb2                  : xHCI Host Contro\nhps_led2              : OFF\nhps_led0              : OFF             serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : OFF\n</code></pre> </li> <li> <p>Change the state of any of the HPS LEDs using the /sys/class/led/hps_ledX/brightness files writing either a '1' or '0' to these. For this, you need to first close the System Check application by typing Ctrl+C in the target serial console. Change the state of the LEDs to 'ON' state as indicated next and reopen the System Check application to observe the new state of the LEDs.</p> <pre><code># Target Serial console \nroot@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led0/brightness root@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led1/brightness root@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led2/brightness root@dhcp0:~# ./intelFPGA/syschk # Target Serial console \nActual changes:\n                                    ALTERA SYSTEM CHECK\n\nlo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                        usb2                  : xHCI Host Contro\nhps_led2              : ON\nhps_led0              : ON              serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : ON\n</code></pre> </li> <li> <p>Close the System Check application with Ctrl+C and return the HPS LEDs to the OFF state. Reconfirm that the state of the LEDs was updated to the new state in the System Check application.</p> <pre><code># Target Serial console \nroot@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led0/brightness root@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led1/brightness root@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led2/brightness root@dhcp0:~# ./intelFPGA/syschk # Target Serial console \nActual changes:\n                              ALTERA SYSTEM CHECK                              lo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                      usb2                  : xHCI Host Contro\nhps_led2              : OFF\nhps_led0              : OFF             serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : OFF\n</code></pre> </li> <li> <p>Close the System Check application with Ctrl+C.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-access-the-web-server-application-from-host-pc","title":"Use Case: Access the Web Server Application from Host PC","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes accessing from the host PC a web page that is being hosted by the target system, which runs a web server application. This application is launched automatically as part of the Linux boot process.</p> Setup <p>Using the uboot-linux_sdcard.simics Simics script, create an incoming port forwarding shown in the following:</p> <pre><code>connect-real-network-port-in ethernet-link = ethernet_switch0 target-ip=10.10.0.100 target-port = 80 host-port = 4080 -tcp </code></pre> <p>The port forwarding created allows you to access the webpage from the host PC. In the configuration, use the connect-real-network-port-in command, port 4080 in the host PC, and the target port in the target system is 80 (HTTP port). You also assign as the target IP, the IP that corresponds to the target system, which is 10.10.0.100. Also, indicate that this port forwarding is related to the TCP protocol. YOu can check the new port forwarding setup using the list-port-forwarding-setup command (this setup also could be done from the Simics CLI but in this case, the simulation should be stopped to perform the network configuration).</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>From the host PC, open a web browser and access the webpage running in the target system using the address: http://localhost:4080 . Note that the host machine is referred to as localhost and the port is 4080, which is the one visible from the host PC. </p> <p></p> <p>Note: The IP address of the host PC could be used as well instead of localhost.</p> <p>Note: The webpage displays instructions to connect to the target system using SSH. These instructions are valid if you run these binaries in real hardware. If you want to establish the SSH connection with a simulated target system, create a second incoming port forwarding with the following setup:</p> <p>connect-real-network-port-in ethernet-link = ethernet_switch0 target-ip=10.10.0.100 target-port = 22 host-port = 4022 -tcp</p> <p>Then, connect to the target system using ssh -p 4022 root@localhost from the host PC or ssh -p 4022 root@&lt;host PC IP address&gt; from any other PC in the same network.</p> </li> </ol> <p>A variation of this use case consists of accessing the web page from another PC under the same network that the host PC (both PCs in a real network). For this, use the IP address of the host PC instead of localhost and continue using the same port: http://&lt;host PC address&gt;:4080.</p> <p>Note: In the Linux Ubuntu system, you can get the IP address using the ifconfig command from a terminal. Also, ensure that the firewall in this PC is not blocking port 80.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-access-on-chip-ram-in-fpga-example-design-from-linux-prompt","title":"Use Case: Access ON-Chip RAM in FPGA Example Design from Linux Prompt","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes accessing from Linux the FPGA fabric example design for read and write operations. For this, the devmem2 Linux application is used. Also, a Simics CLI script is used to write some initial content to the memories in the example design.</p> Setup <p>Start with the setup as the parent use case. From the Simics CLI or using the uboot-linux_sdcard.simics Simics script, add the script branch that adds some content to the memories in the example design. The script branch writes 256 32-bit words in each memory.</p> <p></p> <pre><code># uboot-linux_sdcard.simics\n:\nscript-branch{\n# Wait until we see any message in the Serial Console to be sure the model has been fully initialized\nbp.console_string.wait-for system.board.fpga.soc_inst.hps_subsys.agilex_hps.console0.con \"U-Boot SPL\"\n$idx = 0\nwhile ($idx &lt; 256) {\n$addr = 4*$idx\n$valueMem1 = 0xcafe0000 | $idx\necho \"Set Values \" + (hex($valueMem1)) + \" at address \" + (hex($addr))\nsystem.board.fpga.soc_inst.example_design.design_mem.write $addr $valueMem1    $idx+=1 }\n}\n</code></pre> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Read the first and last locations written by the CLI script in the memories in the example design using the devmem2 application in Linux. This command receives the physical memory that wants to be accessed (in this case, based on the offset where the HPS2FPGA bridges are mapped to):</p> <pre><code>dhcp0 login:  root root@dhcp0:~#  devmem2 0x40000000 w /dev/mem opened.\nMemory mapped at address 0xffffa3940000.\nRead at address  0x40000000 (0xffffa3940000): 0xCAFE0000\nroot@dhcp0:~#  devmem2 0x400003fc w /dev/mem opened.\nMemory mapped at address 0xffff91ac1000.\nRead at address  0x400003FC (0xffff91ac13fc): 0xCAFE00FF\n</code></pre> <p>Observe that the values read matches the expected one shown in the figure above.</p> <p>Note: The addresses in parenthesis in the capture above correspond to the virtual address in which Linux maps the physical address corresponding to the location in the memory example design that is being accessed. This virtual address may be different than the one shown in the capture.</p> </li> <li> <p>Use the <code>devmem2</code> command to write into the memories in the example design and read back the data. For this, the following addresses are selected:</p> Bridge Address Memory Design Addr Index Value HPS2FPGA 0x40000400 0x400 256 0xcafe0200 <pre><code>root@dhcp0:~#  devmem2 0x40000400 w 0xcafe0200 /dev/mem opened.\nMemory mapped at address 0xffffbd034000.\nRead at address  0x40000400 (0xffffbd034400): 0x00000000\nWrite at address 0x40000400 (0xffffbd034400): 0xCAFE0200, readback   0xCAFE0200\n</code></pre> </li> <li> <p>Read back to the previous memory location written to confirm the operation was performed successfully.</p> <pre><code>root@dhcp0:~#  devmem2 0x40000400 w  /dev/mem opened.\nMemory mapped at address 0xffffa5ab9000.\nRead at address  0x40000400 (0xffffa5ab9400): 0xCAFE0200\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-peripheral-components-in-fpga-fabric-example-design","title":"Use Case: Exercise Peripheral Components in FPGA Fabric Example Design","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and exercising:</p> <ul> <li>LED I/O component to write/and read the state of the LED from Simics CLI and from U-Boot shell</li> <li>Dip-Swich and Push-Button I/O components to change the state of the input from Simics CLI and read the state of the input from U-Boot shell. Also configure the triggering of an nterrupts from these component to the HPS.</li> </ul> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <ol> <li>Start the simulation similar to how it is done in the main use case, but in the serial console stop the U-Boot autoboot by pressing a key on the reception of the message \"Hit any key to stop autoboot:\".</li> <li> <p>Here you are going to exercise the setting of some LEDs. Read the state of the LEDs I/O pins from the U-Boot shell through memory access using the address in which the DATA register of this component is mapped (0x20010080) and turn-on the 3 LEDs associated with the 3 less significative bits in this register. Then read-back the state of these pins to confirm these has been updated. You can confirm that the state of the LED's was updated reading directly into the DATA register of the LED I/O components from the Simics CLI.</p> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010080 1\n20010080: 00000000                             \u2026.\nSOCFPGA_AGILEX5 # mw 0x20010080 0x7 1\nSOCFPGA_AGILEX5 # md 0x20010080 1\n20010080: 00000007  </code></pre> <pre><code># Simics CLI\nrunning&gt; print-device-reg-info system.board.fpga.soc_inst.periph_subsys.led_pio.bank.regs.DATA [system.board.fpga.soc_inst.periph_subsys.led_pio.bank.regs.DATA]\nBits : 32\nOffset : 0x0\n          Value : 7\nBit Fields:\n  Data @ [31:0] : 00000000000000000000000000000111\n</code></pre> </li> <li> <p>Next you will exercise the toggling the input pin of the dip-switch component using the Simics CLI through the signal_raise() and signal_lower() and then reading back the state of the pin using the DATA register in this component using the U-Boot shell through the corresponding memory location of this register (0x20010070).</p> <pre><code># Simics CLI\nrunning&gt; @conf.system.board.fpga.soc_inst.periph_subsys.dipsw_pio.port.input_io[0].iface.signal.signal_raise() None\n</code></pre> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010070 1 \n20010070: 00000001 </code></pre> <pre><code># Simics CLI\nrunning&gt;  @conf.system.board.fpga.soc_inst.periph_subsys.dipsw_pio.port.input_io[0].iface.signal.signal_lower() None\n</code></pre> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010070 1 \n20010070: 00000000                             \u2026.\n</code></pre> </li> <li> <p>Finally you are going to exercise triggering an interrupt and clearing the interrupt generated from the rising edge of the input in the button I/O component. This will be exercised from the Simics CLI. To observe that the interrupt is triggered, the log level of the interrupt controller is increased. First the interrupt needs to be enabled using the INTERRUPT register in this component. Once the interrupt is enabled, we can assert the input signal and observe that the interrupt is triggered and the DATA register gets also updated with the set value ('1'). Finally, you will clear the interrupt using again the INTERRUPT register.</p> <pre><code># Simics CLI\nrunning&gt; log-level object = system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic level = 4 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic] Changing log level: 1 \u2192 4\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 0\nrunning&gt;  write-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.INTERRUPTMASK 1 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 already low\nrunning&gt;  @conf.system.board.fpga.soc_inst.periph_subsys.button_pio.port.input_io[0].iface.signal.signal_raise() [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 raised\nNone\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 1\nrunning&gt;  write-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.INTERRUPTMASK 0 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 lowered\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 1\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-usb-disk-hot-plug","title":"Use Case: Exercise USB Disk Hot-Plug","text":"<p>This use case is an extension of the main use case and includes attaching a USB image to one of the USB disks available in the Agilex\u2122 5-E Universal virtual platform and exercising the plug-in and plug-out actions as follows:</p> <ol> <li>Boot to the Linux prompt and plug in the USB disk (default), mount the disk and access some of the disk content, and add new content. The disk used in this use case is usb3_disk connected to the USB 3.0 Gen 1 controller.</li> <li>Unmount and plug-out the disk, and verify that this is not seen by Linux anymore.</li> <li>Plug-in and remount the disk, and verify that the content created is still available.</li> </ol> <p>All this is done as part of a single simulation session. The procedure described in the current use case does not allow to keep persistence of the content updated in the USB image after finishing the simulation.</p> <p>For this use case, we require to create an initial USB disk Image for which some information is provided in the Setup section.</p> Setup <p>Start with the setup as the parent use case an continue with next steps. 1. Create a 32 MB USB image (<code>usbImage.img</code>) following the instructions . The image has a <code>ext4</code> type file system in the partition created that includes as  initial content the <code>hello1.txt</code> file:</p> <ol> <li> <p>In your Simics project directory, create the <code>usbImage.img</code> image:  </p> <pre><code># Create a dircetory to create the image\nmkdir usbDisk &amp;&amp; cd usbDisk\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir part1 &amp;&amp;  cd part1\necho \"This is my original file in USB image\" &gt; hello1.txt cd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P part1/*,num=1,format=ext4,size=16M \\\n-s 32M \\\n-n usbImage.img\n</code></pre> </li> <li> <p>Update the target script to attach the image to the USB disk.</p> <pre><code>#uboot-linux_sdcard.simics   \n$sd_image_filename = \"gsrd-console-image-agilex5.wic\"\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$usb3_image_filename = \"usbDisk/usbImage.img\"\n$hps_boot_core = 0\n$create_hps_sd_card = TRUE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> </li> </ol> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in. By default, the USB disks in the virtual platform are plugged in. These can be detected from the Linux using the fdisk -l command and shown next:</p> <pre><code>root@dhcp0:~# fdisk -l Disk /dev/mmcblk0: 16 GB, 17179869184 bytes, 33554432 sectors 262144 cylinders, 4 heads, 32 sectors/track\nUnits: sectors of 1 * 512 = 512 bytes\n\nDevice       Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/mmcblk0p1 *  16,0,1      1023,3,32         2048    1026047    1024000  500M  b Win95 FAT32\n/dev/mmcblk0p2    1023,3,32   1023,3,32      1026048    4098047    3072000 1500M 83 Linux\nDisk /dev/sda: 32 MB, 33554432 bytes, 65536 sectors 37 cylinders, 43 heads, 41 sectors/track\nUnits: sectors of 1 * 512 = 512 bytes\n\nDevice  Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/sda1    0,32,33     2,42,41           2048      34816      32769 16.0M 83 Linux\nPartition 1 has different physical/logical start (non-Linux?):\n     phys=(0,32,33) logical=(1,6,40)\nPartition 1 has different physical/logical end:\n     phys=(2,42,41) logical=(19,32,8)\n</code></pre> </li> <li> <p>Observe that the usb3_disk corresponds to the /dev/sda device and /dev/sda1 corresponds to the partition created in this disk which size of 16 MB.</p> </li> <li> <p>Mount the partition in usb3_disk, observe the content (hello1.txt file), add new content (hello2.txt), and unmount the disk.</p> <pre><code>root@dhcp0:~# mkdir /media/usbDrive root@dhcp0:~# mount /dev/sda1 /media/usbDrive [  680.753967] EXT4-fs (sda1): mounted filesystem with ordered data mode. Quota mode: none.\nroot@dhcp0:~# ls /media/usbDrive hello1.txt root@dhcp0:~# more /media/usbDrive/hello1.txt This is my original file in USB image\nroot@dhcp0:~# echo \"This is my new file in the USB image\" &gt; /media/usbDrive/hello2.txt root@dhcp0:~# ls /media/usbDrive hello1.txt  hello2.txt root@dhcp0:~# umount /media/usbDrive/ [ 2403.043825] EXT4-fs (sda1): unmounting filesystem.\n</code></pre> </li> <li> <p>Unplug the usb3_disk from the Simics CLI and observe that Linux detects this action.</p> <p>In Simics CLI: <pre><code>running&gt; system.board.usb3_disk.unplug </code></pre></p> <p>In Linux shell: <pre><code>root@dhcp0:~# [ 1115.122439] usb 3-1: USB disconnect, device number 2\n</code></pre></p> <p>You can call fdisk -l command again to observe that /dev/sda device is no longer present.</p> </li> <li> <p>From the Simics CLI plugin, the usb3_disk again provides the usb3 port. Observe in the Linux shell that the device connection is detected. Remount the device partition and confirm that the new content created before is still present. Finally, unmount the disk.</p> <p>In Simics CLI:</p> <p><pre><code>running&gt; system.board.usb3_disk.plug port = usb1_typec\n</code></pre> In Linux shell:</p> <pre><code>root@dhcp0:~# [ 1415.994946] usb 3-1: new SuperSpeed USB device number 3 using xhci-hcd\n[ 1416.015078] usb 3-1: LPM exit latency is zeroed, disabling LPM.\n[ 1416.016520] usb-storage 3-1:1.0: USB Mass Storage device detected\n[ 1416.017476] scsi host0: usb-storage 3-1:1.0\n[ 1417.023153] scsi 0:0:0:0: Direct-Access     Vtech    Turbo_Disk(tm)   0001 PQ: 0 ANSI: 2\n[ 1417.024835] sd 0:0:0:0: [sda] 65536 512-byte logical blocks: (33.6 MB/32.0 MiB)\n[ 1417.025818] sd 0:0:0:0: [sda] Test WP failed, assume Write Enabled\n[ 1417.026685] sd 0:0:0:0: [sda] Asking for cache data failed\n[ 1417.027290] sd 0:0:0:0: [sda] Assuming drive cache: write through\n[ 1417.029785]  sda: sda1\n[ 1417.030333] sd 0:0:0:0: [sda] Attached SCSI disk\n\nroot@dhcp0:~# fdisk -l\nDisk /dev/mmcblk0: 16 GB, 17179869184 bytes, 33554432 sectors\n:\nDevice  Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/sda1    0,32,33     2,42,41           2048      34816      32769 16.0M 83 Linux\nPartition 1 has different physical/logical start (non-Linux?):\n     phys=(0,32,33) logical=(1,6,40)\nPartition 1 has different physical/logical end:\n     phys=(2,42,41) logical=(19,32,8)\nroot@dhcp0:~# mount /dev/sda1 /media/usbDrive [ 5419.362283] EXT4-fs (sda1): mounted filesystem 0fe6c96c-996c-4659-b7e2-e694076e5aef r/w with ordered data mode. Quota mode: none.\nroot@dhcp0:~# ls  /media/usbDrive hello1.txt  hello2.txt  lost+found\nroot@dhcp0:~# more  /media/usbDrive /media/usbDrive/hello2.txt\nThis is my new file in the USB image\nroot@dhcp0:~# umount /media/usbDrive/ [ 7348.324046] EXT4-fs (sda1): unmounting filesystem 0fe6c96c-996c-4659-b7e2-e694076e5aef.\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-ubifs-qspi-boot-flow-from-fsbl-to-linux","title":"Use Case: Exercise UBIFS QSPI Boot Flow from FSBL to Linux","text":"<p>This use case consists of booting from a QSPI flash device going from U-Boot to Linux prompt passing through U-Boot SPL \u2192 ATF \u2192 U-Boot \u2192 Linux using an image with UBIFS format.</p> Setup <p>Perform steps 1 to 4 described in the Simulation Setup section.</p> <ol> <li> <p>In the Intel Simics environment at the project directory, generate a compressed version of the .rpd file created (.craff) file using the craff tool provided under the Simics Base installation directory:</p> <pre><code>&lt;SimicsInstallDir&gt;/simics-6.0.202/bin/craff -o qspi_image.img.craff flash_image_jic.rpd\n</code></pre> <p>The following file is created under the Simics project directory:</p> <ul> <li>qspi_image.img.craff</li> </ul> </li> <li> <p>In the Intel Simics environment at the project directory, create a customized target script to exercise the FSBL to Linux boot flow from QSPI device with an image with UBIFS format. The file to create is called uboot-linux_qspi.simics. This file will look like this:</p> <pre><code>#uboot-linux_qspi.simics\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$qspi_image_filename  = \"qspi_image.img.craff\"\n$hps_boot_core = 0\n$create_hps_sd_card = FALSE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> </li> </ol> Procedure <p>To exercise this use case, follow the steps below once the Simulation setup is complete:</p> <ol> <li> <p>From the project directory, launch the simulation using the uboot-linux_qspi.simics target script. This script launches the simulator and the current terminal becomes the Simics CLI:</p> <pre><code>$ ./simics uboot-linux_qspi.simics </code></pre> </li> <li> <p>From the Simics CLI, start running the simulation with the <code>run</code> command.   <pre><code>simics&gt;  run\n</code></pre></p> </li> <li> <p>Wait for the simulation to get to the Linux prompt in the target serial console.</p> </li> <li> <p>Login into the Linux prompt using the root user without a password.  </p> <pre><code> U-Boot SPL 2024.04 (Oct 16 2024 - 02:54:45 +0000)\nReset state: Cold\n  MPU           875000 kHz\n  L4 Main       400000 kHz\n  L4 sys free   100000 kHz\n  L4 MP         200000 kHz\n  L4 SP         100000 kHz\n  SDMMC          50000 kHz\n  io96b_cal_status: Calibration for IO96B instance 0x18400400 done at 0 msec!\n  init_mem_cal: Initial DDR calibration IO96B_0 succeed\n  io96b_mb_init: num_instance 1\nio96b_mb_init: get memory interface IO96B 0\n:\n  ecc_enable_status: ECC enable status: 0\nDDR: size check success\n  DDR: firewall init success\n  DDR: init success\n  QSPI: Reference clock at 400000 kHz\n  Trying to boot from MMC1\n  MMC: no card present\n  spl: mmc init failed with error: -123\n  Trying to boot from SPI\n  ## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\n  NOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 0\nNOTICE:  BL31: v2.11.0(release):QPDS24.3_REL_GSRD_PR\n  NOTICE:  BL31: Built : 07:09:49, Oct 15 2024\nU-Boot 2024.04 (Oct 16 2024 - 02:54:45 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\n  DRAM:  2 GiB (effective 8 GiB)\nCore:  51 devices, 26 uclasses, devicetree: separate\n  WDT:   Not starting watchdog@10d00200\n  WDT:   Not starting watchdog@10d00300\n  WDT:   Not starting watchdog@10d00400\n  WDT:   Not starting watchdog@10d00500\n  WDT:   Not starting watchdog@10d00600\n  NAND:  4096 MiB\n  MMC:   mmc0@10808000: 0\nLoading Environment from FAT... MMC: no card present\n  :\n  Hit any key to stop autoboot:  0 MMC: no card present\n  SF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\n  Select Environment on UBI: OK\n  Saving Environment to UBI... done\nOK\n  UBI partition 'root' already selected\n  UBI partition 'root' already selected\n  No size specified -&gt; Using max size (196224)\nRead 196224 bytes from volume script to 0000000081000000\nQSPI: Running script from UBIFS\n  QSPI: Trying to boot script at 0x81000000\n  ## Executing script at 81000000\ncrc32+ Trying to boot Linux from device qspi\n\ndevice nor0 &lt;nor0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: u-boot              0x04200000      0x00000000      0\n1: root                0x0be00000      0x04200000      0\ndevice nand0 &lt;nand.0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: nand_uboot          0x00200000      0x00000000      0\n1: nand_root           0x1f400000      0x00200000      0\nactive partition: nor0,0 - (u-boot) 0x04200000 @ 0x00000000\n\ndefaults:\n  mtdids  : nand0=10b80000.nand.0\n  mtdparts: mtdparts=10b80000.nand.0:2m(u-boot),-(root)\nUBI partition 'root' already selected\n  :\n  SF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\n  Enabling QSPI at Linux DTB...\n  Working FDT set to ffae1000\n  QSPI clock frequency updated\n  RSU: Firmware or flash content not supporting RSU\n  RSU: Firmware or flash content not supporting RSU\n  RSU: Firmware or flash content not supporting RSU\n  RSU: Firmware or flash content not supporting RSU\n\nStarting kernel ...\n\nDeasserting all peripheral resets\n  [    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.37-altera-g978b3d90f408 (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240723) #1 SMP PREEMPT Mon Oct 14 01:56:39 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n  [    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n  [    0.000000] efi: UEFI not found.\n  [    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n  [    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n  [    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n  [    0.000000] earlycon: uart0 at MMIO32 0x0000000010c02000 (options '115200n8')\n[    0.000000] printk: bootconsole [uart0] enabled\n  [    0.000000] NUMA: No NUMA configuration found\n  :\n  Poky (Yocto Project Reference Distro) 5.0.5 agilex5dka5e065bb32aes1 ttyS0\n\nagilex5dka5e065bb32aes1 login: [  270.942017] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-0\n  [  270.947263] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-1\n  [  270.952619] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-2\n  :\n  [  281.452200] socfpga-dwmac 10830000.ethernet eth0: Link is Up - 1Gbps/Full - flow control rx/tx\n  [  311.541769] audit: type=1334 audit(1709054902.844:15): prog-id=18 op=UNLOAD\n  [  311.542509] audit: type=1334 audit(1709054902.844:16): prog-id=17 op=UNLOAD\n  [  311.543247] audit: type=1334 audit(1709054902.844:17): prog-id=16 op=UNLOAD\n\ndhcp0 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for testing and development purposes only. It is recommended that you create your own distribution for production use.\n\nroot@dhcp0:~#\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-debug-bare-metal-code-using-intel-simics-simulator","title":"Use Case: Debug Bare-Metal Code Using Intel Simics Simulator","text":"<p>This use case consists of performing a debug session in a bare-metal environment, which in this case corresponds to a U-Boot application example. In this use case, debugging is performed using only the Simics CLI commands allowing us to navigate on the source code of the application, advance in the execution of this, and observe and modify values of variables. The application is created in the form of a U-Boot command (helloTestApp) that should be executed from the U-Boot shell. The application starts by printing a hello message (Hello Intel SoC FPGA!) and printing the number of times the command has been executed since the last power-up. After this, the application enters into a loop in which it waits for 100 sec and increases an iteration counter by one. The content on the loop is executed as long as the iterator counter is lower than 100000 and also the value of the exitVar variable remains in 0, otherwise, it leaves the loop and continues printing the number of times the content of the loop was executed. After this, the code performs some mathematical operations involving the iterator value and other variables and finally prints the result of the final operation.</p> <p>The source code of the application is shown next. This is included in the do_helloTestApp() function, which then is referenced in the U_BOOT_CMD macro, which converts this into a U-Boot command. This source code must be included in a new file under the U-Boot repository as cmd/socFPGATrainingExamples.c. Also, to be built as part of the U-Boot binaries, update the cmd/Makefile file by adding obj-y += socFPGATrainingExamples.o.</p> <pre><code>/*\n   Training Examples called from a command from U-Boot shell\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;command.h&gt;\n#include &lt;linux/delay.h&gt;\nstatic char helloTestCmd_help_text[] =\n\"helloTestApp\\t\\n\";\nstatic unsigned int execCount = 0;\nstatic int do_helloTestApp(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])\n{\nvolatile unsigned char exitVar = 0;\nunsigned int waitIter = 0;\nvolatile unsigned int myVarA = 0;\nunsigned int temp = 0;\nunsigned int result;\nif (argc &gt; 1)\n{\nreturn CMD_RET_USAGE;\n}\nprintf(\"Hello Intel SoC FPGA! \\r\\n\");\nexecCount++;\nprintf(\"Executed %d times \\r\\n\", execCount);\nprintf(\"Relocated address of do_helloTestApp: %p and execCount: %p \\r\\n\", &amp;do_helloTestApp, &amp;execCount);\nwhile ((exitVar == 0) &amp;&amp; (waitIter &lt; 100000)){\nudelay(100);\nwaitIter++;\n}\nprintf(\"Exit from loop at iteration: %d \\r\\n\", waitIter);\ntemp = waitIter + myVarA;\nresult = temp % 1000;\nprintf(\"Final result: %d \\r\\n\", result);\nreturn CMD_RET_SUCCESS;\n}\nU_BOOT_CMD(\nhelloTestApp, 1, 1, do_helloTestApp,\n   \"Command used to launch hello application\", helloTestCmd_help_text\n);\n</code></pre> <p>Note: You can perform the build of this application by updating the Yocto recipe. This can be done by creating a patch in which you describe the files that need to be created/updated in the U-Boot repository and then deploy it. This can be done during the Yocto customization stage (Customize the Yocto Build). To create the u-boot patch (<code>myUbootExampleApp.patch</code>), do the following:</p> <pre><code>cd $TOP_FOLDER\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga u-boot-socfpga-patch\ncd u-boot-socfpga-patch/\n - Create cmd/socFPGATrainingExamples.c file with the source code provided of the example application.\n - Edit cmd/Makefile to include the build of socFPGATrainingExamples.c\n\nobj-y += help.o\n    obj-y += panic.o\n    obj-y += version.o\n    obj-y += socFPGATrainingExamples.o\n\ngit add cmd/Makefile cmd/socFPGATrainingExamples.c\ngit diff --patch --staged &gt; myUbootExampleApp.patch\n</code></pre> <p>To deploy the patch in the Yocto build flow do the following:</p> <ol> <li>Copy the <code>myUbootExampleApp.patch</code> file to the $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/ directory.</li> <li> <p>Request to deploy the path by adding a patch to the $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/u-boot-socfpga_%.bbappend file:</p> <pre><code>SRC_URI:append = \" \\ \n      file://0001-arm-Add-dwarf-4-to-compilation-flag.patch \\   \n      file://0001-arm-agilex-add-board-configuration.patch \\    \n      file://0001-arm-stratix10-add-board-configuration.patch \\ \n      file://myUbootExampleApp.patch \\ \n      \"\n</code></pre> </li> <li> <p>Continue with the rest of the Yocto build flow indicated at Build Yocto section.</p> </li> </ol> <p>After these steps, the application is included in the U-Boot binary file (uboot.itb), which is part of the SDCard image created (gsrd-console-image-agilex5.wic) and a symbol file corresponding to the U-Boot image, located at $TOP_FOLDER/gsrd-socfpga/agilex5_devkit-gsrd-images/u-boot-agilex5_devkit-socdk-gsrd-atf/u-boot. The symbol file is used later during the setup of the debug session.</p> Setup <p>Start with the setup of the main use case defined at [Simulation Setup]#simulation-setup). Modify the target script to add the created symbol file and set a breakpoint at the entry point of the  do_helloTestApp function as indicated in the following:</p> <pre><code># uboot-linux_sdcard.simics\n:\nadd-symbol-file  &lt;path of symbol file&gt;/u-boot  0x7FAF2000 -relative\nbp.source_location.break do_helloTestApp\n</code></pre> <p>Note: The symbol file is being loaded with an offset relocation of 0x7FAF2000. This is needed because in a late stage of the U-Boot execution, this relocates itself into a different SDRAM memory location and this should be indicated to the debugger, so there is a match between the addresses indicated in the symbol file and the real memory address location of the symbols. You can obtain this relocation offset by subtracting the real address of a specific function (which can be obtained from the application being executed) and the original offset from the same function in the symbols file (provided in the u-boot.sym file). This is shown in the following figure:</p> <p></p> Procedure <ol> <li> <p>Start the simulation similar to how it is done in the main use case, but in the serial console stop the U-Boot autoboot by pressing a key on the reception of the message \"Hit any key to stop autoboot:\". </p> </li> <li> <p>Start the U-Boot example application by calling the helloTestApp command from the U-Boot shell. This will make the breakpoint set in the target script trigger and the simulation will be stopped. In the Simics CLI, you will see the following message:</p> <pre><code>  [tcf] Breakpoint 1 on execution in context board.fpga.soc_inst.hps_subsys.agilex_hps.core[0] </code></pre> </li> <li> <p>From Simics CLI, start a debug session by calling the following command:   <pre><code>simics&gt; (psel).debug dbg0 (the arm-cortex-a55 system.board.fpga.soc_inst.hps_subsys.agilex_hps.core[0]) Now debugging the arm-cortex-a55 system.board.fpga.soc_inst.hps_subsys.agilex_hps.core[0] do_helloTestApp(cmdtp=(struct cmd_tbl *) 0xfffc5788, flag=0, argc=1, argv=(char * const *) 0xffb09520) at /home/tasks/gsrd/agilex5/updateUbootApp/agilex5_gsrd/gsrd-socfpga/agilex5_devkit-gsrd-rootfs/tmp/work/agilex5-poky-linux/u-boot-socfpga/1_v2022.10+gitAUTOINC+59fa161039-r0/git/cmd/socFPGATrainingExamples.c:19 19 volatile unsigned char exitVar = 0; </code></pre></p> </li> <li> <p>Following the program's logic, if the value of exitVar stays zero and the program is continued, the loop will continue until it reaches 100,000 and then the program ends with output messages in the serial console. You can check the values of the variable using the sym-type  and sym-value features:   <pre><code>simics&gt; dbg0.sym-type exitVar volatile unsigned char simics&gt; dbg0.sym-value exitVar 0 '\\x00' simics&gt; dbg0.sym-type myVarA volatile unsigned int- simics&gt; dbg0.sym-value myVarA 0\n</code></pre></p> </li> <li> <p>Control the program by using breakpoint and value modification. In this section, first insert a breakpoint at Line 34, which is in the loop (You may let the program run for a few seconds before inserting this breakpoint). With that, expect the program to pause when the breakpoint is met and modify the value of exitVar.   <pre><code>//The loop conditions are exitVar and waitIter   32| while ((exitVar == 0) &amp;&amp; (waitIter &lt; 100000)){   33|    udelay(100);   34|    waitIter++;   35| }\n</code></pre></p> <p>In the Simics Serial Console, enter the following line to insert the breakpoint at Line 34: <pre><code>running&gt; bp.source_line.break filename=socFPGATrainingExamples.c line-number=34\nBreakpoint 2: 0x2 (planted) </code></pre></p> <p>As the breakpoint is planted, continue the program by entering run. The program will stop when the breakpoint is hit. When the program stopped, modify the value of exitVar in the Serial Console by using the sym-write feature.</p> <pre><code>simics&gt; dbg0.sym-write exitVar 1 exitVar = 1 '\\x01'\nsimics&gt; run\n</code></pre> <p>Next, enter run and see the program ends immediately due to exitVar=1. <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n    Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n    Exit from loop at iteration: 9691\nFinal result: 691\nSOCFPGA_AGILEX5 #\n</code></pre></p> <p>From the output print, it shows that the program iterated for 9691 loops before hitting the Line-34 breakpoint you planted, this number would be bigger if you waited longer before planting the breakpoint. Lastly, the modification of exitVar  ended the program.</p> <p>Note:   a) You can modify the value of myVarA and exitVar at any time before the looping ends (the test program ends after 99,999 loops).   b) If the loop-ending condition (myVarA and exitVar) changed, the program should exit in the next run.   c) Using the same Simics session, you can enter helloTestApp in U-boot Shell to restart the test program again.</p> </li> <li> <p>For the first time the program is executed, the output shows \u201cExecuted 1 times\u201d, this value will increase (+1) as you run the program again without ending the Simics session. Meanwhile, in the serial console, the program has ended as soon as it just started because the controlling variable exitVar, having a value of 1, already reached the loop-ending condition. Output on a serial console:</p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n    Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n    Exit from loop at iteration: 2\nFinal result: 2\nSOCFPGA_AGILEX5 #\n</code></pre> </li> <li> <p>If the value exitVar remained zero, the loop counter is allowed to run for 99,999 loops. While the program is looping, you may change the value of myVarA to \u2018345\u2019. The Final result will be 345 when the looping ends. Final result is the modulus value where the <code>Final result = ( (waitIter + myVarA) % 1000 )</code></p> <pre><code> SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n    Executed 2 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n    Exit from loop at iteration: 100,000\n    Final result: 345\nSOCFPGA_AGILEX5 #\n</code></pre> </li> <li> <p>If both values of exitVar and myVarA remain unchanged, both being zero respectively, the looping continues until it reaches waitIter = 100,000. When the program ends, the Final result would be zero.</p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n    Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n    Exit from loop at iteration: 100,000\n    Final result: 0\nSOCFPGA_AGILEX5 #\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-debug-bare-metal-code-using-simics-riscfree","title":"Use Case: Debug Bare-metal Code Using Simics-RiscFree","text":"<p>This use case is an extension to the use case in section Use Case: Debug Bare-metal Code Using Intel Simics Simulator above but the debugging steps are performed in the Simics-RiscFree IDE. The test program used here is the same helloTestApp.c Important: The offset relocation of 0x7FAF2000 in the symbol file is still required and must be done before the symbol file is used to launch Simics-RiscFree.</p> Setup <p>This section requires the simics-riscfree script. It is included in your Intel Simics Simulator project directory.</p> <ol> <li> <p>To launch Simics-RiscFree IDE, use this command:</p> <pre><code>$  ./simics-riscfree </code></pre> </li> <li> <p>Following the command, you must set up a RiscFree  workspace. You should use a new directory as a RiscFree workspace which must be different and outside from the Simics project directory.     </p> </li> <li> <p>In the RiscFree IDE GUI launched, you should see the current Simics project you selected shown in the Project Explorer window. If this is not shown, you can open it from \"Window &gt; Show View &gt; Project Explorer\" menu.</p> <p></p> </li> <li> <p>From the Project Explorer window, right-click on the target script you want to launch (uboot-linux_sdcard.simics) and select \u201cDebug As &gt; Simics Session\u201d.     </p> </li> <li> <p>When prompted for Switching Perspective, select Yes. The interface switches to the RiscFree Debugger, which is more user-friendly for debugging.     </p> </li> </ol> Procedure <ol> <li>In the RiscFree Debugger window, click on the Run button  to launch the Intel Simics Simulator project.</li> <li> <p>As the project is launched, a Simics CLI window appears. When the CLI reaches the Hit any key to stop autoboot message, press any key to stop the autoboot to OS, which will then go into the U-boot Shell.</p> <p></p> </li> <li> <p>Start the test program by entering helloTestApp in the U-boot Shell.</p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nsimics&gt; [tcf] Breakpoint 1 on execution in context board.fpga.soc_inst.hps_subsys.agilex_hps.core[0]\n</code></pre> </li> <li> <p>As the first breakpoint is met, the program is halted at the entry point of the do_helloTestApp() function. Use the step into/step-over buttons  to get to the while ((exitVar == 0)  &amp;&amp;  (waitIter &lt; 100000)) line and show a capture of this with list command.</p> <p></p> </li> <li> <p>At this point, if you click on the Run button, the test program prints \u201cHello Intel SoC FPGA!\u201d and finishes looping after some time.</p> <p></p> <p>Note: If the loop already ended, relaunch the test program \"helloTestApp\" to proceed to the next step.</p> </li> <li> <p>To modify the loop conditions for debugging purposes, you can modify the value of exitVar in the Variable window. For example, changing the value of exitVar from \u2018\\377\u2019 (this is a random value assigned by the system) to \u2018\\001\u2019. As <code>exitVar</code> is no longer zero, the condition of the loop is exceeded, and thus the looping ends.</p> <p>Before modification:</p> <p></p> <p>After modification:</p> <p>[</p> </li> <li> <p>The loop exits depending on two conditions: exitVar not equals to zero OR waitIter reached 100,000. As the value of exitVar is modified to 1 in the middle of looping, the loop ends with exitVar = 1 and <code>waitIter</code> at any number less than 100,000. In this example, waitIter is 82251 when the loop ends. Following the code logic, Final result is the modulus value where Final result = ( (waitIter + myVarA) % 1000 ) = 252.</p> <p></p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-remote-debugging-of-a-linux-user-mode-program-using-arm-ds-debugger","title":"Use Case: Remote Debugging of a Linux User Mode Program Using ARM DS Debugger","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and consists of performing a debug session in a Linux user mode application using ARM Development Studio. For this, the debugging is done using the GDB server running in the target system. Also, set up the Simics network connectivity with the host PC, which is the one that runs ARM DS through TCP protocol. The application to be debugged is listed next myArmDSDebugExample.c. This application determines the core in which this run started and then enters into a loop counting the number of times the loop is executed and continue observing the execution core. It also counts the number of times the application is executed in each one of the four cores. The application exits from the loop when the iterator reaches a limit or the exitVar variable has a value of '1', which normally never should occur. After the loop, the application assigns the value in x variable to the a and b variables and then adds these variables and assigns the result value in c variable. In the end, the application prints the result of the addition, the number of times the loop was iterated and the final value of exitVar, and the number of times each core executed the application.</p> <p> NOTE: At this time, this use case can only be exercised with the Gold license for ARM DS Debugger. In the next release of Arm DS (2025.0) the Altera FPGA Edition license will support this case.</p> <pre><code>#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\n#define NUM_CORES 4\nunsigned int coreCount[NUM_CORES];\nunsigned long int read_mpidr(void)\n{\nunsigned long int value;\nasm volatile(\"mrs %[result], mpidr_el1\" : [result] \"=r\" (value));\nreturn value;\n}\nunsigned int getCore(){\nstatic unsigned int corePrev = (unsigned int)(-1);\nunsigned long mpidr;\nunsigned int core;\nmpidr = read_mpidr();\ncore = (mpidr &gt;&gt; 8) &amp; 0xFF;    if (core != corePrev)\n{\ncoreCount[core]++; corePrev = core;\n}\nreturn core;\n}\nint main()\n{\nint x = 1000;\nunsigned int core;    unsigned int iter = 0;\nint a;\nint b;\nint c;\nvolatile int exitVar = 0;\ncore = getCore();\nprintf(\"=== My Debug example started on Core %d ===\\n\", core); while((exitVar==0) &amp;&amp; (iter &lt; 1000000000))\n{\ncore = getCore(); iter++;\n}\na = x;\nb = x;\nc = a + b;\nprintf(\"Count:%d  iter: %d  exitVar:%d \\n\", c, iter, exitVar);\nfor (core = 0; core &lt; NUM_CORES; core++)\nprintf(\"  core[%d]: %d times\\r\\n\", core, coreCount[core]);\nreturn 0;\n}\n</code></pre> Setup <ol> <li> <p>Start with the setup as the parent use case. From the Simics CLI or from the uboot-linux_sdcard.simics Simics script, add the network configuration that allows establishing the GDB server connexion between the target system and the host PC. This configuration creates an incoming forwarding port for TCP traffic from a port in the host PC to port 9123 in the target system. The port in the host PC is shown when calling the list-port-forwarding-setup command (port 4001 will be used in this example).</p> <pre><code># uboot-linux_sdcard.simics\n:\nconnect-real-network-port-in 9123 ethernet-link = ethernet_switch0 target-ip = 10.10.0.100 -tcp list-port-forwarding-setup\nrunning&gt;  list-port-forwarding-setup NAPT enabled with gateway 10.10.0.1/24 on link ethernet_switch0.link.\nNAPT enabled with gateway fe80::2220:20ff:fe20:2000/64 on link ethernet_switch0.link.\n\nReal DNS enabled at 10.10.0.1/24 on link ethernet_switch0.link.\nReal DNS enabled at fe80::2220:20ff:fe20:2000/64 on link ethernet_switch0.link.\n\nHost TCP port 4001 \u2192 10.10.0.100:9123\n</code></pre> </li> <li> <p>The Linux example application must be compiled so you can have the executable binary available. This binary is generated with a toolchain and should be built to include debug information (i.e. symbol file). ARM DS does not support the DWARF 5.0 format in the symbols files, so the application must be built with a toolchain that creates this with DWARF 4.0 version. The instructions to build the applications are shown next. This generates the myArmDSDebugExample binary.</p> <pre><code>mkdir SymDbg &amp;&amp; cd SymDbg\nwget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.2-2020.11/binrel/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\nrm gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\n\n./gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc -g -o  myArmDSDebugExample myArmDSDebugExample.c\n</code></pre> </li> </ol> Procedure <ol> <li> <p>Execute parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Take the Linux application binary to the target system filesystem using tftp. For this, you will need to do the following. The myArmDSDebugExample binary should be located in the Simics project directory before calling tftp command.</p> <pre><code>root@dhcp0:~# ethtool -K eth1 tx off tx-checksum-ipv4: off\ntx-checksum-ipv6: off\ntx-tcp-segmentation: off [not requested]\ntx-tcp6-segmentation: off [not requested]\nroot@dhcp0:~# tftp -gr myArmDSDebugExample 10.10.0.1 root@dhcp0:~# chmod +x myArmDSDebugExample </code></pre> </li> <li> <p>Start a GDB Server debug session over the application from the Linux prompt using the port created in the target system during the port forwarding setup:</p> <pre><code>root@dhcp0:~# gdbserver 10.10.0.1:9123 myArmDSDebugExample Process /home/root/myArmDSDebugExample created; pid = 283\nListening on port 9123\n</code></pre> </li> <li> <p>In ARM Development Studio, create a new debug connection following the next steps:</p> <p>a) Create a New Debug Connection to a Linux Application Connection. Press Next.</p> <p> </p> <p>b) Give a name to the Debug connection: DebugLinuxAppSimicsGDB . Press Finish.</p> <p></p> <p>c) Edit the configuration. In the Connection tab, select:</p> <p>- Linux Application Debug \u2192 Application Debug \u2192 Connections via AArch64 gdbserver \u2192 Connect to already running application   - Address: localhost (or host PC IP if want to be accessed from a different PC in the same network)   - Port: 4001   - Select Terminate gdbserver on disconnect</p> <p></p> <p>d) Edit the configuration. In Files tab, select the application binary loaded as symbol file:  </p> <p>e) Edit the configuration. In Debugger tab, select Debug from symbol: main </p> <p></p> <p>Press Debug button to start the debug.</p> </li> <li> <p>The application debug can be performed now. ARM DS shows the source code of the test application stopped at the entry point of the main() function and we observe at the left the Debug Control panel with the options to control the execution of the code:</p> <p></p> <p>Observe that in the target serial console, the gdb server reports that the connection with the host was achieved showing the message: Remote debugging from host 10.10.0.1, port 4097</p> <p>a) Run the code and after a few seconds pause it. Observe that it stops under the while loop (or under the getCore() function which is called under the loop). You can observe the value of the variables using the Variables tab. The iter variable is increased in every iteration in the loop and the current value of exitVar variable is 0. You can also observe that the application is being executed in core 0. The loop will exit whenever the exitVar variable has a value of 1 or the iterator reaches gets greater than 1000000000. At this point, the application already printed the === My Debug example started on Core 0 === message in the serial console. </p> <p></p> <p>b) You can change the value of the exitVar variable from the Value column in the Variables tab, use the step-over button to advance in the execution of the application, and confirm that this condition makes it exit from the loop. You can continue advancing in the code execution and observe that the variables a and b gets initialized with the value of x. Observe that the c variable gets updated with the result of the addition of a and b variables.</p> <p></p> <p>c) Proceed to continue the code execution and observe that the application gets finished printing the results. Also, you can get disconnected from the gdb server session and after this, the serial console shows again the Linux prompt.</p> <p></p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/","title":"Simics Zephyr GSRD for Agilex\u2122 5 E-Series Devices","text":"<p> NOTE: Zephyr was not updated in this release. To generate the Zephyr binaries, please look at the latest version available for this GSRD at\u00a0Simics Zephyr\u00a0GSRD. The binearies generated from that release, also work with the Simics installation from Quartus\u00ae Prime Pro Edition Version 25.1.1 release.\u00a0\u00a0</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/","title":"HPS GHRD Linux Boot Tutorial Example Design: Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#overview","title":"Overview","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The key differences versus the GSRD are:</p> <ul> <li>Fabric is configured from U-Boot directly with the rbf file, with <code>fpga load</code> command, instead of using the <code>bootm</code> command with the core.rbf part of the kernel.itb file</li> <li>Single image boot is disabled in U-Boot, and it boots directly with the slected boot source, not trying them all</li> <li>The applications and drivers form <code>meta-intel-fpga-refdes</code> are not included. That includes acessing GPIOs in the fabric for LEDs, pushbuttons, dip switches, the webserver running on the board, etc.</li> </ul> <p>The following scenarios are covered:</p> <ul> <li>Boot from SD Card</li> <li>Boot from QSPI</li> </ul> <p>The instructions on this page are based on the GSRD.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Modular Development Kit GSRD:</p> <ul> <li>Altera Agilex 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#development-kit","title":"Development Kit","text":"<p>Refer to Development Kit for details about the board, including how to install the HPS Boards, and how to set MSEL dispswitches.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#release-notes","title":"Release Notes","text":"<p>Refer to Release Notes for release information.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from SD card.</p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_boot.modular\nmkdir agilex5_boot.modular\ncd agilex5_boot.modular\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Install Yocto Dependencies <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-modular-devkit-som-legacy-baseline.zip\nunzip a5ed065es-modular-devkit-som-legacy-baseline.zip\nrm -f a5ed065es-modular-devkit-som-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\ncat &lt;&lt; EOF &gt; config-fragment-agilex5\n# Enable Ethernet connectivity so we can get an IP address\nCONFIG_MARVELL_PHY=y\nEOF\nmake defconfig\n# Apply custom Configs in file\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex5\nmake oldconfig\nmake -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from QSPI.</p> <p>NOTE:  This section assumes that the Boot from SD Card section has been already built and the environment setup in that section is still available.</p> <p>This section presents how to build the binaries and boot from QSPI with the HPS Enablement Board. While the example is based on the GSRD, it contains the following differences:</p> <ul> <li>U-Boot tries to boot only from QSPI flash, does not try SD card</li> <li>U-Boot does not use a script to boot, instead it used the <code>BOOTCMD</code> environment variable directly</li> <li>kernel.itb file contains only one set of core.rbf, kernel and device tree files, targeted for this scenario</li> </ul> <p>1. Prepare the top folder</p> <pre><code>rm -rf $TOP_FOLDER/qspi-boot\nmkdir $TOP_FOLDER/qspi-boot\n</code></pre> <p>2. Build U-Boot:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from QSPI\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# mtd info\nCONFIG_MTDIDS_DEFAULT=\"nor0=nor0\"\nCONFIG_MTDPARTS_DEFAULT=\"mtdparts=nor0:66m(u-boot),190m(root)\"\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# do not keep env on sd card\nCONFIG_ENV_IS_IN_FAT=n\n# disable NAND related settings from defconfig\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"mtdparts;ubi part root;ubi readvol \\${loadaddr} kernel;ubi detach;setenv bootargs earlycon panic=-1 ubi.mtd=1 root=ubi0:rootfs rootfstype=ubifs rw rootwait;bootm \\${loadaddr}#board-0;\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build <code>kernel.itb</code> FIT file containing kernel, device tree and fpga fabric configuration file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -f core.rbf devicetree.dtb Image.lzma kernel.its kernel.itb\nln -s ../ghrd.core.rbf core.rbf\nln -s ../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb devicetree.dtb\nxz --format=lzma --extreme -k -c ../linux-socfpga/arch/arm64/boot/Image &gt; Image.lzma\ncat &lt;&lt; EOF &gt; kernel.its\n// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2024 Intel Corporation\n *\n */\n/dts-v1/;\n/ {\n    description = \"FIT image with kernel, DTB and FPGA core binary\";\n    #address-cells = &lt;1&gt;;\n    images {\n        kernel {\n            description = \"Linux Kernel\";\n            data = /incbin/(\"./Image.lzma\");\n            type = \"kernel\";\n            arch = \"arm64\";\n            os = \"linux\";\n            compression = \"lzma\";\n            load = &lt;0x86000000&gt;;\n            entry = &lt;0x86000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fdt-0 {\n            description = \"Device Tree\";\n            data = /incbin/(\"./devicetree.dtb\");\n            type = \"flat_dt\";\n            arch = \"arm64\";\n            compression = \"none\";\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fpga-0 {\n            description = \"FPGA bitstream\";\n            data = /incbin/(\"./core.rbf\");\n            type = \"fpga\";\n            arch = \"arm64\";\n            compression = \"none\";\n            load = &lt;0x8A000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n    };\n    configurations {\n        default = \"board-0\";\n        board-0 {\n            description = \"board_0\";\n            kernel = \"kernel\";\n            fdt = \"fdt-0\";\n            fpga = \"fpga-0\";\n            signature {\n                algo = \"crc32\";\n                key-name-hint = \"dev\";\n                sign-images = \"fdt-0\", \"kernel\", \"fpga-0\";\n            };\n        };\n    };\n};\nEOF\n./u-boot-socfpga/tools/mkimage -f kernel.its kernel.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/kernel.itb</code></li> </ul> <p>4. Create U-Boot binary <code>u-boot.bin</code> with a size of exactly 2MB:</p> <pre><code>cp u-boot-socfpga/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Build the <code>rootfs.ubifs</code> file:</p> <pre><code>rm -rf rootfs rootfs.ubifs\nmkdir rootfs tar -xzvf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz -C rootfs mkfs.ubifs -r rootfs -F -e 65408 -m 1 -c 6500 -o rootfs.ubifs </code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/rootfs.ubifs</code></li> </ul> <p>6. Build the <code>root.ubi</code> file:</p> <pre><code>cat &lt;&lt; EOF &gt; ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nvol_id=1\nvol_name=script\nvol_size=128KiB \nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3    \nvol_name=dtb   \nvol_size=256KiB \nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOF\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/root.ubi</code></li> </ul> <p>7. Build the QSPI flash image:</p> <pre><code>ln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof fpga.sof\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\nln -s root.ubi hps.bin\ncat &lt;&lt; EOF &gt; flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n    &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"UBOOT\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"HPS\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"UBOOT\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash_image.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/flash_image.hps.jic</code></li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <p><pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"qspi-boot/flash_image.hps.jic\"\n</code></pre> Note: You need to wipe the micro SD card or remove it from the board before start running.</p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices","text":"<p>The design is compatible with Altera\u00ae Quartus\u00ae Prime Pro Edition version 25.1 Linux.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#overview","title":"Overview","text":"<p>The 4K Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices demonstrates a practical glass-to-glass camera solution. The exclusive support for industry-standard Mobile Industry Processor Interface (MIPI) D-PHY and MIPI CSI-2 interface on Agilex\u2122 5 FPGAs provides a powerful tool for camera product development. The MIPI interface supports up to 2.5Gbps per lane and up to 8x lanes per MIPI interface enables seamless data reception from multiple 4K image sensors to the FPGA fabric for further processing. Each MIPI CSI-2 IP instance converts pixel data to AXI4-Streaming outputs, enabling connectivity to other IP cores within Altera\u00ae's Video and Vision Processing (VVP) Suite.</p> <p>The design is a hardware-software co-design, whose hardware component comprises an Image Signal Processor (ISP), various VVP IPs, Hard Processor Subsystem (HPS) and various connectivity IPs. The software stack is Linux based and runs on the HPS.</p> <p>The hardware includes a multi-sensor input video switch feeding into an Image Signal Processing (ISP) subsystem. The ISP is a video processing pipeline incorporating many VVP IP cores such that the raw sensor image data can be processed into RGB video data. The backend of the ISP pipeline also includes adaptive local tone mapping (TMO) for handling wide dynamic range scenes, 1D-LUT and 3D-LUT IPs for color transformations and High Dynamic Range (HDR) conversion, and a high-performance Warp IP core for geometric distortion correction. The design drives the resulting 4Kp60 streaming video output data through an Altera\u00ae DisplayPort IP.</p> <p>The software stack consists of an application software binary running on Linux operating system with various layers of drivers. The backend part of the application software interrogates the hardware, discovers the IP components dynamically and configures them. Multiple feedback loops monitor the hardware and keep various hardware components in lockstep. Some of the notable feedback loops are Automatic White Balance (AWB), Auto Exposure (AE), and Adaptive Noise Reduction (ANR) algorithms, reading their relevant statistics and adjusting various coefficients and Look Up Tables (LUTs) in real time. The frontend of the software creates a web based Graphical User Interface (GUI) and runs it over a web server.</p> <p>The following diagrams provide an overview of the interaction of software running on ARM CPUs inside the Hard Processor Subsystem (HPS) and hardware components running in the programmable logic parts of the device. (For more information of ARM HPS in Altera\u00ae Agilex\u2122 Devices refer to the User Manuals section.)</p> <p></p> <p> <p>High-Level Block Diagram of the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#pre-requisites","title":"Pre-requisites","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</li> </ul> <p> <p>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit </p> <ul> <li>1 or 2 Framos FSM:GO IMX678C Camera Modules, with:<ul> <li>Wide 110deg HFOV Lens, or</li> <li>Medium 100deg HFOV Lens, or</li> <li>Narrow 54deg HFOV Lens.</li> </ul> </li> <li>Mount/Tripod<ul> <li>Framos Tripod Mount Adapter.</li> <li>Tripod.</li> </ul> </li> <li>A Framos cable for PixelMate MIPI-CSI-2 for each Camera Module:<ul> <li>150mm flex-cable, or</li> <li>300mm micro-coax cable.</li> </ul> </li> <li>Minimum 8GB U3 microSD Card.</li> <li>DP Cable or HDMI Cable (with 4Kp60 Converter Dongle).</li> <li>USB Micro B JTAG Cable (for JTAG programming).</li> <li>USB Micro B Serial Cable (for HPS terminal connection).</li> <li>RJ45 Ethernet Cable (HPS network connection).</li> <li>Monitor/TV (recommend 4Kp60 capable).</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#software-requirements-to-run","title":"Software Requirements to run","text":"<ul> <li>Host PC with:<ul> <li>8 GB of RAM (less if not rebuilding binaries).</li> <li>Linux/Windows OS installed.</li> <li>Serial terminal (such as GtkTerm or Minicom on Linux, and TeraTerm or   PuTTY on Windows).<ul> <li>FTDI FT232R USB UART drivers (for a Windows host).</li> </ul> </li> <li>Tool to write images for removable USB drives or microSD cards such as Win32DiskImager on Windows or \"dd\" command on Linux.</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition version 25.1 Programmer and Tools.</li> <li>Ethernet connection (either direct from Host PC to development board, or   via a switch or router).<ul> <li>Note, you may need to disconnected/disabled VPN if it is installed on the   Host PC.</li> </ul> </li> <li>Web browser.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#download-the-pre-built-binaries","title":"Download the pre-built Binaries","text":"<ul> <li>Download the Agilex\u2122 5 Modular Development board binaries:</li> </ul> <p> <p>Binaries</p> Source Link Description QSPI top.core.jic Allows the development board to be booted from the microSD card microSD Card Image hps-first-vvp-isp-demo-image-agilex5_mk_a5e065bb32aes1.wic.gz The complete Camera Solution System Example Design <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#getting-started-run-with-pre-built-binaries","title":"Getting Started - run with pre-built binaries","text":"<p>Follow the instructions provided in this section to run the 4K Multi-Sensor HDR Camera Solution System Example Design on the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#programming","title":"Programming","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#setting-up-your-modular-development-board","title":"Setting Up your Modular Development Board","text":"<p>Warning</p> <p>Handle ESD-sensitive equipment (boards, microSD Cards, Camera sensors, etc.) only when properly grounded and at an ESD-safe workstation</p> <ul> <li>Configure the board switches as shown:</li> </ul> <p></p> <p> <p>Modular Development Board - Default Switch Positions </p> <p>Main switch configurations used by the Camera Solution System Example Design</p> <p>JTAG Mode:         SOM S4=OFF:OFF, or ASx4 (QSPI) Mode:  SOM S4=ON:ON</p> <p></p> <ul> <li>Connect micro USB cable between the carrier board (<code>J35</code>) and the Host PC.   This will be used for JTAG communication. Look at what ports are enumerated   on your Host computer. There should be a series of four.</li> <li>Connect micro USB cable between the SOM board (<code>J2</code>, HSP_UART) and the Host   PC. This will be used for HPS UART communication. Look at what ports are   enumerated on your Host computer. There should be a series of four. Use the   3rd one in the list as the HPS serial port.</li> <li>Connect an RJ45 cable between the ethernet port on the SOM board (<code>J6</code>, ETH   1G HPS) and make sure it is on the same network as your Host PC. You can   check the <code>eth0</code> IP address after boot using the Linux <code>ip a</code> command.</li> </ul> <p></p> <p> <p>Board Connections </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#burn-the-microsd-card-image","title":"Burn the microSD Card Image","text":"<ul> <li>Either use your own or download the pre-built <code>&lt;name&gt;.wic.gz</code> image.</li> <li> <p>Extract <code>&lt;name&gt;.wic</code> image from the zip file</p> <ul> <li>On Linux, use the <code>dd</code> utility:</li> </ul> <pre><code>tar -xzf `&lt;name&gt;.wic.gz`\n</code></pre> <ul> <li>On Windows, use the 7-Zip program (or similar):<ul> <li>Right click <code>&lt;name&gt;.wic.gz</code> file, and select \"Extract All...\"</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p>Write the <code>&lt;name&gt;.wic</code> image to the microSD card using a USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility:</li> </ul> <pre><code># Determine the device associated with the SD card on the host computer.\ncat /proc/partitions\n# This will return for example /dev/sd&lt;x&gt;\n# Use dd to write the image in the corresponding device\nsudo dd if=&lt;name&gt;.wic of=/dev/sd&lt;x&gt; bs=1M\n# Flush the changes to the microSD card\nsync\n</code></pre> <ul> <li> <p>On Windows, use the Win32DiskImager program (or similar):</p> <ul> <li>Click browse icon and select \"*.*\" filter:</li> </ul> <p> <p>Navigate to your download and select <code>&lt;name&gt;.wic</code> in the \"Disk Imager\" tool </p> <ul> <li>Write the image (note your Device may be different to that shown):</li> </ul> <p> <p>Write the microSD Card using the \"Disk Imager\" tool </p> <ul> <li>Turn off the board and insert the microSD card in the microSD card slot   located on the SOM board.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#program-the-qspi-flash-memory","title":"Program the QSPI Flash Memory","text":"<p>This should only need to be done once. To program the QSPI flash memory:</p> <ul> <li>Power down the board. Set MSEL=JTAG by setting the S4 dip switch   on the SOM to OFF-OFF.<ul> <li>This prevents any bootloader from starting and leaves the JTAG chain in a   default state.</li> </ul> </li> </ul> <ul> <li>Power up the board.</li> </ul> <ul> <li>Either use your own or download the pre-built <code>JIC</code> image, and write it to   the QSPI Flash memory using either the command:<pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.core.jic\" </code></pre> </li> </ul> <ul> <li> <p>or, optionally using the Quartus\u00ae Programmer GUI:</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\" settings as following: </li> </ul> </li> </ul> <p> <p>Programmer - GUI Hardware Settings </p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code>, and press \"Change File..\" </li> </ul> <p> <p>Programmer - After \"Auto Detect\" </p> <p>Select your <code>top.core.jic</code> file. The <code>MT25QU02G</code> device should be shown (see below). Check the \"Program/Configure\" box and press the \"Start\" button. Wait until the programming has been completed (which can take several minutes). </p> <p> <p>Programming the QSPI Flash with the JIC file </p> <ul> <li>Power down the board. Set MSEL=ASX4 (QSPI) by setting the S4 dip switch   on the SOM to ON-ON.<ul> <li>This starts the HPS bootloader and FPGA configuration from the microSD Card   after power up. </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#running","title":"Running","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#board-and-host-pc-setup","title":"Board and Host PC Setup","text":"<p>Warning</p> <p>Handle ESD-sensitive equipment (boards, microSD Cards, Camera sensors, etc.) only when properly grounded and at an ESD-safe workstation</p> <p>Make the required connections between the Host PC and the Modular Development board as shown in the following diagram:</p> <p></p> <p> <p>Development Kit and Host PC Connection diagram </p> <ul> <li>Connect the Framos cable(s) between the Framos Camera Module(s) and the Modular   Development board taking care to align the cable(s) correctly with the   connectors (pin 1 to pin 1). For a single camera module, either MIPI connector can be used.</li> </ul> <p> <p>Board MIPI connections </p> <p> <p>Board MIPI and Ribbon Cable </p> <p> <p>Camera and Ribbon Cable </p> <p> <p>Board with Connections </p> <ul> <li>Connect the Modular Development carrier board DisplayPort Tx connector to the   Monitor using a suitable cable (and dongle if you are using HDMI).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#connect-browser-to-ui","title":"Connect Browser to UI","text":"<ul> <li>Power up the board (if not already powered) and set up the serial terminal emulator (minicom,   teraterm, putty, etc.):<ul> <li>Select the correct <code>COMx</code> port. (The Modular Development board presents 4   serial COM ports over a single connection and the Linux system uses the 3rd   port in order). Set the port configuration as follows:<ul> <li>115200 baud rate, 8 Data bits, 1 Stop bit, CRC and Hardware flow control   disabled.</li> </ul> </li> </ul> </li> <li>The Linux OS will boot and the 4K Multi-Sensor HDR Camera Solution System   Example Design Application should run automatically.</li> <li>A few seconds after Linux boots, the application will detect the attached   Monitor and the ISP processed output will be displayed using the best   supported format.</li> <li> <p>Take note of the board's IP address.</p> <ul> <li> <p>The board's IP address can also be found using the terminal by logging in   as <code>root</code> (no password required) and querying the Ethernet controller:</p> <pre><code>root\nifconfig\n</code></pre> </li> </ul> <ul> <li><code>eth0</code> provides the IPv4 or IPv6 address to connect to. </li> </ul> </li> </ul> <p> <p>Example ifconfig output for if network provides DHCP </p> <p></p> <p></p> <p> <p>Example ifconfig output for if no DHCP support, or direct connection </p> <p></p> <ul> <li>Connect your web browser to the boards IP address so you can interact with   the 4K Multi-Sensor HDR Camera Solution System Example Design using the GUI.<ul> <li>To connect using IPv6 for the examples above you would use   <code>http://[fe80::a8bb:ccff:fe55:6688]</code> (note the square brackets)</li> <li>To connect using IPv4 for the DHCP example above you would use   <code>http://192.168.0.1</code></li> </ul> </li> </ul> <p></p> <p> <p>Example web browser URL for IPv6 address </p> <p></p> <p> <p>Example web browser URL for IPv4 address </p> <p></p> <ul> <li>During connection, you will see the Altera\u00ae splash screen, after which you   will be presented with the    Web GUI:</li> </ul> <p></p> <p> <p>Example Camera Solution GUI </p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#recommended-user-flows","title":"Recommended User Flows","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#sources","title":"Sources","text":"<p>The sources listed in this table are the most current and highly recommended for Quartus\u00ae 25.1 builds. Users are advised to utilize the updated versions of these building blocks in production environments. Please note that this is a demonstration design and is not suitable for production or final deployment.</p> <p> <p>System Example Design Source Repository</p> Component Location Branch Assets Release Tag https://github.com/altera-fpga/agilex-ed-camera/releases/tag/rel-25.1 rel-25.1 Repository https://github.com/altera-fpga/agilex-ed-camera rel-25.1 <p></p> <p></p> <p>With the available resources, you can create and modify, build and compile, and execute the 4K Multi-Sensor HDR Camera Solution System Example Design. There are 3 recommended flows that you can explore:</p> <ul> <li>User Flow 1: Getting Started - Running with pre-built binaries.</li> <li>User Flow 2: Use the SOF Modular Design Toolkit (MDT) Flow - typically   used for Quartus\u00ae with OpenCore Plus IP Evaluation License for time limited and tethered   camera solutions.</li> <li>User Flow 3: Use the RBF Modular Design Toolkit (MDT) Flow - typically   used for Quartus\u00ae with full IP License for turnkey microSD card camera   solutions.</li> </ul> <p>Note</p> <p>The free OpenCore Plus feature allows you to evaluate licensed IP cores in simulation and hardware before purchase. OpenCore Plus evaluation supports the following two operation modes:  Untethered \u2014 run the design containing the licensed IP for a limited time.  Tethered \u2014 run the design containing the licensed IP for a longer time or indefinitely. This operation requires a JTAG connection between your board and the Host computer.  Note: All IP cores that use OpenCore Plus time out simultaneously when any IP core in the design times out.</p> <p></p> <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#flows","title":"Flows","text":"<p>Recommended User Flows</p> User Flow Description User Flow 1 User Flow 2 User Flow 3 Pre-requisites Hardware Requirements. \u2713 \u2713 \u2713 Software Requirements to build. \u2717 \u2713 \u2713 License Requirements to build. \u2717 \u2713 \u2713 Software Requirements to run. \u2713 \u2713 \u2713 Download the Pre-built Binaries. \u2713 \u2717 \u2717 HW-Compilation Creating and Building the Design based on the SOF Modular Design Toolkit (MDT) Flow \u2717 \u2713 SOF MDT Flow  \u2717 Creating and Building the Design based on the RBF Modular Design Toolkit (MDT) Flow \u2717 \u2717 \u2713 RBF MDT Flow  SW-Compilation Create microSD card image (.wic.gz) using YOCTO/KAS NOTE: use KAS_MACHINE=agilex5_mk_a5e065bb32aes1 and kas/agilex_camera_ff.yml configuration \u2717 \u2713 YOCTO/KAS  \u2717 Create microSD card image (.wic.gz) using YOCTO/KAS NOTE: use KAS_MACHINE=agilex5_mk_a5e065bb32aes1 and kas/agilex_camera.yml configuration \u2717 \u2717 \u2713 YOCTO/KAS  Programming Setting Up your Modular Development Board. \u2713 \u2713 \u2713 Burn the microSD card image. \u2713 \u2713 \u2713 Program the QSPI Flash Memory. \u2713 \u2717 \u2713 Running Board and Host PC Setup. \u2713 \u2713 \u2713 Program the FPGA SOF. \u2717 \u2713 \u2717 Connect Browser to UI. \u2713 \u2713 \u2713 <p> </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#camera-solution-system-example-design-documentation","title":"Camera Solution System Example Design - Documentation","text":"<ul> <li>Features.</li> <li>ISP Functional Description.</li> <li>FPGA Hardware Functional Description.</li> <li>Software Functional Description.</li> <li>Web GUI Functional Description.</li> <li>Design Security Considerations.</li> <li>Acronyms and Terminology.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#camera-solution-system-example-design-references","title":"Camera Solution System Example Design - References","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit Product Brief.</li> <li>Framos FSM:GO IMX678C Camera Modules.</li> <li>Video and Vision Processing Suite Altera\u00ae FPGA IP User Guide.</li> <li>VVP IP Suite, VVP Tone Mapping Operator (TMO) IP, VVP Warp IP, and 3D LUT IP.</li> <li>MIPI DPHY IP and MIPI CSI-2 IP.</li> <li>Nios\u00ae V Processor.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#other-repositories-used","title":"Other Repositories Used","text":"Component Location Branch Modular Design Toolkit https://github.com/altera-fpga/modular-design-toolkit rel-25.1 Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.22-lts Arm Trusted Firmware https://github.com/ARM-software/arm-trusted-firmware socfpga_v2.11.0 U-Boot https://github.com/altera-opensource/u-boot-socfpga v2024.01 Yocto Project: poky https://git.yoctoproject.org/poky scarthgap"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#useful-user-manuals-and-reference-materials","title":"Useful User Manuals and Reference Materials","text":"<ul> <li>Hard Processor System Technical Reference Manual: Agilex\u2122 5 SoCs (25.1).</li> <li>NiosV Processor for Altera\u00ae FPGA.</li> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k/camera_4k/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - Design Security Considerations","text":"<p>This system example design is provided as a demonstration specifically for the IP component of the ISP and is not intended for a final product or deployment. As such, there are several features of the design that may not meet customer safety and security requirements. It is important for you to conduct a safety and security review of your final design to ensure you meet your safety and security goals. Some of the areas of further consideration are listed below. Please note that this is not an exhaustive list, and you should perform a full security review of your own system, considering hardware, FPGA design and software aspects, depending on the market requirements of the final product.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#jtagserial-port-connections","title":"JTAG/serial port connections","text":"<p>The development kit hardware includes access to various parts of the design using industry standard interfaces. In this design, these ports are freely available to use to allow visibility into the design ad for debug purposes. You should consider whether these access points are to be made available on your own hardware. If so, they should be protected as per your own security requirements and policies.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#debug-capability","title":"Debug capability","text":"<p>This design includes multiple debug paths, for example, the use of technologies such as Signal Tap, in-system memory editors, access to debuggers, etc. This level of debug access may not be desirable in a final product, and you should consider removing or restricting these capabilities.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#frame-buffers","title":"Frame buffers","text":"<p>This design stores video data in various frame buffers held in both external DDR4 SDRAM memory and on-chip memory blocks. This video information is not encrypted or protected in any way. You should consider if you wish to apply security features to the way the video data is stored.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#memory-management","title":"Memory management","text":"<p>You may implement fine-grained memory access management and put restrictions in place to prevent unauthorized access and protect memory corruption by other IPs.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#use-of-encryptedprotected-video-feeds","title":"Use of encrypted/protected video feeds","text":"<p>This design uses an industry standard DisplayPort video output interface. Within the design, these video streams are not protected against security attacks. You should consider the use of encryption techniques to meet your own security requirements. An example could be the use of the HDCP encryption scheme that is part of the feature set of the video standard.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#fpga-bitstream-encryption","title":"FPGA bitstream encryption","text":"<p>This design does not use Altera\u00ae\u2019s FPGA bitstream encryption technology. You may use this feature to further protect the FPGA design content of your products. Refer to Using the Design Security Features in Altera\u00ae FPGAs for information on FPGA bitstream encryption technology.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#secure-booting-and-os-restrictions","title":"Secure booting and OS restrictions","text":"<p>This design does not employ a secure booting scheme, which should be considered in production-grade designs. The microSD card is not encrypted and therefore can be mounted on another device and accessed freely. Furthermore, the embedded OS does not include predefined user accounts and access policies, instead, a root account with no password carries out all operations. In a final product you should restrict access according to the intended use cases.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#safe-booting-and-remote-updates","title":"Safe booting and remote updates","text":"<p>Adding remote update capability to a design is important for a final product, which is not part of this system example design. It enables patching vulnerabilities and making improvements on the product in the field, especially when it is not feasible to gain physical access to the product. Various stages of the bootloader, embedded Linux, drivers, application software, HPS configurations and FPGA bitstream files may be updated remotely with appropriate recovery mechanisms in place. You may also consider adding remote reset and power cycling features depending on the application.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#secure-network-connection","title":"Secure network connection","text":"<p>In this design the web server of the application uses unencrypted HTTP protocol. In a final product it is necessary to consider the safety implications and use encryption on all types of network connections. It is also imperative to have a firewall suitable for the end user product with proper restrictions and other security considerations in place. In extreme cases you may disable network connectivity at OS kernel level when network connectivity is not desired. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/design-security-considerations/#related-information","title":"Related Information","text":"<ul> <li>AN 556: Using the Design Security Features in Intel FPGAs</li> </ul> <p>Back</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/download-prebuilt-binaries/","title":"Download prebuilt binaries","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/download-prebuilt-binaries/#download-the-pre-built-binaries","title":"Download the pre-built Binaries","text":"<ul> <li>Download the Agilex\u2122 5 Modular Development board binaries:</li> </ul> <p> <p>Binaries</p> Source Link Description QSPI [top.core.jic] Allows the development board to be booted from the microSD card microSD Card Image [hps-first-vvp-isp-demo-image-agilex5_mk_a5e065bb32aes1.wic.gz] The complete Camera Solution System Example Design <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/features/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - Features","text":"<ul> <li>Inputs:<ul> <li>Two MIPI D-PHY interfaces connected to two Framos FSM:GO IMX678 color camera modules with Sony Starvis2 8MP IMX678 sensor and Framos PixelMate MIPI CSI-2 interface.</li> <li>Internal frontend Test Pattern Generator (TPG) supporting SMPTE color bars and solid colors.</li> </ul> </li> </ul> <ul> <li>Input selection switch</li> </ul> <ul> <li>Frontend video pipeline (CFA image):<ul> <li>Clipper IP.</li> <li>ISP IP: Black Level Statistics (BLS), Defective Pixel Correction (DPC), Adaptive Noise Reduction (ANR), Black Level Correction (BLC), Vignette Correction (VC), White Balance Statistics (WBS), White Balance Correction (WBC), and Demosaic (DMS).</li> </ul> </li> </ul> <ul> <li>Backend video pipeline (RGB image):<ul> <li>Histogram Statistics (HS) IP.</li> <li>HDR Processing Pipeline:<ul> <li>1D LUT IP - for operations such as Linear -&gt; sRGB.</li> <li>3D LUT IP \u2013 for operations such as sRGB -&gt; HLG.</li> <li>Second 3D LUT IP \u2013 for operations such as HLG -&gt; BT709.</li> </ul> </li> <li>Tone Mapping Operator (TMO) IP.</li> <li>Un-Sharp Mask (USM) IP.</li> <li>Warp IP.</li> <li>Mixer IP:<ul> <li>TPG Black Output (also supports SMPTE color bars).</li> <li>ISP Output overlay.</li> <li>Logo overlay.</li> </ul> </li> <li>1D LUT IP \u2013 for OETF operations such as Gamma, HLG, and PQ.</li> </ul> </li> </ul> <ul> <li>Up to 4Kp60 10-bit DisplayPort output:<ul> <li>Selects best resolution and color depth supported by the connected Monitor. Supported modes:<ul> <li>720p60, 1080p60, 4Kp30, 8-bit and 10-bit color depth.</li> <li>4Kp60 8-bit color depth.</li> </ul> </li> </ul> </li> </ul> <ul> <li>Video frame capture (3 color plane 16-bit color depth, 48-bit lossless TIFF image):<ul> <li>Sensor Raw Output (Grayscale RGB).</li> <li>ISP Output (RGB).</li> </ul> </li> </ul> <p>Grayscale RGB</p> <p>The single color plane of the sensor CFA image is copied into all 3 color planes on a per-pixel basis to produce an RGB image.</p> <ul> <li>Software stack running on HPS (quad-core ARM Cortex CPU):<ul> <li>Based on Poky Linux with additional Yocto layers supporting Altera\u00ae FPGAs.</li> <li>Uses the Yocto build system.</li> </ul> </li> </ul> <p></p> <p> Back </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - SOF Modular Design Toolkit (MDT) Flow","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#pre-requisites","title":"Pre-requisites","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#software-requirements-to-build","title":"Software Requirements to build","text":"<ul> <li>Linux OS installed.</li> <li>72 GB free storage (~2GB for Quartus\u00ae Build and ~70GB for YOCTO/KAS build).</li> <li>Python/PIP/KAS for Yocto Build (or a suitable container) see KAS.</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition version 25.1 Linux.<ul> <li>Altera\u00ae Quartus\u00ae Agilex\u2122 5 Support.</li> </ul> </li> <li>FPGA NiosV Open-Source Tools 25.1 (installed with Quartus\u00ae Prime).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#license-requirements-to-build","title":"License Requirements to build","text":"<ul> <li>OpenCore Plus (OCP) IP evaluation license.</li> <li>Free licenses (must be downloaded and installed):<ul> <li>Nios\u00ae V Processor.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</li> </ul> <p> <p>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit </p> <ul> <li>1 or 2 Framos FSM:GO IMX678C Camera Modules, with:<ul> <li>Wide 110deg HFOV Lens, or</li> <li>Medium 100deg HFOV Lens, or</li> <li>Narrow 54deg HFOV Lens.</li> </ul> </li> <li>Mount/Tripod<ul> <li>Framos Tripod Mount Adapter.</li> <li>Tripod.</li> </ul> </li> <li>A Framos cable for PixelMate MIPI-CSI-2 for each Camera Module:<ul> <li>150mm flex-cable, or</li> <li>300mm micro-coax cable.</li> </ul> </li> <li>Minimum 8GB U3 microSD Card.</li> <li>DP Cable or HDMI Cable (with 4Kp60 Converter Dongle).</li> <li>USB Micro B JTAG Cable (for JTAG programming).</li> <li>USB Micro B Serial Cable (for HPS terminal connection).</li> <li>RJ45 Ethernet Cable (HPS network connection).</li> <li>Monitor/TV (recommend 4Kp60 capable).</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#software-requirements-to-run","title":"Software Requirements to run","text":"<ul> <li>Host PC with:<ul> <li>8 GB of RAM (less if not rebuilding binaries).</li> <li>Linux/Windows OS installed.</li> <li>Serial terminal (such as GtkTerm or Minicom on Linux, and TeraTerm or   PuTTY on Windows).<ul> <li>FTDI FT232R USB UART drivers (for a Windows host).</li> </ul> </li> <li>Tool to write images for removable USB drives or microSD cards such as Win32DiskImager on Windows or \"dd\" command on Linux.</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition version 25.1 Programmer and Tools.</li> <li>Ethernet connection (either direct from Host PC to development board, or   via a switch or router).<ul> <li>Note, you may need to disconnected/disabled VPN if it is installed on the   Host PC.</li> </ul> </li> <li>Web browser.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#getting-started-build-and-run-sof-and-microsd-card-image","title":"Getting Started - build and run SOF, and microSD Card Image","text":"<p>Follow the instructions provided in this section to build the 4K Multi-Sensor HDR Camera Solution System Example Design on the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit. You will build a <code>SOF</code> file using the Modular Development Toolkit, and a microSD Card image using KAS and Yocto (suitable for use with the OpenCore License).</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#reference-pre-built-binaries","title":"Reference pre-built Binaries","text":"<p>You can use the pre-built binaries for reference:</p> <p> Boot Source Link Pre-built microSD Card Image for SOF MDT Flow fpga-first-vvp-isp-demo-image-agilex5_mk_a5e065bb32aes1.wic.gz Pre-built FPGA First <code>.sof</code> file fsbl_agilex5_modkit_vvpisp_time_limited.sof <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#hw-compilation","title":"HW Compilation","text":"<p>Use the SOF Modular Design Toolkit (MDT) Flow to create and build the FPGA Design.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#sw-compilation","title":"SW Compilation","text":"<p>Use the Create microSD card image (.wic.gz) using YOCTO/KAS flow to create the microSD card image.</p> <p>Note</p> <p>use KAS_MACHINE=agilex5_mk_a5e065bb32aes1 and kas/agilex_camera_ff.yml configuration</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#programming","title":"Programming","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#setting-up-your-modular-development-board","title":"Setting Up your Modular Development Board","text":"<p>Warning</p> <p>Handle ESD-sensitive equipment (boards, microSD Cards, Camera sensors, etc.) only when properly grounded and at an ESD-safe workstation</p> <ul> <li>Configure the board switches as shown:</li> </ul> <p></p> <p> <p>Modular Development Board - Default Switch Positions </p> <p>Main switch configurations used by the Camera Solution System Example Design</p> <p>JTAG Mode:         SOM S4=OFF:OFF, or ASx4 (QSPI) Mode:  SOM S4=ON:ON</p> <p></p> <ul> <li>Connect micro USB cable between the carrier board (<code>J35</code>) and the Host PC.   This will be used for JTAG communication. Look at what ports are enumerated   on your Host computer. There should be a series of four.</li> <li>Connect micro USB cable between the SOM board (<code>J2</code>, HSP_UART) and the Host   PC. This will be used for HPS UART communication. Look at what ports are   enumerated on your Host computer. There should be a series of four. Use the   3rd one in the list as the HPS serial port.</li> <li>Connect an RJ45 cable between the ethernet port on the SOM board (<code>J6</code>, ETH   1G HPS) and make sure it is on the same network as your Host PC. You can   check the <code>eth0</code> IP address after boot using the Linux <code>ip a</code> command.</li> </ul> <p></p> <p> <p>Board Connections </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#burn-the-microsd-card-image","title":"Burn the microSD Card Image","text":"<ul> <li>Either use your own or download the pre-built <code>&lt;name&gt;.wic.gz</code> image.</li> <li> <p>Extract <code>&lt;name&gt;.wic</code> image from the zip file</p> <ul> <li>On Linux, use the <code>dd</code> utility:</li> </ul> <pre><code>tar -xzf `&lt;name&gt;.wic.gz`\n</code></pre> <ul> <li>On Windows, use the 7-Zip program (or similar):<ul> <li>Right click <code>&lt;name&gt;.wic.gz</code> file, and select \"Extract All...\"</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p>Write the <code>&lt;name&gt;.wic</code> image to the microSD card using a USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility:</li> </ul> <pre><code># Determine the device associated with the SD card on the host computer.\ncat /proc/partitions\n# This will return for example /dev/sd&lt;x&gt;\n# Use dd to write the image in the corresponding device\nsudo dd if=&lt;name&gt;.wic of=/dev/sd&lt;x&gt; bs=1M\n# Flush the changes to the microSD card\nsync\n</code></pre> <ul> <li> <p>On Windows, use the Win32DiskImager program (or similar):</p> <ul> <li>Click browse icon and select \"*.*\" filter:</li> </ul> <p> <p>Navigate to your download and select <code>&lt;name&gt;.wic</code> in the \"Disk Imager\" tool </p> <ul> <li>Write the image (note your Device may be different to that shown):</li> </ul> <p> <p>Write the microSD Card using the \"Disk Imager\" tool </p> <ul> <li>Turn off the board and insert the microSD card in the microSD card slot   located on the SOM board.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#running","title":"Running","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#board-and-host-pc-setup","title":"Board and Host PC Setup","text":"<p>Warning</p> <p>Handle ESD-sensitive equipment (boards, microSD Cards, Camera sensors, etc.) only when properly grounded and at an ESD-safe workstation</p> <p>Make the required connections between the Host PC and the Modular Development board as shown in the following diagram:</p> <p></p> <p> <p>Development Kit and Host PC Connection diagram </p> <ul> <li>Connect the Framos cable(s) between the Framos Camera Module(s) and the Modular   Development board taking care to align the cable(s) correctly with the   connectors (pin 1 to pin 1). For a single camera module, either MIPI connector can be used.</li> </ul> <p> <p>Board MIPI connections </p> <p> <p>Board MIPI and Ribbon Cable </p> <p> <p>Camera and Ribbon Cable </p> <p> <p>Board with Connections </p> <ul> <li>Connect the Modular Development carrier board DisplayPort Tx connector to the   Monitor using a suitable cable (and dongle if you are using HDMI).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#program-the-fpga-sof","title":"Program the FPGA SOF","text":"<ul> <li> <p>To program the FPGA using SOF with first stage bootloader (fsbl):</p> <ul> <li>Power down the board. Set MSEL=JTAG by setting the S4 dip switch   on the SOM to OFF-OFF.<ul> <li>This prevents the starting of any bootloader and FPGA configuration after   power up and until the SOF is programmed over JTAG.</li> </ul> </li> </ul> <ul> <li>Power up the board.</li> </ul> <ul> <li> <p>Either use your own or download the pre-built fsbl <code>SOF</code> image, and program   the FPGA with either the command:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"p;fsbl_agilex5_modkit_vvpisp_time_limited.sof\"\n</code></pre> </li> </ul> <ul> <li> <p>or, optionally use the Quartus\u00ae Programmer GUI:</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\"   settings as follows:</li> </ul> </li> </ul> </li> </ul> <p></p> <p> <p>Programmer GUI Hardware Settings </p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code> and press   \"Change File..\" </li> </ul> <p> <p>Programmer after \"Auto Detect\" </p> <p>Select your <code>fsbl_agilex5_modkit_vvpisp_time_limited.sof</code> file. Check the \"Program/Configure\" box and press the \"Start\" button (see below). Wait until the programming has been completed.</p> <p></p> <p> <p>Programming the FPGA with SOF file </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow2-sof-mdt/#connect-browser-to-ui","title":"Connect Browser to UI","text":"<ul> <li>Power up the board (if not already powered) and set up the serial terminal emulator (minicom,   teraterm, putty, etc.):<ul> <li>Select the correct <code>COMx</code> port. (The Modular Development board presents 4   serial COM ports over a single connection and the Linux system uses the 3rd   port in order). Set the port configuration as follows:<ul> <li>115200 baud rate, 8 Data bits, 1 Stop bit, CRC and Hardware flow control   disabled.</li> </ul> </li> </ul> </li> <li>The Linux OS will boot and the 4K Multi-Sensor HDR Camera Solution System   Example Design Application should run automatically.</li> <li>A few seconds after Linux boots, the application will detect the attached   Monitor and the ISP processed output will be displayed using the best   supported format.</li> <li> <p>Take note of the board's IP address.</p> <ul> <li> <p>The board's IP address can also be found using the terminal by logging in   as <code>root</code> (no password required) and querying the Ethernet controller:</p> <pre><code>root\nifconfig\n</code></pre> </li> </ul> <ul> <li><code>eth0</code> provides the IPv4 or IPv6 address to connect to. </li> </ul> </li> </ul> <p> <p>Example ifconfig output for if network provides DHCP </p> <p></p> <p></p> <p> <p>Example ifconfig output for if no DHCP support, or direct connection </p> <p></p> <ul> <li>Connect your web browser to the boards IP address so you can interact with   the 4K Multi-Sensor HDR Camera Solution System Example Design using the GUI.<ul> <li>To connect using IPv6 for the examples above you would use   <code>http://[fe80::a8bb:ccff:fe55:6688]</code> (note the square brackets)</li> <li>To connect using IPv4 for the DHCP example above you would use   <code>http://192.168.0.1</code></li> </ul> </li> </ul> <p></p> <p> <p>Example web browser URL for IPv6 address </p> <p></p> <p> <p>Example web browser URL for IPv4 address </p> <p></p> <ul> <li>During connection, you will see the Altera\u00ae splash screen, after which you   will be presented with the    Web GUI:</li> </ul> <p></p> <p> <p>Example Camera Solution GUI </p> <p></p> <p> Back </p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - RBF Modular Design Toolkit (MDT) Flow","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#pre-requisites","title":"Pre-requisites","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#software-requirements-to-build","title":"Software Requirements to build","text":"<ul> <li>Linux OS installed.</li> <li>72 GB free storage (~2GB for Quartus\u00ae Build and ~70GB for YOCTO/KAS build).</li> <li>Python/PIP/KAS for Yocto Build (or a suitable container) see KAS.</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition version 25.1 Linux.<ul> <li>Altera\u00ae Quartus\u00ae Agilex\u2122 5 Support.</li> </ul> </li> <li>FPGA NiosV Open-Source Tools 25.1 (installed with Quartus\u00ae Prime).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#license-requirements-to-build","title":"License Requirements to build","text":"<ul> <li>Full licenses:<ul> <li>VVP IP Suite, VVP Tone Mapping Operator (TMO) IP, VVP Warp IP, and 3D LUT IP.</li> </ul> </li> <li>Free licenses (must be downloaded and installed):<ul> <li>MIPI DPHY IP and MIPI CSI-2 IP.</li> <li>Nios\u00ae V Processor.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</li> </ul> <p> <p>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit </p> <ul> <li>1 or 2 Framos FSM:GO IMX678C Camera Modules, with:<ul> <li>Wide 110deg HFOV Lens, or</li> <li>Medium 100deg HFOV Lens, or</li> <li>Narrow 54deg HFOV Lens.</li> </ul> </li> <li>Mount/Tripod<ul> <li>Framos Tripod Mount Adapter.</li> <li>Tripod.</li> </ul> </li> <li>A Framos cable for PixelMate MIPI-CSI-2 for each Camera Module:<ul> <li>150mm flex-cable, or</li> <li>300mm micro-coax cable.</li> </ul> </li> <li>Minimum 8GB U3 microSD Card.</li> <li>DP Cable or HDMI Cable (with 4Kp60 Converter Dongle).</li> <li>USB Micro B JTAG Cable (for JTAG programming).</li> <li>USB Micro B Serial Cable (for HPS terminal connection).</li> <li>RJ45 Ethernet Cable (HPS network connection).</li> <li>Monitor/TV (recommend 4Kp60 capable).</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#software-requirements-to-run","title":"Software Requirements to run","text":"<ul> <li>Host PC with:<ul> <li>8 GB of RAM (less if not rebuilding binaries).</li> <li>Linux/Windows OS installed.</li> <li>Serial terminal (such as GtkTerm or Minicom on Linux, and TeraTerm or   PuTTY on Windows).<ul> <li>FTDI FT232R USB UART drivers (for a Windows host).</li> </ul> </li> <li>Tool to write images for removable USB drives or microSD cards such as Win32DiskImager on Windows or \"dd\" command on Linux.</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition version 25.1 Programmer and Tools.</li> <li>Ethernet connection (either direct from Host PC to development board, or   via a switch or router).<ul> <li>Note, you may need to disconnected/disabled VPN if it is installed on the   Host PC.</li> </ul> </li> <li>Web browser.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#getting-started-build-and-run-rbf-jic-and-microsd-card-image","title":"Getting Started - build and run RBF, JIC, and microSD Card Image","text":"<p>Follow the instructions provided in this section to build the 4K Multi-Sensor HDR Camera Solution System Example Design on the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit. You will build <code>RBF</code> and <code>JIC</code> files using the Modular Development Toolkit, and a microSD Card image using KAS and Yocto (suitable for use with fully licensed IP cores).</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#reference-pre-built-binaries","title":"Reference pre-built Binaries","text":"<p>You can use the pre-built binaries for reference:</p> <p> Boot Source Link Pre-built microSD Card Image for RBF MDT Flow hps-first-vvp-isp-demo-image-agilex5_mk_a5e065bb32aes1.wic.gz Pre-built HPS First <code>.rbf</code> file top.core.rbf Pre-built <code>.jic</code> file top.core.jic <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#hw-compilation","title":"HW Compilation","text":"<p>Use the RBF Modular Design Toolkit (MDT) Flow to create and build the FPGA Design.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#sw-compilation","title":"SW Compilation","text":"<p>Use the Create microSD card image (.wic.gz) using YOCTO/KAS flow to create the microSD card image.</p> <p>Note</p> <p>use KAS_MACHINE=agilex5_mk_a5e065bb32aes1 and kas/agilex_camera.yml configuration   You can copy and rename your generated <code>.rbf</code> to  sw/meta-vvp-isp-demo/recipes-bsp/u-boot/files/top.core.rbf to build it into the microSD Card image during the YOCTO flow.  There are alternative methods to get your <code>.rbf</code> onto the microSD Card.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#programming","title":"Programming","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#setting-up-your-modular-development-board","title":"Setting Up your Modular Development Board","text":"<p>Warning</p> <p>Handle ESD-sensitive equipment (boards, microSD Cards, Camera sensors, etc.) only when properly grounded and at an ESD-safe workstation</p> <ul> <li>Configure the board switches as shown:</li> </ul> <p></p> <p> <p>Modular Development Board - Default Switch Positions </p> <p>Main switch configurations used by the Camera Solution System Example Design</p> <p>JTAG Mode:         SOM S4=OFF:OFF, or ASx4 (QSPI) Mode:  SOM S4=ON:ON</p> <p></p> <ul> <li>Connect micro USB cable between the carrier board (<code>J35</code>) and the Host PC.   This will be used for JTAG communication. Look at what ports are enumerated   on your Host computer. There should be a series of four.</li> <li>Connect micro USB cable between the SOM board (<code>J2</code>, HSP_UART) and the Host   PC. This will be used for HPS UART communication. Look at what ports are   enumerated on your Host computer. There should be a series of four. Use the   3rd one in the list as the HPS serial port.</li> <li>Connect an RJ45 cable between the ethernet port on the SOM board (<code>J6</code>, ETH   1G HPS) and make sure it is on the same network as your Host PC. You can   check the <code>eth0</code> IP address after boot using the Linux <code>ip a</code> command.</li> </ul> <p></p> <p> <p>Board Connections </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#burn-the-microsd-card-image","title":"Burn the microSD Card Image","text":"<ul> <li>Either use your own or download the pre-built <code>&lt;name&gt;.wic.gz</code> image.</li> <li> <p>Extract <code>&lt;name&gt;.wic</code> image from the zip file</p> <ul> <li>On Linux, use the <code>dd</code> utility:</li> </ul> <pre><code>tar -xzf `&lt;name&gt;.wic.gz`\n</code></pre> <ul> <li>On Windows, use the 7-Zip program (or similar):<ul> <li>Right click <code>&lt;name&gt;.wic.gz</code> file, and select \"Extract All...\"</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p>Write the <code>&lt;name&gt;.wic</code> image to the microSD card using a USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility:</li> </ul> <pre><code># Determine the device associated with the SD card on the host computer.\ncat /proc/partitions\n# This will return for example /dev/sd&lt;x&gt;\n# Use dd to write the image in the corresponding device\nsudo dd if=&lt;name&gt;.wic of=/dev/sd&lt;x&gt; bs=1M\n# Flush the changes to the microSD card\nsync\n</code></pre> <ul> <li> <p>On Windows, use the Win32DiskImager program (or similar):</p> <ul> <li>Click browse icon and select \"*.*\" filter:</li> </ul> <p> <p>Navigate to your download and select <code>&lt;name&gt;.wic</code> in the \"Disk Imager\" tool </p> <ul> <li>Write the image (note your Device may be different to that shown):</li> </ul> <p> <p>Write the microSD Card using the \"Disk Imager\" tool </p> <ul> <li>Turn off the board and insert the microSD card in the microSD card slot   located on the SOM board.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#program-the-qspi-flash-memory","title":"Program the QSPI Flash Memory","text":"<p>This should only need to be done once. To program the QSPI flash memory:</p> <ul> <li>Power down the board. Set MSEL=JTAG by setting the S4 dip switch   on the SOM to OFF-OFF.<ul> <li>This prevents any bootloader from starting and leaves the JTAG chain in a   default state.</li> </ul> </li> </ul> <ul> <li>Power up the board.</li> </ul> <ul> <li>Either use your own or download the pre-built <code>JIC</code> image, and write it to   the QSPI Flash memory using either the command:<pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.core.jic\" </code></pre> </li> </ul> <ul> <li> <p>or, optionally using the Quartus\u00ae Programmer GUI:</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\" settings as following: </li> </ul> </li> </ul> <p> <p>Programmer - GUI Hardware Settings </p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code>, and press \"Change File..\" </li> </ul> <p> <p>Programmer - After \"Auto Detect\" </p> <p>Select your <code>top.core.jic</code> file. The <code>MT25QU02G</code> device should be shown (see below). Check the \"Program/Configure\" box and press the \"Start\" button. Wait until the programming has been completed (which can take several minutes). </p> <p> <p>Programming the QSPI Flash with the JIC file </p> <ul> <li>Power down the board. Set MSEL=ASX4 (QSPI) by setting the S4 dip switch   on the SOM to ON-ON.<ul> <li>This starts the HPS bootloader and FPGA configuration from the microSD Card   after power up. </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#running","title":"Running","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#board-and-host-pc-setup","title":"Board and Host PC Setup","text":"<p>Warning</p> <p>Handle ESD-sensitive equipment (boards, microSD Cards, Camera sensors, etc.) only when properly grounded and at an ESD-safe workstation</p> <p>Make the required connections between the Host PC and the Modular Development board as shown in the following diagram:</p> <p></p> <p> <p>Development Kit and Host PC Connection diagram </p> <ul> <li>Connect the Framos cable(s) between the Framos Camera Module(s) and the Modular   Development board taking care to align the cable(s) correctly with the   connectors (pin 1 to pin 1). For a single camera module, either MIPI connector can be used.</li> </ul> <p> <p>Board MIPI connections </p> <p> <p>Board MIPI and Ribbon Cable </p> <p> <p>Camera and Ribbon Cable </p> <p> <p>Board with Connections </p> <ul> <li>Connect the Modular Development carrier board DisplayPort Tx connector to the   Monitor using a suitable cable (and dongle if you are using HDMI).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#connect-browser-to-ui","title":"Connect Browser to UI","text":"<ul> <li>Power up the board (if not already powered) and set up the serial terminal emulator (minicom,   teraterm, putty, etc.):<ul> <li>Select the correct <code>COMx</code> port. (The Modular Development board presents 4   serial COM ports over a single connection and the Linux system uses the 3rd   port in order). Set the port configuration as follows:<ul> <li>115200 baud rate, 8 Data bits, 1 Stop bit, CRC and Hardware flow control   disabled.</li> </ul> </li> </ul> </li> <li>The Linux OS will boot and the 4K Multi-Sensor HDR Camera Solution System   Example Design Application should run automatically.</li> <li>A few seconds after Linux boots, the application will detect the attached   Monitor and the ISP processed output will be displayed using the best   supported format.</li> <li> <p>Take note of the board's IP address.</p> <ul> <li> <p>The board's IP address can also be found using the terminal by logging in   as <code>root</code> (no password required) and querying the Ethernet controller:</p> <pre><code>root\nifconfig\n</code></pre> </li> </ul> <ul> <li><code>eth0</code> provides the IPv4 or IPv6 address to connect to. </li> </ul> </li> </ul> <p> <p>Example ifconfig output for if network provides DHCP </p> <p></p> <p></p> <p> <p>Example ifconfig output for if no DHCP support, or direct connection </p> <p></p> <ul> <li>Connect your web browser to the boards IP address so you can interact with   the 4K Multi-Sensor HDR Camera Solution System Example Design using the GUI.<ul> <li>To connect using IPv6 for the examples above you would use   <code>http://[fe80::a8bb:ccff:fe55:6688]</code> (note the square brackets)</li> <li>To connect using IPv4 for the DHCP example above you would use   <code>http://192.168.0.1</code></li> </ul> </li> </ul> <p></p> <p> <p>Example web browser URL for IPv6 address </p> <p></p> <p> <p>Example web browser URL for IPv4 address </p> <p></p> <ul> <li>During connection, you will see the Altera\u00ae splash screen, after which you   will be presented with the    Web GUI:</li> </ul> <p></p> <p> <p>Example Camera Solution GUI </p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/flow3-rbf-mdt/#alternate-rbf-download","title":"Alternate RBF Download","text":"<p>There are several methods to get your <code>.rbf</code> onto the target board. You may want to use this method when developing your own design but do not require the microSD Card to be rebuilt:</p> <ul> <li>Copy your <code>.rbf</code> into the boot partition of the microSD Card:<ul> <li>Power down the board and remove the microSD Card.</li> <li>Rename your <code>agilex5_modkit_vvpisp.hps_first.core.rbf</code> to <code>top.core.rbf</code>.</li> <li>Connect the microSD Card to your Host and copy your <code>top.core.rbf</code> into the   boot partition of the microSD Card.</li> <li>Safely disconnect the microSD Card from your Host.</li> <li>Insert the microSD Card back into the SOM on the board and Power the board   up. Your new <code>.rbf</code> will get loaded by the bootloader.</li> </ul> </li> <li> <p><code>ssh</code> or <code>scp</code> your <code>.rbf</code> to the board:</p> <ul> <li>Power up the board and wait until it fully boots.</li> <li> <p>Using a Linux terminal (or Windows equivalent like PowerShell) on your Host   (and using a board IP address of <code>192.168.0.1</code> as an example):</p> <pre><code>scp agilex5_modkit_vvpisp.hps_first.core.rbf root@192.168.0.1:/mnt/boot/top.core.rbf\n</code></pre> </li> </ul> <ul> <li> <p>Using the board serial terminal connection, login to the board and sync any   pending file writes:</p> <pre><code>root\nsync\n</code></pre> </li> </ul> <ul> <li>Power cycle the board. Your new <code>.rbf</code> will get loaded by the bootloader.</li> </ul> </li> </ul> <p> Back </p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/full_license-requirements-to-build/","title":"Full license requirements to build","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/full_license-requirements-to-build/#license-requirements-to-build","title":"License Requirements to build","text":"<ul> <li>Full licenses:<ul> <li>[VVP IP Suite, VVP Tone Mapping Operator (TMO) IP, VVP Warp IP, and 3D LUT IP].</li> </ul> </li> <li>Free licenses (must be downloaded and installed):<ul> <li>[MIPI DPHY IP and MIPI CSI-2 IP].</li> <li>[Nios\u00ae V Processor].</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/glossary/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - Acronyms and Terminology","text":"<p> Term Description AE Auto Exposure ANR Adaptive Noise Reduction API Application Programming Interface AWB Auto White Balance AXI Advance eXtensible Interface bus protocol BLC Black Level Correction BLS Black Level Statistics BPS Bits Per-Symbol BSP Board Support Package CCM Color Correction Matrix CFA Color Filter Array CPU Central processing unit CSC Color Space Converter CSR Control/Status Registers CDC Cross Clock Domain DDR Double Data-Rate DHCP Dynamic Host Configuration Protocol DMA Direct Memory Access DMS Demosaic DP DisplayPort DPC Defective Pixel Correction DRAM Dynamic RAM DSP Digital Signal Processing DTB Device Tree Blob DTS Device Tree Source EDID Extended Display Identification Data EMIF External Memory Interface EOTF Electrical-Optical Transfer Function FBD Function Block Diagram FMC FPGA Mezzanine Card FPGA Field Programmable Gate Array FPS Frames Per Second FW Firmware GMSL Gigabit Multimedia Serial Link GPIO General Purpose Input-Output GUI Graphical User Interface HDR High-Dynamic Range HDR HLG HDR Hybrid Log Gamma HDR PQ HDR Perceptual Quantization HPS Hard Processor System HPS2FPGA Hard Processor System to FPGA, usually referring to a hardened memory-mapped bridge HS Histogram Statistics HW Hardware IP Intellectual Property (Hardware) IO, I/O Input/Output IRQ Interrupt Request ISP Image Signal Processing ISR Interrupt Service Routine JTAG Joint Test Action Group (industry standard for testing) KAS Setup tool for Yocto projects LAN Local Area Network LED Light Emitting Diode LSB Least Significant Bit LUMA Luminance LUT Look Up Table MDT Modular Development Toolkit MIPI Mobile Industry Processor Interface MP Mega Pixel MSB Most Significant Bit NGPD Next Generation Platform Designer OBR Optical Black Region OETF Opto-Electrical Transfer Function OOTF Opto-Optical Transfer Function PD Usually used to refer to \"Platform Designer\" PIP Pixels In Parallel PLL Phase Locked Loop PPI PHY Protocol Interface QPDS Quartus\u00ae Prime Design Software RAM Random Access Memory RGB Red, Green, and Blue RMS Remosaic ROI Region Of Interest ROM Read Only Memory RTL Register Transfer Level RX Receive SD Secure Digital SDRAM Synchronous DRAM SFC Sequential Function Charts SoC System-on-Chip SSH Secure Shell SW, S/W Software SW1, SW2, ... Switch 1, Switch 2, \u2026 TMO Tone Mapping Operator TPG Test Pattern Generator TX Transmit UART Universal Asynchronous Receiver-Transmitter UHD Ultra-high definition UI User Interface UIO User Space I/O System USM Unsharp Mask VC Vignette Correction VVP Video and Vision Processing <p>Acronyms and Terminology</p> <p></p> <p></p> <p> Back </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - Hardware Functional Description","text":"<p>The hardware design for the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design uses the Modular Design Toolkit (MDT). The MDT is a method of creating and building Platform Designer (PD) based Quartus\u00ae projects from a single <code>.xml</code> file.</p> <p>The main advantages of using MDT are:</p> <ul> <li>Enforces a hierarchical design approach (single level deep).</li> <li>Encourages design reuse through a library of off-the-shelf subsystems.</li> <li>Enables simple porting of designs to different development boards and FPGA   devices.</li> <li>Provides consistent folder structure and helper scripts.</li> <li>Uses TCL scripting for the PD Quartus\u00ae project.  </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#mdt-overview","title":"MDT Overview","text":"<p>The MDT flow consists of 2 separate main steps; a create step and a build step.</p> <p>The create step:</p> <ul> <li>Parses the design <code>.xml</code> file.</li> <li>Creates a Quartus\u00ae project.</li> <li>Creates a PD system for the project.</li> <li>Copies all the project files and adds all the MDT generated files to the Quartus\u00ae project.  </li> </ul> <p>The build step:</p> <ul> <li>Generates the Offset Capability Structure (OCS) ROM (detailed later).</li> <li>Compiles all the Nios\u00ae V Software into <code>.hex</code> files.</li> <li>Runs the Quartus\u00ae compilation flow.</li> <li>Post processes <code>.sof</code> files.  </li> </ul> <p>The following top level block diagram shows the main components and subsystems for the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design hardware.  </p> <p> <p>Top Level Hardware Block Diagram </p> <ul> <li>The Board and Clock Subsystems contain blocks related to the development   board resources, such as buttons, switches, LEDs, reference clocks, and   resets. They also forward the resources to the other subsystems.</li> <li>The HPS Subsystem is an instance of the Agilex\u2122 5 HPS (Hard Processor System)   which runs all the Linux software for the 4Kp60 Multi-Sensor HDR Camera   Solution System Example Design. The subsystem includes an EMIF (External   Memory Interface) for the HPS DDR4 SDRAM on the development board and bridges   out to the FPGA fabric for integration with other subsystems.</li> <li>The OCS Subsystem (readable by the HPS) is a ROM describing the IP (and its   capabilities) within the 4Kp60 Multi-Sensor HDR Camera Solution System   Example Design. Capabilities include the IPs address offset within the system   memory map allowing the software to auto discover the IP during boot. The   main advantage of using the OCS is that Hardware (FPGA RTL) and Software can   be co-developed in parallel without the need to continuously update the   system memory map.</li> <li>MIPI_In, ISP_In, ISP, and VID_Out Subsystems are the blocks related to camera   image ingress and Image Signal Processing (ISP). The MIPI_In Subsystem   includes the D-PHY for interfacing the Framos MIPI connectors on the   development board to the FPGA.</li> <li>The EMIF Subsystem is used for buffering image data and includes an EMIF for   the FPGA DDR4 SDRAM on the development board.</li> <li>The DP_Tx and Nios\u00ae V Subsystems are related to the Display Port (DP) output.   The Nios\u00ae V is used to control the DP IP to provide multi-rate output   support. The DP_Tx Subsystem includes the DP Tx IP.</li> <li>The top level includes the DP Tx Phy to drive the DP Tx connector on the   development board.  </li> </ul> <p>The top level hardware block diagram is color-coded to match the MDT generated PD Quartus\u00ae project from the MDT <code>.xml</code> source file (AGX_5E_Modular_Devkit_ISP_RD.xml) as shown in the following diagram:  </p> <p> <p>MDT PD Quartus\u00ae Project from the MDT <code>.xml</code> source file </p> <p>Although not shown in the above diagram, the <code>.xml</code> also defines:</p> <ul> <li>The name of the overall project.</li> <li>The target development board.</li> <li>The target FPGA device.</li> <li>The QPDS version to use.</li> <li>Global PD parameters (such as Pixels In Parallel for example).</li> <li>Non-PD subsystems (such as the top level).  </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#quartus-project","title":"Quartus\u00ae Project","text":"<p>The MDT PD Quartus\u00ae project and its subsystems (as instantiated from the <code>.xml</code> file) are described in greater detail below.  </p> <p> <p>Quartus\u00ae Project </p> <p>MDT PD subsystems:</p> <ul> <li>Board Subsystem</li> <li>Clock Subsystem</li> <li>HPS Subsystem</li> <li>OCS Subsystem</li> <li>MIPI_In Subsystem</li> <li>ISP_In Subsystem</li> <li>ISP Subsystem</li> <li>EMIF Subsystem</li> <li>VID_Out Subsystem</li> <li>Nios\u00ae V Subsystem</li> <li>DP_Tx Subsystem </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#board-subsystem","title":"Board Subsystem","text":"<p>The Board Subsystem contains blocks related to the board resources such as buttons, switches, and LEDs. The Board Subsystem is part of the MDT common subsystems and the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design does not use all the blocks.  </p> <p> <p>Board Subsystem </p> <p>The Board Subsystem also includes <code>.qsf</code> and <code>.sdc</code> files relating to the IO assignments and timing constraints, as well as non-QPDS IP such as a reset module needed for correct functionality.  </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#clock-subsystem","title":"Clock Subsystem","text":"<p>The Clock Subsystem contains blocks related to the board reference clocks and resets, reset pulse extenders, PLLs for system clock generation, and system reset synchronizers. The Clock Subsystem is part of the MDT common subsystems.  </p> <p> <p>Clock Subsystem </p> <p>The clocks and corresponding resets are distributed to the other subsystems and are detailed in the following table (note that not all clocks are used in this variant of the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design):  </p> <p> <p>Clocks and Resets</p> Clock/Reset Frequency Description Ref 100MHz Board Input Reference (and DP Nios\u00ae V CPU interface) Clock 0 297MHz Video Clock 1 148.5MHz Half-rate Video Clock 2 200MHz IP agent (HPS and TMO Nios\u00ae V CPU interface) Clock 3 74.25MHz Quarter-rate Video Clock 4 16MHz DP Management (DP CPU interface) Clock 5 50MHz EMIF Calibration Clock <p> </p> <p>The Clock Subsystem also includes non-QPDS IP, such as a reset extender, needed for correct functionality.  </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#hps-subsystem","title":"HPS Subsystem","text":"<p>The HPS Subsystem (Hard Processor System) is mainly an instance of the \u201cHard Processor System Agilex\u2122 (or other) FPGA IP\u201d and is generally configured consistently with the GSRD: Agilex\u2122 5 E-Series Modular Development Board GSRD User Guide (25.1) . However, some modifications have been made, for example to increase the number of I2C Masters. Likewise, some blocks are not required for the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design. The HPS boots a custom version of Linux based on Yocto to drive the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design.  </p> <p> <p>HPS Subsystem </p> <p> <p>HPS Subsystem Block Diagram </p> <p>Internally the HPS Subsystem is composed of the HPS, EMIF for external 8GB HPS DDR4 SDRAM (available on the development board), the full HPS to FPGA interface bridge, and an Address Span Extender which provides a movable 512MB read/write access window into one of the external 8GB FPGA DDR4 SDRAMs (also available on the development board). The HPS to FPGA bridge allows the HPS software to read and write IP registers, IP memory tables, and the external FPGA DDR4 SDRAM (via the Address Span Extender) to control the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design. The HPS Subsystem to FPGA memory map is detailed in the following table:  </p> <p> <p>HPS Subsystem to FPGA Memory Map</p> Address Start Address End Subsystem Description 0x4000_0000 0x4000_3FFF OCS Offset Capability Structure subsystem IP 0x4020_0000 0x4027_FFFF ISP ISP subsystem IP 0x4030_0000 0x4030_0FFF ISP_In ISP Input subsystem IP 0x4040_0000 0x4040_3FFF MIPI_In MIPI Input subsystem IP 0x4050_0000 0x4050_0FFF Vid_Out Video Output subsystem IP 0x4400_0000 0x4400_0007 HPS Address Span Extender - Control 0x6000_0000 0x7FFF_FFFF HPS Address Span Extender - FPGA DDR4 SDRAM 512MB Window <p> </p> <p>The HPS Subsystem includes a <code>.qsf</code> file relating to the HPS IO assignments.  </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#ocs-subsystem","title":"OCS Subsystem","text":"<p>The OCS Subsystem (Offset Capability Structure) provides a method to allow the HPS software to self-discover all the IP within the project that it can interact with.  </p> <p> <p>OCS Subsystem </p> <p>All VVP IP contain an OCS entry in the form of:</p> <ul> <li>Type - A unique identifier for the IP.</li> <li>Version - The IP version.</li> <li>ID Component - Instance number of the IP.</li> <li>Base - Base address of the IP register map.</li> <li>Size - Size of the IP Register map.  </li> </ul> <p>OCS entries are stored within the OCS IP inside a ROM. The IP itself can contain any number of ROMs which are linked together within the IP with the first ROM always being at a base address offset of 0x0. The HPS is programmed to always assume that the OCS IP is the first IP on the HPS to FPGA (hps2fpga) bridge (at a base address offset of 0x0) facilitating the auto discovery process.  </p> <p>ROMs can be automatic or manually populated. The MDT flow uses a TCL script during the build step to search for all the IP within the PD project, extracting the OCS entry information, and building the automatic ROM. Manually populated ROMs are used for IP that do not have an OCS entry. Typically, these are non-VVP IP such as the Address Span Extender for example. An OCS Modification Subsystem is used to specify the manual ROM which MDT builds during the create step. Note this does not create an additional PD subsystem as it simply modifies the OCS Subsystem. The 4Kp60 Multi-Sensor HDR Camera Solution System Example Design contains an automatic and a manual ROM. Upon boot, the HPS reads the entries from the ROMs to determine where the IP is; the driver version to load; and how it should be used (using its instance number).  </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#mipi_in-subsystem","title":"MIPI_In Subsystem","text":"<p>The MIPI_In Subsystem is used to ingress 12-bit RAW format 4Kp60 camera sensor data from 2 Framos MIPI inputs.  </p> <p> <p>MIPI_In Subsystem </p> <p> <p>MIPI_In Subsystem Block Diagram </p> <p>The MIPI_In Subsystem consists of a MIPI D-Phy IP configured to support 2 input links - one each for the 2 Framos MIPI sensor inputs. Each link is configured for x4 MIPI lanes @1768 Mbps per lane providing enough bandwidth for 4Kp60 processing with 12-bit RAW format data.  </p> <p>The sensor also supports a Clear HDR feature. In this mode, the sensor simultaneously captures two images at 25 FPS, one with a low gain level set to the bright region and the other a high gain level set to the dark region. Since the images are captured simultaneously, there are no motion chromatic aberrations or other artifacts. The sensor passes the two images interleaved on a line per basis over the same single MIPI link.  </p> <p>The MIPI D-Phy outputs data using a pair of 16-bit PHY Protocol Interfaces (PPI) - one per sensor. Each PPI connects natively to a MIPI CSI-2 IP which decodes the RAW12 format MIPI packets and outputs VVP AXI4-S format packets. Each MIPI CSI-2 IP outputs 1 primary or 2 primary and secondary (for Clear HDR mode) VVP AXI4-S Full streaming interfaces using 4 PIP (Pixels in Parallel) at 297MHz. This rate was chosen to allow for any bursty data coming from the sensor and because no real AXI4-S back pressure can be applied (the sensor cannot be stalled).  </p> <p>The primary MIPI CSI-2 output interfaces each pass through a VVP Monitor IP to determine if a sensor is on and passing the expected image data. The secondary interfaces do not require a Monitor IP. VVP Protocol Converter IPs are then used on all interfaces to change the protocol from VVP AXI4-S Full to VVP AXI4-S Lite. Each pair of MIPI CSI-2 IP output interfaces are then passed into a non-QPDS Exposure Fusion IP which is used to combine the two low and high gain images to produce a single 16-bit HDR image. If Clear HDR mode is in bypass mode, the Exposure Fusion IP simply maps the 12-bit primary interface to a 16-bit output interface (most significant 12-bits aligned with 4 least significant zero bits). Finally, a VVP PIP Converter IP hangs off the back of each Exposure Fusion IP to buffer and convert the image data from 4 PIP down to 2 PIP at 297MHz (enough bandwidth for 4Kp60 processing). The buffer in the PIP Converter means that the MIPI CSI-2 IP Rx buffer can be deliberately shallow to minimize resource usage.  </p> <p>The MIPI_In Subsystem also includes Input and Output PIO IPs which are used to provide control and status for the HPS Software. Currently, no controls are being used in the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design. The Framos MIPI connectors on the development board have additional sensor controls such as master slave sync, etc. These could be controlled by the HPS Software for instance. HPS status information includes FPGA build specific capabilities, such as frame rate, multi-sensor and HDR support, development board target, etc.; and a build timestamp.  </p> <p>The HPS Subsystem to MIPI_In Subsystem memory map is detailed in the following table:  </p> <p> <p>HPS Subsystem to MIPI_In Subsystem Memory Map</p> Address Start Address End Module Description 0x4040_0000 0x4040_0FFF MIPI DPHY IP MIPI D-Phy 0x4040_1000 0x4040_100F PIO IP Input PIO (inst 0) 0x4040_1010 0x4040_101F PIO IP Input PIO (inst 1) 0x4040_1200 0x4040_12FF Exposure Fusion IP Exposure Fusion (inst 0) 0x4040_1400 0x4040_14FF Exposure Fusion IP Exposure Fusion (inst 1) 0x4040_1600 0x4040_17FF VVP PIP Converter IP Pixels In Parallel Converter (inst 0) 0x4040_1800 0x4040_19FF VVP PIP Converter IP Pixels In Parallel Converter (inst 1) 0x4040_1A00 0x4040_1BFF VVP Monitor IP Snoop (inst 0) 0x4040_1C00 0x4040_1DFF VVP Monitor IP Snoop (inst 1) 0x4040_2000 0x4040_2FFF MIPI CSI-2 IP MIPI CSI-2 - via Clock Crossing Bridge (inst 0) 0x4040_3000 0x4040_3FFF MIPI CSI-2 IP MIPI CSI-2 - via Clock Crossing Bridge (inst 1) <p> </p> <p>The MIPI_In Subsystem includes <code>.qsf</code> and <code>.sdc</code> files relating to the IO assignments and timing constraints required for the design.  </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#isp_in-subsystem","title":"ISP_In Subsystem","text":"<p>The ISP_In Subsystem is used to provide the input into the ISP Subsystem.  </p> <p> <p>ISP_In Subsystem </p> <p> <p>ISP_In Subsystem Block Diagram </p> <p>The ISP_In Subsystem consists of a VVP Test Pattern Generator (TPG) IP, a non-QPDS Remosaic (RMS) IP, and a VVP Switch IP to switch between the 3 input sources. Switching, when activated in the HPS Software, always occurs at the end of an active video line. Therefore, software must guard against switching to sources that are not active to avoid lock-up.  </p> <p>The first input into the switch comes from the VVP TPG IP path. The TPG is configured to support color bars and solid color output patterns which can be selected by the HPS Software. However, the TPG only outputs an RGB (Red, Green, Blue) image. And since the ISP operates on a Color Filter Array (CFA) image (sometimes known as a Color Filter Mosaic or Bayer image), a conversion is required. The RMS IP performs this conversion, allowing a programmable CFA phase to be applied to the TPG RGB output image to create a CFA image. The TPG path is used for system testing with or without sensors.  </p> <p>The second and third inputs into the switch come from the 2 outputs of the MIPI_In Subsystem.  </p> <p>The HPS Subsystem to ISP_In Subsystem memory map is detailed in the following table:  </p> <p> <p>HPS Subsystem to ISP_In Subsystem Memory Map</p> Address Start Address End Module Description 0x4030_0400 0x4030_05FF VVP TPG IP RGB Test Pattern Generator 0x4030_0600 0x4030_06FF Remosaic IP Remosaic (RGB to Bayer conversion) 0x4030_0800 0x4030_09FF VVP Switch IP Bayer Switch <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#isp-subsystem","title":"ISP Subsystem","text":"<p>The ISP Subsystem is the main image processing pipeline. Reference should be made to the ISP Functional Description. when reading this section in order to understand the exact IP function.</p> <p> </p> <p> <p>ISP Subsystem </p> <p> <p>ISP Subsystem Block Diagram </p> <p>The input into the ISP is a Color Filter Array (CFA) image from the ISP_In Subsystem. For simplicity, the main block diagram doesn't show all the IP within the ISP Subsystem - just the main processing ISP.  </p> <p>The first ISP IP is the VVP Black Level Statistics (BLS) IP. This IP is used to obtain statistics relating to the Optical Black Region (OBR) of the image sensor - typically a shielded area within the sensor. The BLS is used to continually set the coefficients for the VVP Black Level Correction (BLC) IP as the black level can change, for example with temperature. However, the IMX 678 used in the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design does not allow access to the OBR and as such the BLS isn't used in normal operation. However, it is used during calibration where the sensor lens can be covered to provide a black level reading. Although not as accurate as continuous reading, it does nonetheless provide a pretty good black level reading.  </p> <p>As with all VVP ISP Statistics IP. the BLS IP passes input image data to the output untouched.  </p> <p>The output from BLS feeds into the VVP Clipper IP. The clipper is used to remove the OBR from the image. However, since the OBR is not available for the IMX 678, the input image simply passes through the clipper untouched.  </p> <p>Not shown in the main block diagram is the Raw Capture VVP Switch IP. It takes the clipper output and under HPS SW control, can direct the image data to the Capture VVP Switch IP via a VVP Color Plane Manager (CPM) IP. The CPM is used to replicate the CFA color of a given input pixel into all 3 RGB components of a given output pixel, therefore producing a monochrome RGB image from the CFA raw image. The Capture Switch, under HPS SW control, can direct either the raw image or the output image (ISP post processed output from the Gamma 1D LUT IP) to the VVP Frame Writer (VFW) IP. The Frame Writer uses a frame buffer within a 512MB area of external 8GB FPGA DDR4 SDRAM. It interfaces to an Address Span Extender which provides the 512MB window into the EMIF. The HPS can access the buffer for downloading the captured images.  </p> <p> <p>ISP Subsystem Capture Switch Configuration Block Diagram </p> <p>Switches are required due to the limited EMIF performance for the FPGA Device fitted to the development board which cannot support an uninterrupted 4Kp60 pipeline and 4K capture to a single FPGA DDR4 SDRAM. Therefore, raw capture temporarily switches off the input pipeline while output capture temporarily switches off the output pipeline. The DP output can flicker or go blank during the captures.  </p> <p>The VVP Defective Pixel Correction (DPC) IP takes the output of clipper. The function of the DPC is to effectively remove defective pixels from the sensor image. Defective pixels manifests themselves as drastically different intensity to their neighboring pixels.  </p> <p>The DPC feeds the VVP Adaptive Noise Reduction IP (ANR). ANR is an edge-preserving smoothing filter that mainly reduces the independent pixel noise of an image. It is configured with a 17x17 kernel size and was chosen to maximize functionality with a sensible resource utilization footprint.  </p> <p>VVP Black Level Correction (BLC) IP comes next in the processing pipeline. Based on the BLS results, the image black level can be compensated for by firstly subtracting a pedestal value before scaling the result back to the full dynamic range.  </p> <p>BLC feeds the VVP Vignette Correction (VC) IP. VC is used to compensate for non-uniform intensity across the image, often caused by uneven light-gathering of the sensor and optics. The compensation is achieved using a mesh of coefficient scalers for each color plane and interpolating values between them for any given pixel. The mesh coefficient generation is done using a calibration process often with a white non-reflective image from the sensor. Darker and lighter areas of the image can then be compensated for by boosting or reducing pixel color values.  </p> <p>The next stage in the processing pipeline is the White Balance correction. Both the VVP White Balance Statistics (WBS) IP and VVP White Balance Correction (WBC) IP are used to eliminate color casts which occur due to lighting conditions or difference in the light sensitivity of pixels of different color. The WBS IP collects statistics relating to the red-green and blue-green ratios within a region of interest (ROI). The HPS SW uses the WBS results to set individual color scalers within the WBC IP to alter the balance between the colors, therefore ensuring that whites really look white, and grays really look gray without unwanted color tinting. In the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design, and not shown in the main block diagram, a WBS VVP Switch IP sits in-line between the VC IP and the VVP Demosaic (DMS) IP. Both the WBS and WBC are fully connected to the WBS Switch which allows under HPS software control, WBS to come before or after WBC in the processing pipeline.  </p> <p> <p>ISP Subsystem White Balance Switch Configuration Block Diagram </p> <p>The HPS Auto-White Balance algorithm (AWB) (as used in the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design), switches continuously between the configurations during normal operation to continually adjust the white balance.  </p> <p>VVP Demosaic (DMS) IP is the final processing IP in the CFA image data domain. It is a color reconstructing IP and converts the CFA image into an RGB image. The DMS interpolates missing colors for each pixel based on its neighboring pixels.  </p> <p>The RGB image from DMS feeds into the VVP Histogram Statistics (HS) IP. This IP produces light intensity histograms for both the entire image and a ROI. The HPS Auto-Exposure algorithm (AE) uses the histograms to adjust the sensor's exposure settings such as shutter speed and analog gain.  </p> <p>The Color Correction Matrix (CCM) is primarily used to correct undesired color bleeding across color channels in the sensor, which is mainly caused by pixels being sensitive to color spectrums other than their own intended color. The functionality is provided by a VVP Color Space Converter (CSC) IP which is used to multiply the input RGB values with a 3x3 CCM to produce the corrected output RGB values. The CCM can also be used to provide many artistic effects.  </p> <p>To facilitate conversions between different color spaces and dynamic ranges, or to simply apply artistic effects, the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design provides a combination chain of a VVP 1D LUT IP followed by 2 back to back VVP 3D LUT IPs. The 1D LUT can be used to apply an input to output transfer function, for instance to convert between linear and non-linear color spaces. The IP is configured as a 12-bit LUT with a 16-bit input lookup and a 14-bit output value. The configuration was chosen to maximize functionality with a sensible resource utilization footprint. The VVP 3D LUT IPs can be used to support application specific combinations of color space conversions, such as RGB to HLG followed by HLG to BT.709 for instance. Both 3D LUT IPs are configured for 14-bit input with a LUT size of 17 cubed and 14-bit color depth. The first 3D LUT has an output of 14-bits whereas the second has an output of 12-bit to match the maximum color depth of the VVP Tone Mapping Operator IP. Unused LUTs can be placed in bypass mode when not required.  </p> <p>The VVP TMO IP implements a ROI based tone mapping algorithm to improve the visibility of latent image detail across areas of the image. The IP feeds into a VVP Pixel Adapter IP to reduce the output to 10-bits to match the maximum color depth of the VVP Unsharp Mask (USM) IP.  </p> <p>The USM applies a sharpening algorithm to the input image by implementing an unsharp mask. The input image passes through a low pass blur filter to create a blurred image which is subtracted from the original input image to create a high frequency component. This component is scaled using a positive (sharpen) or negative (soften) strength value which is then multiplied against the original input image before being output.  </p> <p>The VVP Warp IP is used to apply arbitrary transforms and can correct for lens distortions like fisheye for instance. Warp can also scale, rotate, and mirror the image. The Warp uses 512MB of the external 8GB FPGA DDR4 SDRAM. 128MB is allocated for the transform coefficients (which the HPS Software writes) while the remainder is used as frame buffers. The Warp interfaces to an Address Span Extender which provides the 512MB window into the EMIF. The Warp is effectively the last ISP processing IP.  </p> <p>The output of Warp (the ISP) feeds into the VVP Mixer IP. The mixer uses a VVP TPG IP to provide a base, solid black layer, up to 4K resolution in size, for the ISP output to be overlaid onto. This can be useful when the ISP output is of a smaller resolution than the connected monitor. The mixer allows the ISP layer to be placed anywhere over the TPG background, therefore \"framing\" the ISP output for the monitor. In addition, the TPG is also configured to support color bars, which under HPS SW control can be used with no ISP output for system testing. The mixer also has an additional layer for the Altera\u00ae logo overlay. The opacity of this layer can be controlled by the HPS SW.  </p> <p>The mixer output feeds into the Gamma LUT - a second VVP 1D LUT IP instance in the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design. The Gamma LUT is used to implement input to output transfer functions (such as Opto-Optical Transfer Function (OOTF), Opto-Electrical Transfer Function (OETF), and Electrical-Optical Transfer Function (EOTF)) for video standards and traditional gamma compression and decompression, as well as High Dynamic Range Perceptual Quantizer (HDR PQ) and Hybrid Log-Gamma (HDR HLG) correction. The 1D LUT is configured as a 9-bit LUT with a 10-bit input and 16-bit output to support the output capture functionality via the Capture Switch. (The Switch only supports a single color depth configuration and therefore is configured for 16-bit as this is the value used by the Raw Capture pipeline). A VVP Pixel Adapter IP is used to convert the output back to 10-bits for the VID_Out Subsystem input.  </p> <p>The following Color Depth Change Block Diagram summarizes the change in color depth at the different stages in the ISP pipeline.  </p> <p> <p>ISP Subsystem Color Depth Change Block Diagram </p> <p> </p> <p>The HPS Subsystem to ISP Subsystem memory map is detailed in the following table:  </p> <p> <p>HPS Subsystem to ISP Subsystem Memory Map</p> Address Start Address End Module Description 0x4020_0000 0x4020_7FFF VVP Warp IP Warp 0x4020_8200 0x4020_83FF VVP 3D-LUT IP 3D LUT for HDR processing (inst 1) 0x4020_8400 0x4020_87FF VVP Mixer IP Mixer 0x4020_8800 0x4020_89FF VVP TPG IP Test Pattern Generator 0x4020_8A00 0x4020_8BFF VVP BLC IP Black Level Correction 0x4020_8C00 0x4020_8DFF VVP DPC IP Defective Pixel Correction 0x4020_8E00 0x4020_8FFF VVP Clipper IP Clipper 0x4020_9000 0x4020_91FF VVP TMO IP Tone Mapping Operator 0x4020_9200 0x4020_93FF VVP DMS IP Demosaic 0x4020_9400 0x4020_95FF VVP WBC IP White Balance Correction 0x4020_9600 0x4020_97FF VVP BLS IP Black Level Statistics 0x4020_9800 0x4020_99FF VVP USM IP Un-Sharp Mask Filter 0x4020_9A00 0x4020_9BFF VVP 3D-LUT IP 3D LUT for HDR processing (inst 0) 0x4020_9C00 0x4020_9DFF VVP CSC IP Color Correction Matrix 0x4020_B000 0x4020_BFFF VVP HS IP Histogram Statistics 0x4020_C000 0x4020_CFFF VVP WBS IP White Balance Statistics 0x4020_D000 0x4020_D1FF VVP Switch IP White Balance Switch (inst 3) 0x4020_D200 0x4020_D3FF VVP Switch IP Raw Capture Switch (inst 4) 0x4020_D400 0x4020_D5FF VVP VFW IP Frame Writer 0x4020_D800 0x4020_D9FF VVP Switch IP Capture Switch (inst 5) 0x4020_DA00 0x4020_DBFF VVP CPM IP Color Plane Manager 0x4020_E000 0x4020_FFFF VVP 1D-LUT IP 1D LUT for Gamma correction (inst 0) 0x4021_0000 0x4021_3FFF VVP ANR IP Adaptive Noise Reduction 0x4022_0000 0x4022_FFFF VVP 1D-LUT IP 1D LUT for HDR processing (inst 1) 0x4024_0000 0x4027_FFFF VVP VC IP Vignette Correction <p> </p> <p>The ISP Subsystem also includes some additional processing scripts to allow the 3D LUTs to be preloaded with a cube file.  </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#emif-subsystem","title":"EMIF Subsystem","text":"<p>The EMIF Subsystem (External Memory Interface) provides an interface to one of the external 8GB FPGA DDR4 SDRAMs (available on the development board). The local EMIF interface is 256-bit wide running at a clock frequency of 200MHz. This provides just enough bandwidth to perform write and read of a 4K image at 60 FPS with 70% efficiency. The EMIF Subsystem is part of the MDT common subsystems.  </p> <p> <p>EMIF Subsystem </p> <p>The MDT EMIF Subsystem also includes non-QPDS IP such as an AXI shim and reset module needed for correct functionality.  </p> <p>The FPGA DDR4 SDRAM memory map is detailed in the following table:  </p> <p> <p>FPGA DDR4 SDRAM Memory Map</p> Address Start Address End Module Description 0x0_0000_0000 0x0_017F_FFFF VVP Warp IP Warp Buffers 0x0_0180_0000 0x0_01FF_FFFF VVP Warp IP Warp Coefficients 0x0_0200_0000 0x0_03FF_FFFF VVP VFW IP Capture Buffer 0x0_0400_0000 0x1_FFFF_FFFF - Unused <p> </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#vid_out-subsystem","title":"VID_Out Subsystem","text":"<p>The VID_Out Subsystem is used to interface the ISP Subsystem 2 PIP VVP AXI4-S Lite output, to the DP_Tx Subsystem 4 PIP VVP AXI4-S Full input. The VID_Out Subsystem uses both a VVP PIP Converter IP and VVP Protocol Converter IP to achieve the conversion. The VID_Out Subsystem also includes PIO IPs for the HPS software to handshake DP control and status with the DP Nios\u00ae V software.  </p> <p> <p>VID_Out Subsystem </p> <p> <p>VID_Out Subsystem Block Diagram </p> <p> </p> <p>The HPS Subsystem to VID_Out Subsystem memory map is detailed in the following table:  </p> <p> <p>HPS Subsystem to VID_Out Subsystem Memory Map</p> Address Start Address End Module Description 0x4050_0400 0x4050_35FF VVP PIP Converter IP PIP Converter 0x4050_0800 0x4050_080F PIO IP Input DP Rate Control 0x4050_0810 0x4050_081F PIO IP Input DP status 0x4050_0820 0x4050_082F PIO IP Input DP monitor supported formats 0x4050_0830 0x4050_083F PIO IP Input DP current format 0x4050_0840 0x4050_084F PIO IP Output DP new monitor format to override 0x4050_0A00 0x4050_0BFF VVP Protocol Converter IP VVP AXI4-S Lite to VVP AXI4-S Full VVP Protocol Converter <p> </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#nios-v-subsystem","title":"Nios\u00ae V Subsystem","text":"<p>The Nios\u00ae V Subsystem (Nios\u00ae V CPU subsystem) is used to control the Display Port Tx IP. In addition, it provides the EDID (Extended Display Identification Data) processing and interfaces to the HPS for DP control and status handshaking. The Nios\u00ae V Subsystem is part of the MDT common CPU subsystems.  </p> <p> <p>Nios\u00ae V Subsystem </p> <p>The Nios\u00ae V Subsystem consists of the Nios\u00ae V/m soft processor IP along with on-chip RAM, JTAG master, IRQ-management, JTAG UART, and timers. The MDT flow compiles the DP Tx software during the build step and generates the <code>.hex</code> file for the on-chip RAM such that the Nios\u00ae automatically boots and runs on power up. The UART can be used for debug purposes, but it is disabled in the DP Tx software by default for added security. The DP Tx software determines the best resolution and color depth a connected monitor/TV supports and configures the DP Tx IP accordingly. The Nios\u00ae V Subsystem memory map is detailed in the following table:  </p> <p> <p>Nios\u00ae V Subsystem to FPGA Memory Map</p> Address Start Address End Module Description 0x0000_0000 0x0003_FFFF CPU RAM 256KB On-chip RAM (for the Nios\u00ae V CPU) 0x0004_0000 0x0004_3FFF Bridge DP_Tx Subsystem Bridge 0x0040_0000 0x0040_FFFF Nios\u00ae V/m DM Agent Nios\u00ae V/m Debug Module 0x0041_0000 0x0041_003F Nios\u00ae V/m Tmer Nios\u00ae V/m Timer Module 0x0041_0040 0x0041_005F CPU Timer Interval Timer IP (for the Nios\u00ae V CPU) 0x0041_0060 0x0041_0067 JTAG UART JTAG UART IP (for the Nios\u00ae V CPU) <p> </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#dp_tx-subsystem","title":"DP_Tx Subsystem","text":"<p>The DP_Tx Subsystem (Display Port Tx) provides the DP Tx output. It consists of the DP Tx IP, I2C controllers for adjusting reference clock frequencies on the development board, and PIO (Parallel Input/Output) IPs for the DP Nios\u00ae V software to handshake DP control and status with the HPS software.  </p> <p> <p>DP_Tx Subsystem </p> <p> <p>DP_Tx Subsystem Block Diagram </p> <p>The DP_Tx Subsystem includes <code>.qsf</code> and <code>.sdc</code> files relating to the DP Tx IO assignments and timing constraints. The MDT DP_Tx creation Tcl script also includes top level Verilog code for instancing the DP GTS Tx Phy as well as CDC (Cross Clock Domain) code for the PIO handshaking, and the rate control logic for the DP multi-rate support. </p> <p>The Nios\u00ae V Subsystem to DP_Tx Subsystem memory map is detailed in the following table:  </p> <p> <p>Nios\u00ae V Subsystem to DP_Tx Subsystem Memory Map</p> Address Start Address End Module Description 0x0004_0000 0x0004_1FFF DP Tx IP DP Tx IP 0x0004_2000 0x0004_203F I2C Master IP Not Used 0x0004_2040 0x0004_207F I2C Master IP Development board DP reference clock chip reprogram 0x0004_2080 0x0004_208F PIO IP Output DP Rate Control 0x0004_2090 0x0004_209F PIO IP Output DP status 0x0004_20A0 0x0004_20AF PIO IP Output DP monitor supported formats 0x0004_20B0 0x0004_20BF PIO IP Output DP current format 0x0004_20C0 0x0004_20CF PIO IP Input DP new monitor format to override <p> </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/hw-funct-descr/#top-level","title":"Top Level","text":"<p>The Quartus\u00ae project top level Verilog file gets generated through the MDT create step, along with all supporting files such as <code>.qsf</code> and <code>.sdc</code> files. In addition, the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design contains another subsystem <code>system</code> which does not produce a PD subsystem, but instead produces further supporting files such as <code>.qsf</code>, <code>.sdc</code>, <code>dawf</code>, and <code>.stp</code> (when enabled in the <code>.xml</code> file). These are needed to ensure a successful build for the Quartus\u00ae version and IP used and to work around any errata that exist. </p> <p> Back </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - ISP Functional Description","text":"<p>The 4Kp60 Multi-Sensor HDR Camera Solution System Example Design demonstrates a practical glass-to-glass camera solution using standard Altera\u00ae Connectivity and Video and Vision Processing (VVP) Suite IP Cores available through the Quartus\u00ae Prime Design Software (QPDS).</p> <p>The design ingests the video input through industry-standard MIPI directly connected to each sensor. The selected sensor video is then processed through the Image Signal Processing (ISP) pipeline before output through DisplayPort (DP). The pipeline also utilizes additional non-ISP IP Cores from the VVP Suite, such as Test Pattern Generators (TPG) and VVP AXI4-S Switches. Furthermore, the design runs an embedded Linux Software Application (SW App) on the Hard Processor System (HPS) to provide real-time auto white balance (AWB) and auto exposure (AE) functions.</p> <p></p> <p>The following block diagram shows the main components and subsystems of the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design. Note that where an IP has been used multiple times, its instance number is shown (bottom right corner of the IP) and can be used for identification in the detail that follows.</p> <p></p> <p> <p>4Kp60 Multi-Sensor HDR Camera Solution System Example Design Top Block Diagram </p> <p>The Framos FSM:GO IMX678 optical sensor module with PixelMate MIPI-CSI-2 connection uses a 4-lane MIPI interface. The sensor is a Sony Starvis2 8MP IMX678 that outputs a Color Filter Array (CFA) image (also known as a Bayer image) and can support up to a UHD 4K resolution at 60 FPS.</p> <p>A CFA is typically a 2x2 mosaic of tiny colored filters (usually red, green, and blue) placed over a monochromatic image sensor to effectively capture single color pixels. The CFA typically contains twice the number of green filters to align with human vision which is more sensitive to light in the yellow-green part of the spectrum. The example below shows a typical RGGB (Red, Green, Green, Blue) CFA pattern which repeats over the entire image (an 8x8 image in this example). Pixels arrive left to right, top to bottom, as alternating Red and Green pixels on the first line, and then alternating Green and Blue pixels on the next line. This pattern repeats on the next pair of lines, and so on.</p> <p></p> <p> <p>8x8 RGGB Color Filter Array (Bayer) Image Example </p> <p>Using a single color pixels reduces the overall bandwidth requirements of the sensor. A demosaic algorithm can be used to rebuild the full color image. Note that in the CFA domain, 4 color channels actually exist (Red, Green1, Green2, and Blue - using our example from above). Therefore, any given pixel belongs to one of these color channels when processing.</p> <p>The sensor also contains a Clear HDR feature that when enabled allows the sensor to capture two images simultaneously, one with a low gain level set to the bright region and the other with a high gain level set to the dark region. Post sensor processing can be used to combine the two images to produce a 16-bit HDR image. Since images are captured simultaneously, there are no motion chromatic aberrations or other artifacts. However, this mode reduces the frame rate to 25 FPS.</p> <p>The Altera\u00ae MIPI D-PHY IP interfaces the FPGA directly to 2 Framos optical sensor modules via Framos connectors on the Modular Development board and PixelMate CSI-2 Flex-Cables. The design showcases a 3840x2160 sensor resolution up to 60 FPS using 12-bit Bayer pixel samples using MIPI lane rates of 1782 Mbps to provide sufficient bandwidth. The MIPI D-PHY is configured for 2 links (one per sensor) of x4 lanes at 1782 Mbps with no skew calibration and non-continuous clock mode. Each sensor module has additional pins, including Power on Reset, Master/Slave mode, as well as sync signals and a slave I2C interface for control and status. The MAX10 device on the Modular Development board drives some of these signals which can be controlled via the FPGA using another, separate I2C interface. All the I2C interfaces are connected via HPS I2C controllers. The SW App auto-detects and sets up all detected cameras for 1782 Mbps lane speed, 3840x2160 resolution, RAW12 pixel samples, no skew calibration, and blanking for 60 FPS.</p> <p>The design connects an Altera\u00ae MIPI CSI-2 IP to each of the MIPI D-PHY IP Rx links from each optical sensor module using a 4-lane 16-bit PHY Protocol Interface (PPI) bus. The bus effectively runs at 93.312 MHz (calculated as 3840x2160x60FPSx12b/(4x16b)). The design configures each CSI-2 IP output at 4 PIP (Pixels In Parallel) using a 297MHz clock. A VVP Protocol Converter IP converts each CSI-2 IP VVP AXI4-S protocol from Full to Lite.</p> <p>In Clear HDR configuration, the two simultaneous captured sensor images are sent over the single MIPI interface and output as 2 separate image streams by the MIPI CSI-2 IP. The non-QPDS Exposure Fusion IP (supplied with the source project) accepts both image streams and provides preliminary support to combine them into a single HDR image stream. By default, the example design does not enable Clear HDR and the IP operates in bypass. Regardless of the mode of operation, the output is always 16-bits, MSB aligned.</p> <p>To reduce FPGA resources, a VVP PIP Converter IP follows to reduce the PIP from 4 to 2. The PIP Converter contains 2 lines of video buffer for accommodating back-pressuring from downstream IPs.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#descriptions-of-the-ips","title":"Descriptions of the IPs","text":"<p>This section summarizes notable IPs instanced in the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design:</p> <ul> <li>Input Test Pattern Generator</li> <li>Black Level Statistics</li> <li>Clipper</li> <li>Defective Pixel Correction</li> <li>Adaptive Noise Reduction</li> <li>Black Level Correction</li> <li>Vignette Correction</li> <li>White Balance Statistics</li> <li>White Balance Correction</li> <li>Demosaic</li> <li>Histogram Statistics</li> <li>Color Correction Matrix</li> <li>1D LUT</li> <li>3D LUT</li> <li>Tone Mapping Operator</li> <li>Unsharp Mask Filter</li> <li>Warp</li> <li>Logo Overlay</li> <li>Frame Writer</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#input-test-pattern-generator","title":"Input Test Pattern Generator","text":"<p>The Input TPG IP (Instance 0) allows you to test the design without a sensor module input. It uses the VVP Test Pattern Generator IP and a non-QPDS IP called Remosaic (RMS) (supplied with the source project). The TPG has an RGB output which cannot be processed by the ISP as it supports a CFA image. The RMS is used to convert the RGB image into a CFA image by discarding color information for pixels based on the CFA pattern supported by the sensor. The TPG features several modes, including SMPTE color bars and solid colors. The Bayer Switch - VVP Switch IP (Instance 1), is used to select the Input source.</p> <p>Related Information</p> <p>Test Pattern Generator IP Switch IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#black-level-statistics","title":"Black Level Statistics","text":"<p> <p>Black Level Statistics Block Diagram </p> <p>The Black Level Statistics (BLS) IP accumulates pixel values in a Region of Interest (ROI), which is usually associated with a shielded area of an imaging sensor called an Optical Black Region (OBR). The SW App, using these  statistics, may choose to keep the sensor's black-level value constant and compensate for any deviations caused by various external factors like  temperature changes, voltage drifts, or aging.</p> <p>The BLS calculates statistics across an OBR of the 2x2 CFA input from the sensor. The IP has dedicated accumulators for each CFA channel that calculates 4 independent pixel sums. The SW App uses the BLS IP to set the offset and scalar coefficients of the Black Level Correction (BLC) IP. The BLS passes the input image to its output unchanged.</p> <p>Note that although the hardware design includes BLS IP as part of the video pipeline, the SW App does not configure the imaging sensor and the MIPI connectivity IPs to pass the OBR for processing the statistics real time. The SW App reads these statistics as part of a hidden and unsupported offline calibration flow.</p> <p>Related Information</p> <p>Black Level Statistics IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#clipper","title":"Clipper","text":"<p>The Clipper IP crops an active area from an input image and discards the remainder. The SW App may choose to use this IP to discard unwanted regions of the video like OBR from the sensor input or perform digital zoom. Currently, the SW App configures the sensor to output 4K video at the input, therefore it configures the Clipper IP to bypass the input image.</p> <p>Related Information</p> <p>Clipper IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#defective-pixel-correction","title":"Defective Pixel Correction","text":"<p>The Defective Pixel Correction (DPC) IP removes impulse noise associated with defective pixels in the sensor image. Such impulse noise is usually the result of defective pixel circuitry within image sensor for a given pixel, and it manifests itself in those pixels to respond to light drastically differently compared to their neighboring pixels. The DPC IP operates on 2x2 Bayer CFA images, identifying defective pixels using a configurable non-linear filter, and then corrects them.</p> <p></p> <p> <p>Defective Pixel Correction Block Diagram </p> <p></p> <p>The DPC IP works on a 5x5 pixel neighborhood. The IP gathers the 9 pixels of the same color channel closest to the current pixel (the center pixel in the neighborhood) and sorts them according to their pixel values. A non-linear filter calculates a corrected pixel value from the sorted group of pixels depending on the sensitivity setting.</p> <p></p> <p> <p>A Bayer CFA for a 6x6 section of an image and an example pixel neighborhood for green, red, and blue pixels </p> <p></p> <p>The DPC IP dynamically identifies and filters defect pixels and does not support static defective pixel correction of predetermined pixels. When you set the sensitivity level to the weakest value, the pixel value is altered only if its original value falls outside the value range of its whole pixel neighborhood. As the sensitivity increases the IP approximates a class of median filter.</p> <p>Related Information</p> <p>Defective Pixel Correction IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#adaptive-noise-reduction","title":"Adaptive Noise Reduction","text":"<p>The Adaptive Noise Reduction (ANR) IP is an edge-preserving smoothing filter that mainly reduces the independent pixel noise of an image. The IP operates on 2x2 Bayer CFA images.</p> <p></p> <p> <p>Adaptive Noise Reduction Block Diagram </p> <p></p> <p>The ANR IP uses a spatial weighted averaging filter that analyzes the scene and correlates similar pixels dynamically while generating the weights on the fly. The IP utilizes two LUTs when correlating the pixels, one for correlating pixel intensities and the other for correlating the spatial distance between the pixels.</p> <p>The design provides the intensity range LUT pre-calibrated offline using the difference in noise level between two video images with identical content but different temporal noise. The noise level is a function of the sensors analog gain. Therefore, the calibration file contains a table of LUT parameters for a range of sensor analog gain settings. Using a LUT allows you to program different denoising strengths across the pixel intensities. For example, you may opt for stronger denoising of dark content to reduce shadow noise more  aggressively while preserving the details on the mid-tones and highlights.</p> <p>The spatial distance LUT is used to make the ANR more versatile. It is programmed to create a weight distribution from the center pixel to the neighboring pixels. Traditional distributions like a Hamming or Hanning window can be used to reduce ringing artifacts, or the same value entries can be used for a rectangular distribution to maximize denoising capability. By default, the software configures a Gaussian distribution into the spatial distance LUT.</p> <p>Related Information</p> <p>Adaptive Noise Reduction IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#black-level-correction","title":"Black Level Correction","text":"<p>The Black Level Correction (BLC) IP operates on a 2x2 CFA input image and adjusts the minimum brightness level of the image, ensuring an actual black value is represented by the minimum pixel intensity. A camera system typically adds a pedestal value as an offset to the image at the sensor side. Artificially increasing black level creates foot room for preserving noise distribution of the black pixels and prevents artifacts in the final image. The design positions the BLC IP after the ANR IP where the noise is reduced as much as desired.</p> <p></p> <p> <p>Black Level Correction Block Diagram </p> <p></p> <p>The BLC IP subtracts the pedestal value from the input video stream and scales the result back to the full dynamic range. The scaler part of BLC multiplies the pedestal remover value by the scaler coefficient, clipping to the maximum output pixel value should the calculation overflow.</p> <p></p> <p> <p>BLC Function </p> <p></p> <p>The SW App sets the pedestal and scaler coefficients for each of the 2x2 CFA color channels dynamically during runtime. These values can be pre-calibrated, or calculated dynamically from statistics obtained from the BLS IP using OBR of the sensor. You can configure the BLC IP to reflect negative values around zero or clip them to zero.</p> <p></p> <p> <p>Effects of Reflection Around Zero </p> <p></p> <p>Note that for this design, the SW App provided does not utilize the BLS IP to read the OBR of the sensor and relies on pre-calibrated coefficients as a function of analog gain of the sensor.</p> <p>Related Information</p> <p>Black Level Correction IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#vignette-correction","title":"Vignette Correction","text":"<p>The Vignette Correction (VC) IP compensates for non-uniform intensity across the image caused by uneven light-gathering limitation of the sensor and optics. In the usual case, the non-uniformity can be caused by lens geometry transforms such as zoom, aperture, etc., where the center of the lens gathers more light compared to the outer regions. The VC IP corrects uniformity using a runtime mesh of coefficients and interpolating coefficients for any given pixel. </p> <p></p> <p> <p>Vignette Correction Block Diagram </p> <p></p> <p>The VC IP uses a rectangular mesh of coefficients to adjust the pixel intensities across an image, therefore tuning out vignetting and other sensor non-uniformities. The VC IP operates independently on the 4 color channels of the 2x2 CFA input image. For all color channels, you may calculate the mesh coefficients with a calibration process in a controlled imaging environment and configure the SW App to write them to the VC IP. The precision of a mesh coefficient is fixed-point unsigned 8.11, with 8 integer bits and 11 fractional bits. The mesh divides the image into rectangular zones, with mesh points residing at the corners of the zones. For each pixel, the IP selects the 4 mesh points corresponding to the corners of the pixel's zone and interpolates them using the distance from the pixel location to the mesh points. A multiplier scales the input pixels using this interpolated coefficient.</p> <p>Note that the vignetting effect is very low for the sensor module used in this design, therefore, the design does not contain a pre-calibrated mesh of coefficients.</p> <p></p> <p> <p>A Mesh Zone with a Pixel of Interest </p> <p></p> <p>Related Information</p> <p>Vignette Correction IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#white-balance-statistics","title":"White Balance Statistics","text":"<p> <p>White Balance Statistics Block Diagram </p> <p></p> <p>The White Balance Statistics IP (WBS) operates on a 2x2 Bayer CFA image and calculates red-green and blue-green ratios within a Region of Interest (ROI). The ROI is divided into 7x7 zones, and the WBS calculates independent statistics for all 49 zones. The SW App uses the WBS to set the White Balance Correction IP.</p> <p></p> <p> <p>Packing Order of the Zones within a Region of Interest </p> <p></p> <p>Each 2x2 Bayer region creates a virtual pixel from grouping 4 pixels. The IP then calculates a red-green and a blue-green ratio for each virtual pixel within the ROI.</p> <p></p> <p> <p>Example of ratio calculation for 2x2 virtual pixels for a 6x6 Section of Image </p> <p></p> <p>The WBS IP checks both ratios against runtime programmable lower and upper range thresholds and increments a zone virtual pixel count only if both ratios fall between their respective threshold values. If at least one of the ratios is out of range, the IP discards both ratios for that 2x2 virtual pixel and therefore do not contribute to the final statistics of that zone. Ratios of all virtual pixels that are not marked out of range are accumulated, and along with the zone virtual pixel count are transferred to the zone memory at the end of the zone.</p> <p>The SW App reads each zone memory and calculates an average ratio by dividing the accumulated ratio by the virtual pixel count. If the number of counted pixels is too low, it indicates a zone with mixed content and is therefore unsuitable for inclusion in calculating white imbalance of the image. The Auto White Balance (AWB) algorithm is a feedback loop inside the SW App that continuously reads the white balance statistics and guesses the color temperature of the image scene.</p> <p>The WBS IP passes its input image to its output unchanged.</p> <p>Related Information</p> <p>White Balance Statistics IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#white-balance-correction","title":"White Balance Correction","text":"<p>The White Balance Correction (WBC) IP adjusts colors in a CFA image to eliminate color casts, which occur due to lighting conditions or differences in the light sensitivity of the pixels of different color. The IP ensures that gray and white objects appear truly gray and white without, unwanted color tinting.</p> <p></p> <p> <p>White Balance Correction Block Diagram </p> <p></p> <p>The WBC IP multiplies the color channels of a 2x2 CFA input image by scalar coefficients per color channel, clipping to the maximum output pixel value should the calculation overflow.</p> <p>The design provides a table of WBC scalars pre-calibrated for the sensor for a range of color temperatures. The white balance algorithm in the SW App uses color temperature information of the scene to look up WBC scalars from the calibration table and configures the WBC IP over the Avalon\u00ae memory-mapped interface. The SW App uses AWB to guess the color temperature in automatic mode. The SW App also supports many fixed color temperature options.</p> <p>Related Information</p> <p>White Balance Correction IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#demosaic","title":"Demosaic","text":"<p> <p>Demosaic Block Diagram </p> <p></p> <p>The Demosaic IP (DMS) is a color reconstruction IP for converting a 2x2 Bayer CFA input image to an RGB output image. The DMS interpolates missing colors for each pixel based on its neighboring pixels.</p> <p></p> <p> <p>An example of a 2x2 RGGB Bayer Color Filter Array (for an 8x8 pixel section of the image) </p> <p></p> <p>The DMS analyzes the neighboring pixels for every CFA input pixel and interpolates the missing colors to produce an RGB output pixel. The IP uses line buffers to construct pixel neighborhood information, maps the pixels in the neighborhood depending on the position on the 2x2 CFA pattern, and interpolates missing colors to calculate the RGB output.</p> <p>Related Information</p> <p>Demosaic IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#histogram-statistics","title":"Histogram Statistics","text":"<p>The Histogram Statistics (HS) IP operates on RGB images. It analyzes the pixel values for every frame to collects data to form a histogram of light intensity.</p> <p></p> <p> <p>Histogram Statistics Block Diagram </p> <p></p> <p>The HS IP calculates two light intensity histograms on the RGB input image - a whole image histogram and a ROI image histogram. The RGB to intensity conversion is performed according to the ITU-R BT.709 standard.</p> <p>The Automatic Exposure (AE) algorithm is a feedback loop in the SW App that guesses the optimum exposure of the scene. It continuously reads the HS IP and guesses whether the capture is underexposed or overexposed and adjust camera sensor exposure settings accordingly.</p> <p>The HS IP passes its input to its output unmodified.</p> <p>Related Information</p> <p>Histogram Statistics IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#color-correction-matrix","title":"Color Correction Matrix","text":"<p>The Color Correction Matrix (CCM) functionality is provided by the VVP Color Space Converter (CSC) IP. A CCM correction is necessary to untangle the undesired color bleeding across CFA color channels on the sensor. This is mainly caused by each colored pixel being sensitive to color spectrums other than their intended color.</p> <p>The design configures the CSC IP to multiply the input RGB values of each pixel with a 3x3 CCM to obtain the color corrected output RGB values.</p> <p>The design provides a table of CCM coefficients pre-calibrated for the sensor for a range of color temperatures. The AWB algorithm in the SW App uses color temperature information of the scene to look up the CCM coefficients from the calibration table and configures the CSC IP over the Avalon\u00ae memory-mapped interface. The SW App uses AWB to guess the color temperature in automatic mode. The SW App also supports many fixed color temperature options.</p> <p>The SW App also provides many post-processing options to modulate the CCM coefficients for adding an artistic effect on top of the pre-calibrated accurate representation of the scene.</p> <p>Related Information</p> <p>Color Space Converter IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#1d-lut","title":"1D LUT","text":"<p>The 1D LUT IP uses a runtime configurable LUT to apply an input output transfer function to the image. You may use it to implement OOTF, OETF, and EOTF transfer functions defined for video standards and legacy gamma compression or decompression. You may also change the LUT content arbitrarily for other transfer functions or to apply an artistic effect to the image.</p> <p></p> <p> <p>1D LUT Block Diagram </p> <p></p> <p>The 1D LUT IP calculates LUT addresses from the input pixels. It interpolates fractional differences between LUT values to generate output pixel values. The IP uses an independent LUT for each color plane. The SW App uses the Avalon\u00ae memory-mapped interface to configure the LUTs.</p> <p>The example design contains 2 instances of 1D LUT.</p> <p>Instance 0 is used for traditional Gamma, High Dynamic Range Perceptual Quantizer (HDR PQ) and Hybrid Log-Gamma (HDR HLG) correction. The 1D LUT is configured as a 9-bit LUT and the output is increased to 16-bits to support the Capture Switch that follows.</p> <p>Instance 1 is used to facilitate the following 3D LUT IP where the available .cube files do not support linear video. To minimize logic resource, this 1D LUT is configured as a 12-bit LUT and the output is reduced to 14-bits.</p> <p>Related Information</p> <p>1D LUT IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#3d-lut","title":"3D LUT","text":"<p>The 3D LUT IP maps an image's color space to another using interpolated values from a lookup table.</p> <p>Typical applications include:</p> <ul> <li>Color space conversion</li> <li>Chroma keying</li> <li>Dynamic range conversion (standard to high and high to standard)</li> <li>Artistic effects (sepia, hue rotation, color volume adjustment, etc.)</li> </ul> <p></p> <p> <p>3D LUT Color Transform Examples (From top left to right: original, saturation, brightness increase, colorize (purple), colorize (green), desaturation) </p> <p></p> <p> <p>3D LUT Block Diagram </p> <p></p> <p>The 3D LUT uses the most significant bits (MSBs) of the 3 RGB color component inputs to retrieve data values from the LUT and the least significant bits (LSBs) to interpolate the final output value. The SW App connected to the Avalon\u00ae memory-mapped interface handles runtime control and LUT programming.</p> <p>The example design uses 2 back to back 3D LUT IPs to support combinations of conversions and will be application specific. If a 3D LUT isn't required, it can be placed in bypass mode. The output of the final 3D LUT IP is reduced to 12-bits.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#generating-lut-files","title":"Generating LUT Files","text":"<p>You are responsible for sourcing or generating LUTs for the example design. LUTs are generally developed based on input (optical system, sensor, ISP, etc.) and display parameters. Various tools are available under open-source licenses to produce LUTs. One such tool is LUTCalc, which can be used online. When using it to generate LUTs for the 3D LUT IP, ensure that:</p> <ul> <li>The LUT is set to 3D</li> <li>Size matches the 3D LUT IP parameters (i.e. 17, 33, or 65 cube)</li> <li>Input and Output Range are 100%</li> <li>LUT Type is \"General cube LUT (.cube)\"</li> </ul> <p></p> <p> <p>LUTCalc Format Settings </p> <p></p> <p>In general, any LUT file used with this example design must follow these formatting conventions:</p> <ul> <li>RGB component order</li> <li>Components change first from left to right, i.e., R first, G second, B third</li> <li>The data type must match the IP GUI parameter and may either be:<ul> <li>normalized fixed- or floating-point numbers between 0.0 to 1.0</li> <li>integers between 0 and 2LUT_DEPTH-1 (for example, 10-bit: 0 to 1023)</li> </ul> </li> <li>The data type must be the same for the whole file</li> </ul> <p>Related Information</p> <p>3D LUT 3D LUT IP LUTCalc GitHub page</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#tone-mapping-operator","title":"Tone Mapping Operator","text":"<p>The Tone Mapping Operator (TMO) IP implements a tile-based local tone mapping algorithm. It improves the visibility of latent image details and enhances the overall viewing experience.</p> <p></p> <p> <p>Before (left) and after (right) TMO is applied to an example image </p> <p></p> <p> <p>TMO Block Diagram </p> <p></p> <p>The luminance extractor converts the RGB input to LUMA. The image statistics calculator uses LUMA to calculate a set of global and local statistics regarding the contrast of the input image over a 4x4 grid. The LUT generator software runs on an embedded Nios\u00ae V CPU which analyzes the statistics, generates a set of mapping transfer functions, and converts them to LUTs. The contrast enhancement engine applies mapping transfer functions locally for better granularity. The image enhancer combines the information and calculates a set of weights that are applied to the input to generate the contrast-enhanced output. The output is reduced down to 10-bits for the USM IP that follows.</p> <p>The TMO does not use image buffers and therefore the statistics collected from the previous image are used to enhance the current image.</p> <p>The SW App configures the TMO IP over the Avalon\u00ae memory-mapped interface.</p> <p>Related Information</p> <p>Tone Mapping Operator Tone Mapping Operator IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#unsharp-mask-filter","title":"Unsharp Mask Filter","text":"<p>The Unsharp Mask (USM) IP applies a sharpening algorithm to the input image by implementing an unsharp mask filter.</p> <p>The IP firstly converts the RGB input to LUMA. The LUMA input is then passed through a low-pass Gaussian blur filter. The IP subtracts the blurred input from the original LUMA input to generate a high frequency component. A strength scaler is applied to the high frequency component which is then used to scale the input RGB image to generate the output RGB image.</p> <p>The unsharp mask has an agent Avalon\u00ae memory-mapped interface to allow runtime control for changing the sharpening strength. You can configure a positive or negative strength value for sharpening or blurring the image. Setting the strength to 0 is equivalent to bypass i.e. passing the input to the output unmodified.</p> <p>Related Information</p> <p>Unsharp Mask IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#warp","title":"Warp","text":"<p>The Warp IP applies an arbitrary warp (or image transform) to an input image. It allows for lens distortion corrections (fisheye for instance) and the ability to scale, rotate, and mirror the image.</p> <p></p> <p> <p>Warp Transform Examples (From left: arbitrary warp with a 5x5 array of control points, four corner warp with some radial distortion.) </p> <p></p> <p> <p>Warp Mirror and Rotation Examples (From top left clockwise: original image, mirrored, 90\u00b0 rotate and 180\u00b0 rotate.) </p> <p></p> <p> <p>Warp Block Diagram </p> <p></p> <p>The block diagram shows an external memory which is used to buffer the incoming and outgoing image data. The external memory also stores the coefficient tables used to control the Warp IPs operation and define the required image transform.</p> <p>The IP uses its Warp engines to operate on the input images stored in the input buffers and to construct warped, output images from the output buffers.</p> <p>The example design configures the Warp IP with two engines to support any arbitrary transformation at 4K resolution.</p> <p>Related Information</p> <p>Warp Warp IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#logo-overlay","title":"Logo Overlay","text":"<p>The Altera\u00ae logo overlay feature uses a VVP Test Pattern Generator IP, a VVP Mixer IP, and a non-QPDS Icon IP (supplied with the source project). The TPG (Instance 1) is used for the screensaver function and is configured as a 4K solid black image. It is also the base layer for the Mixer IP and is mixed with the ISP pipeline video layer and the Icon IP layer. The opacity of the Icon layer can be changed on the fly using the Avalon\u00ae Memory-Mapped interface.</p> <p>Related Information</p> <p>Test Pattern Generator IP Mixer IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#frame-writer","title":"Frame Writer","text":"<p>The Frame Writer function uses a Video Frame Writer IP which receives and stores frames in external DDR memory connected to the FPGA. The IP has a host Avalon\u00ae memory-mapped interface to allow connection to the external memory and an agent Avalon\u00ae memory-mapped interface connected to the HPS to allow runtime control.</p> <p>The Video Frame Writer IP operates in a single shot mode on RGB 16-bit images. The Capture Switch (VVP Switch IP - Instance 5) is used to feed the Video Frame Writer with the raw sensor input via either the Raw Capture Switch (VVP Switch IP - Instance 4) or the ISP output via the 1D LUT IP (Instance 0). The raw sensor input image uses a single color for each pixel and so a Color Plane Manager IP is used to copy the single color into all 3 color planes to generate a grayscale RGB raw sensor image.</p> <p>The HPS has a host Avalon\u00ae memory-mapped interface to the FPGA external DDR, allowing it to read out captured images.</p> <p>The output of the Capture Switch when not feeding the Video Frame Writer IP, feeds the 16-bit ISP output image into a Pixel Adapter IP to reduce it back down to 10-bit ready for the Display Port output.</p> <p>Related Information</p> <p>Video Frame Writer IP Color Plane Manager IP Bits per Color Sample Adapter IP Protocol Converter IP Pixels in Parallel Converter IP</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#hard-processor-system","title":"Hard Processor System","text":"<p>Hard Processor System (HPS) runs the application software that configures the external optical sensor module and the internal IPs, and provides various control loops like AWB and AE. In addition, it runs a web server that allows you to interact with the demo via an Ethernet connection. The HPS has its own external DDR that is used exclusively by the software stack. Additionally, the HPS is connected to the external FPGA fabric DDR to process the data of the Warp and Frame Writer IPs. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/isp-funct-descr/#additional-reference-information","title":"Additional Reference Information","text":"<ul> <li>Video and Vision Processing Suite Altera\u00ae FPGA IP User Guide</li> <li>Altera\u00ae FPGA Streaming Video Protocol Specification</li> <li>AMBA 4 AXI4-Stream Protocol Specification</li> <li>Avalon\u00ae Interface Specifications \u2013 Avalon\u00ae Streaming Interfaces</li> </ul> <p> Back </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ocp_license-requirements-to-build/","title":"Ocp license requirements to build","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ocp_license-requirements-to-build/#license-requirements-to-build","title":"License Requirements to build","text":"<ul> <li>OpenCore Plus (OCP) IP evaluation license.</li> <li>Free licenses (must be downloaded and installed):<ul> <li>[Nios\u00ae V Processor].</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/sw-funct-descr/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - Software Functional Description","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/sw-funct-descr/#overview","title":"Overview","text":"<p>The primary software components are summarized in the following diagram and described below:  </p> <p> <p>Software Top Block Diagram </p> <p>Summary:</p> <ul> <li>A Software application running on an embedded Linux system.</li> <li>The application provides Web based UI to control the video pipeline and individual ISP IP.</li> <li>User accesses Web UI from a remote PC or tablet over the network with a Web browser e.g. Chrome.</li> <li>Linux system includes necessary drivers allowing the software application to access and control FPGA using register read/write interface.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/sw-funct-descr/#custom-linux-distribution-based-on-kas","title":"Custom Linux distribution based on KAS","text":"<p>For the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices, Altera\u00ae provides the files to build the Linux system to run the ISP demo application. A custom version of Linux is built based on KAS (setup tool for Yocto projects, see KAS) and is composed of the following meta-layers:</p> <ul> <li>Altera\u00ae FPGA Layer - meta-altera-fpga</li> <li>Altera\u00ae FPGA OCS (Offset Capability Structure) Layer - meta-altera-fpga-ocs</li> <li>Camera Layer - meta-vvp-isp-demo</li> </ul> <p>KAS Reference</p> <p>agilex-ed-camera/sw</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/sw-funct-descr/#necessary-elements-in-the-meta-layers-to-bind-software-and-hardware","title":"Necessary elements in the meta-layers to bind Software and Hardware","text":"<p>This section details the various elements included in the meta-layers that facilitate running the camera application. These elements assist in \"binding\" the FPGA Soft IP with the Linus software running on the HPS. The following sections explain these elements to clarify the interaction between the HPS software stack and the FPGA soft IP. This interaction between the HPS and Camera IP serves as an example of how to interface any soft IP in the FPGA fabric with higher-level software.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/sw-funct-descr/#device-tree","title":"Device Tree","text":"<p>Adds a custom .dtsi (device tree fragment) file to the main device tree for Linux kernel boot up stage <code>socfpga_agilex5_socdk.dts</code>. it compiles into a DTB (device tree blob) during kernel compilation and is added to the microSD card image during the Yocto build with the recipe <code>device-tree.bb</code>. The specific file for this design example (<code>agilex5_vvp-isp-demo.dtsi</code>), is appended using <code>device-tree.bbappend</code> directive. Look for these files in the different meta-layers provided. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/sw-funct-descr/#fpga-bitstream","title":"FPGA Bitstream","text":"<p>Adds the <code>agilex5_modkit_vvpisp.hps_first.core.rbf</code> file to the build. The file is generated after Quartus\u00ae compilation. The <code>*core.rbf</code> file is added to the boot partition of the microSD card (renamed as <code>top.core.rbf</code>). The HPS configures the FPGA at initialization using u-boot <code>load</code> command in <code>uboot.txt</code> generated into <code>boot.scr.uimg</code> in the boot partition by  <code>u-boot-socfpga_%.bbappend</code> (look for the files in the meta-layer). </p> <p><pre><code>Found U-Boot script /boot.scr.uimg\n1711 bytes read in 12 ms (138.7 KiB/s)\n## Executing script at 81000000\ncrc32+ 12038144 bytes read in 627 ms (18.3 MiB/s)\n............FPGA reconfiguration OK!\n47645184 bytes read in 2435 ms (18.7 MiB/s)\n42988 bytes read in 17 ms (2.4 MiB/s)\n## Flattened Device Tree blob at 86000000\n   Booting using the fdt blob at 0x86000000\nWorking FDT set to 86000000\n   Loading Device Tree to 00000000feae5000, end 00000000feaf27eb ... OK\nWorking FDT set to feae5000\n\nStarting kernel ...\n</code></pre> <p>FPGA configuration during HPS booting process </p> <p>Look for the print \"..... FPGA reconfiguration OK \" during the device booting process, as shown in the previous figure to ensure the FPGA bitstream (<code>top.core.rbf</code>) has been properly loaded.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/sw-funct-descr/#additional-u-boot-configuration","title":"Additional u-boot configuration","text":"<p>Append to the u-boot arguments using <code>IMAGE_BOOT_ARGS</code> and <code>IMAGE_BOOT_ARGS:append:agilex5_modular</code> in different KAS/YOCTO configuration files to enable UIO drivers defined by <code>uio_pdrv_genirq.of_id=generic-uio</code>. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/sw-funct-descr/#using-a-static-ip-address","title":"Using a Static IP Address","text":"<p>Linux on the microSD card obtains an IP address automatically via DHCP if the Ethernet network has a DHCP server. Alternatively, you may configure the network with a static IP address by editing the following file via the terminal interface: </p> <pre><code>/etc/systemd/network/11-eth.network\n</code></pre> <p>Find the following lines in the file: <pre><code>[Network]\nDHCP=yes\n</code></pre></p> <p>Replace the lines with the following content: <pre><code>[Network]\nDHCP=no\nGateway=192.168.1.1\nAddress=192.168.1.123/24\n</code></pre></p> <p>Use the gateway and the static IP address as appropriate for your network. Save the file and reboot the board. </p> <p> Back </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/","title":"4Kp60 Multi-Sensor HDR Camera Solution System Example Design for Agilex\u2122 5 Devices - Web Graphical User Interface Functional Description","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#running-the-graphical-user-interface-gui","title":"Running the Graphical User Interface (GUI)","text":"<p>The application software of the design has a web-server GUI that is used to control and demonstrate various hardware and software features of the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design. Follow the instructions to run the GUI on a web browser. The GUI is optimized for displaying the full screen on a 1920x1080 resolution screen. Press F11 on your browser to go full screen. </p> <p>The application software is flexible in discovering available hardware components and only drawing the components present in the design on the GUI. Therefore, some parts of the GUI elements can be missing or different across different camera solution designs. Also note that there may be slight variations in the GUI compared to the example images shown in this section. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#connecting-to-isp-demo-application-web-gui","title":"Connecting to ISP Demo Application Web GUI","text":"<p>Take note of the Modular Development board IP address. This will be displayed on the HPS console serial port when the demo application starts. Alternatively, use the following command to list IP addresses:</p> <pre><code>ip a\n</code></pre> <p>Use a web browser of your choice (such as Chrome) on any device connected to the same network as the Modular Development board. If connecting directly without a switch or router, the self-assigned IPv6 address can be used, or assign a static IPv4 Address. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#descriptions-of-the-tabs","title":"Descriptions of the Tabs","text":"<p>This section summarizes the GUI tabs in the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design.</p> <ul> <li>Input Config Tab</li> <li>ISP Pipeline Tab</li> <li>Output Config Tab</li> <li>Pipeline Statistics Tab</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#input-config-tab","title":"Input Config Tab","text":"<p> <p>Input Config Tab </p> <p>The Input Config Tab controls two separate parts of the application:</p> <ul> <li>The Input Stage which corresponds to selecting which input to use and the parameters for those input sources.</li> <li>The Control Loops, corresponding to the Auto White Balance and Auto Exposure functions.  </li> </ul> <p>This section summarizes the GUI controls in the Input Config Tab:</p> <ul> <li>Input Select</li> <li>Test Pattern Generator</li> <li>Camera Control</li> <li>Sensor Profile</li> <li>Histogram</li> <li>Auto Exposure</li> <li>Auto White Balance</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#input-select","title":"Input Select","text":"<p> <p>Input Select </p> <p>The Input Source UI controls which input is selected:</p> <ul> <li>Input TPG corresponds to the Test Pattern Generator (TPG). The TPG RGB output image is passed through a Remosaic IP to convert it to a Color Filter Array (CFA) format image (also known as Bayer) that is consistent with the camera input. It can be used to verify the system without a sensor module.</li> <li>Camera N, where N corresponds to the sensor module or modules connected to the board. The number of sensor modules visible in the dropdown menu depends on the camera solution design and the number of sensor modules physically connected to the development board.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#test-pattern-generator","title":"Test Pattern Generator","text":"<p> <p>Test Pattern Generator </p> <p>The Test Pattern Generator UI allows you to control the Input Test Pattern Generator operation mode:</p> <ul> <li>SMPTE standard color bars.</li> <li>Solid Color. Use the Color Select dropdown box to set the color from the list (including standard SMPTE color bar colors, and a mid-level gray).</li> <li>Rainbow. Cycles every few seconds the color selection from the Solid Color mode.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#camera-control","title":"Camera Control","text":"<p> <p>Camera Control - FSM-IMX678 Sensor </p> <p>The camera control provides manual exposure controls for the corresponding imaging sensor. The UI presents a camera control tile for each sensor module connected to the board. The model field shows the model of the optical sensor module detected. </p> <p>The Analog Gain slider adjusts the light sensitivity of the sensor, allowing the image to be brightened or dimmed. However, increasing exposure via analog gain has a tradeoff of reducing signal-to-noise ratio resulting in a grainier image. </p> <p>The Frame Rate slider adjusts the sensor frame rate. Reducing the frame rate gives more time to accumulate time, while increasing it reduces motion blurring artifacts. For flickering light sources, we recommend setting the frame rate to an integer multiple or reciprocal integer multiple of the electrical grid frequency. For example, for 50 Hz grid frequency you may set the frame rate to 50, 25, 12.5 or 6.25 Hz to mitigate flickering. </p> <p>The Shutter Speed slider controls the light integration time of the sensor, allowing the image to be brightened or dimmed. The maximum shutter speed is inversely proportional to the frame rate, where a lower frame rate gives more time for the sensor to integrate more light. </p> <p>We recommend the following flow for manually adjusting the total exposure of a scene:</p> <ul> <li>Minimize the analog gain.</li> <li>If the image is flickering adjust frame rate to 50 or 60 Hz depending on the   power line frequency.</li> <li>Adjust shutter speed for optimum exposure.</li> <li>If the image is underexposed even at maximum shutter speed, do one or both of   the following, depending on your motion artifact vs. noise preference, until   satisfied:<ul> <li>Reduce the frame rate, halving it if flickering, and further increase the shutter speed. This will reduce the responsiveness of the video and increase motion artifacts without increasing graininess.</li> <li>Increase the analog gain. This will increase the graininess of the video without changing responsiveness.</li> </ul> </li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#sensor-profile","title":"Sensor Profile","text":"<p> <p>Sensor Profile </p> <p>The Import Camera Profile button loads a sensor profile (a JSON format pre-calibrated sensor settings file) into the application. The application comes with a default calibration profile preloaded on the microSD card image for the IMX678 as featured in the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design. Therefore, is not necessary to load a new profile in normal operation. The IMX678 profile was produced using the Calibration Tab in the UI, as well as some offline processes for best-in-class color reproduction. Note that using the calibration tab requires expert knowledge and is therefore hidden in the UI by default.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#histogram","title":"Histogram","text":"<p> <p>Histogram Statistics </p> <p>The Histogram Statistics displays the real time output of the Histogram Statistics IP. It is intended to be used as a visual aid while adjusting exposure controls.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#auto-exposure","title":"Auto Exposure","text":"<p> <p>Auto Exposure Controls </p> <p>The Auto Exposure function built into the camera solution demonstration, uses data from the Histogram Statistics IP to control the sensor analog gain and shutter speed. When using the ROI, the algorithm will prioritize the region specified when calculating the exposure. </p> <p> <p>Auto Exposure - Region of Interest Editor </p> <p>The Region of Interest (ROI) editor allows you to select a region of the image to use for the Auto Exposure function. Drag the region with a mouse stretch and drag the window freely, or enter starting coordinates and the size of the region manually. Highlighting ROI makes the region visible on the ISP output as an overlay. Clicking the circular arrow on the tile resets the configuration to its default values.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#auto-white-balance","title":"Auto White Balance","text":"<p>The Auto White Balance UI allows control of the Automatic White Balance (AWB) function built into the camera solution demonstration. It uses the calibration settings loaded via the Sensor Profile UI.</p> <p></p> <p> <p>Auto White Balance Controls </p> <p>The White Balance control has five modes of operation:</p> <ul> <li>Disabled. This mode turns off the white balance function by bypassing the White Balance Correction and Black Level Correction IPs, as well as unlocking the controls of those IPs in the UI in the ISP Pipeline Tab. You may then enable those IPs and manually change their coefficients. This mode also disables the Color Correction Matrix function by programming it to unity.</li> <li>Choose Temperature. This mode lets you enter a color temperature freely using the Temperature (K) slider. The temperature must be set correctly otherwise incorrect coefficients will be used causing the image to look incorrect. As a guide, scenes generally require a color temperature ranging from 4000 to 6500 Kelvin.</li> <li>Choose Lighting. This mode operates similarly to the Choose Temperature mode. However, in this mode Temperature (K) slider is disabled. Instead, you can choose the lighting conditions from the Lighting dropdown menu. Note that the real temperature varies among the family of light sources.</li> <li>Automatic. Automatic mode turns off all user input and instead uses the White Balance Statistics IP pre- and post- White Balance Correction to attempt to guess the scene's color temperature.</li> <li>Custom Preset (Spot). This is a one-shot automatic white balance mode which runs the AWB function for 2 seconds before locking in the temperature. Clicking the Snapshot button or changing the ROI, resets the mode and triggers another 2 seconds one-shot. This mode is useful where the scene is too colorful. You can position a gray card or position the camera to focus on a gray or white object in the scene, and using the ROI to focus in on just that area, snapshot the temperature to keep it constant for the entire scene.</li> </ul> <p>The Tint Adjustment slider is unlocked across all modes. This control enables you to adjust the magenta-green color balance when the light source illuminating the scene is not an ideal black light source following the black body radiation curve (Planckian locus). </p> <p>The CCM strength slider controls the color vibrancy. A unity value of 1.0 gives the most accurate color reproduction following the sensor profile. If the light source is not ideal, then a value of 1.0 might over-saturate some colors, which requires you to lower it until satisfied. Conversely, you may increase the color vibrancy for artistic purposes. </p> <p>Automatic and Custom Preset (Spot) modes unlock the ROI editor. The selected region defines the area over which the White Balance Statistics IP performs its calculations. Resizing or moving the active region automatically highlights the region on the ISP output as an overlay for 2 seconds. For mixed scenes with plenty of gray content, a full-screen statistics gives decent performance. For mixed scenes, it is beneficial to localize the region of interest onto gray parts of the image as described above. </p> <p>Clicking the circular arrow on the tile resets the configuration to its default values.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#isp-pipeline-tab","title":"ISP Pipeline Tab","text":"<p> <p>ISP Pipeline Tab </p> <p>The ISP Pipeline tab contains the controls corresponding to the core ISP functions and are summarized as follows:</p> <ul> <li>Defective Pixel</li> <li>Adaptive Noise Reduction</li> <li>Black Level Correction</li> <li>Vignette Correction</li> <li>White Balance Correction</li> <li>Demosaic</li> <li>Unsharp Mask Filter</li> <li>Color Correction Matrix</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#defective-pixel-correction","title":"Defective Pixel Correction","text":"<p> <p>Defective Pixel Correction </p> <p>The Defective Pixel Correction UI provides controls for bypassing the Defective Pixel Correction (DPC) IP functionality, and when enabled setting the DPC strength. The default strength is Very Weak which provides a good balance between mitigating defective pixels, and preserving details and specular highlights. Increasing the strength mitigates more defective pixels with a tradeoff of softening the image.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#adaptive-noise-reduction","title":"Adaptive Noise Reduction","text":"<p> <p>Adaptive Noise Reduction </p> <p>The Adaptive Noise Reduction UI provides controls for bypassing or setting the strength of the denoising algorithm of the Adaptive Noise Reduction (ANR) IP. A higher strength provides better denoising with a tradeoff of softening the image.</p> <p>Clicking the circular arrow on the tile resets the ANR configuration to its default values.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#black-level-correction","title":"Black Level Correction","text":"<p> <p>Black Level Correction </p> <p>The Black Level Correction UI provides access to low level Black Level Correction (BLC) IP controls. This tile is locked, displaying live values for most of the white balance modes in the Auto White Balance Control as the settings are controlled by the Application software. Note that disabling Auto White Balance to enable manual BLC controls is not implemented by default. This is because the SW App does not configure the imaging sensor and the MIPI connectivity IPs to pass the Optical Black Region (OBR) required for processing the black level statistics in real time. Instead, it uses offline calibrated values.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#vignette-correction","title":"Vignette Correction","text":"<p> <p>Vignette Correction Controls </p> <p>Vignette Correction (VC) is used to compensate for non-uniform intensity across the image caused by the uneven light gathering limitations of the sensor and optics. The most common non-uniformity is where the center of the lens gathers more light compared to the outer regions. The VC IP corrects uniformity using a runtime mesh of pre-calibrated coefficients and interpolating coefficients for any given pixel. </p> <p>The Vignette Correction UI controls the Vignette Correction (VC) IP and provides controls for bypassing as well as radial and lens corona correction. Inverting the functionality allows adding vignetting to the image for artistic purposes or showcasing the effect. The Radial Vignette slider simulates radial vignetting as commonly seen on fisheye lenses. Likewise, the Lens Corona simulates the effects of a strong light source on an imperfect lens, showing as a bright spot in the center. The Application software translates the controls into a mesh of coefficients that the VC IP uses. </p> <p>Clicking the circular arrow on the tile resets the configuration to its default values.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#white-balance-correction","title":"White Balance Correction","text":"<p> <p>White Balance Correction Controls </p> <p>The White Balance Correction UI provides access to low level White Balance Correction (WBC) IP controls. This tile is locked, displaying live values for most of the white balance modes in the Auto White Balance Control as the settings are controlled by the Application software. Disable Auto White Balance to enable manual WBC controls. </p> <p>Clicking the circular arrow on the tile resets the configuration to its default values.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#demosaic","title":"Demosaic","text":"<p> <p>Demosaic Controls </p> <p>The bypass control is the only option in the Demosaic UI controls. In bypass mode the Demosaic IP generates an RGB monochrome output image by simply replicating the single color of a given input CFA pixel to all 3 color planes to generate the given output RGB pixel.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#unsharp-mask-filter","title":"Unsharp Mask Filter","text":"<p> <p>Unsharp Mask Filter Controls </p> <p>The Unsharp Mask Filter UI controls the strength of the sharpening applied to the image. Positive strengths will sharpen the image, while negative strengths will soften the image. </p> <p>Clicking the circular arrow on the tile will reset the configuration of the IP to its default values.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#color-correction-matrix","title":"Color Correction Matrix","text":"<p> <p>Color Correction Matrix Control </p> <p>The Color Correction Matrix (CCM) UI is an artistic control interface for tuning the CCM (which is implemented by the Color Space Converter (CSC) IP). The white balance function of the application software calculates a base CCM targeting an accurate representation of the scene. The application software calculates the final CCM based on the control settings on the Color Correction Matrix UI:</p> <ul> <li>Hue, Saturation, and Value (Brightness) controls enable transformations in the HSV color space.</li> <li>Enabling color temperature post-processing enables further control for the color temperature and tint on top of the values set by the white balance controls.</li> <li>Red, Green, Blue Channel Strength sliders enable transformations in the RGB color space.</li> <li>Contrast adjustment and raising image floor change the dynamic range of the image.</li> </ul> <p>Clicking the circular arrow on the tile of the UI resets the functionality of these controls to their default values.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#output-config-tab","title":"Output Config Tab","text":"<p> <p>Output Config Tab </p> <p>The Output Config tab contains UI controls for IP Cores typically located after the ISP core pipeline, right up to and including the output.  </p> <p>This section summarizes the GUI controls in the Output Config Tab:</p> <ul> <li>1D LUT and Color Volume Manipulations Controls</li> <li>Tone Mapping Operator</li> <li>Warp Engine</li> <li>1D LUT</li> <li>Logo</li> <li>Frame Writer</li> <li>Output Source</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#1d-lut-and-color-volume-manipulation-controls","title":"1D LUT and Color Volume Manipulation Controls","text":"<p> <p>1D LUT \u2013 3D LUT \u2013 3D LUT Control Chain </p> <p>The output of the ISP core functions is linear which is not suited for viewing on a video sink, capturing, or broadcasting. The 1D LUT \u2013 3D LUT \u2013 3D LUT chain enables fine-grained controls for the color compression and color volume of the image to better match the end device. </p> <p>An example video pipeline is to compress linear video to the sRGB domain with the 1D LUT, then change the color volume to better match Hybrid Log Gamma (HLG); and finally apply an arbitrary color volume manipulation with the final 3D LUT for artistic effects. Note that setting the 1D LUT into Legacy Gamma OETF mode with a Gamma value of 2.2 approximates a linear to sRGB transformation. </p> <p>If a complex color transformation is not necessary, then you may use one of the 3D LUTs and keep the other 3D LUT and the 1D LUT in bypass. By default, all IPs in the chain are in bypass mode. 3D LUT files are not supplied with the 4Kp60 Multi-Sensor HDR Camera Solution System Example Design. </p> <p>3D LUT IPs can support dual buffer mode to allow 2 LUT tables to be loaded and switched between. However, for resource utilization reasons, the 4Kp60 Multi-Sensor HDR Camera Solution System Example Designs only supports single buffer mode and so the LUT 2 section of the UI is grayed out.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#tone-mapping-operator","title":"Tone Mapping Operator","text":"<p>The Tone Mapping Operator (TMO) UI has controls to bypass the tone mapping and sliders to adjust the threshold and level. The threshold slider controls the strength of the tone mapping. The level slider controls the alpha blending percentage between fully processed TMO output and its original input. The tone mapping feature can use an ROI which can be adjusted from a pop-up panel.</p> <p></p> <p> <p>TMO Controls</p> <p></p> <p> <p>TMO ROI Editor </p> <p> </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#warp","title":"Warp","text":"<p>The main Warp UI is a popup interface you open by clicking the Show Controls button in the Warp tile.</p> <p></p> <p> <p>Warp Controls </p> <p>The dialog box that pops up has 3 blue buttons at the center/bottom which switch between the three warp editing modes: Fixed, Corners and Arbitrary. </p> <p>If any transformations go outside the warp IP's capability, the mesh will change color from blue to red indicating an invalid configuration. When the parameterization ranges become valid again, the mesh color will change back to blue. The Scale View slider zooms out the Mesh Editor which makes it possible to view transforms that could extend outside the target window. The Show alignment guide box lets you turn the 16x9 grid of squares on and off.</p> <p></p> <p> <p>Fixed Warp Controls </p> <p>The Fixed Controls panel has high-level controls for specifying a warp mesh based on various mathematical transforms. Clicking on the 3x3 mesh button on Fixed Controls title page snapshots the current mesh and changes the warp editing mode to arbitrary mesh control mode. Clicking the circular arrow next to it resets the functionality of these controls to their default values.</p> <p></p> <p> <p>Corner Warp Controls </p> <p>Corner Controls mode allows you to drag 4 corners of the transformation mesh rectangle. There is also a control to apply additional radial distortion.</p> <p></p> <p> <p>Arbitrary Warp Controls </p> <p>The mesh editor in Arbitrary Controls mode lets you manually adjust the mesh by dragging any control points. The number of control points can be changed with the slider. The interface also allows you to export and import mesh files to and from your host device.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#1d-lut","title":"1D LUT","text":"<p> <p>1D LUT Control </p> <p>The 1D LUT UI allows you to apply a transfer function to the output video image to match the video sink. You may bypass the functionality or use it in one of two modes:</p> <ul> <li>Enable Gamma Layer calculates industry standard OETF, EOTF and OOTF LUTs from the options provided. The default transfer function is an OETF Gamma Curve compliant with BT.709 standard.</li> <li>Enable Custom Curve allows you to draw a custom transfer function curve using the Custom Curve Editor popup window. The background histogram allows you to guide shaping the transfer function, and you have the option of using the full screen or ROI histograms. You adjust the ROI using the UI pane provided in the bottom left corner of the popup window. The number of segments allows you to control more points on the transfer function window. Resetting the curve changes the curve to a unity transfer function.</li> </ul> <p>Clicking the circular arrow on the title of the UI resets the functionality of these controls to their default values.</p> <p></p> <p> <p>Custom Curve Editor </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#logo","title":"Logo","text":"<p> <p>Logo Control </p> <p>The Logo UI controls the position and opacity of the Altera\u00ae logo on the screen. The UI also lets you adjust the location of the logo which can be positioned in each corner or configured to bounce across the screen. The opacity slider determines how transparent the Logo is, where 1 is fully opaque and 0 is fully transparent. The Logo also has a configurable screensaver function to protect screen burn-in where applicable. If you enable the screensaver, the screen output will drop to a black background with the logo bouncing across the screen. Interact with the GUI on your web browser to get out of the screensaver.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#frame-writer","title":"Frame Writer","text":"<p> <p>Frame Writer Controls </p> <p>The Frame Writer UI allows you to take screenshots of the raw sensor input image or the final processed output image prior to the final Gamma 1D LUT. Clicking Raw Camera Snapshot or ISP Output Snapshot, captures a single image from the input or output of the video pipeline, respectively. The Download Image button allows you to download a 48-bit MSB-aligned RGB TIFF image to the device running the Web browser. Just as in Demosaic bypass, the application software replicates CFA data to the RGB channels when you select raw capture. </p> <p>Note that the output flickers while the image capture is in progress and the GUI becomes unresponsive for a moment. A popup notification indicates that the application software has finished the capture process, and that the image is ready for download.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#output-source","title":"Output Source","text":"<p> <p>Output Source Control </p> <p>The Output Source UI controls which output is selected:</p> <ul> <li>Select the ISP option to output the fully processed final image.</li> <li>Select the SMPTE Bars option to output an unprocessed SMPTE color bar image. This option allows you to test the video connection to the video sink.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#pipeline-statistics-tab","title":"Pipeline Statistics Tab","text":"<p> <p>Pipeline Statistics Tab </p> <p>The Pipeline Statistics Tab contains UI controls to help visualize the statistics IPs within the ISP pipeline.  </p> <p>This section summarizes the GUI controls in the Pipeline Statistics Tab:</p> <ul> <li>Black Level Statistics</li> <li>White Balance Statistics</li> <li>Histogram Statistics</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#black-level-statistics","title":"Black Level Statistics","text":"<p> <p>Black level Statistics </p> <p>The Black Level Statistics UI visualizes the black level from the white balance algorithm. The channels are color-coded so that they match the color channels of the CFA pattern. Note that the BLS IP remains in bypass in normal operation and is only used during calibration. The application software shows these calibrated statistics used by the white balance algorithm.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#white-balance-statistics","title":"White Balance Statistics","text":"<p> <p>White Balance Statistics </p> <p>The White Balance Statistics UI shows a color ratio representation of a captured scene from the camera input. The scene is split into 7x7 zones and clicking on a grid square will select and visualize the ratios below. </p> <p>It is important to note that the color grid does not capture luminosity, only color ratios. Therefore, results in some zones may appear unusual. For example, dark gray and light gray sections will be indistinguishable. </p> <p>The UI works on a captured scene. You can use the \"Update\" button to force a scene capture update.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/camera_4k_resources/ui-funct-descr/#histogram-statistics","title":"Histogram Statistics","text":"<p> <p>Histogram Statistics </p> <p>The Histogram Statistics UI shows a luminosity histogram of the current scene. The Auto Exposure algorithm uses the histogram statistics in the background as part of the brightness control function. </p> <p>The histogram automatically updates at a frequency of 1Hz, which you may disable using the Auto Update checkbox. Read Stats button triggers a manual update of the histogram. </p> <p>The Histogram Statistics IP calculates two histograms, one for the entire frame and the other for an ROI. The display mode dropdown box allows you to display either histogram statistics separately, or overlays them on the UI. </p> <p>Finally, the \"Edit ROI\" button opens a popup window for adjusting the ROI. </p> <p> Back </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/board-host-pc-setup/","title":"Board host pc setup","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/board-host-pc-setup/#board-and-host-pc-setup","title":"Board and Host PC Setup","text":"<p>Warning</p> <p>Handle ESD-sensitive equipment (boards, microSD Cards, Camera sensors, etc.) only when properly grounded and at an ESD-safe workstation</p> <p>Make the required connections between the Host PC and the Modular Development board as shown in the following diagram:</p> <p></p> <p> <p>Development Kit and Host PC Connection diagram </p> <ul> <li>Connect the Framos cable(s) between the Framos Camera Module(s) and the Modular   Development board taking care to align the cable(s) correctly with the   connectors (pin 1 to pin 1). For a single camera module, either MIPI connector can be used.</li> </ul> <p> <p>Board MIPI connections </p> <p> <p>Board MIPI and Ribbon Cable </p> <p> <p>Camera and Ribbon Cable </p> <p> <p>Board with Connections </p> <ul> <li>Connect the Modular Development carrier board DisplayPort Tx connector to the   Monitor using a suitable cable (and dongle if you are using HDMI).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/board-setup/","title":"Board setup","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/board-setup/#setting-up-your-modular-development-board","title":"Setting Up your Modular Development Board","text":"<p>Warning</p> <p>Handle ESD-sensitive equipment (boards, microSD Cards, Camera sensors, etc.) only when properly grounded and at an ESD-safe workstation</p> <ul> <li>Configure the board switches as shown:</li> </ul> <p></p> <p> <p>Modular Development Board - Default Switch Positions </p> <p>Main switch configurations used by the Camera Solution System Example Design</p> <p>JTAG Mode:         SOM S4=OFF:OFF, or ASx4 (QSPI) Mode:  SOM S4=ON:ON</p> <p></p> <ul> <li>Connect micro USB cable between the carrier board (<code>J35</code>) and the Host PC.   This will be used for JTAG communication. Look at what ports are enumerated   on your Host computer. There should be a series of four.</li> <li>Connect micro USB cable between the SOM board (<code>J2</code>, HSP_UART) and the Host   PC. This will be used for HPS UART communication. Look at what ports are   enumerated on your Host computer. There should be a series of four. Use the   3rd one in the list as the HPS serial port.</li> <li>Connect an RJ45 cable between the ethernet port on the SOM board (<code>J6</code>, ETH   1G HPS) and make sure it is on the same network as your Host PC. You can   check the <code>eth0</code> IP address after boot using the Linux <code>ip a</code> command.</li> </ul> <p></p> <p> <p>Board Connections </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/burn-sd-card/","title":"Burn sd card","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/burn-sd-card/#burn-the-microsd-card-image","title":"Burn the microSD Card Image","text":"<ul> <li>Either use your own or download the pre-built <code>&lt;name&gt;.wic.gz</code> image.</li> <li> <p>Extract <code>&lt;name&gt;.wic</code> image from the zip file</p> <ul> <li>On Linux, use the <code>dd</code> utility:</li> </ul> <pre><code>tar -xzf `&lt;name&gt;.wic.gz`\n</code></pre> <ul> <li>On Windows, use the 7-Zip program (or similar):<ul> <li>Right click <code>&lt;name&gt;.wic.gz</code> file, and select \"Extract All...\"</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p>Write the <code>&lt;name&gt;.wic</code> image to the microSD card using a USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility:</li> </ul> <pre><code># Determine the device associated with the SD card on the host computer.\ncat /proc/partitions\n# This will return for example /dev/sd&lt;x&gt;\n# Use dd to write the image in the corresponding device\nsudo dd if=&lt;name&gt;.wic of=/dev/sd&lt;x&gt; bs=1M\n# Flush the changes to the microSD card\nsync\n</code></pre> <ul> <li> <p>On Windows, use the Win32DiskImager program (or similar):</p> <ul> <li>Click browse icon and select \"*.*\" filter:</li> </ul> <p> <p>Navigate to your download and select <code>&lt;name&gt;.wic</code> in the \"Disk Imager\" tool </p> <ul> <li>Write the image (note your Device may be different to that shown):</li> </ul> <p> <p>Write the microSD Card using the \"Disk Imager\" tool </p> <ul> <li>Turn off the board and insert the microSD card in the microSD card slot   located on the SOM board.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/connect-browser/","title":"Connect browser","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/connect-browser/#connect-browser-to-ui","title":"Connect Browser to UI","text":"<ul> <li>Power up the board (if not already powered) and set up the serial terminal emulator (minicom,   [teraterm], [putty], etc.):<ul> <li>Select the correct <code>COMx</code> port. (The Modular Development board presents 4   serial COM ports over a single connection and the Linux system uses the 3rd   port in order). Set the port configuration as follows:<ul> <li>115200 baud rate, 8 Data bits, 1 Stop bit, CRC and Hardware flow control   disabled.</li> </ul> </li> </ul> </li> <li>The Linux OS will boot and the 4K Multi-Sensor HDR Camera Solution System   Example Design Application should run automatically.</li> <li>A few seconds after Linux boots, the application will detect the attached   Monitor and the ISP processed output will be displayed using the best   supported format.</li> <li> <p>Take note of the board's IP address.</p> <ul> <li> <p>The board's IP address can also be found using the terminal by logging in   as <code>root</code> (no password required) and querying the Ethernet controller:</p> <pre><code>root\nifconfig\n</code></pre> </li> </ul> <ul> <li><code>eth0</code> provides the IPv4 or IPv6 address to connect to. </li> </ul> </li> </ul> <p> <p>Example ifconfig output for if network provides DHCP </p> <p></p> <p></p> <p> <p>Example ifconfig output for if no DHCP support, or direct connection </p> <p></p> <ul> <li>Connect your web browser to the boards IP address so you can interact with   the 4K Multi-Sensor HDR Camera Solution System Example Design using the GUI.<ul> <li>To connect using IPv6 for the examples above you would use   <code>http://[fe80::a8bb:ccff:fe55:6688]</code> (note the square brackets)</li> <li>To connect using IPv4 for the DHCP example above you would use   <code>http://192.168.0.1</code></li> </ul> </li> </ul> <p></p> <p> <p>Example web browser URL for IPv6 address </p> <p></p> <p> <p>Example web browser URL for IPv4 address </p> <p></p> <ul> <li>During connection, you will see the Altera\u00ae splash screen, after which you   will be presented with the    Web GUI:</li> </ul> <p></p> <p> <p>Example Camera Solution GUI </p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/hw-requirements/","title":"Hw requirements","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/hw-requirements/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>[Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit].</li> </ul> <p> <p>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit </p> <ul> <li>1 or 2 [Framos FSM:GO IMX678C Camera Modules], with:<ul> <li>[Wide 110deg HFOV Lens], or</li> <li>[Medium 100deg HFOV Lens], or</li> <li>[Narrow 54deg HFOV Lens].</li> </ul> </li> <li>Mount/Tripod<ul> <li>[Framos Tripod Mount Adapter].</li> <li>[Tripod].</li> </ul> </li> <li>A Framos cable for PixelMate MIPI-CSI-2 for each Camera Module:<ul> <li>[150mm flex-cable], or</li> <li>[300mm micro-coax cable].</li> </ul> </li> <li>Minimum 8GB U3 microSD Card.</li> <li>DP Cable or HDMI Cable (with [4Kp60 Converter Dongle]).</li> <li>USB Micro B JTAG Cable (for JTAG programming).</li> <li>USB Micro B Serial Cable (for HPS terminal connection).</li> <li>RJ45 Ethernet Cable (HPS network connection).</li> <li>Monitor/TV (recommend 4Kp60 capable).</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/nios-compile/","title":"Nios compile","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/nios-compile/#compiling-and-building-the-niosv-application-and-bsp","title":"Compiling and Building the NiosV application and BSP","text":"<p>Before rebuilding the BSP, ensure that the <code>settings.bsp</code> file correctly generates. To generate BSP, use command line and <code>niosv-bsp</code> command.</p> <p>The design includes an initial version of <code>settings.bsp</code> that contains parameters to run the design. If you modify the Platform Designer's hardware, ensure you keep the integrity of the <code>settings.bsp</code> file.</p> <ul> <li> <p>After changing the <code>settings.bsp</code> file, compile the application and generate the BSP   with the command:</p> <pre><code>  cd &lt;project&gt;/software/*niosv_subsystem*\n  make\n</code></pre> </li> </ul> <p>Running <code>make</code> takes an existing template <code>settings.bsp</code> file and creates a new one based on it for the current project. It updates locations of project then builds the <code>.bsp</code> and the NiosV application. See the provided <code>makefile</code> and <code>CMakeList.txt</code> files for more details in about the software build. The app.elf file is in <code>&lt;project&gt;/software/*niosv_subsystem*/build/bin</code></p> <p>If necessary, compile the hardware again to update the <code>.sof</code> file, so it contains the new binaries (<code>.hex</code>) for memory initialization (<code>&lt;project&gt;/software/*niosv_subsystem*/build/bin/mem_init</code>).</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/notices-and-disclaimers/","title":"Notices and disclaimers","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/notices-and-disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera\u00ae products described herein. You agree to grant Altera\u00ae Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera\u00ae or product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. Altera\u00ae disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \u00a9 Altera\u00ae Corporation. Altera\u00ae, the Altera logo, and other Altera\u00ae marks are trademarks of Altera\u00ae Corporation. Other names and brands may be claimed as the property of others.</p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/prog-qspi/","title":"Prog qspi","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/prog-qspi/#program-the-qspi-flash-memory","title":"Program the QSPI Flash Memory","text":"<p>This should only need to be done once. To program the QSPI flash memory:</p> <ul> <li>Power down the board. Set MSEL=JTAG by setting the S4 dip switch   on the SOM to OFF-OFF.<ul> <li>This prevents any bootloader from starting and leaves the JTAG chain in a   default state.</li> </ul> </li> </ul> <ul> <li>Power up the board.</li> </ul> <ul> <li>Either use your own or download the pre-built <code>JIC</code> image, and write it to   the QSPI Flash memory using either the command:<pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.core.jic\" </code></pre> </li> </ul> <ul> <li> <p>or, optionally using the Quartus\u00ae Programmer GUI:</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\" settings as following: </li> </ul> </li> </ul> <p> <p>Programmer - GUI Hardware Settings </p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code>, and press \"Change File..\" </li> </ul> <p> <p>Programmer - After \"Auto Detect\" </p> <p>Select your <code>top.core.jic</code> file. The <code>MT25QU02G</code> device should be shown (see below). Check the \"Program/Configure\" box and press the \"Start\" button. Wait until the programming has been completed (which can take several minutes). </p> <p> <p>Programming the QSPI Flash with the JIC file </p> <ul> <li>Power down the board. Set MSEL=ASX4 (QSPI) by setting the S4 dip switch   on the SOM to ON-ON.<ul> <li>This starts the HPS bootloader and FPGA configuration from the microSD Card   after power up. </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/prog-sof/","title":"Prog sof","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/prog-sof/#program-the-fpga-sof","title":"Program the FPGA SOF","text":"<ul> <li> <p>To program the FPGA using SOF with first stage bootloader (fsbl):</p> <ul> <li>Power down the board. Set MSEL=JTAG by setting the S4 dip switch   on the SOM to OFF-OFF.<ul> <li>This prevents the starting of any bootloader and FPGA configuration after   power up and until the SOF is programmed over JTAG.</li> </ul> </li> </ul> <ul> <li>Power up the board.</li> </ul> <ul> <li> <p>Either use your own or download the pre-built fsbl <code>SOF</code> image, and program   the FPGA with either the command:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"p;fsbl_agilex5_modkit_vvpisp_time_limited.sof\"\n</code></pre> </li> </ul> <ul> <li> <p>or, optionally use the Quartus\u00ae Programmer GUI:</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\"   settings as follows:</li> </ul> </li> </ul> </li> </ul> <p></p> <p> <p>Programmer GUI Hardware Settings </p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code> and press   \"Change File..\" </li> </ul> <p> <p>Programmer after \"Auto Detect\" </p> <p>Select your <code>fsbl_agilex5_modkit_vvpisp_time_limited.sof</code> file. Check the \"Program/Configure\" box and press the \"Start\" button (see below). Wait until the programming has been completed.</p> <p></p> <p> <p>Programming the FPGA with SOF file </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/sw-requirements-to-build/","title":"Sw requirements to build","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/sw-requirements-to-build/#software-requirements-to-build","title":"Software Requirements to build","text":"<ul> <li>Linux OS installed.</li> <li>72 GB free storage (~2GB for Quartus\u00ae Build and ~70GB for YOCTO/KAS build).</li> <li>Python/PIP/KAS for Yocto Build (or a suitable container) see [KAS].</li> <li>[Altera\u00ae Quartus\u00ae Prime Pro Edition version 25.1 Linux].<ul> <li>Altera\u00ae Quartus\u00ae Agilex\u2122 5 Support.</li> </ul> </li> <li>FPGA NiosV Open-Source Tools 25.1 (installed with Quartus\u00ae Prime).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/sw-requirements-to-run/","title":"Sw requirements to run","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/camera/common/sw-requirements-to-run/#software-requirements-to-run","title":"Software Requirements to run","text":"<ul> <li>Host PC with:<ul> <li>8 GB of RAM (less if not rebuilding binaries).</li> <li>Linux/Windows OS installed.</li> <li>Serial terminal (such as GtkTerm or Minicom on Linux, and [TeraTerm] or   PuTTY on Windows).<ul> <li>FTDI FT232R USB UART drivers (for a Windows host).</li> </ul> </li> <li>Tool to write images for removable USB drives or microSD cards such as [Win32DiskImager] on Windows or \"dd\" command on Linux.</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition version 25.1 Programmer and Tools.</li> <li>Ethernet connection (either direct from Host PC to development board, or   via a switch or router).<ul> <li>Note, you may need to disconnected/disabled VPN if it is installed on the   Host PC.</li> </ul> </li> <li>Web browser.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/","title":"ROS Consolidated Robot Controller Example Design for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#overview","title":"Overview","text":"<p>This example design demonstrates:</p> <ul> <li>ROS 2 running on the Hard Processor System (HPS) in a Docker container.</li> <li>Embedded real-time 6-Axis motor control in the FPGA fabric.</li> <li>Robot control leveraging ROS 2, MoveIt2 and integration with Drive-on-Chip FPGA IP.</li> </ul> <p> The Robot Operating System (ROS) is a set of software libraries and tools that help you build robot applications. In this example design we demonstrate a ROS 2 based, 6-axis robot controller running on the Agilex\u2122 5 FPGA E-Series Modular Development Kit. Motor drives and control is handled by a 6-axis Drive-on-Chip design integrated with ROS 2 through a ROS Control hardware interface. MoveIt2 is used to provide path planning capabilities along with collision avoidance and scene mapping. A basic MoveIt client is provided which employs a simulated UFACTORY Lite 6 robot arm.</p> <p> <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#pre-requisites","title":"Pre-requisites","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit (MK-A5E065BB32AES1)</li> <li>Power supply</li> <li>Micro USB Cable</li> <li>Network cables</li> <li>Micro SD card and reader</li> </ul> <p>Note</p> <p>A separate PC running Linux with display out is required to setup the Agilex\u2122 5 development kit and run the ROS Visualizer (RViz).</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#software-requirements","title":"Software Requirements","text":"<ul> <li>Host PC<ul> <li>Linux OS</li> <li>Serial terminal</li> <li>Docker</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1 Programmer and Tools</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#getting-started","title":"Getting Started","text":"<p>There are 3 main components to this example design which are described below.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#fpga-drive-on-chip-design","title":"FPGA Drive-on-Chip Design","text":"<p>This example uses the 6-axis Drive-on-Chip design variant for FPGA based motor control. See HERE for more information on the design.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#hard-processor-system-hps-linux-image","title":"Hard Processor System (HPS) Linux Image","text":"<p>A custom Linux image is provided to support the Drive-on-Chip FPGA design which includes Docker and other dependencies for successfully deploying this example. The FPGA bitstream is included in the Linux image and flashed by the first-stage bootloader on boot. The Yocto layers and configuration files used to build the image can be found HERE.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#ros-2-docker-image","title":"ROS 2 Docker Image","text":"<p>A Docker build script is provided in the Altera ROS 2 repository in order to build a Docker image with the required software components to run this example. The Docker image is run on the HPS and also the host PC if visualizing the robot arm.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>Prebuilt binaries are provided to help get the example design running quickly. You can find links to the required binaries below.</p> <p> Description Links Linux Image wic.gz, wic.bmap QSPI Image top.hps.jic <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#setting-up-your-development-board","title":"Setting Up your Development Board","text":"<ul> <li>Configure the board switches:   The following provides the default configuration for all the switches in the   board.</li> </ul> <p> <p>Development Board switch position </p> <p>Main configurations used in this example design</p> <p>JTAG:     SOM SW4[2:1]=OFF:OFF  ASx4 (QSPI):  SOM SW4[2:1]=ON:ON</p> <p></p> <ul> <li>Connect micro USB cable from bottom left of the carrier board to PC (<code>J35</code>).   This will be used for JTAG communication (see figure below).</li> <li>Connect micro USB cable from bottom right of the SOM board to PC   (<code>J2</code>, HSP_UART). This will be used for HPS UART communication. Look at what   ports are enumerated on your host computer, there should be a series of   four. Use the 3rd one in the list as the HPS serial port (see figure below).</li> <li>If ethernet capabilities or remote connection via <code>ssh</code> is required connect an   ethernet cable to the ethernet port on the SOM board (<code>J6</code>, ETH 1G HPS) and make   sure your device is in the same network as your intended host device. After   Linux boots, check the IP address of the <code>end2</code> ethernet interface using the   <code>ip addr</code> command.</li> </ul> <p> <p>USB connections to the board </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#sd-card-image-flashing","title":"SD Card Image Flashing","text":"<ul> <li>Download SD card image (<code>.wic</code> or <code>.wic.gz</code>) from the prebuilt binary links above.</li> <li>Write the <code>.wic</code> or <code>.wic.gz</code> SD card image to the micro SD card using one of the options below.</li> <li>Turn off the board and insert the SD card in the micro SD card slot on the SOM board.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#usbimager-windows-linux-mac-os","title":"USBImager (Windows, Linux, Mac OS)","text":"<ul> <li>Open USBImager and click the <code>...</code> button in the top right.</li> <li>Select the image you downloaded earlier and click <code>Open</code>.</li> <li>Next select the device associated with your SD card reader from the drop-down list.</li> <li>Click <code>Write</code> to start flashing.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#bmaptool-linux","title":"bmaptool (Linux)","text":"<p>Note</p> <p>You will require a <code>.wic.bmap</code> file in addition to the <code>.wic</code> or <code>.wic.gz</code> in order to use <code>bmaptool</code>. If this is not available use <code>USBImager</code>.</p> <p>On many distributions <code>bmap-tools</code> can be installed using your distros package manager (e.g. <code>sudo apt install bmap-tools</code>).</p> <p>For more information see the Yocto documentation for <code>bmaptool</code>.</p> <p>First of all determine the device <code>logical name</code> associated with the SD card on your host:</p> <pre><code>sudo lshw -class disk\n</code></pre> <p>Use <code>bmaptool</code> to copy the image to the SD card. Make sure the <code>wic</code> image file and <code>bmap</code> file are in the same directory.</p> <pre><code>sudo bmaptool copy ${IMAGE} ${DEVICE}\n</code></pre> <p>For example:</p> <pre><code>sudo bmaptool copy core-image-minimal-agilex5_mk_a5e065bb32aes1.wic.gz /dev/sda\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#flash-the-qspi","title":"Flash The QSPI","text":"<ul> <li>Download the <code>.jic</code> image from the prebuilt binary links above.</li> <li>Power down the board.</li> <li>Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</li> <li>Power up the board.</li> <li>Program the QSPI with the following command.<pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.hps.jic\" </code></pre> </li> </ul> <ul> <li> <p>(Optional) Use the Quartus\u00ae Programmer GUI</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\"   settings as follows: </li> </ul> <p></p> <p></p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code> and press   \"Change File..\" </li> </ul> <p></p> <p></p> <ul> <li>Select the <code>.jic</code> file you downloaded earlier. The <code>MT25QU02G</code> device   should now show. Select the \"Program/Configure\" box, and press \"Start\".   Wait until completed (It could take several minutes). </li> </ul> <p></p> <p></p> </li> </ul> <ul> <li>Power down the board. Set MSEL dip switch S4 on SOM to ASX4 (QSPI): ON-ON </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#build-docker-image","title":"Build Docker Image","text":"<p>The following steps will need to be run on both the Agilex\u2122 5 development kit HPS and the host PC if you wish to run the ROS Visualizer.</p> <p>Note</p> <p>An internet connection is required to run the following commands.</p> <pre><code>git clone https://github.com/altera-fpga/altera-ros2.git\ncd altera-ros2\ndocker build -f .docker/Dockerfile -t altera-ros2 .\n</code></pre> <p>The Docker image should now be available.</p> <pre><code>docker image ls\n\nREPOSITORY                      TAG              IMAGE ID       CREATED         SIZE\naltera-ros2                     latest           92816d4b0459   6 weeks ago     3.8GB\n</code></pre> <p>The resulting Docker image includes the Altera\u00ae ROS 2 packages and examples pre-installed and ready to use.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#run-the-example-moveit-client","title":"Run The Example MoveIt Client","text":"<p>We will now deploy an instance of the example MoveIt client in a container on the HPS using the image we built previously. The MoveIt client is written in C++ and simply generates random pose goals for a given robot description before attempting to plan and execute a trajectory using the relevant <code>MoveGroup</code>. The client makes use of the <code>MoveGroupInterface</code> class making it compatible with various robot arms. In this example we will be launching an instance to control a simulated UFACTORY Lite 6 robot arm.</p> <p>ROS uses Python based <code>launch</code> files to bring up the necessary services and nodes for a given use-case. In this case we will be using the lite6_moveit_demo.launch.py launch file which intializes the required controllers, publishers and move groups along with our client application. The result is a fully simulated robot controller implementation with low-level drives handled by the FPGA through the Altera\u00ae Drive-on-Chip IP and high-level functionality provided by ROS and MoveIt running on the HPS.</p> <p>Run the following command on the HPS to start a container passing through the Drive-on-Chip UIO devices used for motor control:</p> <p><pre><code>docker run -it --rm --network host --device /dev/uio0 --device /dev/uio1 --device /dev/uio2 altera-ros2\n</code></pre> Next run the following command to launch the example:</p> <pre><code>ros2 launch moveit_demo_client lite6_moveit_demo.launch.py random:=true mode:=doc use_rviz:=false\n</code></pre> <p>Upon successful initialization you should see a stream of messages similar to that below indicating planning requests are being received by the <code>MoveGroup</code> and trajectories are being executed by the relevant controllers.</p> <pre><code>[move_group-3] [INFO]: Motion plan was computed successfully.\n[moveit_demo_client-5] [INFO]: Planning request complete!\n[moveit_demo_client-5] [INFO]: time taken to generate plan: 0.0128849 seconds\n[moveit_demo_client-5] [INFO]: Execute request accepted\n[move_group-3] [INFO]: Execution request received\n[move_group-3] [INFO]: Starting trajectory execution ...\n[move_group-3] [INFO]: sending trajectory to lite6_traj_controller\n[ros2_control_node-4] [INFO]: Received new action goal\n[ros2_control_node-4] [INFO]: Accepted new action goal\n[move_group-3] [INFO]: lite6_traj_controller started execution\n[move_group-3] [INFO]: Goal request accepted!\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#ros-visualizer-rviz","title":"ROS Visualizer (RViz)","text":"<p>In order to visualize what is happening behind the scenes you can use a tool called RViz on your host PC.</p> <p>For the purposes of this example we will be running RViz in a Docker container using the <code>altera-ros2</code> image built earlier. For this we need our Docker container to have access to the display server on the host in order to load a graphical application. To make this easier it is recommended to use Rocker.</p> <ul> <li>Follow the official installation instructions to install Rocker</li> <li>Once installed run the following command to start RViz</li> </ul> <pre><code>rocker --x11 --devices /dev/dri --network host altera-ros2 rviz2\n</code></pre> <p>Note</p> <p>If you are using a Nvidia graphics card in your host you will need to follow these additional steps and include the <code>--nvidia</code> flag in the command above.</p> <ul> <li>Once RViz has loaded go to the left-hand panel and find <code>Fixed Frame</code> under <code>Global Options</code>. Select <code>world</code> from the drop-down list as in the screenshot below.</li> </ul> <p> <p></p> <p></p> <ul> <li>Next click the <code>Add</code> button at the bottom of the left-hand panel and select <code>PlanningScene</code> in the popup window before finally clicking <code>OK</code>.</li> </ul> <p> <p></p> <p></p> <p>At this point you should see a live visualization of the robot arm moving from pose to pose. The planning scene includes a table with the robot arm on top.</p> <p> <p></p> <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera\u00ae products described herein. You agree to grant Altera\u00ae Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera\u00ae or product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. Altera\u00ae disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \u00a9 Altera\u00ae Corporation. Altera\u00ae, the Altera logo, and other Altera\u00ae marks are trademarks of Altera\u00ae Corporation. Other names and brands may be claimed as the property of others.</p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#overview","title":"Overview","text":"<p>This design demonstrates how to achieve IEC 61508 SIL 2 and ISO 13849 Cat 3 PLd safety certification using Agilex\u2122 5 SoC devices. The design is based on the T\u00dcV Rheinland approved Intel\u00ae Cyclone V SoC FPGA Cat 3 PLd and SIL 2 safety concept.</p> <p>Altera\u00ae does not intend you to certify the design. Therefore, Altera\u00ae only applies the safety design process described in IEC 61508 only where relevant. The design shows how you apply the Altera\u00ae SoC FPGA Cat 3 PL d and SIL 2 safety concept. The architecture is based around a particular component of the drive-on-chip, the speed limit. You can extend the concept to monitor, cross-compare, and control other relevant physical and logical variables that are key for safety.</p> <p>This design demonstrates synchronous control of up to two three-phase permanent magnet synchronous motors (PMSMs) or brushless DC (BLDC) motors. The design includes a motor and power board model that removes the need for a physical motor setup. This design is an extension of the existing Drive-on-Chip Design Example for Agilex\u2122 5 Devices. It includes safety function to demonstrate how Agilex\u2122 5 SoC devices may achieve IEC 61508 SIL 2 or ISO 13849 Cat 3 PL d safety certification.</p> <p>You need an Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit to run the design. The motor and power model helps you tune and test the control system before using a physical power stage. The motor and power board model are based on the former Tandem Motion 48 V board, described in AN 994 Drive-on-Chip Design Example for Agilex\u2122 7 Devices.</p> <p></p> <p> <p>High-Level Block Diagram of the Drive-On-Chip  with Functional Safety Design Example. </p> <p>The blocks in yellow belong to the original Drive-On-Chip Design Example for \u2122 5 Devices. The blocks in green are the implementation of the FPGA safety channel and the blue blocks are the implementation of the HPS safety channel. The diagram shows the logic that the design shares between both channels necessary to process the safety response time (1ms) and for data sharing for cross-comparison.</p> <p>The following diagrams provide an overview of the interaction of software and hardware components in this example design.</p> <p></p> <p> <p>High-Level HW/SW Block Diagram of the Drive-On-Chip with Functional Safety Design Example. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#pre-requisites","title":"Pre-requisites","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#software-requirements-to-run","title":"Software Requirements to run","text":"<p>The following are required to be able to fully exercise the Agilex\u2122 5 Modular Development Kit:</p> <ul> <li>Host PC with<ul> <li>8 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding.</li> <li>Linux/Windows OS installed.</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or   PuTTY on Windows)</li> <li>Tool to write images for USB sticks or SD cards such as DiskImager or Rufus</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1</li> <li>To run the GUI:<ul> <li>Python 3.10.5</li> <li>Pip 22.2.2</li> <li>Python libraries: Pyside6 (6.3.2), pyqtgraph (0.13.1), numpy (1.23.2),   Python Standard Libraries: traceback, sys, re, math, struct, subprocess,   os, time, threading.</li> </ul> </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#software-requirements-to-build","title":"Software Requirements to build","text":"<ul> <li>Linux OS installed.</li> <li>62 GB free storage (~2GB for Quartus\u00ae Build and ~60GB for YOCTO/KAS build)</li> <li>Python/PIP/KAS for Yocto Build (or a suitable container).</li> <li>FPGA NiosV/g Open-Source Tools 25.1 (installed with Quartus\u00ae Prime).</li> <li>Altera\u00ae Quartus\u00ae Agilex\u2122 5 Support</li> <li>MATLAB 2021b with Simulink (Optional).</li> <li>DSP Builder for Altera\u00ae FPGAs Pro Edition v25.1 (Optional).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Altera\u00ae Agilex\u2122; 5 FPGA E-Series 065B Modular Development Kit,   ordering code MK-A5E065BB32AES1. Refer to   Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit   for more information about the development kit.</li> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable (optional)</li> <li>Micro SD card and USB card writer</li> </ul> <ul> <li>Optional:<ul> <li>Motor and power board</li> </ul> </li> </ul> <p> <p>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#sources","title":"Sources","text":"<p>The sources provided in this table are the latest and greatest recommended for Quartus\u00ae 25.1 builds. It is recommended to the user to use updated version of the building blocks for production environments. This is an example design not ready for production or end-production.</p> <p></p> <p> <p>Example Design Source Repositories.</p> Component Location Branch Assets Release Tag https://github.com/altera-fpga/agilex-ed-drive-on-chip/releases/tag/rel-safety-25.1 rel-safety-25.1 Drive-On-Chip Variants https://github.com/altera-fpga/agilex-ed-drive-on-chip rel/25.1 Modular Design Toolkit https://github.com/altera-fpga/modular-design-toolkit re/25.1 Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.12.11-lts Arm Trusted Firmware https://github.com/ARM-software/arm-trusted-firmware socfpga_v2.12.0 U-Boot https://github.com/altera-opensource/u-boot-socfpga v2025.01 Yocto Project: poky https://git.yoctoproject.org/poky scarthgap Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#getting-started-run-with-pre-build-binaries","title":"Getting Started - run with pre-build binaries","text":"<p>Follow the instructions provided in this section to run this example design in Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#download-the-minimum-pre-built-binaries","title":"Download the minimum Pre-built Binaries","text":"<ul> <li>Download the Agilex\u2122 5 Modular Development Kit binaries that are located at:</li> </ul> <p> <p>Binaries</p> Boot Source Link SD Card wic.gz, wic.bmap QSPI top.hps.jic GUI doc-gui.zip <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#setting-up-your-development-board","title":"Setting Up your Development Board","text":"<ul> <li>Configure the board switches:   The following provides the default configuration for all the switches in the   board.</li> </ul> <p> <p>Development Board switch position </p> <p>Main configurations used in this example design</p> <p>JTAG:     SOM SW4[2:1]=OFF:OFF  ASx4 (QSPI):  SOM SW4[2:1]=ON:ON</p> <p></p> <ul> <li>Connect micro USB cable from bottom left of the carrier board to PC (<code>J35</code>).   This will be used for JTAG communication (see figure below).</li> <li>Connect micro USB cable from bottom right of the SOM board to PC   (<code>J2</code>, HSP_UART). This will be used for HPS UART communication. Look at what   ports are enumerated on your host computer, there should be a series of   four. Use the 3rd one in the list as the HPS serial port (see figure below).</li> <li>If ethernet capabilities or remote connection via <code>ssh</code> is required connect an   ethernet cable to the ethernet port on the SOM board (<code>J6</code>, ETH 1G HPS) and make   sure your device is in the same network as your intended host device. After   Linux boots, check the IP address of the <code>end2</code> ethernet interface using the   <code>ip addr</code> command.</li> </ul> <p> <p>USB connections to the board </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#sd-card-image-flashing","title":"SD Card Image Flashing","text":"<ul> <li>Download SD card image (<code>.wic</code> or <code>.wic.gz</code>) from the prebuilt binary links above.</li> <li>Write the <code>.wic</code> or <code>.wic.gz</code> SD card image to the micro SD card using one of the options below.</li> <li>Turn off the board and insert the SD card in the micro SD card slot on the SOM board.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#usbimager-windows-linux-mac-os","title":"USBImager (Windows, Linux, Mac OS)","text":"<ul> <li>Open USBImager and click the <code>...</code> button in the top right.</li> <li>Select the image you downloaded earlier and click <code>Open</code>.</li> <li>Next select the device associated with your SD card reader from the drop-down list.</li> <li>Click <code>Write</code> to start flashing.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#bmaptool-linux","title":"bmaptool (Linux)","text":"<p>Note</p> <p>You will require a <code>.wic.bmap</code> file in addition to the <code>.wic</code> or <code>.wic.gz</code> in order to use <code>bmaptool</code>. If this is not available use <code>USBImager</code>.</p> <p>On many distributions <code>bmap-tools</code> can be installed using your distros package manager (e.g. <code>sudo apt install bmap-tools</code>).</p> <p>For more information see the Yocto documentation for <code>bmaptool</code>.</p> <p>First of all determine the device <code>logical name</code> associated with the SD card on your host:</p> <pre><code>sudo lshw -class disk\n</code></pre> <p>Use <code>bmaptool</code> to copy the image to the SD card. Make sure the <code>wic</code> image file and <code>bmap</code> file are in the same directory.</p> <pre><code>sudo bmaptool copy ${IMAGE} ${DEVICE}\n</code></pre> <p>For example:</p> <pre><code>sudo bmaptool copy core-image-minimal-agilex5_mk_a5e065bb32aes1.wic.gz /dev/sda\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#flash-the-qspi","title":"Flash The QSPI","text":"<ul> <li>Download the <code>.jic</code> image from the prebuilt binary links above.</li> <li>Power down the board.</li> <li>Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</li> <li>Power up the board.</li> <li>Program the QSPI with the following command.<pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.hps.jic\" </code></pre> </li> </ul> <ul> <li> <p>(Optional) Use the Quartus\u00ae Programmer GUI</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\"   settings as follows: </li> </ul> <p></p> <p></p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code> and press   \"Change File..\" </li> </ul> <p></p> <p></p> <ul> <li>Select the <code>.jic</code> file you downloaded earlier. The <code>MT25QU02G</code> device   should now show. Select the \"Program/Configure\" box, and press \"Start\".   Wait until completed (It could take several minutes). </li> </ul> <p></p> <p></p> </li> </ul> <ul> <li>Power down the board. Set MSEL dip switch S4 on SOM to ASX4 (QSPI): ON-ON </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#run-the-design-example","title":"Run the design example","text":"<ul> <li>Power up the board and setup the serial terminal (minicom, putty, etc):<ul> <li>Select the correct <code>COMx</code> port. From the HPS serial UART, select the third port (out of four). </li> <li>Serial Port configuration:<ul> <li>Baud rate: 115200, Data bits: 8,   Stop bits: 1, CRC: disabled, Hardware flow control: disabled</li> </ul> </li> <li>Connect your terminal emulator.</li> </ul> </li> </ul> <ul> <li>Wait for Linux to boot, the safety application should run after ~30s.   (No inputs from the user required)</li> </ul> <ul> <li>The serial terminal should show the following:</li> </ul> <p> <p>HPS Safety Function Serial Port Printing. </p> <ul> <li>Keep the Altera\u00ae FPGA download cable and JTAG connection to the board.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#debugging-and-monitoring-the-safety-function","title":"Debugging and Monitoring the Safety Function.","text":"<ul> <li>Unzip the GUI source code:</li> </ul> <pre><code>    unzip doc-gui_1.0.0.zip\n    cd &lt;download&gt;/doc-gui_1.0.0\n</code></pre> <ul> <li>Open a terminal and run:</li> </ul> <pre><code>    python __main__.py\n</code></pre> <ul> <li>Select the right JTAG master from the menu (if it is not selected automatically).   Usually AE5(C0\u20260)...</li> </ul> <p> <p>Select the Agilex\u2122 device in the JTAG Device dropdown menu. </p> <ul> <li>When the GUI is running, change to the Safety tab, in the left panel, with the   ! symbol. The tab summarizes of the safety status of the design.The Safety   tab shows information about the status of both safety channels, FPGA and HPS.   The estimated speed, the payload comparison results, the over-speed detection   and the payload count. The Status widget shows if the motor goes into safe state.</li> </ul> <p></p> <p> <p>Safety Function Tab. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#looking-into-the-drive-on-chip-output","title":"Looking into the Drive-On-Chip Output.","text":"<p>Additionally, just after few seconds fromt turning the board on, you can observe the output from the drive-on-chip application that runs in the Nios V/g processor.</p> <ul> <li>Connect a micro-USB cable to the integrated USB blaster II in the board.</li> <li>Run (source the Nios V command shell if required):</li> </ul> <pre><code>    juart-terminal -d 2 -i 0\n</code></pre> <p></p> <p> <p>Nios V/g Drive-on-chip application output. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#recommended-user-flows","title":"Recommended User Flows","text":"<p>With the available resources, you can build, compile, modify, and execute this design example. Additionally, there are two extra user flows that you can explore.</p> <ul> <li>User Flow 1: Getting Started - Running with pre-build binaries.</li> <li>User Flow 2: Running the example design using the QAR and KAS</li> <li>User Flow 3: Running the example design by create/build Modular Design   Toolkit (MDT) and KAS.</li> </ul> <p> <p>More resources.</p> Source Link Pre-created QAR file DOC_SAFETY_TANDEM_MOTORSIM_AGILEX5.qar JIC/RBF files top.hps.jic top.core.rbf u-boot-spl-dtb.hex u-boot-spl-dtb.hex HPS Channel Safety Application hpssafechannel_1.0.tar.gz <p></p> <p> <p>Recommended User Flows.</p> User Flow Description User flow 1 User flow 2 User flow 3 Pre-requisites Software Requirements to run. \u2713 \u2713 \u2713 Software Requirements to build. \u2717 \u2713 \u2713 Hardware Requirements. \u2713 \u2713 \u2713 Download the minimum Pre-built Binaries. \u2713 \u2717 \u2717 HW-Compilation Compile pre-created QAR with Quartus\u00ae. \u2717 \u2713 \u2717 Generating and Building the NiosV/g BSP for the Drive-On-Chip Application. \u2717 \u2713 \u2717 Creating and Building the Design based on Modular Design Toolkit (MDT). \u2717 \u2717 \u2713 Creating the QSPI Flash and SD card configuration bitstreams for the board (JIC/RBF). \u2717 \u2713 \u2713 SW-Compilation Create SD card image (.wic) using YOCTO/KAS NOTE: use KAS_MACHINE=agilex5_modular and kas-safety_dual_axis.yml configuration \u2717 \u2713 \u2713 Programming Setting Up your Development Board. \u2713 \u2713 \u2713 Burn the SD card image. \u2713 \u2713 \u2713 Program the QSPI Flash Memory. \u2713 \u2713 \u2713 Testing Run the example design. \u2713 \u2713 \u2713 Debugging and Monitoring the Safety Function. \u2713 \u2713 \u2713 Looking into the Drive-On-Chip Output. \u2713 \u2713 \u2713 <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#example-design-documentation","title":"Example Design Documentation","text":"<p>Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices</p> <ul> <li>Design Example Safety Features.</li> </ul> <ul> <li>FPGA Channel - Hardware Functional Description.</li> </ul> <ul> <li>Safety IP Input-Output Signals and Register List.</li> </ul> <ul> <li>HPS Channel Safety Software - Custom Linux.</li> </ul> <ul> <li>HPS Channel Safety Software - Speed Monitoring Safety Application.</li> </ul> <ul> <li>Drive-on-Chip with Functional Safety Design Recommendations and Disclaimers.</li> </ul> <ul> <li>Acronyms and Terminology.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#other-drive-on-chip-documentation-and-references","title":"Other Drive-On-Chip Documentation and References","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#example-designs","title":"Example Designs","text":"<ul> <li>Drive-On-Chip with PLC System Example Design for Agilex\u2122 Devices</li> <li>ROS Consolidated Robot Controller Example Design for Agilex\u2122 5 Devices</li> <li>Agilex\u2122 5 FPGA - Drive-On-Chip Design Example</li> <li>Intel\u00ae Agilex\u2122 7 FPGA \u2013 Drive-On-Chip for Intel\u00ae Agilex\u2122 7 Devices Design Example</li> <li>Agilex\u2122 7 FPGA \u2013 Safe Drive-On-Chip Design Example</li> <li>Agilex\u2122 5 E-Series Modular Development Kit GSRD User Guide (25.1)</li> <li>Agilex\u2122 5 E-Series Modular Development Kit GHRD Linux Boot Examples</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#application-notes","title":"Application Notes","text":"<ul> <li>AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices</li> <li>AN 999: Drive-on-Chip with Functional Safety Design Example: Agilex\u2122 7 Devices</li> <li>AN 994: Drive-on-Chip Design Example for Intel\u00ae Agilex\u2122 7 Devices</li> <li>AN 773: Drive-On-Chip Design Example for Intel\u00ae MAX\u00ae 10 Devices</li> <li>AN 669: Drive-On-Chip Design Example for Cyclone V Devices</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#user-manuals","title":"User Manuals","text":"<ul> <li>Hard Processor System Technical Reference Manual: Agilex\u2122 5 SoCs (25.1)</li> <li>NiosV Processor for Altera\u00ae FPGA</li> <li>Tandem Motion-Power 48 V Board Reference Manual</li> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit</li> <li>Motor Control Designs with an Integrated FPGA Design Flow</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera\u00ae products described herein. You agree to grant Altera\u00ae Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera\u00ae or product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. Altera\u00ae disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \u00a9 Altera\u00ae Corporation. Altera\u00ae, the Altera logo, and other Altera\u00ae marks are trademarks of Altera\u00ae Corporation. Other names and brands may be claimed as the property of others.</p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/","title":"Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#drive-on-chip-with-plc-design-example-for-agilextm-devices","title":"Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices","text":"<p> Select your device: </p> Agilex\u2122 5 Agilex\u2122 3 <p> <p>Currently selected: None</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#overview","title":"Overview","text":"<p>This example demonstrates:</p> <ul> <li>Use of a Programmable Logic Controller (PLC) runtime to control FPGA IP   via an IEC 61131 PLC application.</li> <li>Embedded Real Time Dual Axis motor control in the FPGA fabric.</li> <li>Deployment of a Docker container on the Agilex\u2122 SoC HPS running Linux.</li> <li>Monitoring the motor drives via the Python GUI and JTAG interface.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#programmable-logic-controller","title":"Programmable Logic Controller","text":"<p>The Programmable Logic Controller has been a fundamental component of industrial automation for decades.  The IEC 61131-3 standard that defines the programming languages of these devices provides compatibility across different manufacturers and a familiar programming environment for the technicians who install and configure them.</p> <p>The Drive-on-Chip with PLC Design Example for Agilex\u2122 Devices shows how the PLC programming environment can be used to interface to Motor Control Soft IP in the FPGA fabric. The design example combines a PLC Runtime, webserver and multi-axis simulated motor drives.  The PLC runtime runs PLC applications.  The webserver provides the interface to monitor the motor drives. The design includes a motor and power board model on the FPGA that removes the need for a physical motor setup.</p> <p>The following diagrams provide an overview of the interaction of software running on ARM CPUs inside the Hard Processor Subsystem (HPS) and hardware components running in the programmable logic (FPGA) parts of the device.</p> <p>For more information of ARM HPS in Altera\u00ae Agilex\u2122 Devices refer to User Manuals section.</p> <p></p> <p> <p>High-Level Block Diagram of the Drive-OnChip  with PLC Design Example. </p> <p>The previous figure shows that the PLC Runtime and webserver run in a Docker container on the HPS Operating System (OS, Custom Linux). The Docker container separates the applications from the operating system. The container includes the runtime libraries and software utilities required by the PLC application to run. The connections to the operating system are the only interfaces needed for the motor control and web interface to execute.</p> <p>The Drive-On-Chip (DoC) Python GUI monitors the simulated motor axes. The connection to the Drive-on-Chip IP in the FPGA is a JTAG interface that bypasses the HPS.  The GUI provides a confirmation of the activity of the motor axes independent of the software on the HPS.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#pre-requisites","title":"Pre-requisites","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#software-requirements-to-run","title":"Software Requirements to run","text":"<p>The following are required to be able to fully exercise the Agilex\u2122 Development Kit:</p> <ul> <li>Host PC with<ul> <li>8 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding.</li> <li>Linux/Windows OS installed.</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or   PuTTY on Windows).</li> <li>Tool to write images for USB sticks or SD cards such as \"DiskImager\" or \"Rufus\".</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1/25.1.1 Programmer and Tools.</li> <li>To run the GUI:<ul> <li>Python 3.10.5</li> <li>Pip 22.2.2</li> <li>Python libraries: Pyside6 (6.3.2), pyqtgraph (0.13.1), numpy (1.23.2),   Python Standard Libraries: traceback, sys, re, math, struct, subprocess,   os, time, threading.</li> </ul> </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#software-requirements-to-build","title":"Software Requirements to build","text":"Agilex\u2122 5Agilex\u2122 3 <ul> <li>Linux OS installed.</li> <li>62 GB free storage (~2GB for Quartus\u00ae Build and ~60GB for YOCTO/KAS build).</li> <li>350 MB for Docker Container Cross-Compilation.</li> <li>Python/PIP/KAS for Yocto Build (or a suitable container).</li> <li>Docker Engine Version 26.0 or later with Buildx support for ARM64.</li> <li>Full Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1 </li> <li>FPGA NiosV/g Open-Source Tools 25.1 (installed with Quartus\u00ae Prime).</li> <li>Altera\u00ae Quartus\u00ae Agilex\u2122 5 Support.</li> <li>MATLAB 2021b with Simulink (Optional).</li> <li>DSP Builder for Altera\u00ae FPGAs Pro Edition v25.1 (Optional).</li> </ul> <ul> <li>Linux OS installed.</li> <li>62 GB free storage (~2GB for Quartus\u00ae Build and ~60GB for YOCTO/KAS build).</li> <li>350 MB for Docker Container Cross-Compilation.</li> <li>Python/PIP/KAS for Yocto Build (or a suitable container).</li> <li>Docker Engine Version 26.0 or later with Buildx support for ARM64.</li> <li>Full Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>FPGA NiosV/g Open-Source Tools 25.1.1 (installed with Quartus\u00ae Prime).</li> <li>Altera\u00ae Quartus\u00ae Agilex\u2122 3 Support.</li> <li>MATLAB 2021b with Simulink (Optional).</li> <li>DSP Builder for Altera\u00ae FPGAs Pro Edition v25.1.1 (Optional).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#hardware-requirements","title":"Hardware Requirements","text":"Agilex\u2122 5Agilex\u2122 3 <ul> <li>Altera\u00ae Agilex\u2122; 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit for more information about the development kit.</li> <li>Power supply.</li> <li>2 x Micro USB Cable.</li> <li>USB cable (USB A to micro USB) \u2013 JTAG connector.</li> <li>USB cable (USB A to micro USB) \u2013 Serial console.</li> <li>Network cables.</li> <li>Router (including power supply).</li> <li>Micro SD card and USB card writer.</li> </ul> <ul> <li>Agilex\u2122 3 FPGA and SoC C-Series Development Kit, ordering code DK-A3W135BM16AEA Refer to Agilex\u2122 3 FPGA C-Series Development Kit for more information about the development kit.</li> <li>USB-C Power supply (27E to 54W).</li> <li>USB cable (USB A to USB C) \u2013 JTAG connector.</li> <li>USB cable (USB A to micro USB) \u2013 Serial console.</li> <li>Network cables.</li> <li>Router (including power supply).</li> <li>Micro SD card and USB card writer.</li> </ul> Agilex\u2122 5Agilex\u2122 3 <p> <p>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit. </p> <p> <p>Agilex\u2122 3 FPGA and SoC C-Series Development Kit. </p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#sources","title":"Sources","text":"<p>The sources listed in this table are the most current and highly recommended for Quartus\u00ae builds. Users are advised to utilize the updated versions of these building blocks in production environments. Please note that this is a sample design and is not suitable for production or final deployment.</p> <p></p> <p> <p>Example Design Source Repositories.</p> Agilex\u2122 5Agilex\u2122 3 Component Location Branch Assets Release Tag https://github.com/altera-fpga/agilex-ed-drive-on-chip/releases/tag/rel-plc-25.1 rel-plc-25.1 Drive-On-Chip Variants https://github.com/altera-fpga/agilex-ed-drive-on-chip rel/25.1 Modular Design Toolkit https://github.com/altera-fpga/modular-design-toolkit rel/25.1 Altera FPGA PLCopen and RTMotion https://github.com/altera-fpga/altera-openplc main Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.12.11-lts Arm Trusted Firmware https://github.com/ARM-software/arm-trusted-firmware socfpga_v2.12.0 U-Boot https://github.com/altera-opensource/u-boot-socfpga v2025.01 Yocto Project: poky https://git.yoctoproject.org/poky scarthgap Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap Component Location Branch Assets Release Tag https://github.com/altera-fpga/agilex-ed-drive-on-chip/releases/tag/rel-plc-25.1.1 rel-plc-25.1.1 Drive-On-Chip Variants https://github.com/altera-fpga/agilex-ed-drive-on-chip main Modular Design Toolkit https://github.com/altera-fpga/modular-design-toolkit main Altera FPGA PLCopen and RTMotion https://github.com/altera-fpga/altera-openplc main Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.12.19-lts Arm Trusted Firmware https://github.com/ARM-software/arm-trusted-firmware socfpga_v2.12.1 U-Boot https://github.com/altera-opensource/u-boot-socfpga v2025.04 Yocto Project: poky https://git.yoctoproject.org/poky scarthgap Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#getting-started-run-with-pre-build-binaries","title":"Getting Started - run with pre-build binaries","text":"<p>Follow the instructions provided in this section to run this example design in Agilex\u2122 Development Kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#download-the-minimum-pre-built-binaries","title":"Download the minimum Pre-built Binaries","text":"<p> <p>Binaries</p> Agilex\u2122 5Agilex\u2122 3 <p>Download the Agilex\u2122 5 Modular Development Kit binaries that are located at:</p> Boot Source Link SD Card Image wic.gz, wic.bmap QSPI top.hps.jic Structured Language (ST) program agilex_doc.st GUI doc-gui.zip <p>Download the Agilex\u2122 3 Development Kit binaries that are located at:</p> Boot Source Link SD Card Image agx3-wic.gz, agx3-wic.bmap QSPI agx3-top.hps.jic Structured Language (ST) program agx3-agilex_doc.st GUI agx3-doc-gui.zip <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#setting-up-your-development-board","title":"Setting Up your Development Board","text":"Agilex\u2122 5Agilex\u2122 3 <ul> <li>Configure the board switches:   The following provides the default configuration for all the switches in the   board.</li> </ul> <p> <p>Development Board switch position </p> <p>Main configurations used in this example design</p> <p>JTAG:     SOM SW4[2:1]=OFF:OFF  ASx4 (QSPI):  SOM SW4[2:1]=ON:ON</p> <p></p> <ul> <li>Connect micro USB cable from bottom left of the carrier board to PC (<code>J35</code>).   This will be used for JTAG communication (see figure below).</li> <li>Connect micro USB cable from bottom right of the SOM board to PC   (<code>J2</code>, HSP_UART). This will be used for HPS UART communication. Look at what   ports are enumerated on your host computer, there should be a series of   four. Use the 3rd one in the list as the HPS serial port (see figure below).</li> <li>If ethernet capabilities or remote connection via <code>ssh</code> is required connect an   ethernet cable to the ethernet port on the SOM board (<code>J6</code>, ETH 1G HPS) and make   sure your device is in the same network as your intended host device. After   Linux boots, check the IP address of the <code>end2</code> ethernet interface using the   <code>ip addr</code> command.</li> </ul> <p> <p>USB connections to the board </p> <ul> <li>Configure the board switches:   The following provides the default configuration for all the switches in the   board.</li> </ul> <p> <p>Development Board switch position </p> <p></p> <ul> <li>Connect USB-C cable from top-right connector of the board to PC (<code>J2</code>).   This will be used for JTAG communication (see figure below).</li> <li>Connect micro USB cable from top left of the board to PC   (<code>U1</code>, UART). This will be used for HPS UART communication. Look at what   ports are enumerated on your host computer, there should be a new one as    soon as the board is connected to the PC.</li> <li>If ethernet capabilities or remote connection via <code>ssh</code> is required connect an   ethernet cable to the ethernet port on the board (<code>J10</code>, ETH 1G HPS) and make   sure your device is in the same network as your intended host device. After   Linux boots, check the IP address of the <code>end2</code> ethernet interface using the   <code>ip addr</code> command.</li> </ul> <p> <p>USB connections to the board </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#sd-card-image-flashing","title":"SD Card Image Flashing","text":"<ul> <li>Download SD card image (<code>.wic</code> or <code>.wic.gz</code>) from the prebuilt binary links above.</li> <li>Write the <code>.wic</code> or <code>.wic.gz</code> SD card image to the micro SD card using one of the options below.</li> <li>Turn off the board and insert the SD card in the micro SD card slot on the SOM board.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#usbimager-windows-linux-mac-os","title":"USBImager (Windows, Linux, Mac OS)","text":"<ul> <li>Open USBImager and click the <code>...</code> button in the top right.</li> <li>Select the image you downloaded earlier and click <code>Open</code>.</li> <li>Next select the device associated with your SD card reader from the drop-down list.</li> <li>Click <code>Write</code> to start flashing.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#bmaptool-linux","title":"bmaptool (Linux)","text":"<p>Note</p> <p>You will require a <code>.wic.bmap</code> file in addition to the <code>.wic</code> or <code>.wic.gz</code> in order to use <code>bmaptool</code>. If this is not available use <code>USBImager</code>.</p> <p>On many distributions <code>bmap-tools</code> can be installed using your distros package manager (e.g. <code>sudo apt install bmap-tools</code>).</p> <p>For more information see the Yocto documentation for <code>bmaptool</code>.</p> <p>First of all determine the device <code>logical name</code> associated with the SD card on your host:</p> <pre><code>sudo lshw -class disk\n</code></pre> <p>Use <code>bmaptool</code> to copy the image to the SD card. Make sure the <code>wic</code> image file and <code>bmap</code> file are in the same directory.</p> <pre><code>sudo bmaptool copy ${IMAGE} ${DEVICE}\n</code></pre> <p>For example:</p> <pre><code>sudo bmaptool copy core-image-minimal-agilex5_mk_a5e065bb32aes1.wic.gz /dev/sda\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#expand-the-sd-card-root-file-system-partition","title":"Expand the SD card Root File System Partition.","text":"<p>The Root File System partition (<code>root</code>, Ext4) may require resizing to accommodate larger files, such as example design applications. Users can select their preferred tool to perform this task; however, the following steps provide instructions using the <code>Disks</code> utility (based on <code>e2fsprogs</code>):</p> <ul> <li>Insert the SD card image in the Linux machine that has the <code>Disks</code> utility   installed. You should be able to see the available storage devices.</li> <li>Select the <code>root</code> partition of the SD card and click the \"gear\" icon as shown in the   figure below to display the menu. Navigate to <code>Resize...</code></li> </ul> <p> <p>Select the \"root\" partition for resizing. </p> <ul> <li>Use the slider to increment the partition storage capacity (the maximum is   recommended). Then, click the <code>Resize</code> button.</li> </ul> <p> <p>Resize the root partition to the maximum. </p> <ul> <li>Eject the disk safely. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#flash-the-qspi","title":"Flash The QSPI","text":"Agilex\u2122 5Agilex\u2122 3 <ul> <li>Download the <code>.jic</code> image from the prebuilt binary links above.</li> <li>Power down the board.</li> <li>Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</li> <li>Power up the board.</li> <li> <p>Program the QSPI with the following command.</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.hps.jic\" </code></pre> </li> </ul> <ul> <li> <p>(Optional) Use the Quartus\u00ae Programmer GUI</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\"   settings as follows: </li> </ul> <p></p> <p></p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code> and press   \"Change File..\" </li> </ul> <p></p> <p></p> <ul> <li>Select the <code>.jic</code> file you downloaded earlier. The <code>MT25QU02G</code> device   should now show. Select the \"Program/Configure\" box, and press \"Start\".   Wait until completed (It could take several minutes). </li> </ul> <p></p> <p></p> </li> </ul> <ul> <li>Power down the board. Set MSEL dip switch S4 on SOM to ASX4 (QSPI): ON-ON </li> </ul> <ul> <li>Download the <code>.jic</code> image from the prebuilt binary links above.</li> <li>Power up the board.</li> <li> <p>Program the QSPI with the following command.</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.hps.jic\" </code></pre> </li> </ul> <ul> <li> <p>(Optional) Use the Quartus\u00ae Programmer GUI</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\"   settings as follows: </li> </ul> <p></p> <p></p> <ul> <li>Click \"Auto Detect\", select the device <code>A3CW135BM16A</code> and press   \"Change File..\"</li> <li>Select the <code>.jic</code> file you downloaded earlier. The <code>MT25QU512</code> device   should now show. Select the \"Program/Configure\" box, and press \"Start\".   Wait until completed (It could take several minutes). </li> </ul> <p></p> <p></p> </li> </ul> <ul> <li>Power cycle the board. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#run-the-openplc-docker-container","title":"Run the OpenPLC Docker Container.","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#board-and-pc-setup","title":"Board and PC setup","text":"<p>Use the following diagram to connect the required equipment to run this example design.</p> <p></p> Agilex\u2122 5Agilex\u2122 3 <p></p> <p> <p>Development Kit and PC connection diagram </p> <ul> <li>Power up the board and setup the serial terminal emulator (minicom, putty, etc):</li> <li>Select the correct <code>COMx</code> port. From the HPS serial UART, select the third COM port (out of four).</li> <li>Serial Port configuration:     * Baud rate: 115200, Data bits: 8,     Stop bits: 1, CRC: disabled, Hardware flow control: disabled</li> <li>Connect your terminal emulator.</li> </ul> <p></p> <p> <p>Development Kit and PC connection diagram </p> <ul> <li>Power up the board and setup the serial terminal emulator (minicom, putty, etc):</li> <li>Select the correct <code>COMx</code> port. From the HPS serial UART.</li> <li>Serial Port configuration:     * Baud rate: 115200, Data bits: 8,     Stop bits: 1, CRC: disabled, Hardware flow control: disabled</li> <li>Connect your terminal emulator.</li> </ul> <p> To continue, select method a) or method b) to deploy a Docker container image </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#a-boot-linux-create-a-docker-image-using-the-dockerfile","title":"a) Boot Linux, create a Docker image using the Dockerfile","text":"<ul> <li>In the Development Kit, wait for Linux to boot, and clone the   \"altera-openplc\" repository:</li> </ul> <pre><code>    git clone https://github.com/altera-fpga/altera-openplc.git\n    cd altera-openplc\n</code></pre> <ul> <li>Build the Docker Image (this can take several minutes):</li> </ul> <pre><code>    docker build -t altera-plc:arm64 .\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#b-boot-linux-copy-and-load-a-cross-compiled-docker-container-image","title":"b) Boot Linux, copy and load a cross-compiled Docker container image","text":"<ul> <li>Follow the instructions provided in Altera OpenPLC Docker Container Image Cross-compilation.   to get a cross-compiled Docker image file (name it <code>altera-plc.tar.gz</code>)</li> </ul> <ul> <li>Wait for Linux to boot and query the Development Kit IP address:</li> </ul> <pre><code>    ifconfig\n</code></pre> <ul> <li>The serial terminal should show the following:</li> </ul> Agilex\u2122 5Agilex\u2122 3 <p> <p>Agilex\u2122 5 Modular Development Kit IP Address. </p> <p> <p>Agilex\u2122 3 C-series Development Kit IP Address. </p> <p></p> <ul> <li>Take a note of the board's IP address or <code>&lt;dk-ip-address&gt;</code></li> </ul> <ul> <li>Copy the PLC docker previously generated Docker container image to the board,   preferably to the <code>/home/root</code> directory in the RootFile System. The   suggested method to do it is using <code>scp</code> or <code>sftp</code> commands to transfer   the file from your host machine to the development kit.</li> </ul> <pre><code>    scp -rp altera-plc.tar.gz root@&lt;dk-ip-address&gt;:/home/root\n</code></pre> <ul> <li>Load the Image and deploy the PLC Container. To load the Docker Image use the   following commands (in the Development Kit):</li> </ul> <pre><code>    docker ps -a\n    docker load &lt; altera-plc.tar.gz\n</code></pre> <p> <p>Load the PLC Docker image. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#deploy-the-plc-container","title":"Deploy the PLC Container.","text":"<ul> <li>Verify and deploy the container.</li> </ul> <pre><code>    docker image ls\n    docker run -it --rm --device /dev/uio0 --network host altera-plc:arm64\n</code></pre> <ul> <li>The following image shows the IP address and port to interface with the   PLC web-server.</li> </ul> <p> <p>\"docker run\" command output. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#launching-the-plc-webserver-and-running-an-st-file","title":"Launching the PLC Webserver and Running an ST file.","text":"<ul> <li>In a host machine within the same network as the development kit, launch   a web browser with the address that was shown in the console window   (usually <code>http://&lt;dk-ip-address&gt;:8080</code>) and login. For example in Firefox:</li> </ul> <p>Login into the OpenPLC webserver with:</p> <p>username: openplc  password: openplc</p> <p> <p>OpenPLC Webserver interface login screen. </p> <ul> <li>Load the <code>Agilex Drive On Chip</code> OpenPLC driver. In the OpenPLC Webserver, navigate   to <code>Hardware</code> and select <code>Agilex Drive-On-Chip</code> OpenPLC Hardware Layer. Press   the <code>Save Changes</code> button and let let the compilation finish (it can take a   few minutes). When done, press the <code>Go to Dashboard</code> button at the bottom   of the page.</li> </ul> <p> <p>Agilex\u2122 Drive-On-Chip PLC driver selection. </p> <ul> <li>In the OpenPLC webserver, navigate to <code>Programs</code> tab in the left panel, then   press <code>Browse</code> and load <code>agilex_doc.st</code> file (see   Binaries). Press the button   <code>Upload Program</code>. Give the program a name, e.g. \"doc-agilex\" and press   <code>Upload Program</code> button. Let the compilation finish (this can take a few minutes).</li> </ul> <p> <p>Structured Text (ST) PLC program load and compile. </p> <ul> <li>Press the <code>Go to Dashboard</code> button to select the <code>Dashboard</code> tab and execute   the <code>.st</code> program with the button <code>Start PLC</code> in the left panel. The PLC   Controller will start to run and control the Drive On Chip system in the FPGA fabric.</li> </ul> <p> <p>Start the PLC-based Drive-On-Chip motion controller. </p> <ul> <li>In the OpenPLC webserver, in the left panel, navigate to the <code>Monitoring</code> tab.   This will show the dual axes of the \"Drive On Chip\" being controlled by   OpenPLC and the PLCopen-based RTMotion Library according to the <code>.st</code>   (structured text) program loaded previously.</li> </ul> <p> <p>OpenPLC Webserver Monitoring tab for Axis Control Visualization. </p> <p>Create and run your own program: </p> <p>You can create your own <code>.st</code> file and load it in the OpenPLC Programmable Logic Controller to modify the speed and/or position of any of the two drives in the FPGA systems (Dual Axis Drive-On-Chip)</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#monitoring-the-doc-through-jtag-interface","title":"Monitoring the DoC through JTAG interface.","text":"<p>The user can visualize the \"Drive On Chip\" (DoC) behavior using an independent JTAG channel. This channel shows the axes speed/position that is being requested by the PLC Controller. The \"Drive On Chip\" system exposes these (and other) values through JTAG chain that can be accessed with a GUI running in your local host. To visualize the DoC drive control characteristics follow these steps:</p> <ul> <li>Keep the Altera\u00ae FPGA download cable and JTAG connection to the board.</li> </ul> <ul> <li>Unzip the GUI source code, see Binaries:</li> </ul> <pre><code>unzip doc-gui_1.0.0.zip\ncd &lt;download&gt;/doc-gui_1.0.0\n</code></pre> <ul> <li>Open a terminal, install the requirements (if needed) and run:</li> </ul> <pre><code>pip install -r requirements.txt\npython __main__.py\n</code></pre> <ul> <li>Select the right JTAG master from the menu (if it is not selected automatically).   Usually AE5(C0\u20260)... (or similar)</li> </ul> <p></p> <p> <p>Select the Agilex\u2122 device in the JTAG Device dropdown menu. </p> <ul> <li>When the GUI is running, change to the \"Axis\" tab, in the left panel. The tab   shows the speed values of both Axis changing as it is shown in the OpenPLC webserver.   To see more details, press the <code>Start Trace</code> button in the right-bottom of   the GUI to display speed and position traces.</li> </ul> <p></p> <p> <p>Drive On Chip GUI for visualization. </p> <p>Warning</p> <p>Do not change speed or position values in the Python GUI. The drives are being controlled by the PLC and the GUI should be only used for visualization purposes.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#recommended-user-flows","title":"Recommended User Flows","text":"<p>With the available resources, you can build, compile, modify, and execute this design example. Additionally, there are two extra user flows that you can explore.</p> <ul> <li>User Flow 1: Getting Started - Running with pre-build binaries.</li> <li>User Flow 2: Running the example design using the QAR and KAS</li> <li>User Flow 3: Running the example design by create/build Modular Design   Toolkit (MDT) and KAS.</li> </ul> <p> <p>More resources.</p> Agilex\u2122 5Agilex\u2122 3 Source Link Pre-created QAR file DOC_PLC_TANDEM_MOTORSIM_AGILEX5.qar JIC/RBF files top.hps.jic top.core.rbf u-boot-spl-dtb.hex u-boot-spl-dtb.hex Source Link Pre-created QAR file DOC_PLC_TANDEM_MOTORSIM_AGILEX3.qar JIC/RBF files agx3-top.hps.jic agx3-top.core.rbf u-boot-spl-dtb.hex agx3-u-boot-spl-dtb.hex <p></p> <p> <p>Recommended User Flows.</p> User Flow Description User flow 1 User flow 2 User flow 3 Pre-requisites Software Requirements to run. \u2713 \u2713 \u2713 Software Requirements to build. \u2717 \u2713 \u2713 Hardware Requirements. \u2713 \u2713 \u2713 Download the minimum Pre-built Binaries. \u2713 \u2717 \u2717 HW-Compilation Compile pre-created QAR with Quartus\u00ae. \u2717 \u2713 \u2717 Generating and Building the NiosV/g BSP for the Drive-On-Chip Application. \u2717 \u2713 \u2717 Creating and Building the Design based on Modular Design Toolkit (MDT). \u2717 \u2717 \u2713 Creating the QSPI Flash and SD card configuration bitstreams for the board (JIC/RBF). \u2717 \u2713 \u2713 SW-Compilation Create SD card image (.wic) using YOCTO/KAS NOTE: use KAS_MACHINE=agilex5_modular or KAS_MACHINE=agilex3  and kas_dual_axis.yml configuration \u2717 \u2713 \u2713 Altera OpenPLC Docker Container Image Cross-compilation.  Optional  \u2717 * * Programming Setting Up your Development Board. \u2713 \u2713 \u2713 Burn the SD card image. \u2713 \u2713 \u2713 Expand the SD card Root File System Partition. \u2713 \u2713 \u2713 Program the QSPI Flash Memory. \u2713 \u2713 \u2713 Testing Run the OpenPLC Docker Container. \u2713 \u2713 \u2713 Launching the PLC Webserver and Running an ST file. \u2713 \u2713 \u2713 Monitoring the DoC through JTAG interface. \u2713 \u2713 \u2713 <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#example-design-documentation","title":"Example Design Documentation","text":"<p>Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices</p> <ul> <li>Design Example Features.</li> <li>FPGA Hardware Functional Description.</li> <li>Software Stack Functional Description.</li> <li>Drive-on-Chip with PLC Design Recommendations and Disclaimers.</li> <li>Acronyms and Terminology.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#other-drive-on-chip-documentation-and-references","title":"Other Drive-On-Chip Documentation and References","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#example-designs","title":"Example Designs","text":"<ul> <li>Drive-On-Chip with Functional Safety System Example Design for Agilex\u2122 5 Devices.</li> <li>ROS Consolidated Robot Controller Example Design for Agilex\u2122 5 Devices.</li> <li>Agilex\u2122 5 FPGA - Drive-On-Chip Design Example.</li> <li>Intel\u00ae Agilex\u2122 7 FPGA \u2013 Drive-On-Chip for Intel\u00ae Agilex\u2122 7 Devices Design Example.</li> <li>Agilex\u2122 7 FPGA \u2013 Safe Drive-On-Chip Design Example.</li> <li>Agilex\u2122 5 E-Series Modular Development Kit GSRD User Guide (25.1).</li> <li>Agilex\u2122 5 E-Series Modular Development Kit GHRD Linux Boot Examples.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#application-notes","title":"Application Notes","text":"<ul> <li>AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices.</li> <li>AN 999: Drive-on-Chip with Functional Safety Design Example: Agilex\u2122 7 Devices.</li> <li>AN 994: Drive-on-Chip Design Example for Intel\u00ae Agilex\u2122 7 Devices.</li> <li>AN 773: Drive-On-Chip Design Example for Intel\u00ae MAX\u00ae 10 Devices.</li> <li>AN 669: Drive-On-Chip Design Example for Cyclone V Devices.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#user-manuals","title":"User Manuals","text":"<ul> <li>Hard Processor System Technical Reference Manual: Agilex\u2122 5 SoCs (25.1).</li> <li>NiosV Processor for Altera\u00ae FPGA.</li> <li>Tandem Motion-Power 48 V Board Reference Manual.</li> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</li> <li>Agilex\u2122 3 FPGA C-Series Development Kit.</li> <li>Motor Control Designs with an Integrated FPGA Design Flow.</li> <li>Install Docker Engine.</li> <li>Docker Build: Multi-Platform Builds.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#external-sources","title":"External Sources","text":"<ul> <li>OpenPLC Runtime version 3.</li> <li>Ruckig: Instantaneous Motion Generation for Robots and Machines.</li> <li>PLCopen Motion Control Specification.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera\u00ae products described herein. You agree to grant Altera\u00ae Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera\u00ae or product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. Altera\u00ae disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \u00a9 Altera\u00ae Corporation. Altera\u00ae, the Altera logo, and other Altera\u00ae marks are trademarks of Altera\u00ae Corporation. Other names and brands may be claimed as the property of others.</p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/board-setup-agx3/","title":"Board setup agx3","text":"<ul> <li>Configure the board switches:   The following provides the default configuration for all the switches in the   board.</li> </ul> <p> <p>Development Board switch position </p> <p></p> <ul> <li>Connect USB-C cable from top-right connector of the board to PC (<code>J2</code>).   This will be used for JTAG communication (see figure below).</li> <li>Connect micro USB cable from top left of the board to PC   (<code>U1</code>, UART). This will be used for HPS UART communication. Look at what   ports are enumerated on your host computer, there should be a new one as    soon as the board is connected to the PC.</li> <li>If ethernet capabilities or remote connection via <code>ssh</code> is required connect an   ethernet cable to the ethernet port on the board (<code>J10</code>, ETH 1G HPS) and make   sure your device is in the same network as your intended host device. After   Linux boots, check the IP address of the <code>end2</code> ethernet interface using the   <code>ip addr</code> command.</li> </ul> <p> <p>USB connections to the board </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/board-setup/","title":"Board setup","text":"<ul> <li>Configure the board switches:   The following provides the default configuration for all the switches in the   board.</li> </ul> <p> <p>Development Board switch position </p> <p>Main configurations used in this example design</p> <p>JTAG:     SOM SW4[2:1]=OFF:OFF  ASx4 (QSPI):  SOM SW4[2:1]=ON:ON</p> <p></p> <ul> <li>Connect micro USB cable from bottom left of the carrier board to PC (<code>J35</code>).   This will be used for JTAG communication (see figure below).</li> <li>Connect micro USB cable from bottom right of the SOM board to PC   (<code>J2</code>, HSP_UART). This will be used for HPS UART communication. Look at what   ports are enumerated on your host computer, there should be a series of   four. Use the 3rd one in the list as the HPS serial port (see figure below).</li> <li>If ethernet capabilities or remote connection via <code>ssh</code> is required connect an   ethernet cable to the ethernet port on the SOM board (<code>J6</code>, ETH 1G HPS) and make   sure your device is in the same network as your intended host device. After   Linux boots, check the IP address of the <code>end2</code> ethernet interface using the   <code>ip addr</code> command.</li> </ul> <p> <p>USB connections to the board </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/burn-sd-card/","title":"Burn sd card","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/burn-sd-card/#sd-card-image-flashing","title":"SD Card Image Flashing","text":"<ul> <li>Download SD card image (<code>.wic</code> or <code>.wic.gz</code>) from the prebuilt binary links above.</li> <li>Write the <code>.wic</code> or <code>.wic.gz</code> SD card image to the micro SD card using one of the options below.</li> <li>Turn off the board and insert the SD card in the micro SD card slot on the SOM board.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/burn-sd-card/#usbimager-windows-linux-mac-os","title":"USBImager (Windows, Linux, Mac OS)","text":"<ul> <li>Open USBImager and click the <code>...</code> button in the top right.</li> <li>Select the image you downloaded earlier and click <code>Open</code>.</li> <li>Next select the device associated with your SD card reader from the drop-down list.</li> <li>Click <code>Write</code> to start flashing.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/burn-sd-card/#bmaptool-linux","title":"bmaptool (Linux)","text":"<p>Note</p> <p>You will require a <code>.wic.bmap</code> file in addition to the <code>.wic</code> or <code>.wic.gz</code> in order to use <code>bmaptool</code>. If this is not available use <code>USBImager</code>.</p> <p>On many distributions <code>bmap-tools</code> can be installed using your distros package manager (e.g. <code>sudo apt install bmap-tools</code>).</p> <p>For more information see the Yocto documentation for <code>bmaptool</code>.</p> <p>First of all determine the device <code>logical name</code> associated with the SD card on your host:</p> <pre><code>sudo lshw -class disk\n</code></pre> <p>Use <code>bmaptool</code> to copy the image to the SD card. Make sure the <code>wic</code> image file and <code>bmap</code> file are in the same directory.</p> <pre><code>sudo bmaptool copy ${IMAGE} ${DEVICE}\n</code></pre> <p>For example:</p> <pre><code>sudo bmaptool copy core-image-minimal-agilex5_mk_a5e065bb32aes1.wic.gz /dev/sda\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/expand-sd-card-rootfs/","title":"Expand sd card rootfs","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/expand-sd-card-rootfs/#expand-the-sd-card-root-file-system-partition","title":"Expand the SD card Root File System Partition.","text":"<p>The Root File System partition (<code>root</code>, Ext4) may require resizing to accommodate larger files, such as example design applications. Users can select their preferred tool to perform this task; however, the following steps provide instructions using the <code>Disks</code> utility (based on <code>e2fsprogs</code>):</p> <ul> <li>Insert the SD card image in the Linux machine that has the <code>Disks</code> utility   installed. You should be able to see the available storage devices.</li> <li>Select the <code>root</code> partition of the SD card and click the \"gear\" icon as shown in the   figure below to display the menu. Navigate to <code>Resize...</code></li> </ul> <p> <p>Select the \"root\" partition for resizing. </p> <ul> <li>Use the slider to increment the partition storage capacity (the maximum is   recommended). Then, click the <code>Resize</code> button.</li> </ul> <p> <p>Resize the root partition to the maximum. </p> <ul> <li>Eject the disk safely. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/nios-compile/","title":"Nios compile","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/nios-compile/#compiling-and-building-the-niosv-application-and-bsp","title":"Compiling and Building the NiosV application and BSP","text":"<p>Before rebuilding the BSP, ensure that the <code>settings.bsp</code> file correctly generates. To generate BSP, use command line and <code>niosv-bsp</code> command.</p> <p>The design includes an initial version of <code>settings.bsp</code> that contains parameters to run the design. If you modify the Platform Designer's hardware, ensure you keep the integrity of the <code>settings.bsp</code> file.</p> <ul> <li> <p>After changing the <code>settings.bsp</code> file, compile the application and generate the BSP   with the command:</p> <pre><code>  cd &lt;project&gt;/software/*niosv_subsystem*\n  make\n</code></pre> </li> </ul> <p>Running <code>make</code> takes an existing template <code>settings.bsp</code> file and creates a new one based on it for the current project. It updates locations of project then builds the <code>.bsp</code> and the NiosV application. See the provided <code>makefile</code> and <code>CMakeList.txt</code> files for more details in about the software build. The app.elf file is in <code>&lt;project&gt;/software/*niosv_subsystem*/build/bin</code></p> <p>If necessary, compile the hardware again to update the <code>.sof</code> file, so it contains the new binaries (<code>.hex</code>) for memory initialization (<code>&lt;project&gt;/software/*niosv_subsystem*/build/bin/mem_init</code>).</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/notices-and-disclaimers/","title":"Notices and disclaimers","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/notices-and-disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera\u00ae products described herein. You agree to grant Altera\u00ae Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera\u00ae or product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. Altera\u00ae disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \u00a9 Altera\u00ae Corporation. Altera\u00ae, the Altera logo, and other Altera\u00ae marks are trademarks of Altera\u00ae Corporation. Other names and brands may be claimed as the property of others.</p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/prog-qspi-agx3/","title":"Prog qspi agx3","text":"<ul> <li>Download the <code>.jic</code> image from the prebuilt binary links above.</li> <li>Power up the board.</li> <li>Program the QSPI with the following command.<pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.hps.jic\" </code></pre> </li> </ul> <ul> <li> <p>(Optional) Use the Quartus\u00ae Programmer GUI</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\"   settings as follows: </li> </ul> <p></p> <p></p> <ul> <li>Click \"Auto Detect\", select the device <code>A3CW135BM16A</code> and press   \"Change File..\"</li> <li>Select the <code>.jic</code> file you downloaded earlier. The <code>MT25QU512</code> device   should now show. Select the \"Program/Configure\" box, and press \"Start\".   Wait until completed (It could take several minutes). </li> </ul> <p></p> <p></p> </li> </ul> <ul> <li>Power cycle the board. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/prog-qspi/","title":"Prog qspi","text":"<ul> <li>Download the <code>.jic</code> image from the prebuilt binary links above.</li> <li>Power down the board.</li> <li>Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</li> <li>Power up the board.</li> <li>Program the QSPI with the following command.<pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;top.hps.jic\" </code></pre> </li> </ul> <ul> <li> <p>(Optional) Use the Quartus\u00ae Programmer GUI</p> <ul> <li>Launch the Quartus\u00ae Programmer and Configure the \"Hardware Setup...\"   settings as follows: </li> </ul> <p></p> <p></p> <ul> <li>Click \"Auto Detect\", select the device <code>A5EC065BB32AR0</code> and press   \"Change File..\" </li> </ul> <p></p> <p></p> <ul> <li>Select the <code>.jic</code> file you downloaded earlier. The <code>MT25QU02G</code> device   should now show. Select the \"Program/Configure\" box, and press \"Start\".   Wait until completed (It could take several minutes). </li> </ul> <p></p> <p></p> </li> </ul> <ul> <li>Power down the board. Set MSEL dip switch S4 on SOM to ASX4 (QSPI): ON-ON </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/qar-compile/","title":"Qar compile","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/qar-compile/#compiling-the-project-using-a-mdt-qar-file","title":"Compiling the project using a MDT QAR file","text":"<ul> <li>Download the relevant design <code>.qar</code> file for your development kit and power    board from  link/repository.</li> </ul> <ul> <li>Double click in the .qar file or alternatively use Quartus\u00ae command line to   open it:<pre><code>  quartus &lt;MDT_QAR_NAME&gt;.qar\n</code></pre> <p>The contents of the <code>.qar</code> file open into the working directory. The   design example has the following directory structure.</p> <p></p> <p> <p>QAR file content. </p> <p>Note: This <code>QAR</code> file was generated using the \"Modular Design Toolkit\" flow.</p> <p></p> <p> <p>QAR and Project Directory Structure.</p> Directory Description assets Contains base files to run the example design derived from the hardware compilation. non_qpds_ip Contains the source code (RTL) of the design\u2019s custom IP that is not part of Quartus\u00ae Prime. quartus Contains the base files for the Quartus\u00ae Project including the top.qpf, top.qsf. rtl Contains the sources files to build the project. scripts Contains a collection of TCL scripts from \"Modular Design Toolkit\" to build and compile the design software and hardware. sdc Contains the .sdc files for the subsystems to compile the project. software Contains all the files for building the application for the Nios V and/or HPS. Look for the app.elf binary or *_cpu_ram_cpu_ram.hex that is included in the SOF <p></p> <p></p> <ul> <li>Navigate to <code>&lt;project&gt;/quartus/</code> and open the <code>top.qpf</code> file either by double    clicking on it or using the command:<pre><code>quartus top.qpf\n</code></pre> </li> </ul> <ul> <li>To generate the <code>.sof</code> file, click on \"Processing -&gt; Start Compilation Ctrl+L\"   or simply press the \"Start Compilation\" icon in the Quartus\u00ae Prime Pro GUI.</li> </ul> <p></p> <p> <p>Quartus\u00ae Prime Pro compilation flow. </p> <p>Wait for the compilation to finish. The <code>.sof</code> file should be located in the   <code>&lt;project&gt;/quartus/output_files</code> directory. Follow the steps generate the   <code>RBF/JIC</code> file using the <code>.sof</code> file and the <code>u-boot-spl-dtb.hex</code> file.</p> <p>Note: it si recommended to generate any embedded software images that are included in the <code>.sof</code> file before compiling, i.e NiosV software.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/rbf-jic-gen/","title":"Rbf jic gen","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/rbf-jic-gen/#creating-the-qspi-flash-and-sd-card-configuration-bitstreams-for-the-board","title":"Creating the QSPI Flash and SD card configuration bitstreams for the board","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/rbf-jic-gen/#create-phase-1-and-phase-2-configuration-bitstreams-for-hps-first-flow","title":"Create phase 1 and phase 2 configuration bitstreams for \"HPS First\" Flow","text":"<p>Follow these steps if the \"HPS init\" property for the <code>hps_subsystem</code> in the <code>XML</code> is set to <code>\"HPS FIRST\"</code>. You can check this property by executing the following Quartus\u00ae command and the <code>\"\\*.sof\"</code> file. For example:</p> <pre><code>quartus_pfg -i top.sof\n</code></pre> <p>In the log, look for the property <code>\"HPS/FPGA configuration order\"</code> SET TO <code>\"HPS_FIRST\"</code></p> <p></p> <p> <p>HPS First SOF file. </p> <p>Important! The following step depends on the output of u-boot compilation specifically the file <code>u-boot-spl-dtb.hex</code>. To generate the pair <code>top.core.rbf</code> and <code>top.hps.jic</code> execute:</p> Agilex\u2122 5Agilex\u2122 3 <p>For Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre></p> <p>For [Agilex\u2122 3 FPGA and SoC C-Series Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU512 \\\n-o flash_loader=A3CW135BM16AE6S \\\n-o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/common/rbf-jic-gen/#create-phase-1-and-phase-2-configuration-bitstream-for-fpga-first-flow","title":"Create phase 1 and phase 2 configuration bitstream for \"FPGA First\" Flow","text":"<p>Follow these steps if the <code>\"HPS init\"</code> property for the hps_subsystem in the <code>XML</code> is set to <code>\"AFTER INIT_DONE\"</code>. You can check this property by executing the following Quartus\u00ae command and the <code>\"\\*.sof\"</code> file. For example:</p> <pre><code>quartus_pfg -i top.sof\n</code></pre> <p>In the log, look for the property <code>\"HPS/FPGA configuration order\"</code> SET TO <code>\"AFTER INIT_DONE\"</code></p> <p></p> <p> <p>FPGA First SOF file. </p> <p>Important! The following step depends on the output of u-boot compilation specifically the file <code>u-boot-spl-dtb.hex</code>. To generate the <code>top.jic</code> execute:</p> Agilex\u2122 5Agilex\u2122 3 <p>For Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=A5ED065BB32AE6SR0 -o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n</code></pre></p> <p>For [Agilex\u2122 3 FPGA and SoC C-Series Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU512 \\\n-o flash_loader=A3CW135BM16AE6S -o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/hw-funct-descr/","title":"6-Axis Drive-on-Chip Example Design for Agilex\u00ae 5 Devices","text":"<p>This document provides insights about the functionality of the design example using the hardware blocks as a reference. The Platform Designer high-level system includes many subsystems which are detailed below.</p> <ul> <li>The <code>clock_subsystem</code> and <code>board_subsystem</code> contain blocks related to the board resources such as buttons, switches, LEDs, reference clocks and resets. They provide the clocks and resets used by other subsystems.</li> <li>The <code>hps_subsystem</code> is an instance of the Agilex\u2122 5 HPS, which operates the higher-level software stack in Linux. It includes an External Memory Interface (EMIF) to the on-board DDR4 chip, featuring presets and connections to link the HPS2FPGA AXI bridges to other subsystems.</li> <li> <p>The subsystems <code>dniosv_subsystem</code>, <code>motor_model_subsystem</code>, <code>drive_subsystem</code>and <code>control_subsystem</code> are blocks related to motor control and motor modeling. These are instantiated to achieve 6 motor drives being controlled in the FPGA fabric (3 NiosV/g cores controlling 2 drive subsystems each).</p> <p>For more information on these blocks, refer to AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices </p> </li> </ul> <p>The following block diagrams show the main components and subsystems of the 6-Axis Drive-On-Chip design. The first diagram shows an instance of the dual-axis Drive-On-Chip design with an AXI Interface intended for the HPS Host.</p> <p> <p></p> <p></p> <p>The next diagram shows three instances of the dual-axis Drive-On-Chip design seen above connected to the AXI interface making a total of 6 axes (3x2) which can be controlled by the HPS.</p> <p> <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/hw-funct-descr/#hardware-subsystems-components","title":"Hardware Subsystems &amp; Components","text":"<p>This project variant is based on AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices and AN 994: Drive-on-Chip Design Example for Intel\u00ae Agilex\u2122 7 Devices. In this design an HPS Subsystem (Hard Processor System) has been included to provide a higher level of abstraction for motion control.</p> <p>The subsystems instantiated in the design are described below.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/hw-funct-descr/#clock-and-board-subsystems","title":"Clock and Board Subsystems","text":"<p>The clock subsystem alongside the board subsystem contains blocks related to the board resources such as buttons, switches, LEDs, reference clocks and resets. They provide the clocks and resets for the other subsystems.</p> <p> <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/hw-funct-descr/#hps-subsystem","title":"HPS Subsystem","text":"<p>The HPS subsystem is mainly an instance of the \"Hard Processor System Agilex\u2122 (or other) FPGA IP\". The HPS in this design boots a custom version of Linux built using Yocto where high-level motion control interfaces can run. Internally the subsystem is composed of the HPS, EMIF for external DDR and AXI interfaces for the lightweight and full HPS-to-FPGA bridges (highlighted in the image below). The full HPS-to-FPGA bridge is utilized to interface with the control subsystem block. This enables the HPS to modify, set and configure motor control parameters, such as adjusting speed and position.</p> <p> <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/hw-funct-descr/#cpu-dnios_-subsystem","title":"CPU (dnios_) Subsystem","text":"<p>The NiosV/g processor subsystem offers a fully functional processor system with debugging capabilities. The NiosV/g processor subsystem comprises the following Platform Designer components:  * NiosV/g softprocessor  * On-chip RAM  * JTAG master  * IRQ management  * JTAG UART  * Timers  * Performance counters</p> <p> <p></p> <p></p> <p>This soft CPU subsystem is responsible for low-level motor control, managing and initializing resources and tracing signals.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/hw-funct-descr/#drive-subsystem","title":"Drive Subsystem","text":"<p>There are a total of 6 instances of the \"drive_subsystem\" in this variant. A pair of drive subsystems are managed by a single CPU (dnios_) subsystem. This subsystem is a collection of IPs to enable interfaces, signals and ports for motor control using FPGA. The main components of this subsystem are:  * Six-channel PWM Interface IP (doc_pwm)  * Drive System Monitor IP (doc_sm)  * Quadrature Encoder Interface IP (doc_qep)  * Sigma-Delta ADC interfaces for Drive Axes (doc_adc and doc_adc_pow)  * Field-Oriented Control Algorithm IP generated with DSP Builder (doc_foc_fixp)  * Resolver SPI interface IP (doc_rslvr_spi*)  * Parallel IO IP (hall pio) for hall interface</p> <p> <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/hw-funct-descr/#control-subsystem","title":"Control Subsystem","text":"<p>The Drive-On-Chip design uses the debugging RAM to send commands and receive status information. The debugging dump memory stores trace data that you can display as time graphs (doc_svm_dump). The debug memory (doc_sys__debug_ram) is used to interact and provide commands to the Drive-On-Chip control application.</p> <p> <p></p> <p></p> <p>To interface directly with the Drive-On-Chip application for command and configuration purposes, utilize the full HPS-to-FPGA bridge base address along with the specified offsets (each being a 32-bit wide value). Be sure to account for the offset between the first and second axis.</p> <p> Axis Offset from HPS bridge base Axis0 0x0008_0000 Axis1 0x0008_0108 :----: :-------------------------- Axis2 0x0018_0000 Axis3 0x0018_0108 :----: :-------------------------- Axis4 0x0028_0000 Axis5 0x0028_0108 <p></p> <p>Note</p> <p>In the previous table the address 0x0008_0000 is the base address of the debug memory (doc_sys__debug_ram). Each axis has 66x 32-bit wide data locations and hence the first axis initiates at 0x0 and the second axis memory space initiates at 0x108.</p> <p>You can interact with the motor control application by reading or writing to the following memory locations from the axis base offset.</p> <p> Offset from Axis base Register Name Read/Write Description 0x00 DOC_DBG_DRIVE_STATE R State of the Drive System Monitor IP, refer to source code if the Drive-On-Chip  app running on NiosV for more details. 0x04 DOC_DBG_RUNTIME R Time in seconds the DoC App has been running. 0x08 DOC_DBG_DSP_MODE R Software (0x0) or DSP Builder IP (0x1) Field Oriented Control Algorithm execution. 0x0C DOC_DBG_APP_STATE R Drive-On-Chip Embedded Software Application State, refer to source code if  the Drive-On-Chip app running on NiosV for more details. 0x10 DOC_DBG_LATENCY1 R Latency of the FOC algorithm calculation. 0x28 DOC_DBG_SPEED R Measured Speed in RPM of the axis. 0x30 DOC_DBG_POSITION R Measured position of the encoder, need to decode the value to get degrees = \\&lt;value&gt; * 360 / 65536 0x34 DOC_DBG_BUTTON_DSP_MODE R/W Software (0x0) or DSP Builder IP (0x1) Field Oriented Control Algorithm execution 0x38 DOC_DBG_BUTTON_DRIVE_RESET R/W Write a 0x1 to the first axis of the array, to reset all axes controlled by a  single Nios, this register clears automatically. 0x3C DOC_DBG_DEMO_MODE R/W Close-loop, Open-loop, with 16kHz, 32kHz and 64kHz variants, refer  to source code if the Drive-On-Chip app running on NiosV for more details. 0x48 DOC_DBG_I_PI_KP R/W Current Loop Proportional Gain. 0X4C DOC_DBG_I_PI_KI R/W Current Loop Integral Gain. 0x50 DOC_DBG_SPEED_PI_KP R/W Speed Loop Proportional Gain. 0x54 DOC_DBG_SPEED_PI_KI R/W Speed Loop Integral Gain. 0x58 DOC_DBG_SPEED_SETP0 R/W Speed set-point for the axis in RPM. 0x64 DOC_DBG_POS_SETP0 R/W Position set-point. E.g: If you want 1500 degrees then write to the  memory location 1500 * 65536 / 360 = 273066 =&gt; 0x42AAA 0x74 DOC_DBG_WAVE_DEMO_MODE R/W Motor control mode 0x0 for speed mode, 0x1 for position mode. 0x78 DOC_DBG_POS_SPEED_LIMIT R/W Speed limit in position mode in RPM. 0x7C DOC_DBG_POS_PI_KP R/W Position Loop Proportional Gain. 0xE0 DOC_DBG_LATENCY2 R ISR Latency. <p></p> <p>For other values, refer to the source code of the Drive-On-Chip app running on NiosV for more details. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-crc/hw-funct-descr/#motor-model-subsystem","title":"Motor Model Subsystem","text":"<p>The Drive-On-Chip design example for Agilex\u2122 devices implements a simulated motor and power board model instead of a real motor kit. The motor and power board model is built using DSP Builder which generates the RTL used in the design. By integrating the Avalon interface, motor parameters are accurately configured to represent a tandem motor kit. The motor model included in this design example is based on the Tandem Motion 48V power board with a Tamagawa TS4747N3200E600 motor. There are six instances of the motor_model_subsystem in this design.</p> <p> <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/doc-design-recomendations/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/doc-design-recomendations/#drive-on-chip-design-recommendations-and-disclaimers","title":"Drive-on-Chip Design Recommendations and Disclaimers","text":"<p>The Drive-on-Chip with Functional Safety Design Example for Agilex\u2122 5 devices implements the CAT3 Pl D safety concept for Altera\u00ae FPGAs. The design is based on the monitoring of axis speed in the Drive-On-Chip Design Example for Agilex\u2122 5 Devices.</p> <p>This design only shows how to implement the safety concept. Altera\u00ae does not intend in any way for you to deploy this design in a real-world production environment. The design is not validated for any certification related to safety standards compliance.</p> <p>This design only demonstrates the safety concept principles, but it does not meet the rigorous standards and requirements for deployment in production systems. You must put in place all mechanisms, validation, verification, checks, and extension of the safety concept for your design if such application is required.</p> <p>The external safety logic block constitutes a fundamental part of the safety concept for FPGA. It must be an independent piece of hardware (another FPGA, micro-controller, CPU, etc) for the safety concept to be valid. This design includes the external safety logic in the same Agilex\u2122 device fabric as the safety function logic to demonstrate the design in a single chip. You must implement the external safety logic as a separate entity.</p> <p>The design provides meta-layers for custom Yocto build based on KAS with the same underlying components recommended in the Agilex\u2122 5 GSRD 25.1 documented on the Altera\u00ae FPGA Developer Site website. The meta layer provides the application and the modifications to the SD card collaterals to enable the HPS safety channel and the communication with devices in the FPGA fabric. However, you must modify or fix the meta layer and the software application components if you use any other version of these components as a base to build the SD card image. Altera\u00ae does not maintain the SW and SD card images. An SD card image, based on the GSRD and/or in this example design is not a production ready framework. You must validate the operating system of your choice and programming models to certify your system with functional safety standards.</p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/features-and-safety-concept/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/features-and-safety-concept/#features-of-the-drive-on-chip-with-functional-safety-design-example-for-agilextm-5-devices","title":"Features of the Drive-on-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":"<ul> <li>Motor control for Agilex\u2122 5 devices, refer to AN 1000: Drive-On-Chip Design   Example for Agilex\u2122 5 Devices.</li> <li>Python-based GUI for motor feedback information, debugging and control of motors. Extension to provide visual safety outputs.</li> <li>Motor speed safety function according to Cat 3 PLd architecture.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/features-and-safety-concept/#about-the-safety-concept","title":"About the Safety Concept","text":"<p>Applying safety concept principles to the Drive-on-Chip with Functional Safety Design Examples</p> <p>According to ISO 13849-1, clause 6.2.6 the Category 3 requirements are:</p> <ul> <li>Apply designated architecture for Cat. 3.</li> <li>Apply measures against common cause failures (CCF) (see Annex F).</li> <li>For category 3, apply the same basic safety principles as those according to   6.2.3 for category By.</li> <li>Follow \u201cWell-tried safety principles\u201d (see ISO 13849-2) according to 6.2.4.</li> <li>Design SRP/CS of category 3 so that a single fault in any of these parts does   not lead to the loss of the safety function.</li> <li>Whenever reasonably practicable, detect the single fault at or before the next   demand upon the safety function.</li> <li>Ensure the diagnostic coverage (DCavg) of the total safety related parts of   the control system (SRP/CS) including fault detection must be at least low.</li> <li>Ensure the mean time to dangerous failure (MTTFD) of each of the redundant   channels must be low-to-high, depending on the performance level.</li> </ul> <p> According to ISO 13849-1:2015, clause 6.2.6, the designated architecture for Cat.3 requires two channels with independent inputs and outputs and a cross comparison (CC). Altera\u00ae can satisfy this architecture by implementing two logical blocks in a single SoC FPGA, with an external safety logic to mitigate common cause failures. The design meets Cat 3 designated architecture and the measures against CCF. However the reliability parameters (MTTFD , DCavg) are application-specific and you can only evaluate them at application level with a specific safety concept, although the design includes examples of such diagnostics.</p> <p> The figure shows the basic architecture of the safety concept divided in two independent safety channels.</p> <p></p> <p> <p>First-Level Safety Concept Diagram Applied to Drive-on-Chip Design Example. </p> <p>The design implements the first channel using the hard processor system (HPS) in the Agilex\u2122 5 SoC devices to run speed monitoring and cross-comparison functions. The HPS safety function interacts with the non-safe function or drive-on-chip block to monitor and estimate the speed for a safe threshold.</p> <p>The design implements the second channel in the FPGA fabric using custom and Platform Designer IP to monitor and calculate motor rotational speed. The design cross compares and verifies data from the HPS safety channel and the FPGA safety channel by its counterpart within the safety response time. Multiple mechanisms verify the correct behavior of the safety logic.</p> <p>Many faults in motor control can lead to the motor over-speeding and so if either of the speed monitor safety functions detects such a fault, the design removes power from the motor to prevent the motor running unsafely.</p> <p>The HPS and FPGA channels provide diverse implementations of the safety function that improves the diagnostic coverage. The design can detect some systematic faults and random faults and also counts towards CCF measures. AXI and APB interfaces pass the cross-comparison data between the FPGA and HPS. This maximizes RTL reuse and also allow use of third party verification IP, which can help reduce systematic faults and add independence to the verification process.</p> <p>The external safety logic detects when FPGA and SoC fail simultaneously and performs functions such as monitoring temperature and providing a watchdog function. In a real design, the external safety logic is a physically separate device. However, this design models it within the FPGA.</p> <p>FPGA features add diagnostics. ECC and complementary pins. ECC in the shared memory detects multi-bit errors and corrects single-bit errors.</p> <p>Complementary-pair signaling adds redundancy to detect stuck or short type faults. The complementary-pair consists of two signals denoted <code>_p</code> and <code>_n</code> corresponding to active-high and active-low respectively. Under normal circumstances the <code>_p</code> and <code>_n</code> elements are always opposite polarity to each other. If they are the same, a fault has occurred \u2013 e.g. stuck-high or low fault, short to adjacent pin.</p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/glossary/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":"<p> <p>Acronyms and Terminology</p> Term Description DoC Drive On Chip FOC Field Oriented Control QEP Quadrature Encoder Pulse EMIF External Memory Interface FPGA Field Programmable Gate Array BSP Board Support Package IP Intellectual Property (hardware) DSP Digital Signal Processing CAN Controller Area Network GUI Graphical User Interface JTAG Joint Test Action Group (industry standard for testing) UART Universal Asynchronous Receiver-Transmitter RAM Random Access Memory SRT Safety Response Time HPS Hard Processor System ESL External Safety Logic FUSA Functional Safety APB Advance Peripheral Bus Interface AXI Advance eXtensible Interface bus protocol SDM Secure Device Manager ADC Analog to Digital Converter HPS2FPGA Hard Processor System to FPGA, usually referring to a hardened memory-mapped bridge IRQ Interrupt Request PD Usually used to refer to \"Platform Designer SPI Serial Peripheral Interface PIO Parallel Input/Output DSP BA Used to refer to \"DSP Builder Advanced tool RTL Register Transfer Level DTS Device Tree Source DTB Device Tree Blob <p></p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-app/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-app/#hps-channel-speed-monitoring-safety-application","title":"HPS Channel Speed Monitoring Safety Application","text":"<p>The Drive-On-Chip with Functional Safety design implements an HPS channel safety function with an application running in the Agilex\u2122 5 HPS. The application is by default cross compiled for ARM64 architecture and the executable is added to <code>/opt/hpssafechannel/</code> directory during the Yocto build.The application is set to run as a service after the HPS finish booting Linux. If necessary, you can compile and modify the application without building Yocto.</p> <p>The main functions of the HPS channel speed monitoring safety application are:</p> <ul> <li>Detect and connect with the devices in the FPGA soft logic necessary to   implement the Safety Function</li> <li>Estimate speed at 25 kHz rate, accessing the Drive-on-Chip quadrature encoder   pulse encoder raw position values.</li> <li>Generate the HPS payload according to specification.</li> <li>Detect overs-peed in the Axis0 of the Drive-on-Chip hardware.</li> <li>Cross compare the HPS payload with the FPGA payload.</li> <li>Generate HPS channel safety outputs to the external safety logic block.</li> <li>Write values for GUI display in the GUI safety memory.</li> <li>Print the status of the application in the UART terminal.</li> </ul> <p>You can find the HPS Channel for Speed Monitoring Application as part of the assets (in the GitHub Release Tag), or in the <code>recipes-example</code> directory of the <code>meta-driveonchip</code> layer with the name <code>hpssafechannel_1.0.tar.gz</code></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-app/#main-hps_safe_channelc","title":"Main (hps_safe_channel.c)","text":"<p>The main function is in <code>&lt;.tar.gz_location&gt;/hps_safe_channel_1.0/</code> . The flow of the main function consists of device and memory initialization from UIO, thread creation, and initialization for speed estimation, terminal printing and the running of the main safety function. Then the main runs an infinite loop until the design issues the program with a <code>SIGNALTERM</code>. At the end, some clean up functions.</p> <p></p> <p> <p>HPS Safety Function Main Execution Flow. </p> <p>The loop does not finish unless you stop it. When the interval timer triggers the interrupt, the HPS calculates a new speed and HPS payload.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-app/#speed-estimation-thread-speed_estimationch","title":"Speed Estimation Thread (speed_estimation.c/.h)","text":"<p>The thread, which you can change, runs every 25ms (4kHz). The mechanism calculates a wake up time. It runs the speed estimation in every cycle after the wake-up time taking readings from the drive-on-chip encoder, specifically from the Raw Count Capture register (accessing the device <code>doc_qep0</code>). The design passes the values to main functions using pointers and the HPS calculates the next wake up time.</p> <p></p> <p> <p>Speed Estimation Thread Execution Flow. </p> <p>The design allocates this thread to core 3, which is isolated for this purpose.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-app/#printing-thread-print_safetych","title":"Printing Thread (print_safety.c/.h)","text":"<p>The thread provides information about the safety function in the UART terminal after the program runs in Linux. The design allocates the thread to a different HPS core, and it refreshes the information every second. The thread finishes after <code>CTRL+C</code> or <code>SignalTerm</code>. The program assigns the thread to core 1, which is not isolated.</p> <p></p> <p> <p>Printing Thread Execution Flow. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-app/#safety-function-application-srtch","title":"Safety Function Application (srt.c/.h)","text":"<p>This thread implements the safety function in the HPS channel. The program allocates the thread and the interrupt to an isolated core 2. It sets the interval timer to run at 1ms (the safety response time, SRT).</p> <p></p> <p> <p>HPS Safety Function Flow Diagram. </p> <p>In every interrupt by the timer the application copies an HPS channel speed estimation from the speed estimation thread. The program generates and copies the payload to the shared memory. Then it compares the latest with the payload available from the HPS safe channel. The HPS asserts the safety signals and writes to registers for the FPGA-HPS channel synchronization. If the safe state is triggered, the motor is stopped. The safety function pauses until you clear the state with the push button. Then the function continues with the regular activities for safe speed monitoring in Axis0.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-app/#access-to-devices","title":"Access to devices","text":"<p>The helper functions that access registers and memory spaces of these devices are in <code>&lt;.tar.gz_location&gt;/hps_safe_channel_1.0/devices</code></p> <ul> <li><code>drive_on_chip.c/.h</code>: functions to write and read information from   doc_safety_dump memory for visualization of safety parameters in the GUI. Also   functions to access any device connected to the lightweight HPS to FPGA bridge,   if necessary, e.g. changing the speed of the axis.</li> <li><code>fpga_speed_est.c/.h</code>: functions to clear the over speed latch in the FPGA   channel after safe state clearance.</li> <li><code>hps_gpio.c/h</code>: functions to read and write to the hps_fpga_gpio to   provide HPS safety outputs to the external safety logic (speed comparison and   over-speed) and receive the output of the of the external safety logic (motor   power down). Routines to indicate safe state to the external safety logic from   the HPS safety channel.</li> <li><code>interval_timer.c/h</code>: functions to control the interval timer, set free running,   clear timeout signals, set the timer count.</li> <li><code>qep_encoder.c</code>: functions to get the quadrature encoder pulse count for speed   estimation.</li> <li><code>safe_memory.c/.h</code>: functions to write and read information from the share   memory (shared_mem) and to cross compare payloads produced by both safety   channels.</li> <li><code>scan_devices.c/h</code>: a set of helper functions to determine the location,   name, addresses, and offsets of the required devices. Also to get a pointer to   handle the access to base memory. Devices must be mapped in the DTS as UIO devices.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-app/#core-isolation-and-core-affinity","title":"Core Isolation and Core Affinity","text":"<p>This system isolates design cores 2 and 3 for timing critical functions. Core 2 runs the HPS safety function and serves the interrupt generated by the Interval timer. Core 3 is for the thread that does speed estimation. The Linux Kernel scheduler allocates other threads to core 1 and 0. Core isolation and core affinity ensures the timing critical parts of the application meet their deadlines (1 ms, safety response time). You can check the core allocation using the tool <code>htop</code>.</p> <p></p> <p> <p>Core Affinity and Isolation using HTOP View. </p> <p>The figure shows the intended core allocation for HPS safe application threads. The figure shows no other kernel or user-space application runs in core 2 or 3, only core 0 and 1 are available for the remainder of the applications and services.</p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#overview","title":"Overview","text":"<p>In the Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices the HPS implements the secondary safety channel, runs speed estimation and monitoring, cross compares payload, automatically detects the devices, and generates GUI data. The HPS safety channel comprises</p> <ul> <li>HPS configuration in Platform Designer.</li> <li>The Yocto meta layer that you must add to the SD card image build.</li> <li>HPS channel speed monitoring safety application source code, compilation, and running</li> </ul> <p>This page describes the elements for getting a custom distribution of Linux based on YOCTO/KAS for this application.</p> <p>The files and contents described in the following sections can be found in the <code>doc-variants</code> repository, within the <code>sw</code> directory see: meta-driveonchip.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#hps-channel-safety-software-custom-linux","title":"HPS Channel Safety Software - Custom Linux","text":"<p>For the Drive-On-Chip Functional Safety Design Example for Agilex\u2122 5 Devices, Altera\u00ae provides the files to build the Linux system to run the HPS channel safety application. The custom version of linux is built based on KAS (see: agilex-ed-drive-on-chip/sw). An it is compose of two main meta-layers. In this document the files relevant for the \"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices\" are highlighted.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#fpga-embedded-layer","title":"FPGA Embedded Layer","text":"<ul> <li>See meta-altera-fpga</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#drive-on-chip-layer","title":"Drive-On-Chip Layer","text":"<ul> <li>See meta-driveonchip</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#necessary-elements-in-the-meta-layers-to-bind-software-and-hardware","title":"Necessary elements in the meta-layers to bind Software and Hardware","text":"<p>This section explains the different elements included in the meta-layers that help to run the HPS Safety Application. These elements help to \"bind\" the FPGA Soft IP that implements the Safety function in the \"FPGA Channel\" with the software that runs in the HPS on top of Linux. This elements are explained in the following sections to clarify the interaction of the HPS Safety Application (Software), with the FPGA Safety Channel (soft logic).</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#device-tree","title":"Device Tree.","text":"<p>Adds a custom .dtsi (device tree fragment) file to the main device tree for Linux kernel boot up stage <code>socfpga_agilex5_socdk.dts</code>. it compiles into a DTB (device tree blob) during kernel compilation and is added to the SD card image during the Yocto build. The recipe <code>device-tree.bb</code>. The specific file for this design example (<code>agilex5_safety_dual_axis.dtsi</code>), is appended using <code>device-tree.bbappend</code> directive. Look for these files in the different meta-layers provided above.</p> <p></p> <p> <p>Custom Device Tree Fragment. </p> <p>You expand the device tree by appending the contents of the file <code>agilex5_safety_dual_axis.dtsi</code> that exposes seven devices as UIO devices in the RootFS. The figure shows the instances of the devices. These definitions should match with the devices that the HPS can access in the FPGA soft logic and you can verify the address map in the Platform Designer Project (<code>.qsys</code>).</p> <p>For example, the interval timer has the address <code>0x0000_0020</code> in Platform Designer, but from the view of HPS you should add the offset reflecting the HPS-FPGA bridge <code>0x4000_0000</code> refer ( System Memory Mapping Scheme in the Hard Processor System Technical Reference Manual: Agilex\u2122 5 SoCs (25.1)) specifying the address <code>0x4000_0020</code> in the <code>agilex5_safety_dual_axis.dtsi</code> file. Components connected to the full HPS to FPGA bridge have an offset of <code>0x4000_0000</code> and components connected to lightweight HPS-to-FPGA bridge have an offset of <code>0x2000_0000</code>.</p> <p>All components are listed in the .dtsi as compatible <code>generic_uio</code>, which is a way to map devices using generic user IO interface in the Linux kernel and user space. If you modify or add memory mapped devices in Platform Designer, reflect the change in the <code>.dtsi</code> file. When the Yocto build refreshes, the Linux system lists the device in the corresponding <code>/dev/uiox</code> and populates the information in <code>/sys/class/uio/uiox</code>. The <code>.dtsi</code> and Platform Designer mapping should be consistent to provide the HPS safety function application to run correctly.</p> <p>For example, the application looks for the names specified in the <code>.dtsi</code>, for example <code>interval_timer0</code> and gets the device UIOX identifier, the address, the offset, and all meaningful information to access the device in the FPGA.</p> <p>A particularity of the <code>.dtsi</code> in the previous figure is the interrupts metadata. The \"interval timer\" processes the safety function by issuing an interrupt to the HPS that is polled by software. The interrupt <code>&lt;0 17 4&gt;</code> is the first interrupt line accepted by the HPS from any FPGA (soft logic) device. In Platform Designer the interrupt line to the interval timer shows Interrupt number 0.</p> <p> <p>Interval Timer Interrupt line connection to the HPS </p> <p>You can check the number of interrupts triggered by the interval timer at any point by issuing the following command in the Agilex\u2122 5 command line:</p> <pre><code>cat /proc/interrupt\n</code></pre> <p></p> <p> <p>Amount of Interrupts Triggered by the Interval Timer </p> <p>Look for interrupt 53, subscribed to the Interval Timer. As shown in the previous figure, interrupt 53 has been allocated to core 2 (isolated core), using the directives in the <code>start.sh</code> file installed in <code>/usr/bin</code> (or <code>start_agx5.sh</code> file in the meta-layers).</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#fpga-bitstream","title":"FPGA Bitstream.","text":"<p>Adds the <code>agilex5_modular_safety_dual_axis.core.rbf</code> file to the build. The file is generated after Quartus\u00ae Prime compilation. The <code>*core.rbf</code> file is added to the boot partition of the SD card (renamed as <code>top.core.rbf</code>). The HPS configures the FPGA at initialization using u-boot <code>load</code> command in <code>uboot.txt</code> generated into <code>boot.scr.uimg</code> in the boot partition by <code>u-boot-socfpga_%.bbappend</code> (look for the files in the meta-layer).</p> <p></p> <p> <p>FPGA configuration during HPS booting process. </p> <p>Look for the print \"..... FPGA reconfiguration OK \" during the device booting process, as shown in the previous figure to ensure the FPGA bitstream (<code>top.core.rb</code>) has been properly loaded.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#additional-u-boot-configuration","title":"Additional u-boot configuration.","text":"<p>An append to the u-boot arguments using <code>IMAGE_BOOT_ARGS</code> and <code>IMAGE_BOOT_ARGS:append:agilex5_modular</code> in different KAS/YOCTO configuration files to enable UIO drivers defined by <code>uio_pdrv_genirq.of_id=generic-uio</code>.</p> <p>Additionally, this design isolates cores 2 and 3 for use exclusively in the application (speed estimation and main safety function). The u-boot arguments <code>nohz_full=2,3</code> and <code>isolcpus=2,3</code> inside the KAS/YOCTO configuration files ensure the isolation of cores for the application. You can verify the core allocation in the C source code.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#hps-channel-safety-application-and-services-recipes-example","title":"HPS Channel Safety Application and Services (recipes-example)","text":"<p>Recipe to build and deploy the HPS safety application (<code>hpssafechnnel_1.0.bb</code>). The source code is contained in <code>hpssafechannel_1.0.tar.gz</code> and the <code>Makefile</code> is provided.</p> <p>The recipe <code>hpssafechannel_1.0.bb</code> compiles and packages the executable into the SD card image (.wic). The recipe installs the executable in <code>/opt/hpssafechannel/</code></p> <p>The recipe <code>hpsafechannel_1.0.bb</code> also deploys the HPS safety application as a service, it installs the file <code>hpssafechannel.service</code> to <code>/lib/system/system</code> and launches it some seconds after kernel initialization using the <code>start.sh</code> script in <code>/usr/bin/</code></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#additional-tools","title":"Additional tools.","text":"<p>See the KAS configuration file for this example design <code>kas_safety_dual_axis.yml</code>. Some tools installed are:</p> <ul> <li><code>hpssafechannel</code>: custom HPS Channel Safety Application.</li> <li><code>htop</code>: cross-platform interactive process viewer to verify core isolation   and affinity.</li> <li><code>devemem2</code>: to easily access memory-mapped devices.</li> <li><code>uio-pdrv-genirq</code>: kernel module to map devices as \"User IO\"</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hps-channel-custom-linux/#preempt-rt-patch","title":"PREEMPT-RT patch.","text":"<p>This example show the user how to easily \"patch\" the Linux kernel with <code>PREEMPT_RT</code> patch, which provides soft Real Time characteristics particularly useful for embedded hardware applications. In this design example <code>PREEMTP_RT</code> patch helps to guarantee the processing time of the SRT (Safety Response Time) by giving priority to the interrupt raised by the Interval timer that synchronizes the FPGA and the HPS Safety Functions. See the file <code>linux-socfpga-rt_6.6.bb</code></p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#hardware-description-and-functionality","title":"Hardware Description and Functionality","text":"<p>This document provides insights about the functionality of the design example using the hardware blocks as a reference. The user must account for the interaction of the hardware described in this section and the software that executes in the Hard Processor System to gain full understanding of the implementation of the Safety Concept for Speed Monitoring.</p> <p>The Platform Designer high-level system includes many subsystems. These subsystems allow the system to work appropriately.</p> <ul> <li>The <code>clock_subsystem</code> and <code>board_subsystem</code> contain blocks related to the board   resources such buttons, switches, LEDs, reference clocks, resets. They provide   the clocks and resets for the other subsystems.</li> <li>The <code>hps_subsystem</code> is an instance of the Agilex\u2122 5 HPS that runs the HPS safe   channel application in Linux. EMIF to on-board DDR4 chip includes presets   and connections of the HPS2FPGA bridges to other subsystems. The subsystem   includes an instance of DDR4 EMIF to interface with on-board memory chip with   all presets and connections to the HPS2FPGA bridges to other subsystems.</li> <li>The <code>shared_mem_subsystem</code> enables cross comparison data to pass between the   FPGA and HPS as part of the safety concept. A memory location where the FPGA   channel and the HPS channel read and write the necessary safety payloads.</li> <li>The <code>esl_subsystem</code> is an internal (FPGA fabric) implementation of the external   safety logic. In a production functional safety application, you remove this   block and you implement it in a separate device from the Agilex\u2122 device.</li> <li>The <code>hardware_subsystem</code> collects information off the device that you can use   to implement safety features such as voltage and temperature monitoring and validation.</li> <li>The <code>safety_subsystem</code> implements one channel of the the safety concept in the   FPGA. This safety channel is currently attached to the speed monitoring of Axis0</li> <li>The subsystems <code>dniosv_subsystem*</code>, <code>motor_model_subsystem*</code>, <code>drive_subsystem*</code>   and <code>control_subsystem*</code> are blocks related to motor control and motor modeling.   For more information on these blocks, refer to AN1000: Drive-On-Chip Design   Example for Agilex\u2122 5 Devices. </li> </ul> <p>The following block diagram shows the main components and subsystems of the \"Drive-On-Chip with Functional Example Design\".</p> <p></p> <p> <p>Hardware Top Block Diagram. </p> <p>The diagram is color-coded to match the Platform Designer view and the XML file (Modular Design Toolkit methodology) for this design (see: AGX_5E_Modular_Devkit_HPS_NIOSVg_DoC_safe_dual_axis.xml). The following figure correlates the block diagram, the XML file and the Platform Designer view:</p> <p></p> <p> <p>Modular Design Tool Kit PD project vs XML file. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#safety-specific-hardware-subsystems-and-components","title":"Safety-specific Hardware Subsystems and Components","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#a-safety-subsystem","title":"a. Safety Subsystem","text":"<p>The safety subsystem consists of various submodules that collect appropriate information to indicate the status and actions of the whole system, which passes into the external safety logic.</p> <p>The safety subsystem comprises the following blocks:</p> <ul> <li>Safety block (FPGA implementation of the safety channel)</li> <li>Quadrature encoder pulse</li> <li>Interval timer</li> <li>Push button debounce (for reset)</li> <li>Bridges for control and device access.</li> </ul> <p></p> <p> <p>Safety Subsystem Platform Designer View. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#a1-safety-block","title":"a.1. Safety Block","text":"<p>This block implements the FPGA safety channel. It has two main functional blocks: FPGA safety function block and the FPGA cross-comparison function for HPS-FPGA payloads.  </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#a11-safety-function-block","title":"a.1.1 Safety Function Block","text":"<p>Contains the FUSA and timer heartbeat generator, speed estimator, and payload generator. </p> <ul> <li>FUSA and Timer Heartbeat Generator: The heartbeat generator monitors the   condition of all the other IPs in the FPGA and HPS channels. The generate bit   is a control signal that toggles the heartbeat. For the FPGA, the generate input   is derived from the FPGA Comparison Function state machine's start output,   which in turn triggers from the timeout. Therefore, the FPGA heartbeat signal   indicates correct restarting controlled by the software and operating comparison   function state machine.</li> <li>Speed Estimator: The speed estimator estimates the speeds of the motor model   based off quadrature encoder pulse count. Using this calculated value, the   module determines respective safety bits, which pass into the external safety   logic. The main algorithm of the estimator is similar to the one in drive on   chip, with additional safety diagnostics. The speed estimator module controls   local parameters and modifies sampling frequencies.</li> <li>Payload Generator: The payload generator takes in many different signals   from around the overall safety block and generates a payload with all the   relevant information. The FPGA-side payload is passed into the cross-comparison   block for relevant and respective checks. </li> </ul> <p>The following table shows the format for the payload data.</p> <p></p> <p> <p>32-bit Safety Payload format.</p> Bit range Length Intended Data Description [0] 1 bit Over-speed indication 1 for Over-speed [25:1] 25 bits Estimated speed Measured in rpm [31:26] 6 bits Sequence Implemented an internal counter to register the sequence of measurements.(0-128) always looping around. <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#a12-cross-comparison-block","title":"a.1.2 Cross-Comparison Block","text":"<p>The cross-comparison block consists mainly of a state machine which, when triggered by the timer, writes to and reads from the shared memory to compare the FPGA payload with the HPS payload. The following diagram specifies the in-built states of the state machine.</p> <p></p> <p> <p>State Machine Diagram to execute the Speed  Monitoring Safety Function. </p> <p>When triggered in the initial <code>init</code> state by the timer, the state machine waits a clock cycle for the payload to be generated before writing it to the shared memory. The FPGA status location is then updated in the shared memory to indicate that the FPGA payload is valid. The state machine then waits, checking the shared memory location for the HPS status to determine when the HPS writes its payload data to the shared memory. The design performs cross comparison that verifies that the payload sequence number in the two payloads matches and also that the two speeds match to within the allowed tolerance. Various factors determine the acceptable tolerance between the two speed estimations: The maximum acceleration of the motor</p> <ul> <li>The interrupt response time in the HPS software</li> <li>The alignment of the 4 kHz speed estimation sampling between the HPS and FPGA</li> <li>Clock cycle tolerance in the sampling of the encoder quadrature. One decoder   can sample a change in the quadrature signals one clock cycle after the other.</li> </ul> <p>Although the over-speed flag is in the payload data, the design does not cross compare flags because tolerances in the speed estimation means that one speed estimation can be just over the threshold and one just under. Hence the <code>over_speed</code> flags not matching is a valid condition.</p> <p>The state machine then updates the FPGA status in the shared memory to indicate when the FPGA completes its cross comparison. The state machine then waits, monitoring the HPS status for its cross comparison to be complete. The FPGA state machine then clears the HPS status in the shared memory and the HPS reciprocally clears the FPGA status in the shared memory. This handshaking ensures that state machines in the FPGA and HPS remain synchronized with each other. The FPGA state machine then returns to the initial state and the process repeats.</p> <p>Between the <code>generate</code> state and returning to the <code>init</code> state, the design enables a watchdog timer. This watchdog prevents the FPGA state machine from waiting indefinitely for the HPS. If the watchdog expires, the state machine transitions to the error state and the <code>compare_good_p/n</code> output pair is asserted. The design only exits the error state when the <code>reset_safety_n</code> input is asserted (active-low). </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#a2-quadrature-encoder-pulse","title":"a.2. Quadrature Encoder Pulse","text":"<p>The quadrature encoder pulse IP decodes the quadrature inputs from the position encoder, signals <code>A</code>, <code>B</code> and <code>I</code>. The Drive-on-Chip with Functional Safety Design Example design reuses the IP from the Drive-on-Chip Design Example. However, it now exposes the count value to pass it for further analysis. The IP also monitors any errors due to over-speed.where both <code>A</code> and <code>B</code> phases of the quadrature change in the same sampling period. The IP may monitor the encoder\u2019s error output.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#a3-interval-timer","title":"a.3. Interval Timer","text":"<p>The interval timer from the Quartus\u00ae or Platform Designer IP catalog is the source of synchronization of the FPGA channel and the HPS channel. Calculating the speed in both the channels, the cross comparison, and evaluating the safety function must occur in the interval between the timer timeout and interrupt signals.</p> <p>The interval timer provides the safety response time. In this design, the safety response time is 1 ms. During that time, the FPGA channel generates a payload, writes the payload to shared memory, retrieves the payload from the HPS, and runs the comparison. Similar for the HPS safety channel. The HPS uses the interrupt line from Linux to start the safety function.</p> <p>In this design, the timer is set to 1 ms interval by writing a count value according by the clock frequency of the timer (in this case 100 MHz). This IP writes to the registers <code>periodl</code> and <code>periodh</code>. Then, the timer runs in free running mode by writing a <code>0x7</code> in the control register. When the count reach <code>0x0</code>, the timer issues an Interrupt for the Linux system (the timer is registered as a UIO device in the Linux DTS with its corresponding interrupt number) and the design assert the timeout output. These signals trigger the safety function in the FPGA and HPS channel respectively. When the interrupt occurs, the systems clears the interrupt and the timeout signal and sets the timer to free running mode again.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#b-shared-memory-subsystem","title":"b. Shared Memory Subsystem","text":"<p>The shared memory is a 4x32 bit dual-port block RAM. One side connects via AXI to the HPS. The other side connects via APB interface to the FPGA cross comparison block. The design implements error correction codes (ECC) on both ports, allowing single-bit errors to be automatically corrected and multi-bit errors to be detected. The correction of single-bit errors allows the safety function to continue despite a single fault. If uncorrectable multi-bit errors are detected, the <code>memory_fault_p/n</code> complementary-pair output is asserted. You can only de-assert this output by the active-low <code>reset_safety_n</code> input.</p> <p></p> <p> <p>Intended Shared Memory Address Map.</p> Address Data 0x0 FPGA payload 0x4 FPGA status 0x8 HPS payload 0xC HPS status <p></p> <p></p> <p> <p>Intended definition of Status Bit.</p> FPGA status / HPS status bit Meaning 0 Valid data from the channel is ready  to be compared. Comparison pending. 1 Comparison done in the corresponding channel <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#c-external-safety-logic-subsystem","title":"c. External Safety Logic Subsystem","text":"<p>The external safety logic identifies common causes of failures and disparities in the overall system. You can model the external safety logic via internal logic when no external device is present. The following descriptions state each of the diagnostics external safety logic Implements. </p> <ul> <li>Results of payload comparison: Both the FPGA and HPS process their own   comparisons to ensure both values of payload agree. The design passes these   outputs into the external safety logic to ensure that both comparison checks agree.</li> <li>Clock Checker: The external safety logic actively takes in respective FPGA   and HPS clocks as inputs of different frequencies. The design processes these   signals through the clock checker to ensure frequencies are in a tolerable range.   The clock checker takes a fixed reference clock and its respective reset, and   compares it to a clock under comparison. Using fixed parameterizable thresholds,   the clock checker determines whether the clock under test falls into appropriate   and safe frequencies. The external safety logic uses the clock checker to ensure   that HPS and PGA clocks operate at appropriate frequencies, and the design has   no instances of skewing or jitter when passing through various blocks.</li> <li>Channel Operation: Refers to the two heartbeat signals present in FPGA and   HPS operations. These signals help to identify that everything is functional   within a process safety time. The external safety logic receives these signals   as inputs, which the design then delays using two flip-flops to prevent any   metastable values that might fluctuate through. The design applies a window   check to allow for the heartbeat to arrive within a determinable time span.</li> <li>CRAM Configuration Check: Ensures that no soft errors or transient faults occur.</li> <li>Power Supply Check: Ensures no failures because of loss of power or unsafe   operating voltage conditions. The design checks the power supply by using the   Mailbox Client with Avalon Streaming Interface IP. The design compares the   voltages to optimal operating voltage conditions. Refer to Agilex\u2122 User Guide.</li> <li>Temperature Check: Ensures no failures because of unsafe temperatures. The   design checks the temperature by using the Mailbox Client with Avalon Streaming   Interface IP. The design compares the temperature values against parameterizable   temperature limits to ensure they are in a safe range. For more details on   power supply and temperature check, refer to Agilex\u2122 Power Management User Guide.</li> <li>Complementary Bit Package: The complementary bit package contains a typedef   for a definition of type called <code>compli</code> which allows effective storage of   complementary bit pairs. The complementary bit check also contains fault checking   functions to ensure that received complementary pairs are organized into the   correct format. The design processes external safety logic's I/O in a   complementary manner to detect any stuck bits during transmissions. To   accommodate any timing delays, complementary pairs can arrive within a preset   and adjustable window. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#d-hardware-subsystem","title":"d. Hardware Subsystem","text":"<p>The hardware subsystem collects information about the system, which the external safety logic can use. Agilex\u2122 devices contain on-chip voltage and temperature sensors. </p> <p>The secure device manager stores sampled data, which you can access by using the Mailbox Client with Avalon Streaming Interface Altera\u00ae FPGA IP. Using the relevant information, external safety logic can determine unsafe temperatures and inoperable voltage conditions. </p> <p>The subsystem comprises command, response, a set of command addresses, and a mailbox client. During the command stage, the mailbox receives preprogrammed addresses. The response stage receives results from the mailbox and sorts into corresponding arrays. </p> <p>The following table contains command address information.</p> <p></p> <p> <p>Hardware Subsystem Command and Address Information. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#e-voltage-thresholds","title":"e. Voltage Thresholds","text":"<p>The design tests the voltage measurements received from the secure device manager (SDM) against the thresholds (hex digital value).</p> <p></p> <p> <p>Derivation of Voltage Rail Thresholds. </p> <p>The design divides some of the voltages rails by a factor of two before the on-board ADC samples them. The SDM multiplies up those samples by two again. The ADC measures to \u00b13.5% accuracy. The final digital output from the SDM mailbox is represented as an unsigned fixed point number with 16 bits below the binary point (e.g. <code>0x0000C000 = 0.75 V</code>, <code>0x00010000 = 1.0 V</code>).</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#drive-on-chip-related-hardware-subsystems-and-components","title":"Drive-On-Chip-related Hardware Subsystems and Components","text":"<p>This project variant is based on the \"Drive-On-Chip Example Design for Agilex\u2122 Devices\" see AN 999: Drive-on-Chip with Functional Safety Design Example: Agilex\u2122 7 Devices and AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices. Enhancing it with an instance of the HPS Subsystem (Hard Processor System) to provide a higher level of abstraction for motion control. The subsystems instantiated in the XML file are described below. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#a-hps-subsystem","title":"a. HPS Subsystem","text":"<p>The HPS Subsystem is mainly an instance of the \u201cHard Processor System Agilex\u2122 (or other) FPGA IP\u201d and is configured consistently with the GSRD. The HPS in this design should run all the necessary SW components to implement the HPS safety channel( e.g., OS, RTOS, containers, drivers, user application, etc). Internally, the subsystem comprises the HPS, EMIF for external DDR4 on the development kit, and lightweight and full HPS-to-FPGA bridges. The lightweight bridge accesses blocks related to the Drive-On-Chip application (drives, motor models, encoders, control memory, GUI memories). The full HPS-to-FPGA bridge connects safety-related blocks (shared safety memory, FPGA safety blocks). The HPS controls the timer that controls the safety function, reads and writes safety payloads, and cleans the FPGA channel control registers if necessary. </p> <p>The connection from the HPS2FPGA LW bridge to all drive-on-chip subsystem blocks. This connection allows the HPS to change parameters of the motor control. The connection allows the HPS to run speed estimation using the drive0 encoder.</p> <p>This design connects the HPS to the block <code>hps_fpga_gpio</code> for the inputs for the external safety logic if any of the safe state conditions in the HPS safety channel is asserted.</p> <p>This design subsystem connects the HPS to the <code>hps_fpga_gpio</code> block. The outputs from <code>hps_fpga_gpio</code> are inputs the external safety logic. Asserting the signals from <code>hps_fpga_gpio</code> triggers the safe state condition from the HPS safety channel.</p> <p></p> <p> <p>HPS Subsystem PD sub-Blocks. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#b-cpu-dnios_-subsystem","title":"b. CPU (dnios_) Subsystem","text":"<p>The Drive-On-Chip Design Example NiosV/g processor subsystem offers a fully functional processor system with debugging capabilities. The NiosV/g processor subsystem comprises the following Platform Designer components: NiosV/g soft processor, on-chip RAM, JTAG master, IRQ management, JTAG UART, timers and, performance counters.</p> <p></p> <p> <p>NIOSV/g Subsystem PD sub-Blocks. </p> <p>The ISR uses the memory blocks for code and data to ensure fast, predictable execution time for the motor control algorithm. The NiosV/g subsystem uses the JTAG master and debug memories to allow real-time interactions between the GUI and the processor. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#c-drive-subsystem","title":"c. Drive Subsystem","text":"<p>There are two instances of the <code>drive_subsystem</code> in this variant. This subsystem is a collection of IPs to enable interfaces, signals and ports for motor control using FPGA. The main components of this subsystem are Six-channel PWM Interface IP (<code>doc_pwm</code>), a Drive System Monitor IP (<code>doc_sm</code>), Quadrature Encoder Interface IP (<code>doc_qep</code>),  Sigma-Delta ADC interfaces for Drive Axes (<code>doc_adc</code> and <code>doc_adc_pow</code>), an instance of Field-Oriented Control Algorithm IP generated with DSP Builder (<code>doc_foc_fixp</code>), resolver SPI interface IP (<code>doc_rslvr_spi*</code>), and Parallel IO IP (<code>hall pio</code>) for hall interface. More details about these blocks can be found in Application Notes AN 999: Drive-on-Chip with Functional Safety Design Example: Agilex\u2122 7 Devices and AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices</p> <p></p> <p> <p>Drive Subsystem PD sub-Blocks. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#d-control-subsystem","title":"d. Control Subsystem","text":"<p>The Drive-On-Chip Design uses the debugging RAM to send commands and receive status information. The debugging dump memory stores trace data that you can display as time graphs in the GUI (<code>doc_svm_dump</code>). The  debug memory (<code>doc_sys__debug_ram</code>) is used to interact and provide commands to the Drive-On-Chip control application. The memories contained in the control subsystem are fundamental to interacting with the DoC capabilities and getting feedback signals for debugging and external control.  In this safety-oriented variant an additional <code>doc_safety_dump</code> memory in the <code>control_subsystem</code> to show safety-related values in another interface e.g. a GUI.</p> <p></p> <p> <p>Control Subsystem PD sub-Blocks. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#e-motor-model-subsystem","title":"e. Motor Model Subsystem","text":"<p>The Drive-On-Chip Design Example for Agilex\u2122 Devices implements a motor and power board model instead of a real motor kit. The motor and power board model is a DSP Builder model, which generates the RTL for the motor and power board model. By integrating the Avalon interface, motor parameters are accurately configured to represent a tandem motor kit. You can experiment with the design without investing in an expensive motor kit. You can explore and optimize your designs. The motor model included in this design example is based on the Tandem Motion 48V power board parameter specifications with a <code>Tamagawa TS4747N3200E600</code> motor. There are two instances of the motor_model_subsystem in this design.  To expand safety capabilities, the connection between the motor_model subsystem and the <code>esl_subsystem</code> allows you to disconnect the motor from power supply if the system goes into \"safe state\" whenever the design detects an unsafe condition. The external safety logic asserts the signal to disconnect the motor.</p> <p></p> <p> <p>Motor Model Subsystem PD sub-Blocks. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#general-use-hardware-subsystems-and-components","title":"General Use Hardware Subsystems and Components","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/hw-funct-descr/#a-clock-and-board-subsystems","title":"a. Clock and Board Subsystems","text":"<p>The clock Subsystem alongside the board subsystem contains blocks related to the board resources such as buttons, switches, LEDs, reference clocks, and resets. They provide the clocks and resets for the other subsystems.</p> <p></p> <p> <p>Board and Clock Subsystems PD sub-Blocks. </p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#safety-ip-input-and-output-signals","title":"Safety IP Input and Output Signals","text":"<p>The signals connect various blocks in the Drive-On-Chip for Functional Safety Design Example for Agilex\u2122 5 devices.</p> <p></p> <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#drive-on-chip-safety-interface-signals","title":"Drive-on-chip Safety Interface Signals","text":"Port name Polarity Description clk Input Clock. Asynchronous to any other clock reset_n Input Active low reset. Asynchronous to any other resets. reset_safety_n_i Input Reset to get out of the safe state reset_safety_n_o Output Reset to get out of the safe state reset_safety_mem_n_o Output Extension of <code>reset_safety_n</code> for memory safe state clearance qep_count [31 : 0] Input Quadrature encoder pulse IP counter input timer_pulse Input Time-out signal from the Interval timer block quad_error (_p, _n) Output Quadrature encoder pulse error feed to the external safety logic. fpga_is_safe (_p, _n) Output Over-speed detection. Traduced to safe status. fpga_compare_good_p(_p, _n) Output Result of comparison of HPS and FPGA payloads compare_timeout Output FPGA finite state machine timeout asserted heartbeat_fusa Output The heartbeat signal of FuSa block 1 toggle once every  safety cycle period to indicate correct functionality. heartbeat_timer Output The heartbeat signal of interval time toggle once every  safety cycle period to indicate correct functionality. AXI Lite Interface - - APB Interface - - <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#drive-on-chip-safety-function-interface-signals","title":"Drive-on-chip Safety Function Interface Signals","text":"Port name Polarity Description clk Input Clock. Asynchronous to any other clock reset_n Input Active low reset. Asynchronous to any other resets. reset_safety_n Input Reset to get out of the safe state generate_bit Input Enable the heartbeat generation timeout_pulse Input Time-out signal from the Interval timer block qep_count [31 : 0] Input Quadrature encoder pulse IP counter input qep_error Input Error input. Assert when you detect a quadrature decode  error (over-speed). If A and B both change during the same  clock cycle or if the encoder error input (E) is asserted. quad_error (_p, _n) Output Quadrature encoder pulse Error feed to the external safety logic. fpga_is_safe (_p, _n) Output Overs-peed detection: traduced to safe status. over_speed Output Asserted if the calculated speed in the speed estimator is over the threshold over_speed_led Output <code>over_speed</code> negated, routed to a board LED heartbeat_fusa Output The heartbeat signal of FUSA block 1 toggle once every  safety cycle period to indicate correct functionality. heartbeat_timer Output The heartbeat signal of timer block 1 toggle once every  safety cycle period to indicate functionality. payload [31 : 0] Output Type <code>t_safety_payload</code> defined in <code>pkg_doc_safety.sv</code> AXI Lite Interface - - <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#axi-to-apb-block-interface-signals-platform-designer-block","title":"AXI to APB block Interface Signals (Platform Designer Block)","text":"Port name Polarity Description s_axi_aclk Input Clock. Asynchronous to any other clock s_axi_aresetn Input Active low reset. Asynchronous to any other resets. reset_safety_n Input Reset to get out of the safe state AXI Lite Interface - - APB Interface - - <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#heartbeat-generator-interface-signals","title":"Heartbeat Generator Interface Signals","text":"Port name Polarity Description clk Input Clock generateBit Input Control signal to toggle the state of heartbeat output. Input may be  derived from comparison function output or timeout pulse. heartbeat Output Singular bit to indicate the heartbeat. Indicates overall block functionality. <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#speed-estimator-block-interface-signals","title":"Speed Estimator block Interface Signals","text":"Port name Polarity Description clk Input Clock reset Input Reset qep_count [31 : 0] Input Quadrature encoder pulse IP counter input qep_error Input Error input. Asserted when a quadrature decode error (over-speed)  is detected. If A and B both change during the same clock cycle  or if the encoder error input (E) is asserted. over_speed Output Singular bit to indicate whether the current estimated speed  is beyond a parameterizable threshold. led_signal Output Singular bit to be sent to an active low LED to represent the  status of <code>over_speed</code>. motor_speed_filtered Output Custom variable type, <code>t_speed</code>. quad_error (_p, _n) Output Complementary bits (p = 1'b0, n = 1'b1) to represent whether  a quadrature error is detected. Entirely based of the input  <code>qep_error</code>. fpga_is_safe (_p, _n) Output Complementary bits (p = 1'b1, n = 1'b0) to represent that FPGA  is overall safe, in respect to <code>over_speed</code>. APB Interface - - <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#payload-generator-block-interface-signals","title":"Payload Generator block Interface Signals","text":"Port name Polarity Description clk Input Clock reset_n Input Reset reset_safety_n Input Reset to get out of the safe state speed_rpm Input Incoming signal from the speed estimator module, which indicates  the current estimated speed of the motor. Type <code>t_speed</code> over_speed Input Singular bit to indicate whether the current estimated speed  is beyond a threshold. generate_pulse Input Control signal to create a valid payload and increment an  internal sequence counter when asserted. fpga_payload Output Created using a custom defined <code>struct</code>, <code>t_safety_payload</code>,  which has the properties over-speed, speed and sequence.  The design assigns these properties. <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#cross-comparison-function-block-interface-signals","title":"Cross-comparison Function block Interface Signals","text":"Port name Polarity Description clk Input Clock reset_n Input Reset reset_safety_n Input Reset to get out of the safe state start Input Assert to start the FPGA safe channel cycle by the Interval timer  every safety response time. fpga_payload Input Type <code>t_safety_payload</code>Over-speed, speed in rpm, sequence number. generate_fpga Output Indicates to the safety function block to return a valid payload  from the speed estimation. compare_good(_p, _n) Output Output asserted if the HPS payload and FPGA payload  in memory are consistent. compare_timeout Output FPGA finite state machine timeout asserted APB Interface - - <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#quadrature-encoder-pulse-block-interface-signals","title":"Quadrature Encoder Pulse block Interface Signals","text":"Port name Polarity Description clk Input Clock reset_n Input Reset QEP_A Input Quadrature pulse from motor (model) QEP_B Input Quadrature pulse from motor (model) QEP_I Input Index pulse, per complete revolution QEP_E Input Encoder Error input. 1 indicates that the motor's encoder detects  a fault and the design cannot rely on the quadrature signals. QEP_error Output Error output. Asserted when a quadrature decode error (over-speed)  is detected. If A and B both change during the same clock cycle or  if the encoder error input (E) is asserted.Only de-asserted when you write a 1 to the <code>reset_quad_error</code>  bit in the control register via the Avalon bus. QEP_count [31 : 0] Output Quadrature encoder pulse IP counter output Avalon Interface - Avalon bus byte addressing but only full word accesses supported. <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#external-safety-logic-interface-signals","title":"External Safety Logic Interface Signals","text":"Port name Polarity Description esl_clk Input Clock. Asynchronous to any other clock esl_reset Input Reset. Independent to any other reset clk_hps Input HPS clock clk_fpga Input FPGA clock Heartbeat_timer Input Heartbeat signal of the timer that toggles once every  safety cycle period to indicate correct behavior Heartbeat_fusa Input Heartbeat signal of FUSA block 1 that toggles once  every safety cycle period to indicate correct behavior Quad_error (_p, _n) Input Indicates that the quadrature encoder pulse detects  a quadrature error.(<code>p</code>=0, <code>n</code>=1) FPGA_safe (_p, _n) Input Indicates that the FPGA detects the motor speed  as safe (<code>p</code>=1, <code>n</code>=0) FPGA_compare (_p, _n) Input Indicates that the FPGA cross comparison function  detects the FPGA and HPS payloads as the same  (<code>p</code>=1, <code>n</code>=0) HPS_safe (_p, _n) Input Indicates that the HPS detects the motor speed  as safe (<code>p</code>=1, <code>n</code>=0) HPS_compare (_p, _n) Input Indicates that the HPS cross comparison function detects  the FPGA and HPS payloads as the same (<code>p</code>=1, <code>n</code>=0) compare_timeout Input FPGA finite state machine timeout asserted CRAM_good (_p, _n) Input Indicates that no fault is detected in the FPGA's  CRAM (<code>p</code>=1, <code>n</code>=0) power_good (_p, _n) Input Indicates that the voltage monitor block measures  the power rails within the acceptable  range (<code>p</code>=1, <code>n</code>=0) current_rp_temp Input Variable of parameterizable bits that indicates the  current temperature measured by the hardware block. safe_state (_p, _n) Output Control signal from the external safety logic to the  power control to the motor to put the motor into a  safe state (<code>p</code>=1, <code>n</code>=0) APB Interface - - <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#hardware-block-interface-signals","title":"Hardware block Interface Signals","text":"<p>The following table details the Hardware Subsystem's I/O and a description of the signal. All I/O signals are asynchronous to the input clock, to avoid meta-stability these are synchronized.</p> Port name Polarity Description hw_clk Input Clock. Asynchronous to any other clock hw_reset Input Reset. Independent to any other reset pwr_good (_p, _n) Output Complementary bits to represent that power is functional  as intended, all voltages measured are within safe limits. temp_good (_p, _n) Output Complementary bits to represent measured temperatures  are safe, within limits. cram_good (_p, _n) Output Complementary bits to represent measured temperatures  are safe, within limits. <p></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#safety-ip-registers","title":"Safety IP Registers","text":"<p>The Drive-on-Chip with Functional Safety Design Example for Agilex\u2122 5 devices contain registers that you can set.</p> <p></p> <p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/ip-io-signals-registers/#speed-estimator-block-registers","title":"Speed Estimator Block Registers.","text":"Address Access Register 0x00 R/W Control.Bit 0 <code>overspeed_error_reset</code>. * Writing 1 clears the over-speed bit in the status register. * This bit is self-clearing.  Bit 1 <code>quadrature_error_reset</code>. * Writing 1 clears the quadrature  error bit in the status register. * This bit is self-clearing.  Bit 31 <code>sw_reset</code>.*  Resets all registers in the safety function. 0x04 RO Clock frequency in Hz. 0x08 R/W Speed estimation frequency. Default to 4 kHz. 0x0C R/W Over-speed threshold (rpm). Speed at which the  over-speed signal and register is asserted. Default is 3000 rpm. 0x10 RO Status.Bit 0 <code>overspeed</code>.Bit 1 <code>quadrature_error</code> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/other-user-flow/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/other-user-flow/#compiling-the-project-using-a-mdt-qar-file","title":"Compiling the project using a MDT QAR file","text":"<ul> <li>Download the relevant design <code>.qar</code> file for your development kit and power    board from  link/repository.</li> </ul> <ul> <li>Double click in the .qar file or alternatively use Quartus\u00ae command line to   open it:<pre><code>  quartus &lt;MDT_QAR_NAME&gt;.qar\n</code></pre> <p>The contents of the <code>.qar</code> file open into the working directory. The   design example has the following directory structure.</p> <p></p> <p> <p>QAR file content. </p> <p>Note: This <code>QAR</code> file was generated using the \"Modular Design Toolkit\" flow.</p> <p></p> <p> <p>QAR and Project Directory Structure.</p> Directory Description assets Contains base files to run the example design derived from the hardware compilation. non_qpds_ip Contains the source code (RTL) of the design\u2019s custom IP that is not part of Quartus\u00ae Prime. quartus Contains the base files for the Quartus\u00ae Project including the top.qpf, top.qsf. rtl Contains the sources files to build the project. scripts Contains a collection of TCL scripts from \"Modular Design Toolkit\" to build and compile the design software and hardware. sdc Contains the .sdc files for the subsystems to compile the project. software Contains all the files for building the application for the Nios V and/or HPS. Look for the app.elf binary or *_cpu_ram_cpu_ram.hex that is included in the SOF <p></p> <p></p> <ul> <li>Navigate to <code>&lt;project&gt;/quartus/</code> and open the <code>top.qpf</code> file either by double    clicking on it or using the command:<pre><code>quartus top.qpf\n</code></pre> </li> </ul> <ul> <li>To generate the <code>.sof</code> file, click on \"Processing -&gt; Start Compilation Ctrl+L\"   or simply press the \"Start Compilation\" icon in the Quartus\u00ae Prime Pro GUI.</li> </ul> <p></p> <p> <p>Quartus\u00ae Prime Pro compilation flow. </p> <p>Wait for the compilation to finish. The <code>.sof</code> file should be located in the   <code>&lt;project&gt;/quartus/output_files</code> directory. Follow the steps generate the   <code>RBF/JIC</code> file using the <code>.sof</code> file and the <code>u-boot-spl-dtb.hex</code> file.</p> <p>Note: it si recommended to generate any embedded software images that are included in the <code>.sof</code> file before compiling, i.e NiosV software.</p> <p></p> <p>Back to User Flows</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/other-user-flow/#compiling-and-building-the-niosv-application-and-bsp","title":"Compiling and Building the NiosV application and BSP","text":"<p>Before rebuilding the BSP, ensure that the <code>settings.bsp</code> file correctly generates. To generate BSP, use command line and <code>niosv-bsp</code> command.</p> <p>The design includes an initial version of <code>settings.bsp</code> that contains parameters to run the design. If you modify the Platform Designer's hardware, ensure you keep the integrity of the <code>settings.bsp</code> file.</p> <ul> <li> <p>After changing the <code>settings.bsp</code> file, compile the application and generate the BSP   with the command:</p> <pre><code>  cd &lt;project&gt;/software/*niosv_subsystem*\n  make\n</code></pre> </li> </ul> <p>Running <code>make</code> takes an existing template <code>settings.bsp</code> file and creates a new one based on it for the current project. It updates locations of project then builds the <code>.bsp</code> and the NiosV application. See the provided <code>makefile</code> and <code>CMakeList.txt</code> files for more details in about the software build. The app.elf file is in <code>&lt;project&gt;/software/*niosv_subsystem*/build/bin</code></p> <p>If necessary, compile the hardware again to update the <code>.sof</code> file, so it contains the new binaries (<code>.hex</code>) for memory initialization (<code>&lt;project&gt;/software/*niosv_subsystem*/build/bin/mem_init</code>).</p> <p></p> <p></p> <p>Back to User Flows</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/other-user-flow/#creating-the-qspi-flash-and-sd-card-configuration-bitstreams-for-the-board","title":"Creating the QSPI Flash and SD card configuration bitstreams for the board","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/other-user-flow/#create-phase-1-and-phase-2-configuration-bitstreams-for-hps-first-flow","title":"Create phase 1 and phase 2 configuration bitstreams for \"HPS First\" Flow","text":"<p>Follow these steps if the \"HPS init\" property for the <code>hps_subsystem</code> in the <code>XML</code> is set to <code>\"HPS FIRST\"</code>. You can check this property by executing the following Quartus\u00ae command and the <code>\"\\*.sof\"</code> file. For example:</p> <pre><code>quartus_pfg -i top.sof\n</code></pre> <p>In the log, look for the property <code>\"HPS/FPGA configuration order\"</code> SET TO <code>\"HPS_FIRST\"</code></p> <p></p> <p> <p>HPS First SOF file. </p> <p>Important! The following step depends on the output of u-boot compilation specifically the file <code>u-boot-spl-dtb.hex</code>. To generate the pair <code>top.core.rbf</code> and <code>top.hps.jic</code> execute:</p> Agilex\u2122 5Agilex\u2122 3 <p>For [Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre></p> <p>For [Agilex\u2122 3 FPGA and SoC C-Series Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU512 \\\n-o flash_loader=A3CW135BM16AE6S \\\n-o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-funct-safety/other-user-flow/#create-phase-1-and-phase-2-configuration-bitstream-for-fpga-first-flow","title":"Create phase 1 and phase 2 configuration bitstream for \"FPGA First\" Flow","text":"<p>Follow these steps if the <code>\"HPS init\"</code> property for the hps_subsystem in the <code>XML</code> is set to <code>\"AFTER INIT_DONE\"</code>. You can check this property by executing the following Quartus\u00ae command and the <code>\"\\*.sof\"</code> file. For example:</p> <pre><code>quartus_pfg -i top.sof\n</code></pre> <p>In the log, look for the property <code>\"HPS/FPGA configuration order\"</code> SET TO <code>\"AFTER INIT_DONE\"</code></p> <p></p> <p> <p>FPGA First SOF file. </p> <p>Important! The following step depends on the output of u-boot compilation specifically the file <code>u-boot-spl-dtb.hex</code>. To generate the <code>top.jic</code> execute:</p> Agilex\u2122 5Agilex\u2122 3 <p>For [Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=A5ED065BB32AE6SR0 -o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n</code></pre></p> <p>For [Agilex\u2122 3 FPGA and SoC C-Series Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU512 \\\n-o flash_loader=A3CW135BM16AE6S -o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n</code></pre></p> <p></p> <p>Back to User Flows</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/features-plc/","title":"Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/features-plc/#features-of-the-drive-on-chip-with-plc-design-example-for-agilextm-devices","title":"Features of the Drive-on-Chip with PLC Design Example for Agilex\u2122 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/features-plc/#linux-operating-system-on-the-agilextm-hps","title":"Linux operating system on the Agilex\u2122 HPS","text":"<ul> <li>Based on Poky Linux with additional Yocto layers supporting Altera\u00ae FPGAs.</li> <li>Uses the Yocto build system.</li> <li>Additional Yocto Layer(s) supporting OpenPLC and Docker (meta-altera-fpga).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/features-plc/#docker-container-for-runtime","title":"Docker container for Runtime","text":"<p>A Docker container is an encapsulated environment used to isolate programs from each other within an operating system.</p> <ul> <li>Dockerfile and build scripts are supplied for OpenPLC runtime.</li> <li>Docker build flow for cross-compiling:<ul> <li>The container is built on x86 system to run on Arm processor HPS.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/features-plc/#openplc-runtime","title":"OpenPLC Runtime","text":"<p>The OpenPLC Runtime is a system for running IEC 61131 Structured Text (ST) PLC Applications to control the Drive-on-Chip simulated motor axes.</p> <ul> <li>OpenPLC is an Open Source PLC (Programmable Logic Controller) Runtime.</li> <li>The PLC Runtime has software tools to convert the PLC application   (written in Structured Text) to a compiled binary for the Agilex\u2122 HPS.</li> <li>The software compiling tools run on a host PC x86-64 architecture and the   output binaries (docker image) are for the Arm64 (Agilex\u2122 HPS architecture)</li> <li>A Motion Control library as specified by the PLCOpen Standard   is integrated into the runtime and is available to PLC applications.</li> <li>The Motion Control library provides a high level API for motor   axis control e.g. setting velocity, setting position, stopping,   etc; with defined constraints for acceleration and speed.</li> <li>Drive-On-Chip OpenPLC driver for Agilex\u2122 devices.</li> <li>Ruckig library for trajectory control.</li> <li>Hardware support for dual axis Agilex\u2122 Drive-On-Chip IP application.</li> <li>Structured Text (.st) example application for Agilex\u2122 Drive-On-Chip control.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/features-plc/#drive-on-chip-motor-control-ip-on-the-agilextm-fpga","title":"Drive-on-Chip Motor Control IP on the Agilex\u2122 FPGA","text":"<ul> <li>Integration in a single Agilex\u2122 FPGA of multi-axis   motor control IP, see:<ul> <li>AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices</li> <li>AN 999: Drive-on-Chip with Functional Safety Design Example: Agilex\u2122 7 Devices</li> </ul> </li> </ul> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/glossary/","title":"Drive-On-Chip with Functional Safety Design Example for Agilex\u2122 5 Devices","text":"<p> <p>Acronyms and Terminology</p> Term Description PLC Programmable Logic Controller DoC Drive On Chip FOC Field Oriented Control QEP Quadrature Encoder Pulse EMIF External Memory Interface FPGA Field Programmable Gate Array BSP Board Support Package IP Intellectual Property (hardware) DSP Digital Signal Processing CAN Controller Area Network GUI Graphical User Interface JTAG Joint Test Action Group (industry standard for testing) UART Universal Asynchronous Receiver-Transmitter RAM Random Access Memory HPS Hard Processor System AXI Advance eXtensible Interface bus protocol SDM Secure Device Manager ADC Analog to Digital Converter HPS2FPGA Hard Processor System to FPGA, usually referring to a hardened memory-mapped bridge IRQ Interrupt Request PD Usually used to refer to \"Platform Designer SPI Serial Peripheral Interface PIO Parallel Input/Output DSP BA Used to refer to \"DSP Builder Advanced tool RTL Register Transfer Level DTS Device Tree Source DTB Device Tree Blob ST Structured Text LD Ladder Logic FBD Function Block Diagram SFC Sequential Function Charts ISR Interrupt Service Routine IEC International Electro-technical Commission RT Real Time UIO User Space I/O System <p></p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/hw-funct-descr/","title":"Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices","text":"<p>This document provides insights about the functionality of the design example using the hardware blocks as a reference. The user must account for the interaction of the hardware described in this section and the software that executes in the Hard Processor System to gain full understanding of the implementation of the PLC Application for Speed motion control.</p> <p>The Platform Designer high-level system includes many subsystems. These subsystems allow the system to work appropriately.</p> <ul> <li>The <code>clock_subsystem</code> and <code>board_subsystem</code> contain blocks related to the board   resources such buttons, switches, LEDs, reference clocks, resets. They provide   the clocks and resets for the other subsystems.</li> <li>The <code>hps_subsystem</code> is an instance of the Agilex\u2122 HPS, which operates the   higher-level software stack in Linux. It includes an EMIF to the on-board DDR4   chip, featuring presets and connections for the HPS2FPGA bridges to other   subsystems. Additionally, the subsystem incorporates a DDR4 EMIF instance to   interface with the on-board memory chip, complete with all necessary presets   and connections to the HPS2FPGA bridges for integration with other subsystems.</li> <li>The subsystems <code>dniosv_subsystem*</code>, <code>motor_model_subsystem*</code>, <code>drive_subsystem*</code>   and <code>control_subsystem*</code> are blocks related to motor control and motor modeling.   For more information on these blocks, refer to   AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices. </li> </ul> <p>The following block diagram shows the main components and subsystems of the \"Drive-On-Chip with PLC Design Example\".</p> <p></p> <p> <p>Hardware Top Block Diagram. </p> <p>The diagram is color-coded to match the Platform Designer view and the XML file (Modular Design Toolkit methodology) for this design (see: AGX_5E_Modular_Devkit_HPS_NIOSVg_DoC_dual_axis.xml). The following figure correlates the block diagram, the XML file and the Platform Designer view:</p> <p></p> <p> <p>Modular Design Tool Kit PD project vs XML file. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/hw-funct-descr/#hardware-subsystems-and-components","title":"Hardware Subsystems and Components","text":"<p>This project variant is based on the \"Drive-On-Chip Example Design for Agilex Devices\" see AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices and AN 994: Drive-on-Chip Design Example for Intel\u00ae Agilex\u2122 7 Devices. Enhancing it with an instance of the HPS Subsystem (Hard Processor System) to provide a higher level of abstraction for motion control. The subsystems instantiated in the XML file are described below.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/hw-funct-descr/#a-clock-and-board-subsystems","title":"a. Clock and Board Subsystems","text":"<p>The clock Subsystem alongside the Board subsystem contains blocks related to the board resources such as buttons, switches, LEDs, reference clocks, and resets. They provide the clocks and resets for the other subsystems.</p> <p></p> <p> <p>Board and Clock Subsystems PD sub-Blocks. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/hw-funct-descr/#b-hps-subsystem","title":"b. HPS Subsystem","text":"<p>The HPS Subsystem is mainly an instance of the \u201cHard Processor System Agilex\u2122 (or other) FPGA IP\u201d and is configured consistently with the GSRD: Agilex\u2122 5 E-Series Modular Development Kit GSRD User Guide (25.1). The HPS in this design boots a custom version of Linux based on Yocto to implement any higher-level abstraction motion control interface with the Drive-On-Chip. Internally the subsystem is composed of the HPS, EMIF for external DDR available on the development kit and bridges for the Lightweight and Full HPS to FPGA bridge (highlighted in the next figure). The Full HPS-to-FPGA bridge is utilized to interface with the Control Subsystem block. This enables the HPS to modify, set, and configure motor control parameters, such as adjusting speed, position, speed limits, and configuring proportional/integral gains for the control loops, among other settings.</p> <p></p> <p> <p>Hard Processor System (HPS) PD sub-Block. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/hw-funct-descr/#c-cpu-dnios_-subsystem","title":"c. CPU (dnios_) Subsystem","text":"<p>The Drive-On-Chip Design Example NiosV/g processor subsystem offers a fully functional processor system with debugging capabilities. The NiosV/g processor subsystem comprises the following Platform Designer components: NiosV/g soft processor, on-chip RAM, JTAG master, IRQ management, JTAG UART, timers and, performance counters.</p> <p></p> <p> <p>CPU Subsystem (NIOSV/g) PD sub-Blocks. </p> <p>The ISR uses the memory blocks for code and data to ensure fast, predictable execution time for the motor control algorithm. The NiosV/g subsystem uses the JTAG master and debug memories to allow real-time interactions between the GUI and the processor.</p> <p>This CPU subsystem performs all the tasks required for deploying lower-level motor control algorithms, managing and initializing motor control resources, and tracing signals.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/hw-funct-descr/#d-drive-subsystem","title":"d. Drive Subsystem","text":"<p>There are two instances of the \"drive_subsystem\" in this variant. This subsystem is a collection of IPs to enable interfaces, signals and ports for motor control using FPGA. The main components of this subsystem are Six-channel PWM Interface IP (doc_pwm), a Drive System Monitor IP (doc_sm), Quadrature Encoder Interface IP (doc_qep), Sigma-Delta ADC interfaces for Drive Axes (doc_adc and doc_adc_pow), an instance of Field-Oriented Control Algorithm IP generated with DSP Builder (doc_foc_fixp), resolver SPI interface IP (doc_rslvr_spi*), and Parallel IO IP (hall pio) for hall interface. More details about these blocks can be found in Application Notes AN 1000: Drive-on-Chip Design Example: Agilex\u2122 5 Devices and AN 999: Drive-on-Chip with Functional Safety Design Example: Agilex\u2122 7 Devices</p> <p></p> <p> <p>Drive Subsystem PD sub-Blocks. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/hw-funct-descr/#e-control-subsystem","title":"e. Control Subsystem","text":"<p>The Drive-On-Chip Design uses the debugging RAM to send commands and receive status information. The debugging dump memory stores trace data that you can display as time graphs in the GUI (doc_svm_dump). The debug memory (doc_sys__debug_ram) is used to interact and provide commands to the Drive-On-Chip control application. The memories contained in the control subsystem are fundamental to interacting with the DoC capabilities and getting feedback signals for debugging and external control.</p> <p></p> <p> <p>Control Subsystem PD sub-Blocks. </p> <p>To interface directly with the Drive-On-Chip application for command and configuration purposes, utilize the FULL HPS-to-FPGA Bridge base address along with the specified offsets (each being a 32-bit wide value). Be sure to account for the offset between the first and second axis.</p> <p> Axis Offset from HPS bridge base Axis0 0x0008_0000 Axis1 0x0008_0108 <p></p> <p>Note</p> <p>In the previous table the address 0x0008_0000 is the base address of the  debug memory (doc_sys__debug_ram), each Axis has 66 32-bit wide data locations (hence the first axis initiates at 0x0 and the second axis memory space initiates at 0x108).</p> <p>The user can interact with the motor control application by reading or writing to the following memory locations from the Axis* base.</p> <p> Offset from Axis base Register Name Read/Write Description 0x00 DOC_DBG_DRIVE_STATE R State of the Drive System Monitor IP, refer to source code if the Drive-On-Chip  app running on NiosV for more details. 0x04 DOC_DBG_RUNTIME R Time in seconds the DoC App has been running. 0x08 DOC_DBG_DSP_MODE R Software (0x0) or DSP Builder IP (0x1) Field Oriented Control Algorithm execution. 0x0C DOC_DBG_APP_STATE R Drive-On-Chip Embedded Software Application State, refer to source code if  the Drive-On-Chip app running on NiosV for more details. 0x10 DOC_DBG_LATENCY1 R Latency of the FOC algorithm calculation. 0x28 DOC_DBG_SPEED R Measured Speed in RPM of the axis. 0x30 DOC_DBG_POSITION R Measured position of the encoder, need to decode the value to get degrees = \\&lt;value&gt; * 360 / 65536 0x34 DOC_DBG_BUTTON_DSP_MODE R/W Software (0x0) or DSP Builder IP (0x1) Field Oriented Control Algorithm execution 0x38 DOC_DBG_BUTTON_DRIVE_RESET R/W Write a 0x1 to the first axis of the array, to reset all axes controlled by a  single Nios, this register clears automatically. 0x3C DOC_DBG_DEMO_MODE R/W Close-loop, Open-loop, with 16kHz, 32kHz and 64kHz variants, refer  to source code if the Drive-On-Chip app running on NiosV for more details. 0x48 DOC_DBG_I_PI_KP R/W Current Loop Proportional Gain. 0X4C DOC_DBG_I_PI_KI R/W Current Loop Integral Gain. 0x50 DOC_DBG_SPEED_PI_KP R/W Speed Loop Proportional Gain. 0x54 DOC_DBG_SPEED_PI_KI R/W Speed Loop Integral Gain. 0x58 DOC_DBG_SPEED_SETP0 R/W Speed set-point for the axis in RPM. 0x64 DOC_DBG_POS_SETP0 R/W Position set-point. E.g: If you want 1500 degrees then write to the  memory location 1500 * 65536 / 360 = 273066 =&gt; 0x42AAA 0x74 DOC_DBG_WAVE_DEMO_MODE R/W Motor control mode 0x0 for speed mode, 0x1 for position mode. 0x78 DOC_DBG_POS_SPEED_LIMIT R/W Speed limit in position mode in RPM. 0x7C DOC_DBG_POS_PI_KP R/W Position Loop Proportional Gain. 0xE0 DOC_DBG_LATENCY2 R ISR Latency. <p></p> <p>For other values, refer to the source code of the Drive-On-Chip app running on NiosV for more details. </p> <p>The resulting addressing formula is as the following:  <code>Target = HPS_bridge_base + Debug_Memory_Base + (Axis_Number * Axis_Mem_Space_Span) + Offset_from_Axis_Base_Reg</code>. Where <code>Axis_Mem_Space_Span</code> is <code>0x108</code>.</p> <p>For example: to change the speed in RPM of axis1 (second axis) in an Agilex\u2122 device using the FULL HPS-to-FPGA bridge:</p> <ul> <li>DOC_DBG_SPEED_SETP0_add_from_HPS = HPS_bridge_base + Debug_Memory_Bas + (Axis_Number * Axis_Mem_Space_Span) + Offset_from_Axis_Base_Reg</li> <li>DOC_DBG_SPEED_SETP0_add_from_HPS = 0x4000_0000 + 0x0008_0000 + (0x1 * 0x108) + DOC_DBG_POS_SETP0; where DOC_DBG_POS_SETP0 is 0x58</li> <li>DOC_DBG_SPEED_SETP0_add_from_HPS = 0x4008_0160</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/hw-funct-descr/#f-motor-model-subsystem","title":"f. Motor Model Subsystem","text":"<p>The Drive-On-Chip Design Example for Agilex\u2122 Devices implements a motor and power board model instead of a real motor kit. The motor and power board model is a DSP Builder model, which generates the RTL for the motor and power board model. By integrating the Avalon interface, motor parameters are accurately configured to represent a tandem motor kit. You can experiment with the design without investing in an expensive motor kit. You can explore and optimize your designs. The motor model included in this design example is based on the Tandem Motion 48V power board parameter specifications with a Tamagawa TS4747N3200E600 motor. There are two instances of the motor_model_subsystem in this design.</p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/other-user-flow/","title":"Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/other-user-flow/#compiling-the-project-using-a-mdt-qar-file","title":"Compiling the project using a MDT QAR file","text":"<ul> <li>Download the relevant design <code>.qar</code> file for your development kit and power    board from  link/repository.</li> </ul> <ul> <li>Double click in the .qar file or alternatively use Quartus\u00ae command line to   open it:<pre><code>  quartus &lt;MDT_QAR_NAME&gt;.qar\n</code></pre> <p>The contents of the <code>.qar</code> file open into the working directory. The   design example has the following directory structure.</p> <p></p> <p> <p>QAR file content. </p> <p>Note: This <code>QAR</code> file was generated using the \"Modular Design Toolkit\" flow.</p> <p></p> <p> <p>QAR and Project Directory Structure.</p> Directory Description assets Contains base files to run the example design derived from the hardware compilation. non_qpds_ip Contains the source code (RTL) of the design\u2019s custom IP that is not part of Quartus\u00ae Prime. quartus Contains the base files for the Quartus\u00ae Project including the top.qpf, top.qsf. rtl Contains the sources files to build the project. scripts Contains a collection of TCL scripts from \"Modular Design Toolkit\" to build and compile the design software and hardware. sdc Contains the .sdc files for the subsystems to compile the project. software Contains all the files for building the application for the Nios V and/or HPS. Look for the app.elf binary or *_cpu_ram_cpu_ram.hex that is included in the SOF <p></p> <p></p> <ul> <li>Navigate to <code>&lt;project&gt;/quartus/</code> and open the <code>top.qpf</code> file either by double    clicking on it or using the command:<pre><code>quartus top.qpf\n</code></pre> </li> </ul> <ul> <li>To generate the <code>.sof</code> file, click on \"Processing -&gt; Start Compilation Ctrl+L\"   or simply press the \"Start Compilation\" icon in the Quartus\u00ae Prime Pro GUI.</li> </ul> <p></p> <p> <p>Quartus\u00ae Prime Pro compilation flow. </p> <p>Wait for the compilation to finish. The <code>.sof</code> file should be located in the   <code>&lt;project&gt;/quartus/output_files</code> directory. Follow the steps generate the   <code>RBF/JIC</code> file using the <code>.sof</code> file and the <code>u-boot-spl-dtb.hex</code> file.</p> <p>Note: it si recommended to generate any embedded software images that are included in the <code>.sof</code> file before compiling, i.e NiosV software.</p> <p></p> <p>Back to User Flows</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/other-user-flow/#compiling-and-building-the-niosv-application-and-bsp","title":"Compiling and Building the NiosV application and BSP","text":"<p>Before rebuilding the BSP, ensure that the <code>settings.bsp</code> file correctly generates. To generate BSP, use command line and <code>niosv-bsp</code> command.</p> <p>The design includes an initial version of <code>settings.bsp</code> that contains parameters to run the design. If you modify the Platform Designer's hardware, ensure you keep the integrity of the <code>settings.bsp</code> file.</p> <ul> <li> <p>After changing the <code>settings.bsp</code> file, compile the application and generate the BSP   with the command:</p> <pre><code>  cd &lt;project&gt;/software/*niosv_subsystem*\n  make\n</code></pre> </li> </ul> <p>Running <code>make</code> takes an existing template <code>settings.bsp</code> file and creates a new one based on it for the current project. It updates locations of project then builds the <code>.bsp</code> and the NiosV application. See the provided <code>makefile</code> and <code>CMakeList.txt</code> files for more details in about the software build. The app.elf file is in <code>&lt;project&gt;/software/*niosv_subsystem*/build/bin</code></p> <p>If necessary, compile the hardware again to update the <code>.sof</code> file, so it contains the new binaries (<code>.hex</code>) for memory initialization (<code>&lt;project&gt;/software/*niosv_subsystem*/build/bin/mem_init</code>).</p> <p></p> <p></p> <p>Back to User Flows</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/other-user-flow/#creating-the-qspi-flash-and-sd-card-configuration-bitstreams-for-the-board","title":"Creating the QSPI Flash and SD card configuration bitstreams for the board","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/other-user-flow/#create-phase-1-and-phase-2-configuration-bitstreams-for-hps-first-flow","title":"Create phase 1 and phase 2 configuration bitstreams for \"HPS First\" Flow","text":"<p>Follow these steps if the \"HPS init\" property for the <code>hps_subsystem</code> in the <code>XML</code> is set to <code>\"HPS FIRST\"</code>. You can check this property by executing the following Quartus\u00ae command and the <code>\"\\*.sof\"</code> file. For example:</p> <pre><code>quartus_pfg -i top.sof\n</code></pre> <p>In the log, look for the property <code>\"HPS/FPGA configuration order\"</code> SET TO <code>\"HPS_FIRST\"</code></p> <p></p> <p> <p>HPS First SOF file. </p> <p>Important! The following step depends on the output of u-boot compilation specifically the file <code>u-boot-spl-dtb.hex</code>. To generate the pair <code>top.core.rbf</code> and <code>top.hps.jic</code> execute:</p> Agilex\u2122 5Agilex\u2122 3 <p>For [Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre></p> <p>For [Agilex\u2122 3 FPGA and SoC C-Series Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU512 \\\n-o flash_loader=A3CW135BM16AE6S \\\n-o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/other-user-flow/#create-phase-1-and-phase-2-configuration-bitstream-for-fpga-first-flow","title":"Create phase 1 and phase 2 configuration bitstream for \"FPGA First\" Flow","text":"<p>Follow these steps if the <code>\"HPS init\"</code> property for the hps_subsystem in the <code>XML</code> is set to <code>\"AFTER INIT_DONE\"</code>. You can check this property by executing the following Quartus\u00ae command and the <code>\"\\*.sof\"</code> file. For example:</p> <pre><code>quartus_pfg -i top.sof\n</code></pre> <p>In the log, look for the property <code>\"HPS/FPGA configuration order\"</code> SET TO <code>\"AFTER INIT_DONE\"</code></p> <p></p> <p> <p>FPGA First SOF file. </p> <p>Important! The following step depends on the output of u-boot compilation specifically the file <code>u-boot-spl-dtb.hex</code>. To generate the <code>top.jic</code> execute:</p> Agilex\u2122 5Agilex\u2122 3 <p>For [Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=A5ED065BB32AE6SR0 -o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n</code></pre></p> <p>For [Agilex\u2122 3 FPGA and SoC C-Series Development Kit] <pre><code>quartus_pfg -c top.sof top.jic \\\n-o device=MT25QU512 \\\n-o flash_loader=A3CW135BM16AE6S -o hps_path=u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n</code></pre></p> <p></p> <p>Back to User Flows</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/plc-design-recomendations/","title":"Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/plc-design-recomendations/#recommendations-and-disclaimers","title":"Recommendations and Disclaimers","text":"<p>The Drive-on-Chip with PLC Design Example for Agilex\u2122 devices implements the a combination of hardware compiled using Quartus\u00ae, Altera\u00ae Platform designer and high-level software from OpenSource resources deployed with Docker to demonstrate a basic PLC (Programmable Logic Controller) system. The design is based on the controlling the Drive-On-Chip IP (dual axis) from a Structured Text (ST) PLC IEC 61131-3 complaint program and the OpenPLC Runtime.</p> <p>This design only shows how to implement the PLC system concept in a SoC FPGA device. Altera\u00ae does not intend in any way for you to deploy this design in a real-world production environment. The design is not validated for any certification related to industrial or safety standards compliance.</p> <p>This design only demonstrates the PLC concept principles, but it does not meet the rigorous standards and requirements for deployment in production systems. You must put in place all mechanisms, validation, verification, checks, and extension of your production application.</p> <p>The design provides meta-layers for custom Yocto build based on KAS with the same underlying components recommended in the Agilex\u2122 GSRD documented on the Altera\u00ae FPGA Developer Site website. The meta layer provides the application and the modifications to the SD card collaterals to enable the HPS software stack and the communication with devices in the FPGA fabric. However, you must modify or fix the meta layer and the software application components if you use any other version of these components as a base to build the SD card image. Altera\u00ae does not maintain the SW and SD card images. An SD card image, based on the GSRD and/or in this example design is not a production ready framework. You must validate the operating system of your choice and programming models to certify your system with suitable industry standards. The same principles apply with any \"production-ready\" implications concerning the deployment of docker containers and OpenSource software.</p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/","title":"Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#a-overview-software-stack-functional-description","title":"a. Overview: Software stack functional description","text":"<p>High-level software components for running the OpenPLC runtime in this design example are deployed using Docker and a custom Linux distribution based on YOCTO. By enabling virtualization, Docker, and UIO devices, the high-level software can communicate with custom hardware programmed into the FPGA fabric (Drive-On-Chip, see \"Hardware Functional Description\"). This example design demonstrates how to interface the OpenPLC runtime with logic programmed in the FPGA fabric, a concept that can be replicated using the software stack with any IP in the FPGA.</p> <p>The primary software components are summarized in the following figure and described in the subsequent sections:</p> <p></p> <p> <p>Software Top Block Diagram. </p> <p>In summary:</p> <ul> <li>A custom distribution of Linux with virtualization enabled, docker,   UIO device driver, build based on KAS.</li> <li>Debian-based container to support portability across devices. Cross-compiled   for ARM64 architecture.</li> <li>Servo Driver (or Drive-On-Chip) OpenPLC hardware support to interface the   OpenPLC Runtime with FPGA IP (in this case the Drive-On-Chip IP/System).   This include patches to enable Agilex\u2122 Hardware selection in the OpenPLC   Runtime web-server interface.</li> <li>OpenPLC Motion Control Library (Implemented using RT Motion library) based   on PLCOpen standard IEC-61131-3. See: PLCopen Motion Control Specification</li> <li>Integration of Ruckig Motion Planner Library, to generate trajectories   constrained by velocity, acceleration and other parameters. See:   Ruckig: Instantaneous Motion Generation for Robots and Machines</li> <li>OpenPLC Runtime: An Open Source Programmable Logic Controller implementation   created in accordance to the IEC 61131-3 standard that defines architecture   and basic programming languages for PLCs.</li> <li>The OpenPLC runtime has an in-build webserver that allows basic runtime   configuration.</li> <li>An example of how to run an user-specific PLC program in Structured Text (ST)   language to control and interface with the Drive-On-Chip System in the FPGA   fabric.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#b-custom-linux-distribution-based-on-kas","title":"b. Custom Linux distribution based on KAS","text":"<p>For the Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices, Altera\u00ae provides the files to build the Linux system to run the PLC Software Stack enclosed in a Docker Container. The custom version of linux is built based on KAS (see: agilex-ed-drive-on-chip/sw). An it is compose of two main meta-layers. In this document the files relevant for the \"Drive-On-Chip with PLC Design Example for Agilex\u2122 Devices\" are highlighted.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#fpga-embedded-layer","title":"FPGA Embedded Layer","text":"<ul> <li>See meta-altera-fpga</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#drive-on-chip-layer","title":"Drive-On-Chip Layer","text":"<ul> <li>See meta-driveonchip</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#b1-necessary-elements-in-the-meta-layers-to-bind-software-and-hardware","title":"b.1. Necessary elements in the meta-layers to bind Software and Hardware","text":"<p>This section details the various elements included in the meta-layers that facilitate running the PLC application. These elements assist in \"binding\" the FPGA Soft IP, such as Drive-On-Chip, with the software running on the HPS, which operates on Linux and is containerized using Docker. The following sections explain these elements to clarify the interaction between the HPS software stack and the FPGA IP (soft logic, Drive-On-Chip). This interaction between the PLC and Drive-On-Chip IP serves as an example of how to interface any soft IP in the FPGA fabric with higher-level software, such as the OpenPLC Runtime contained within a Docker image.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#b11-device-tree","title":"b.1.1. Device Tree","text":"<p>Adds a custom .dtsi (device tree fragment) file to the main device tree for Linux kernel boot up stage <code>socfpga_agilex5_socdk.dts</code>. it compiles into a DTB (device tree blob) during kernel compilation and is added to the SD card image during the Yocto build. The recipe <code>device-tree.bb</code>. The specific file for this design example (<code>agilex5_dual_axis.dtsi</code>), is appended using <code>device-tree.bbappend</code> directive. Look for these files in the different meta-layers provided above.</p> <p></p> <p> <p>Custom Device Tree Fragment. </p> <p>You expand the device tree by appending the contents of the file <code>agilex5_dual_axis.dtsi</code>, that exposes an additional as UIO device in the RootFS (<code>generic-uio</code>). The figure shows the instance of the device. This definition should match with the devices that the HPS can access in the FPGA soft logic and you can verify the address map in the Platform Designer Project (<code>.qsys</code>).</p> <p>For example, the Drive-On-Chip control subsystem <code>debug memory</code> (<code>doc_sys_debug_ram</code>) that  is used to interact and provide commands to the Drive-On-Chip control application has the base address <code>0x0008_0000</code> in Platform Designer, but from the view of HPS you should add the offset reflecting the HPS-FPGA bridge <code>0x4000_0000</code>, refer ( System Memory Mapping Scheme in the Hard Processor System Technical Reference Manual: Agilex\u2122 5 SoCs (25.1)) specifying the address <code>0x4008_0000</code> in the <code>agilex5_dual_axis.dtsi</code> file. Components connected to the full HPS to FPGA bridge have an offset of <code>0x4000_0000</code> and components connected to lightweight HPS-to-FPGA bridge have an offset of <code>0x2000_0000</code>.</p> <p>The Drive-On-Chip component is listed in the .dtsi as compatible <code>generic_uio</code>, which is a way to map devices using generic user IO interface in the Linux kernel and user space. If you modify or add memory mapped devices in Platform Designer, also add the change in the <code>.dtsi</code> file. When the Yocto build refreshes, the Linux system lists the device in the corresponding <code>/dev/uiox</code> and populates the information in <code>/sys/class/uio/uiox</code>. To enable UIO devices two Linux kernel modules must be enabled in <code>uio.cfg</code> file: <code>CONFIG_UIO</code> and <code>CONFIG_UIO_PDRV_GENIRQ</code> The <code>.dtsi</code> and Platform Designer mapping should be consistent to provide the HPS software application to run correctly.</p> <p>The interaction between the Drive-On-Chip UIO device and the OpenPLC Runtime is achieved by enabling hardware support for the Agilex\u2122 Device. In this example design this is applied using the source file <code>agilex_doc.cpp</code> and the patch file <code>agilex_doc.patch</code> </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#b12-fpga-bitstream","title":"b.1.2. FPGA Bitstream","text":"<p>Adds the <code>agilex5_modular_dual_axis.core.rbf</code> file to the build. The file is generated after Quartus\u00ae Prime compilation. The <code>*core.rbf</code> file is added to the boot partition of the SD card (renamed as <code>top.core.rbf</code>). The HPS configures the FPGA at initialization using u-boot <code>load</code> command in <code>uboot.txt</code> generated into <code>boot.scr.uimg</code> in the boot partition by <code>u-boot-socfpga_%.bbappend</code> (look for the files in the meta-layer).</p> <p></p> <p> <p>FPGA configuration during HPS booting process. </p> <p>Look for the print \"..... FPGA reconfiguration OK \" during the device booting process, as shown in the previous figure to ensure the FPGA bitstream (<code>top.core.rb</code>) has been properly loaded. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#b13-additional-u-boot-configuration","title":"b.1.3. Additional u-boot configuration","text":"<p>An append to the u-boot arguments using <code>IMAGE_BOOT_ARGS</code> and <code>IMAGE_BOOT_ARGS:append:agilex5_modular</code> in different KAS/YOCTO configuration files to enable UIO drivers defined by <code>uio_pdrv_genirq.of_id=generic-uio</code>. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#b2-necessary-elements-in-the-meta-layers-to-enable-docker-deployments","title":"b.2. Necessary elements in the meta-layers to enable Docker deployments","text":"<p>To enable the execution of Docker container-based applications on the SoC FPGA platform, certain additions are required for the custom Linux build based on KAS. These include enabling virtualization through the <code>meta-virtualization</code> layer, configuring the respective kernel settings, and installing Docker in the SD card image.</p> <p>These customizations are implemented using the <code>docker.yml</code> KAS configuration file, which adds the <code>meta-virtualization</code> layer to the YOCTO build and installs <code>docker</code> and <code>docker-compose</code> into the RootFS. This configuration is included in the includes: section of the main KAS-YOCTO configuration file, <code>kas_dual_axis.yml</code>. The necessary kernel configuration settings to enable Docker and virtualization are contained in the <code>docker.cfg</code> file, wrapped within the <code>virtualization-layer</code> (dynamic layer).</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#b3-preempt-rt-patch","title":"b.3. PREEMPT-RT patch","text":"<p>This example shows the user how to easily \"patch\" the Linux kernel with <code>PREEMPT_RT</code> patch, which provides soft Real Time characteristics particularly useful for embedded hardware applications. See the file <code>linux-socfpga-rt_6.6.bb</code></p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#c-debian-based-container-image-for-openplc","title":"c. Debian-based container image for OpenPLC","text":"<p>The OpenPLC Runtime is packaged within a Docker image, which includes the necessary applications and libraries to operate the web server, application database, and PLC control application. The Docker container image deployed on the target Agilex\u2122 device is built and cross-compiled for ARM64 architecture, using a <code>Dockerfile</code> provided in the Altera\u00ae FPGA PLC repository (https://github.com/altera-fpga/altera-openplc).</p> <p>The main instructions to build the docker image in the provided Dockerfile are:</p> <ul> <li>Specifies the base image for building the container using the Debian 11   \"Bullseye\" release with a specific update (July 22, 2024) from the docker   registry, see: docker-bullseye-20240722</li> <li>Installs necessary build tools (cmake, git, build-essentials, etc).</li> <li>Clones the OpenPLC and installs Ruckig repositories:<ul> <li>OpenPLC Runtime version 3.</li> <li>Ruckig: Instantaneous Motion Generation for Robots and Machines.</li> </ul> </li> <li>Installs PLC Motion libraries and applies patches for Agilex\u2122 hardware support.</li> <li>Installs OpenPLC Runtime.</li> <li>Entrypoint is defined as OpenPLC Runtime with the <code>start_openplc.sh</code> script.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#d-servo-driver-drive-on-chip-openplc-hardware-support","title":"d. Servo Driver (Drive-On-Chip) OpenPLC hardware support","text":"<p>This C++ program is designed to interface with a hardware device using the UIO (Userspace I/O) framework in Linux. It primarily focuses on controlling servo motors through the Drive-on-Chip device.</p> <p>The following definitions and enumerations are enclosed in the namespace called <code>DoC</code>:</p> <p> <p>Definitions and Enums for servo Driver Program</p> Definitions and Enums Description <code>RTMOTION</code> A macro defined at the beginning, likely indicating that the program is  part of the RTmotion library or framework <code>DRIVE_AXIS_PER_DEVICE</code>, <code>MAX_AXIS_NUM</code> Constants defining the number of axes per device and the  maximum number of axes, respectively <code>WaveDemoMode</code>, <code>WaveDemoWaveform</code> Enumerations defining different modes and waveforms for a wave demonstration feature <code>DebugRegister</code> An enumeration listing various registers for debugging and controlling the  device. These registers cover a wide range  of functionalities, from general drive  status to specific control parameters <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#d1-uiodevice-class","title":"d.1. \"UIODevice\" class","text":"<p>Manages the interaction with a UIO device, including memory mapping and register access. The constructor <code>UIODevice</code> initializes the device and axis, checks for device and axis availability, and sets up memory mapping. The destructor <code>~UIODevice</code> cleans up the memory mapping.</p> <p> <p>Class Methods</p> Method Description <code>Read</code> Reads a value from a specified register <code>Write</code> Writes a value to a specified register <code>GetDevicePath</code> Determines the device path for a given device name <code>IsAxisMapped</code> Checks if a specific axis is mapped for a given device <code>ReadSysHexVal</code> Reads a hexadecimal value from a system file <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#d2-docservo-class","title":"d.2. \"DoCServo\" class","text":"<p>Represents a servo motor controlled by the DoC device. The constructor <code>DoCServo</code> initializes the servo for a specific axis, checking if the axis is mapped and setting up the device. The destructor is empty.</p> <p> <p>Class Methods</p> Method Description <code>setVel</code> Sets the target velocity for the servo <code>vel</code> Retrieves the current velocity from the device <code>runCycle</code> Updates the device with the current target  velocity and configures the wave demo settings <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#d3-global-variables-and-functions","title":"d.3. Global variables and functions","text":"<p> Variables and Functions Description Global Variables <code>config</code> Array of AxisConfig objects for configuring axes <code>servo</code> Array of pointers to DoCServo objects <code>active_drives_num</code> Tracks the number of active drives Global Functions <code>initializeHardware</code> Initializes the hardware by setting up axes and servos,  and configuring them <code>finalizeHardware</code> Cleans up resources by deleting axes and servos <code>updateBuffersIn</code> Updates input buffers, running the cycle for each  active axis <code>updateBuffersOut</code> Placeholder function for updating output buffers <p></p> <p>In summary the program in <code>agilex_doc.cpp</code> files is structured to manage and control servo motors using a UIO device interface. It sets up memory mapping for device registers, configures axes and servos, and provides functions to initialize and finalize hardware resources. The program also includes mechanisms to read and write to device registers, allowing for real-time control and monitoring of servo motor parameters.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#e-plcopen-motion-control-standard-and-rtmotion-motion-control-library","title":"e. PLCOpen Motion Control Standard and RTmotion Motion Control Library","text":"<p>PLCopen is a standards organization that supports automation for PLCs. The PLCopen Motion Control standard defines operations on motor axes using functional blocks.  The blocks wrap the complex operations of motor control in a simplified API. The advantages include:</p> <ul> <li>A standard interface to different manufacturers motor hardware.</li> <li>Portability of applications.</li> <li>Reduced training required to implement motor control applications.</li> </ul> <p>The figure below is an example of how this can be used to coordinate two motor axes:</p> <p></p> <p> <p>Example of PLCOpen Motion control functional block. </p> <ul> <li>The Execute input triggers the first function block to move motor   <code>Axis X</code> to a defined position <code>X_POS</code>.</li> <li>When the first operation is complete the Done output starts the   second function block which  moves motor <code>Axis Y</code> to its predefined   position <code>Y_POS</code>.</li> </ul> <p>The RTmotion library implements the PLCopen Motion Control functional blocks. The library is released under the open source license Apache V2.0. The RTmotion library has a dependency on the Ruckig library. Ruckig is used for motion planning operations: calculating the optimum speed profile for the axis so the system moves efficiently but within the constraints of maximum acceleration and jerk (rate of change of acceleration). For more details see: Ruckig: Instantaneous Motion Generation for Robots and Machines.</p> <p>A copy of the RTmotion library is included into the Altera\u00ae FPGA PLC repository https://github.com/altera-fpga/altera-openplc.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#f-openplc-runtime","title":"f. OpenPLC Runtime","text":"<p>OpenPLC is an open-source programmable logic controller (PLC) platform designed to provide a flexible and cost-effective solution for industrial automation and control systems. It is built to be compatible with the IEC 61131-3 standard, which is the international standard for PLC programming languages. OpenPLC supports multiple programming languages defined by this standard, including Ladder Logic (LD), Structured Text (ST), Function Block Diagram (FBD), and Sequential Function Charts (SFC). The runtime includes a web-based interface for programming and monitoring, which simplifies the process of developing and managing PLC projects.</p> <p>The OpenPLC project consists of Editor and Runtime components. The Editor is used to create and simulate applications written in the IEC 61131 PLC languages. To run the applications on real hardware the OpenPLC Editor converts the programs to Structured Text (ST) format. The OpenPLC Editor supports two deployment options for the resulting Structured Text output:</p> <ul> <li>Upload to a Linux target system via the OpenPLC Runtime webserver.   The runtime converts Structured Text to C source code  and compiles   it on the target device to a  binary that implements the PLC operations.</li> <li>Use OpenPLC Editor convert and compile the application on the host PC   before downloading the resulting binary to a micro-controller.</li> </ul> <p>The Drive-on-Chip with PLC Design Example for Agilex\u2122 Devices uses the first option to build and deploy ST program.</p> <p>More information about OpenPLC can be found in: OpenPLC Documentation</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#g-example-of-an-user-specific-plc-program-in-structured-text-st-for-doc-control","title":"g. Example of an user-specific PLC program in Structured Text (ST) for DoC control","text":"<p>The example on how to control the Drive-On-Chip IP in the FPGA fabric with an Structured Text program that executes in the OpenPLC Runtime is described in the file <code>agilex_doc.st</code>. The program description is as follows:</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#g1-function_block-onoffintervaltimer","title":"g.1. FUNCTION_BLOCK \"OnOffIntervalTimer\"","text":"<p>This function block is designed to control an on-off interval timer. It has the following components:</p> <p> <p>Function Block Description.</p> Variable Description VAR_INPUT <code>ON_TIME</code> A <code>TIME</code> variable specifying the duration for which the timer should be active <code>OFF_TIME</code> A <code>TIME</code> variable specifying the duration for which the timer should be inactive VAR_OUTPUT <code>ACTIVE</code> A <code>BOOL</code> variable indicating whether the timer is currently active VAR <code>LATCH</code> An RS (Reset-Set) latch used to control the timing logic <code>ON_INTERVAL</code> A TP (Timer Pulse) block that generates a pulse for the <code>ON_TIME</code> <code>OFF_INTERVAL</code> A TOF (Timer Off Delay) block that manages the <code>OFF_TIME</code> Logic <code>LATCH</code> It is set when the <code>OFF_INTERVAL</code> is not active and reset when the <code>ON_INTERVAL</code> is active <code>ON_INTERVAL</code> It is triggered by the latch and runs for the <code>ON_TIME</code> <code>OFF_INTERVAL</code> It starts when the <code>ON_INTERVAL</code> finishes and runs for the <code>OFF_TIME</code> <code>ACTIVE</code> The output is true when the <code>ON_INTERVAL</code> is active <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#g2-program-prog0","title":"g.2 PROGRAM \"prog0\"","text":"<p>This program utilizes the <code>OnOffIntervalTimer</code> function block to control two axes of a motor system. It includes:</p> <p> Variable Description VAR <code>MOTOR_PULSE0</code> An instance of <code>OnOffIntervalTimer</code> to manage the timing of motor pulses VAR <code>AXIS_0_HALT</code>, <code>AXIS_1_HALT</code> Instances of <code>MC_HALT</code> to stop the axes <code>AXIS_0_SET_VEL</code>, <code>AXIS_1_SET_VEL</code> Instances of <code>MC_MOVEVELOCITY</code> to set the velocity of the axes <code>AXIS_0_READ_VEL</code>, <code>AXIS_1_READ_VEL</code> Instances of <code>MC_READACTUALVELOCITY</code> to read the actual velocity of the axes <code>AXIS_0_POWER</code>, <code>AXIS_1_POWER</code> Instances of <code>MC_POWER</code> to control the power state of the axes VAR <code>AXIS_0_VELOCITY</code>, <code>AXIS_1_VELOCITY</code> Real variables to store the actual velocity of each axis <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#g22-program-logic","title":"g.2.2. Program Logic","text":"<ul> <li>Powers on both axes with positive and negative enable.</li> <li>Uses <code>MOTOR_PULSE0</code> to control the execution of velocity setting and   halting commands based on its <code>ACTIVE</code> state.</li> <li>Sets the velocity, acceleration, deceleration, and jerk for each axis   when the timer is active.</li> <li>Halts the axes when the timer is inactive.</li> <li>Reads and stores the actual velocity of each axis.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/drive-on-chip/doc-plc/sw-funct-descr/#g3-configuration-config0","title":"g.3. CONFIGURATION \"Config0\"","text":"<p>This configuration sets up the PLC environment:</p> <ul> <li>RESOURCE Res0 ON PLC:<ul> <li>Defines a resource named <code>Res0</code> on the PLC.</li> <li>TASK Main: A task with a 50ms interval and priority 0.</li> <li>PROGRAM Inst0 WITH Main: Associates the <code>prog0</code> program with the <code>Main</code> task.</li> </ul> </li> </ul> <p>In summary, this ST file configures a PLC program to control motor axes using an on-off interval timer, managing power, velocity, and halting based on the timer's state.</p> <p></p> <p>Back to Documentation</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/ethernet/agx5e-ethernet-10g/ug-agx5e-ethernet-10g/","title":"Agilex\u2122 5 FPGA E-Series Modular Development Kit 1x10G Ethernet System Example Design","text":"<p> NOTE: This page is not available in this release. The latest release in which 1x10G Ethernet System Example Design User Guide is supported corresponds to 25.1. Please refer to the following page to access the latest documentation: 1x10G Ethernet System Example Design User Guide. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/","title":"HPS GSRD User Guide for the Agilex\u2122 5 E-Series Modular Dev Kit","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#gsrd-overview","title":"GSRD Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex\u2122 5 E-Series Modular Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Modular Development Kit GSRD:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex 5 Modular Development Kit GSRD binaries are located at https://releases.rocketboards.org/2025.08/:</p> Boot Source Link SD Card https://releases.rocketboards.org/2025.08/gsrd/agilex5_mk_a5e065bb32aes1_gsrd/ QSPI https://releases.rocketboards.org/2025.08/qspi/agilex5_mk_a5e065bb32aes1_qspi/"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#development-kit","title":"Development Kit","text":"<p>This release targets the Agilex 5 FPGA E-Series 065B Modular Development Kit. It is composed of a carrier board which offers additional connectivity, and a SOM board which contains the FPGA part, HPS DDRAM and all other required circuitry. Refer to board documentation for more information about the development kit.</p> <p></p> Changing MSEL <p>MSEL signals instruct the FPGA device on which configuration scheme to use. Configuration schemes used by the scenarios presented in this guide are JTAG and ASx4 (QSPI). MSEL is changed through dipswitch S4 on the top left cornet of the SOM board. Only change the settings while the board is powered off.</p> <p>The MSEL settings are:</p> <ul> <li>JTAG: SW4[2:1]=OFF:OFF</li> <li>ASx4 (QSPI): SW4[2:1]=ON:ON</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Dual core Arm Cortex-A76 processor</li> <li>Dual core Arm Cortex-A55 processor</li> <li>HPS Peripherals<ul> <li>Micro SD Card</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>UART</li> <li>I2C    </li> <li>USB 3.1</li> </ul> </li> </ul> </li> <li>Multi-Ported Front End (MPFE) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>One user LED output</li> <li>Two user DIP switch inputs</li> <li>One user push-button input</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <p> </p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>  MPU Address Maps <p>This section presents the address maps as seen from the MPU side.  </p>  HPS-to-FPGA Address Map <p>The three FPGA windows in the MPU address map provide access to 256 GB of FPGA space. First window is 1 GB from 00_4000_0000, second window is 15 GB from 04_4000_0000, third window is 240 GB from 44_0000_0000. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU, which starts at the lightweight HPS-to-FPGA base address of 0x00_2000_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0001_0000 32 Unique system ID button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs led_pio 0x0001_0080 16 LED outputs JTAG Master Address Map <p>There are three JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface and another for FPGA fabric to SDRAM.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0001_0000 32 Unique system ID button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs led_pio 0x0001_0080 16 LED outputs  Interrupt Routing <p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[1] DIP switch input button_pio f2h_irq0[0] Push button input"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#exercising-prebuilt-binaries","title":"Exercising Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Connect micro USB cable from bottom left of the carrier board to PC. This will be used for JTAG communication.</p> <p>3. Connect micro USB cable from bottom right of the SOM board to PC. This will be used for HPS UART communication.</p> <p>4. Connect Ethernet cable from SOM board to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>Each of the USB connections listed above will enumerate 4 USB serial ports on your host computer. The HPS UART port is the 3rd one enumerated by the connection to the SOM board.</p> <p>1. Install a serial terminal emulator application on your host PC:  </p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Remove USB cables, and power down your board if powered up. Look at what USB serial ports are enumerated on your computer by default, without board being connected.</p> <p>3. Power up the board.</p> <p>4. Connect micro USB cable from bottom left of the carrier board to PC. This will be used for JTAG communication. Look at what ports are enumerated on your host computer, there should be a series of four.</p> <p>5. Connect micro USB cable from bottom right of the SOM board to PC. This will be used for HPS UART communication. Look at what ports are enumerated on your host computer, there should be a series of four. Use the 3rd one in the list as the HPS serial port.</p> Possible serial port allocation in Windows <ul> <li>COM3: already there before board was installed</li> <li>COM4-7: enumerated by the JTAG connection</li> <li>COM8-11: enumerated by the HPS connection</li> </ul> <p>In the above case, the port to use for HPS serial communication would be COM10.</p> Possible serial port allocation in Linux <ul> <li>/dev/ttyUSB0-3: enumerated by the JTAG connection</li> <li>/dev/ttyUSB4-7:enumerated by the HPS connection</li> </ul> <p>In the above case, the port to use for HPS serial communication would be /dev/ttyUSB6.</p> <p>Notes:</p> <ul> <li>On Windows, the port number may be kept between power cycles, but not always. </li> <li>On Linux, the port numbe may change depending on the order in which cables are inserted.</li> </ul> <p>6. Configure your serial terminal emulator to use the following settings:  </p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>7. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#booting-from-sd-card","title":"Booting from SD Card","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#write-sd-card-image","title":"Write SD CardWrite QSPI FlashBoot LinuxRun Sample ApplicationsControl LEDConnect to Board Using SSHVisit Board Web Page","text":"<p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2025.08/gsrd/agilex5_mk_a5e065bb32aes1_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the gsrd-console-image-agilex5_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. For this, first rename the gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p> </p> <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/agilex5_mk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\ntar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>1. Boot to Linux</p> <p>2. Change current folder to <code>intelFPGA</code> folder <pre><code>cd intelFPGA\n</code></pre> 3. Run the hello world application <pre><code>./hello\n</code></pre> 4. Run the <code>syscheck</code> application <pre><code>./syscheck\n</code></pre> Press <code>q</code> to exit the <code>syscheck</code> application.</p> <p>1. Boot to Linux</p> <p>2. Control LED by using the following sysfs entries:</p> <ul> <li>/sys/class/leds/fpga_led0/brightness</li> <li>/sys/class/leds/hps_led1/brightness</li> </ul> <p>using commands such as: <pre><code>cat /sys/class/leds/fpga_led0/brightness\necho 0 &gt; /sys/class/leds/fpga_led0/brightness\necho 1 &gt; /sys/class/leds/fpga_led1/brightness\n</code></pre></p> <p>Because of how the LEDs are connected, for the above commands <code>0</code> means LED is turned on, <code>1</code> means LED is turned off.</p> <p>1. Boot to Linux  </p> <p>2. Determine the board IP address using the <code>ifconfig</code> command: <pre><code>root@agilex5devkit:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 192.168.1.153  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 fe80::f0eb:c8ff:fec4:eed7  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether f2:eb:c8:c4:ee:d7  txqueuelen 1000  (Ethernet)\nRX packets 649  bytes 45132 (44.0 KiB)\nRX errors 0  dropped 226  overruns 0  frame 0\nTX packets 56  bytes 8789 (8.5 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 23  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 100  bytes 8408 (8.2 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 100  bytes 8408 (8.2 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> 3. Connect to the board over SSH using <code>root</code> username, no password will be requested: <pre><code>ssh root@192.168.1.153\n</code></pre> Note: Make sure to replace the above IP address to the one matching the output of running <code>ifconfig</code> on youir board.</p> <p>1. Boot to Linux  </p> <p>2. Determine board IP address using <code>ifconfig</code> like in the previous scenario  </p> <p>3. Start a web browser and enter the IP address in the address bar  </p> <p>4. The web browser will display a page served by the web server running on the board.  </p> <p>Note: Current release has a limitation, in that the LEDs are not controllable from the web page. This will be resolved in the next release.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#booting-from-qspi","title":"Booting from QSPI","text":"<p>This section presents how to boot from QSPI. One notable aspect is that you need to wipe the SD card partitioning information, as otherwise U-Boot SPL could find a valid SD card image, and try to boot from that first.</p> Wipe SD Card <p>Either write 1MB of zeroes at the beginning of the SD card, or remove the SD card from the HPS Daughter Card. You can use <code>dd</code> on Linux, or <code>Win32DiskImager</code> on Windows to achieve this.</p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2025.08/qspi/agilex5_mk_a5e065bb32aes1_qspi/agilex_flash_image.hps.jic.tar.gz\ntar xf agilex_flash_image.hps.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;agilex_flash_image.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>Note: On first boot, the UBIFS rootfilesystem is initialized, and that takes a few minutes. This will not happen on next reboots. See a sample log below:</p> <pre><code>[   17.033558] UBIFS (ubi0:4): Mounting in unauthenticated mode\n[   17.039470] UBIFS (ubi0:4): background thread \"ubifs_bgt0_4\" started, PID 130\n[   17.061510] UBIFS (ubi0:4): start fixing up free space\n[   20.644496] random: crng init done\n[   27.120040] platform soc:leds: deferred probe pending\n[  243.190874] UBIFS (ubi0:4): free space fixup complete\n[  243.315909] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[  243.323290] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[  243.332653] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#rebuilding-the-gsrd","title":"Rebuilding the GSRD","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#yocto-build-prerequisites","title":"Yocto Build Prerequisites","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#build-sd-card-boot-binaries","title":"Build SD Card Boot Binaries","text":"<p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.modular\nmkdir agilex5_gsrd.modular\ncd agilex5_gsrd.modular\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-modular-devkit-som-legacy-baseline.zip\nunzip a5ed065es-modular-devkit-som-legacy-baseline.zip\nrm -f a5ed065es-modular-devkit-som-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_mk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_mk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_mk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_mk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_mk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_mk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_mk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#build-qspi-boot-binaries","title":"Build QSPI Boot Binaries","text":"<p>The diagram below shows how booting from QSPI JIC is built. The hardware project compilation and Yocto build remain the same, and the QSPI JIC is built based on the resulted files: </p> <p>1. Create the folder to contain all the files:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf qspi_boot\nmkdir qspi_boot\ncd qspi_boot\n</code></pre> <p>2. Get the <code>ubinize.cfg</code> file which contains the details on how to build the <code>root.ubi</code> volume, and <code>agilex5_devkit_flash_image_hps.pfg</code> which contains the instructions for Programming File Generator on how to create the .jic file:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/qspi/agilex5_mk_a5e065bb32aes1_qspi/ubinize.cfg\nwget https://releases.rocketboards.org/2025.08/qspi/agilex5_mk_a5e065bb32aes1_qspi/agilex5_devkit_flash_image_hps.pfg\nsed -i 's/ghrd_a5ed065bb32ae6sr0\\.sof/legacy_baseline.sof/g' agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>3. Link to the files that are needed from building the hardware design, and yocto:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nor.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof .\n</code></pre> <p>4. Process the u-boot.itb file to be exactly 2MB in size:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the <code>root.ubi</code> file and rename it to <code>hps.bin</code> as Programming File Generator needs the <code>.bin</code> extension:</p> <pre><code>ubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>6. Create the JIC file:</p> <pre><code>quartus_pfg -c agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi_boot/agilex_flash_image.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/","title":"HPS TSN SGMII XCVR System 3x2.5G Example Design User Guide","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#introduction","title":"Introduction","text":"<p>The IEEE Ethernet is a core technology which is a backbone for IT operations and was designed to provide best effort communication suitable for IT operations. Operational Technology vendors have innovatively used Core IEEE Ethernet technology with proprietary solutions for enabling time-bounded communication. To address the need for precision timing, traffic shaping, and time-bounded communication over networks, IEEE introduced a suite of standards known as Time Sensitive Networking (TSN).</p> <p>Agilex\u2122 5 E-Series is designed as an end point for Industrial automation application with support for the following TSN protocols:</p>  Time Synchronization Protocols:  <ul> <li>IEEE 1588-2008 Advanced Timestamp (Precision Time Protocol - PTP):<ul> <li>Function: Provides sub-microsecond accuracy for time synchronization between computing systems over a local area network.<ul> <li>Key Features: 2-step synchronization, PTP offload, and timestamping.</li> <li>Use Case: Synchronizing industrial devices to operate in unison, ensuring coordinated actions across factory or plant operations.</li> </ul> </li> <li>IEEE 802.1AS (Timing and Synchronization):<ul> <li>Function: A profile of PTP (version 2) that ensures precise time synchronization in a hierarchical master-slave architecture.</li> <li>Key Features: Prioritizes accuracy and variability of timing, crucial for industrial and automotive systems.</li> <li>Use Case: Synchronizing devices to a common time for optimal operation and collaboration.</li> </ul> </li> </ul> </li> </ul>  Credit Based Shaper Protocol:  <ul> <li>IEEE 802.1Qav (Time-Sensitive Streams Forwarding and Queuing):<ul> <li>Function: Provides low-latency, time-synchronized delivery of audio and video streams over Ethernet networks.<ul> <li>Key Features: Credit-based shaper ensuring end-to-end guaranteed bandwidth with fairness to best-effort traffic.</li> <li>Use Case: Ensuring dedicated bandwidth for audio-video bridging (AVB) streams with minimal latency.</li> </ul> </li> </ul> </li> </ul>  Traffic Scheduling Protocols:  <ul> <li>IEEE 802.1Qbv (Time-Scheduled Traffic Enhancements):<ul> <li>Function: Enables the transmission of frames at specific scheduled times within microsecond ranges.<ul> <li>Key Features: Critical for time-sensitive scheduled traffic in industrial applications.</li> <li>Use Case: Facilitating precise, time-critical communication for industrial devices like PLCs and drives.</li> </ul> </li> <li>IEEE 802.1Qbu (Frame Preemption):<ul> <li>Function: Allows high-priority frames to preempt lower-priority frames, reducing latency and jitter.</li> <li>Key Features: Utilizes Express Media Access Control (eMAC) and Preemptable Media Access Control (pMAC).</li> <li>Use Case: Ensuring high-priority frames arrive with fixed latency, crucial for applications requiring consistent timing.</li> </ul> </li> </ul> </li> </ul> <p>These TSN standards collectively enable precise timing, traffic shaping, and time-bounded communication, making them indispensable for applications requiring high reliability and determinism.</p> <p>The details of TSN is not in the scope of this document. Here are some reference to the TSN specifications:</p> <ul> <li>The IEEE Std 802.1AS\u2122-2011 \"Timing and Synchronization for Time-Sensitive Applications in Bridged Local Area Networks\"</li> <li>The IEEE Std 802.1Qav\u2122-2009 \u201cForwarding and Queuing Enhancements for Time-Sensitive Streams\u201d</li> <li>The IEEE Std 802.1Qbv\u2122-2015 \u201cEnhancements for Scheduled Traffic\u201d</li> <li>The IEEE Std 802.1Qbu\u2122-2016 \u201cFrame Preemption\u201d</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#tsn-sgmii-xcvr-3x25g-overview","title":"TSN SGMII+ XCVR 3x2.5G Overview","text":"<p>The TSN SGMII+ XCVR is a Reference design, enable datapath between HPS, EMAC Controller, Multirate Ethernet PHY IP and Marvell PHY 88E2110 running at 2.5G rate on the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</p> <pre><code>Note:              1. This is the pre-production release of the Agilex\u2122 5 TSN SGMII XCVR System Example Design, on Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit with -6S\u202fspeed grade. This corresponds to Engineering Samples Silicon quality.\n 2. Three PHY is enabled with 2.5G fixed rate in this release.\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#prerequisites","title":"Prerequisites","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to the board documentation for more information about the development kit.</li> </ul> <ul> <li>Mini and Micro USB Cable. Included with the development kit.</li> </ul> <ul> <li>CAT6A Ethernet Cable. Included with the development kit.</li> </ul> <ul> <li>Micro SD card and USB card writer. Included with the development kit.</li> </ul> <ul> <li>Host PC with 64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> </ul> <ul> <li>Linux OS installed on host PC, preferably Ubuntu 22.04LTS , while other versions and distributions may work too.</li> </ul> <ul> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> </ul> <ul> <li>Quartus\u00ae Prime Pro Edition software version 25.1.1 is used to recompile the hardware design. If only writing binaries is required, then the Quartus\u00ae Prime Pro Edition Programmer version 25.1.1 is sufficient.</li> </ul> <ul> <li>Local Ethernet network, with DHCP server Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#binaries","title":"Binaries","text":"<ul> <li>Prebuilt binaries are located here.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#sources","title":"Sources","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release.</p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 5 GHRD https://github.com/altera-fpga/agilex5-ed-tsn-sgmii/tree/25.1.1-1/src/hw rel/25.1.1 rel/25.1.1 Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar QPDS25.1.1_REL_GSRD_PR Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR GSRD Build Script: gsrd-socfpga https://github.com/altera-fpga/agilex5-ed-tsn-sgmii/tree/25.1.1-1/src/sw rel/25.1.1 rel/25.1.1 <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#release-notes","title":"Release Notes","text":"<ul> <li>Refer this link for Known Issues.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#tsn-xcvr-sgmii-25g-architecture","title":"TSN XCVR SGMII+ 2.5G Architecture","text":"<p>Agilex\u2122  FPGAs provide a powerful platform for showcasing 2.5G Ethernet with TSN-enabled applications with all the TSN features including IEEE 802.1AS, IEEE802.1Qbv, IEEE802.1Qbu, IEEE802.1Qav in HPS subsystem by enabling the EMAC Controller.  To support the 2.5G rate, you must enable the 8-bit GMII interface to the FPGA fabric, from where it gets connected to a Marvell PHY 88E2110  (through the FPGA transceivers) device to drive the RJ45 CAT6A copper media.</p> <p>This design demonstrate 3x2.5G ports to HPS</p> <p>Enable the Data path between HPS &lt;-&gt; XGMAC &lt;-&gt;MR PHY (Direct mode) &lt;-&gt; 2 Marvell PHY port + 1 SFP running at 2.5G rate.</p> <p>This Example design  showcases 2.5G data rate.</p> <ul> <li>Enable the Deterministic Latency (DL) feature of MR PHY IP which precisely determines the delay between the PCS elastic FIFO (EFIFO) and the PMA pins for TSN usecases. Also enable the CSR interface with HPS Light weight bridge to convey these delays (Soft PCS, Hard PCS and PMA delays) for both RX and TX directions.</li> </ul> <ul> <li>GMII (8-bit) interface for TSN enabled ethernet data transfers to and from XGMAC to external PHY. Tranceiever\u2019s reference clocks are used to derive the required frequency for running this parallel interface as the expectation is to have zero ppm difference between these clocks.</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#hps-subsystem","title":"HPS Subsystem","text":"<p>The Hard Processor System (HPS) in this design is a critical component that interfaces with various subsystems and peripherals to ensure efficient and high-performance operation. The following are the key connections of the HPS to other design components;</p> <ul> <li>Light Weight HPS to FPGA Manager (H2F) interface to access control and status registers of TSN Subsystem and Peripheral Subsystem</li> </ul> <ul> <li>8-bit EMAC GMII interface to connect to 1G/2.5G/5G/10G Multirate Ethernet PHY IP for TSN-enabled ethernet data transfers</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#tsn-subsystem","title":"TSN Subsystem","text":"<p>The main components of the TSN Subsystem are Multirate Ethernet PHY IP, GTS System PLL Clocks IP, Reset Release IP and IOPLL IP.</p> <ul> <li>The Multirate Ethernet PHY IP transmits outgoing traffic (from HPS GMII interface) and receives incoming traffic through GTS Transceiver PHY.</li> </ul> <ul> <li>The GMII adapter is enabled to convert the 8-bit GMII data from HPS to the 16-bit data inside the Multirate Ethernet PHY IP</li> </ul> <ul> <li>The IEEE 1588 Precision Time Protocol feature is enabled to accurately measure internal data path delay, ensuring high accuracy of TSN applications.</li> </ul> <ul> <li>The GTS System PLL Clocks IP provides a system PLL clock input to Multirate Ethernet PHY IP, while the IOPLL IP generates a clock source for latency_sclk and latency_measurement_clk of Multirate Ethernet PHY IP.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#hardware-setup","title":"Hardware Setup","text":"<p>The Board-to-Board hardware setup connection details are captured in the image below.</p> <p> Note:</p> <p>1. This is the reference hardware setup  and user can leverage with their own hardware setup(Ex: Board to Third party device).</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#hps-lw-h2f-register-map","title":"HPS LW H2F Register Map","text":"Address Offset Size (Bytes) Peripheral Description GHRD-aligned address space 0x2001_0000 8 System ID Hardware configuration system ID (0xacd5cafe) 0x2001_0060 16 Button PIO Push Button 0x2001_0070 16 DIPSW PIO DIP Switch 0x2001_0080 16 LED PIO LED connections on board Application-specific address space 0x3002_0100 64 Multirate Ethernet PHY Multirate Ethernet PHY IP CSR 0x3002_0180 64 Multirate Ethernet PHY Multirate Ethernet PHY IP CSR 0x3002_0200 64 Multirate Ethernet PHY Multirate Ethernet PHY IP CSR 0x2002_0300 256 User space CSR Sideband status and control signals of various modules"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#user-space-csr","title":"User Space CSR","text":"<p>The User Space CSR contains registers specific to system-level status (e.g. PLL locked, RX ready) and control (e.g., reset).</p> Access Definition RO Read only RW Read and write  Multirate Ethernet PHY Status Register (Offset 0x00) Name Bit Access Default Description Reserved [31:21] RO 11'b0 Reserved PHY_2_op_speed [20:18] RO 3'b100 PHY2 -MRPHY Op speed - 2.5G PHY_2_rx_block_lock [17:17] RO 1'b0 PHY2 -Asserted when 66b block alignment is finished on all PCS virtual lanes PHY_2_tx_ready [16:16] RO 1'b0 PHY2 -Asserted when MRPHY TX is ready PHY_2_rx_ready [15:15] RO 1'b0 PHY2 -Asserted when MRPHY RX is ready PHY_2_mrphy_pll_lock [14:14] RO 1'b0 PHY2 -Asserted when PLL in MRPHY soft logic is locked PHY_1_op_speed [13:11] RO 3'b100 PHY1 -MRPHY Op speed - 2.5G PHY_1_rx_block_lock [10:10] RO 1'b0 PHY1 -Asserted when 66b block alignment is finished on all PCS virtual lanes PHY_1_tx_ready [9:9] RO 1'b0 PHY1 -Asserted when MRPHY TX is ready PHY_1_rx_ready [8:8] RO 1'b0 PHY1 -Asserted when MRPHY RX is ready PHY_1_mrphy_pll_lock [7:7] RO 1'b0 PHY1 -Asserted when PLL in MRPHY soft logic is locked PHY_0_op_speed [6:4] RO 3'b100 PHY0 -MRPHY Op speed - 2.5G PHY_0_rx_block_lock [3:3] RO 1'b0 PHY0 -Asserted when 66b block alignment is finished on all PCS virtual lanes PHY_0_tx_ready [2:2] RO 1'b0 PHY0 -Asserted when MRPHY TX is ready PHY_0_rx_ready [1:1] RO 1'b0 PHY0 -Asserted when MRPHY RX is ready PHY_0_mrphy_pll_lock [0:0] RO 1'b0 PHY0 - Asserted when PLL in MRPHY soft logic is locked Multirate Ethernet PHY Reset Control Register (Offset 0x04) Name Bit Access Default Description Reserved [31:9] RO 23'b0 Reserved PHY_2_i_rx_rst_n [8:8] RW 1'b1 PHY2 -Reset MRPHY RX path. Self cleared on o_rx_rst_ack_n PHY_2_i_tx_rst_n [7:7] RW 1'b1 PHY2 -Reset MRPHY TX path. Self cleared on o_rx_rst_ack_n PHY_2_i_rst_n [6:6] RW 1'b1 PHY2 -Global reset to MRPHY. Self cleared on o_rst_ack_n PHY_1_i_rx_rst_n [5:5] RW 1'b1 PHY1 -Reset MRPHY RX path. Self cleared on o_rx_rst_ack_n PHY_1_i_tx_rst_n [4:4] RW 1'b1 PHY1 -Reset MRPHY TX path. Self cleared on o_rx_rst_ack_n PHY_1_i_rst_n [3:3] RW 1'b1 PHY1 -Global reset to MRPHY. Self cleared on o_rst_ack_n PHY_0_i_rx_rst_n [2:2] RW 1'b1 PHY0 -Reset MRPHY RX path. Self cleared on o_rx_rst_ack_n PHY_0_i_tx_rst_n [1:1] RW 1'b1 PHY0 -Reset MRPHY TX path. Self cleared on o_rx_rst_ack_n PHY_0_i_rst_n [0:0] RW 1'b1 PHY0 -Global reset to MRPHY. Self cleared on o_rst_ack_n TX Delay Register (Offset 0x08) Name Bit Access Default Description Reserved [31:12] RO 20'b0 Reserved Additional_User_added_delay1 [11:8] RO 4'b0 Future - In concurrent use case Additional_User_added_delay2 [7:4] RO 4'b0 Future - In concurrent use case Additional_User_added_delay3 [3:0] RO 4'b0 Additional GMII Datapath Delay added by used if timing issue arise in number of clock cycles gmii8_tx_clkout RX Delay Register (Offset 0x0C) Name Bit Access Default Description Reserved [31:12] RO 20'b0 Reserved Additional_User_added_delay1 [11:8] RO 4'b0 Future - In concurrent use case Additional_User_added_delay2 [7:4] RO 4'b0 Future - In concurrent use case Additional_User_added_delay3 [3:0] RO 4'b0 Additional GMII Datapath Delay added by used if timing issue arise in number of clock cycles gmii8_rx_clkout Error Status Register (Offset 0x10) Name Bit Access Default Description Reserved [31:3] RO 29'b0 Reserved Unsupported_Speed_Error1 [2:1] RW 2'b0 For concurrent Usecases Unsupported_Speed_Error2 [0:0] RW 1'b0 Assert high when XGMAC publish unsupported speeds. SW to clear these bits once addressed"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on user flow.</p>  User Flow 1: Testing with Prebuild Binaries.   User Flow 2: Testing Complete Flow.  User Flow Description Required for User flow 1 Required for User flow 2 Environment Setup Tools Download and Installation Yes Yes Installing Dependency Packages for SW Compilation No Yes Package Download No Yes Compilation Simulation No No Hardware Compilation No Yes Software Compilation No Yes Programing Programing Hardware binary Yes Yes Programing Software Image Yes Yes Linux boot Yes Yes Testing Run Ping Test Yes Yes Running iperf Test Yes Yes"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#tools-download-and-installation","title":"Tools Download and Installation","text":"<p>1. Quartus Prime Pro</p> <ul> <li>Download the Quartus\u00ae Prime Pro Edition software version 25.1.1 from the FPGA Software Download Center webpage of the Intel website. Follow the on-screen instructions to complete the installation process. Choose an installation directory that is relative to the Quartus\u00ae Prime Pro Edition software installation directory.</li> </ul> <ul> <li>Set up the Quartus tools in the PATH, so they are accessible without full path.</li> </ul> <pre><code>    export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\n    export PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <p>Note that this is installed in the <code>TOP_FOLDER</code>. You may installed this is in other location, but note the path and export it accordingly</p> <pre><code># Create the top folder to store all the build artifacts:\nsudo rm -rf artifacts.enablement\nmkdir artifacts.enablement\ncd artifacts.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\n</code></pre> <pre><code>export PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu- </code></pre> <p>3. Win32 Disk Imager</p> <ul> <li>Download and install the latest Win32 Disk Imager.</li> </ul> <p>4. Agile\u2122  5 FPGA E-Series 065B Modular Development Kit Board Test System (BTS)</p> <ul> <li> <p>Go to the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit webpage, download and extract the installer package, which includes BTS.</p> <p>Note: If you are using User Flow 1, after the BTS installation, go to Programming stage directly.</p> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#installing-dependency-packages-for-sw-compilation","title":"Installing Dependency Packages for SW Compilation","text":"<p>Follow the instructions in the Base GSRD Yocto Build Prerequisites section.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#package-download","title":"Package Download","text":"<pre><code>cd $TOP_FOLDER\nrm -rf agilex5-ed-tsn-sgmii\ngit clone -b rel/25.1.1 https://github.com/altera-fpga/agilex5-ed-tsn-sgmii\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#compilation","title":"Compilation","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#hardware-compilation","title":"Hardware Compilation","text":"<pre><code>cd $TOP_FOLDER/agilex5-ed-tsn-sgmii/src/hw/a5e065bb32aes1_mdk_3x2.5G/\nquartus_sh --flow compile a5ed065bb32ae6sr0\n</code></pre> <p>The following file will be generated:</p> <p><code>$TOP_FOLDER/agilex5-ed-tsn-sgmii/src/hw/a5e065bb32aes1_mdk_3x2.5G/output_files/a5ed065bb32ae6sr0.sof</code></p> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f a5ed065bb32ae6sr0.hps.jic a5ed065bb32ae6sr0.core.rbf\n\n# Note : If user doing compilation first time, download the prebuilt u-boot-spl-dtb.hex  file and create the following path $TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/ and copy the u boot file here.\nquartus_pfg \\\n-c agilex5-ed-tsn-sgmii/src/hw/a5e065bb32aes1_mdk_3x2.5G/output_files/a5ed065bb32ae6sr0.sof a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=agilex5-ed-tsn-sgmii/src/sw/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file will be created:</p> <p><code>$TOP_FOLDER/a5ed065bb32ae6sr0.jic</code></p> Build RBF <pre><code>cd $TOP_FOLDER\nrm -f a5ed065bb32ae6sr0.*.rbf\n\n# Note : If user doing compilation first time, download the prebuilt u-boot-spl-dtb.hex  file and create the following path $TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/ and copy the u boot file here.\nquartus_pfg \\\n-c agilex5-ed-tsn-sgmii/src/hw/a5e065bb32aes1_mdk_3x2.5G/output_files/a5ed065bb32ae6sr0.sof  a5ed065bb32ae6sr0.rbf \\\n-o hps_path=agilex5-ed-tsn-sgmii/src/sw/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file will be generated:</p> <p><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code> <code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#software-compilation","title":"Software Compilation","text":"Set Up Yocto <pre><code>   cd $TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw\n   # Run the `agilex5_mk_a5e065bb32aes1-gsrd-build.sh` script to sync the submodules.\n. agilex5_mk_a5e065bb32aes1-gsrd-build.sh\n   # Run the `build_setup` script to set up the build environment.\nbuild_setup\n</code></pre>  Optional: Follow these steps, if you have a custom GHRD   <p>Follow the below procedure to add the generated <code>agilex5_*_a5e065bb32aes1_gsrd_ghrd.core.rbf</code> file.</p> <ul> <li>For Agilex5 MK-A5E065BB32AES1:-agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf</li> </ul> <p>Update the recipe <code>$WORKSPACE/meta-sm-tsn-sgmii/recipes-bsp/ghrd/hw-ref-design.bbappend</code> as follows:</p> <pre><code>cd $TOP_FOLDER\nCORE_RBF=$WORKSPACE/meta-sm-tsn-sgmii/recipes-bsp/ghrd/files/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nrm -rf $CORE_RBF\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nFILE=\"$WORKSPACE/meta-sm-tsn-sgmii/recipes-bsp/ghrd/hw-ref-design.bbappend\"\nOLD_URI='SRC_URI\\[agilex5_mk_a5e065bb32aes1_gsrd_core_cfg3.sha256sum\\] += \"[^\"]*\"'\nNEW_URI=\"SRC_URI[agilex5_mk_a5e065bb32aes1_gsrd_core_cfg3.sha256sum] += \\\"$CORE_SHA\\\"\"\nsed -i \"s|$OLD_URI|$NEW_URI|\" \"$FILE\"\n</code></pre>  Build Yocto  <p>Build Yocto:</p> <pre><code>    # Run the `bitbake_image` command to generate the binaries.\nbitbake_image\n</code></pre> <p>Gather Files:</p> <pre><code>   #  Package the binaries into the build folder.\npackage\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> </ul> <ul> <li><code>$TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb</code></li> </ul> <ul> <li><code>$TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_mk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#programing","title":"Programing","text":"<p>Note:</p> <ul> <li>Download the Prebuild Binaries, if you are leveraging on User Flow 1.</li> <li>Leave all jumpers and switches in their default configuration.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#programing-software-image","title":"Programing Software Image","text":"Write SD Card  <ol> <li> <p>Extract the SD card image(sdimage.tar.gz) archive and obtain the file <code>gsrd-console-image-agilex5.wic</code>.</p> </li> <li> <p>Write the extracted SD card image (gsrd-console-image-agilex5_devkit.wic) to the micro-SD card using the included USB writer in the host computer:</p> </li> </ol> <p>On Linux, use the dd utility as shown below:</p> <pre><code>    # Determine the device associated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5.wic of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre> <p>On Windows, use the Win32DiskImager program. First, rename the gsrd-console-image-agilex5.wic to an .img file (sdcard.img, for example) and write the image as shown in the following figure:</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#programing-hardware-binary","title":"Programing Hardware binary","text":"Write QSPI Flash <ol> <li>Download the JIC image, then write it to QSPI.</li> </ol> <pre><code>jtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.jic\"\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#linux-boot","title":"Linux Boot","text":"<ol> <li> <p>Open the serial port of Board A and Board B by using serial communication utility.</p> <p>Note: Follow the instructions in the Base GSRD configure-serial-console section, to configure and setup serial connection.</p> </li> <li> <p>Power cycle the board.</p> </li> <li> <p>Monitor the serial communication windows and wait for Linux to boot, use root as user name, and no password is required.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#running-ping-test","title":"Running Ping Test","text":"<p>Use ifconfig to configure the IP address on both the Board DUT and start testing.</p> <p>Example:-</p> <pre><code>ifconfig\n\neth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\ninet 169.254.220.240  netmask 255.255.0.0  broadcast 169.254.255.255\n        inet6 fe80::b068:1aff:fe7c:aa02  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether b2:68:1a:7c:aa:02  txqueuelen 1000  (Ethernet)\nRX packets 347637  bytes 484781613 (462.3 MiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 178614  bytes 32669690 (31.1 MiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 23  base 0x8000\n\neth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\ninet 169.254.225.122  netmask 255.255.0.0  broadcast 169.254.255.255\n        inet6 fe80::e45c:b0ff:fee4:767c  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether e6:5c:b0:e4:76:7c  txqueuelen 1000  (Ethernet)\nRX packets 328640  bytes 456017787 (434.8 MiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 171153  bytes 32075199 (30.5 MiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 40\neth2: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\ninet 169.254.158.219  netmask 255.255.0.0  broadcast 169.254.255.255\n        inet6 fe80::88be:c9ff:fe7a:7bec  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 8a:be:c9:7a:7b:ec  txqueuelen 1000  (Ethernet)\nRX packets 342615  bytes 477159176 (455.0 MiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 176198  bytes 32459349 (30.9 MiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 57  base 0x8000\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 2736892  bytes 166952698 (159.2 MiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 2736892  bytes 166952698 (159.2 MiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n# Execute this command on Board #A DUT: \nifconfig eth0 192.168.1.100\n ifconfig eth1 192.169.1.100\n ifconfig eth2 192.170.1.100 # Execute this command on Board #B DUT: \nifconfig eth0 192.168.1.101\n ifconfig eth1 192.169.1.101\n ifconfig eth2 192.170.1.101\n\n# Do ping to Board #B from Board #A\nroot@agilex5mka5e065bb32aes1:~# ping -I eth0 192.168.1.101\nPING 192.168.1.101 (192.168.1.101): 56 data bytes\n64 bytes from 192.168.1.101: seq=0 ttl=64 time=1.053 ms\n64 bytes from 192.168.1.101: seq=1 ttl=64 time=0.330 ms\n64 bytes from 192.168.1.101: seq=2 ttl=64 time=0.250 ms\n64 bytes from 192.168.1.101: seq=3 ttl=64 time=0.178 ms\n64 bytes from 192.168.1.101: seq=4 ttl=64 time=0.164 ms\n\n--- 192.168.1.101 ping statistics ---\n5 packets transmitted, 5 packets received, 0% packet loss\nround-trip min/avg/max = 0.164/0.395/1.053 ms\n\nroot@agilex5mka5e065bb32aes1:~# ping -I eth1 192.169.1.101\nPING 192.169.1.101 (192.169.1.101): 56 data bytes\n64 bytes from 192.169.1.101: seq=0 ttl=64 time=0.587 ms\n64 bytes from 192.169.1.101: seq=1 ttl=64 time=0.256 ms\n64 bytes from 192.169.1.101: seq=2 ttl=64 time=0.194 ms\n64 bytes from 192.169.1.101: seq=3 ttl=64 time=0.622 ms\n\n--- 192.169.1.101 ping statistics ---\n4 packets transmitted, 4 packets received, 0% packet loss\nround-trip min/avg/max = 0.194/0.414/0.622 ms\n\nroot@agilex5mka5e065bb32aes1:~# ping -I eth2 192.170.1.101\nPING 192.170.1.101 (192.170.1.101): 56 data bytes\n64 bytes from 192.170.1.101: seq=0 ttl=64 time=0.906 ms\n64 bytes from 192.170.1.101: seq=1 ttl=64 time=0.456 ms\n64 bytes from 192.170.1.101: seq=2 ttl=64 time=0.280 ms\n64 bytes from 192.170.1.101: seq=3 ttl=64 time=0.212 ms\n\n--- 192.170.1.101 ping statistics ---\n4 packets transmitted, 4 packets received, 0% packet loss\nround-trip min/avg/max = 0.212/0.463/0.906 ms\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#running-iperf-test","title":"Running iperf Test","text":"<ol> <li> <p>Execute below command on Board #A DUT.</p> <p><code>iperf3 --bind-dev eth0 -s -p 5201 &gt; eth0.log &amp; iperf3 --bind-dev eth1 -s -p 5202 &gt; eth1.log &amp; iperf3 --bind-dev eth2 -s -p 5203 &gt; eth2.log &amp;</code></p> </li> <li> <p>Execute below command on Board #B DUT. User need to configurate the inet address.</p> <p><code>iperf3 --bind-dev eth0 -c 169.254.220.240 -p 5201 &amp; iperf3 --bind-dev eth1 -c 169.254.225.122 -p 5202 &amp;  iperf3 --bind-dev eth2 -c 169.254.158.219 -p 5203 &amp;</code></p> </li> <li> <p>Output:</p> </li> </ol> <pre><code>vi eth0.log\n\n-----------------------------------------------------------\nServer listening on 5201 (test #1)\n-----------------------------------------------------------\nAccepted connection from 169.254.247.159, port 54490\n[  5] local 169.254.220.240 port 5201 connected to 169.254.247.159 port 54494\n[ ID] Interval           Transfer     Bitrate\n[  5]   0.00-1.00   sec  6.88 MBytes  57.6 Mbits/sec\n[  5]   1.00-2.00   sec  8.12 MBytes  68.2 Mbits/sec\n[  5]   2.00-3.00   sec  6.25 MBytes  52.4 Mbits/sec\n[  5]   3.00-4.00   sec  7.38 MBytes  61.9 Mbits/sec\n[  5]   4.00-5.00   sec  5.62 MBytes  47.2 Mbits/sec\n[  5]   5.00-6.00   sec  7.00 MBytes  58.7 Mbits/sec\n[  5]   6.00-7.00   sec  6.38 MBytes  53.5 Mbits/sec\n[  5]   7.00-8.00   sec  6.38 MBytes  53.5 Mbits/sec\n[  5]   8.00-9.00   sec  5.00 MBytes  41.9 Mbits/sec\n[  5]   9.00-10.00  sec  7.50 MBytes  62.9 Mbits/sec\n- - - - - - - - - - - - - - - - - - - - - - - - -\n[ ID] Interval           Transfer     Bitrate\n[  5]   0.00-10.01  sec  66.5 MBytes  55.7 Mbits/sec                  receiver\n\nvi eth1.log\n\n-----------------------------------------------------------\nServer listening on 5202 (test #1)\n-----------------------------------------------------------\nAccepted connection from 169.254.164.238, port 34570\n[  5] local 169.254.225.122 port 5202 connected to 169.254.164.238 port 34584\n[ ID] Interval           Transfer     Bitrate\n[  5]   0.00-1.00   sec  6.12 MBytes  51.3 Mbits/sec\n[  5]   1.00-2.00   sec  6.38 MBytes  53.5 Mbits/sec\n[  5]   2.00-3.00   sec  7.38 MBytes  61.9 Mbits/sec\n[  5]   3.00-4.00   sec  6.62 MBytes  55.6 Mbits/sec\n[  5]   4.00-5.00   sec  7.00 MBytes  58.7 Mbits/sec\n[  5]   5.00-6.00   sec  7.00 MBytes  58.8 Mbits/sec\n[  5]   6.00-7.00   sec  7.62 MBytes  63.9 Mbits/sec\n[  5]   7.00-8.00   sec  7.25 MBytes  60.8 Mbits/sec\n[  5]   8.00-9.00   sec  8.00 MBytes  67.1 Mbits/sec\n[  5]   9.00-10.00  sec  6.50 MBytes  54.5 Mbits/sec\n- - - - - - - - - - - - - - - - - - - - - - - - -\n[ ID] Interval           Transfer     Bitrate\n[  5]   0.00-10.01  sec  69.9 MBytes  58.6 Mbits/sec                  receiver\n\nvi eth2.log\n\n-----------------------------------------------------------\nServer listening on 5203 (test #1)\n-----------------------------------------------------------\nAccepted connection from 169.254.16.245, port 50092\n[  5] local 169.254.158.219 port 5203 connected to 169.254.16.245 port 50094\n[ ID] Interval           Transfer     Bitrate\n[  5]   0.00-1.00   sec  8.12 MBytes  68.1 Mbits/sec\n[  5]   1.00-2.00   sec  6.38 MBytes  53.5 Mbits/sec\n[  5]   2.00-3.00   sec  6.12 MBytes  51.4 Mbits/sec\n[  5]   3.00-4.00   sec  6.25 MBytes  52.4 Mbits/sec\n[  5]   4.00-5.00   sec  7.12 MBytes  59.8 Mbits/sec\n[  5]   5.00-6.00   sec  6.50 MBytes  54.6 Mbits/sec\n[  5]   6.00-7.00   sec  5.25 MBytes  44.0 Mbits/sec\n[  5]   7.00-8.00   sec  6.75 MBytes  56.6 Mbits/sec\n[  5]   8.00-9.00   sec  6.62 MBytes  55.6 Mbits/sec\n[  5]   9.00-10.00  sec  7.25 MBytes  60.8 Mbits/sec\n- - - - - - - - - - - - - - - - - - - - - - - - -\n[ ID] Interval           Transfer     Bitrate\n[  5]   0.00-10.00  sec  66.4 MBytes  55.7 Mbits/sec                  receiver\n</code></pre> <pre><code>_Note : Update the Board #A DUT IP address using the above command._\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/tsn/sgmii_xcvr_3x2.5G/ug-tsn-sgmii-xcvr-3x2.5G-agilex5/#sm-tsn-config-3-kernel-bootup","title":"SM TSN Config-3 Kernel Bootup","text":"<p>Note: For TSN and PTP tests, programming of the egress and ingress delays with delays of mrphy IP is required. Once you boot till kernel prompt, at the /home/root/ you will find the below files</p> <ol> <li>README_ tsn-delay-config</li> <li>tsn-delay-config</li> </ol> <p>For the concurrent design, as the delay values needs to be updated for all the three interface eth0, eth1 and eth2, you just need to run the tsn-delay-config application just once at every power cycle (./tsn-delay-config), the application itself will detect automatically all the eth interfaces connected to the mrphy and will update the egress and ingress values. You can then run the PTP and TSN test cases.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/","title":"HPS Xen Hypervisor GSRD for the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#introduction","title":"Introduction","text":"<p>This page presents the Xen GSRD, which is based on the Linux GSRD for the Agilex\u2122 5 E-Series Modular Development Kit. The Xen GSRD uses the SD card for storing the root filesystem.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#xen-overview","title":"Xen Overview","text":"<p>Xen is a free open-source Type-1 hypervisor which enables efficient and secure virtualization of hardware resources to run multiple operating systems on a single physical machine. </p> <p></p> <p>In Xen's architecture, there are two domains. Dom0 is the privileged management domain that runs the hypervisor and has full access to physical hardware, acting as the bridge between the hypervisor and other virtual machines. DomUs are unprivileged guest domains that run operating systems or applications, relying on Dom0 for resource allocation. Dom0 and DomUs operate independently, ensuring isolation and security.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex\u2122 5 Modular Development Kit GSRD:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex\u2122 5 Modular Development Kit GSRD binaries are located at https://releases.rocketboards.org/2025.08/xen/agilex5_mk_a5e065bb32aes1_xen/.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#exercise-xen-gsrd-prebuilt-binaries","title":"Exercise Xen GSRD Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the Xen GSRD, on the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</p> <p>Running the boot from SD card section of the GSRD is a prerequisite step for running the Xen examples, as not all steps are as detailed on this page as in the GSRD page. Refer to the following links for help on getting started:</p> Link Description Board Documentation Board user guide, schematics, etc GSRD Development Kit Section Details about the development kit GSRD Board Setup Section Setting up the development kit GSRD Serial Console Section Setting up serial console GSRD Write SD Card Section Writing SD card image"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#write-binaries","title":"Write Binaries","text":"<p>This section shows presents downloading and flashing the SD card image and JIC files, and downloading the xen rootfs cpio archive to be used by DomUs VMs.</p> <p>1. Download and write to SD card the image https://releases.rocketboards.org/2025.08/xen/agilex5_mk_a5e065bb32aes1_xen/sdimage.tar.gz</p> <p>2. Download and write to QSPI flash the JIC file https://releases.rocketboards.org/2025.08/xen/agilex5_mk_a5e065bb32aes1_xen/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz</p> <p>3. Set MSEL to QSPI, and power cycle the board to boot to Linux.</p> <p>4. On the host computer, download the xen rootf cpio archive:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/xen/agilex5_mk_a5e065bb32aes1_xen/xen-image-minimal-agilex5_modular.cpio.gz\nmv xen-image-minimal-agilex5_modular.cpio.gz xen-image-minimal-agilex5.cpio.gz\n</code></pre> <p>5. On the Linux on target board, copy over the above downloaded file in 'xen' folder:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/xen-image-minimal-agilex5.cpio.gz .\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#boot-xen-gsrd","title":"Boot Xen GSRD","text":"<p>This section shows how to boot the Xen GSRD. By default, if no other operation is done, the board boots into normal, non-Xen enabled GSRD on a power cycle. In order to boot with the Xen Hypervisor, you need to stop the U-Boot countdown, and boot Linux manually using the commands shown in the below sections. This is provided for convenience, and when used in a real production system, U-Boot can be configured to boot the required Xen configuration automatically.</p> <p></p> Boot Without Passthrough <p>1. Set MSEL to QSPI, and power cycle the board</p> <p>2. Press any key during U-Boot countdown to stop it</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> Boot With Passthrough <p>The instructions are the same as without passthrough, just that the following command needs to be added befote the 'booti' command:</p> Device Passthrough Command QSPI fdt set /soc@0/spi@108d2000 xen,passthrough Ethernet fdt set /soc@0/ethernet@10830000 xen,passthrough"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#manage-vms","title":"Manage VMs","text":"<p>This section shows how to use the 'xl' Xen utility to manage VMs running on DomUs. Only a few options are used, refer to 'xl' command help for more options.</p> <p>1. Boot Xen GSRD as shown above. It can be either with or without passthrough</p> <p>2. Create VM1 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_1.cfg\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>3. Start VM1:</p> <pre><code>xl create test_vm_1.cfg\n</code></pre> <p>4. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>5. Connect to VM1 console:</p> <pre><code>xl console DomU1\n</code></pre> <p>6. Run some commands in VM1:</p> <pre><code>pwd\nls -la\n</code></pre> <p>7. Exit from VM1 console by pressing CTRL + ]. Note this works only from serial console, and not over SSH connection.</p> <p>8. Create VM2 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_2.cfg\n# Guest name\nname = \"DomU2\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>9. Start VM2:</p> <pre><code>xl create test_vm_2.cfg\n</code></pre> <p>10. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>11. Shutdown VM1:</p> <pre><code>xl shutdown DomU1\n</code></pre> <p>The above command politely asks DomU1 to shut down by using the ACPI shutdown signal and letting the OS shut down.</p> <p>Alternatively, when needed, you can also use 'destroy' commands which acts as a hard power cycle:</p> <pre><code>xl destroy DomU1\n</code></pre> <p>12. List VMs again, it will not show VM1 anymore</p> <pre><code>xl list\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#ethernet-passthrough","title":"Ethernet Passthrough","text":"<p>This section shows an example of how to assign the Ethernet IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc@0/ethernet@10830000 xen,passthrough\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Run 'ifconfig' to confirm Dom0 Linux does not have Ethernet anymore:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 2172  bytes 134772 (131.6 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 2172  bytes 134772 (131.6 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> <p>7. Go to xen folder and look at the provided Ethernet passthrough files (dtb file and VM configuration file)</p> <pre><code>root@agilex5dka5e065bb32aes1:~/# cd xen\nroot@agilex5dka5e065bb32aes1:~/xen# ls *ethernet*\nethernet@10830000.cfg  ethernet@10830000.dtb\nroot@agilex5dka5e065bb32aes1:~/xen# cat ethernet@10830000.cfg\n# SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"/home/root/xen/xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\ndevice_tree = \"ethernet@10830000.dtb\"\ndtdev = [ \"/soc@0/ethernet@10830000\" ]\niomem = [ \"0x10830,4\",\"0x10d12,1\" ]\nirqs = [ 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 267, 268, 269, 270, 271, 272 ]\n</code></pre> <p>8. Start the VM:</p> <pre><code>xl create ethernet\\@10830000.cfg\n</code></pre> <p>9. Connect to VM console </p> <pre><code>xl console DomU1\n</code></pre> <p>10. In the VM console, login with 'root' account, then do an 'ifconfig' or other commands to confirm Ethernet is working:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\neth0      Link encap:Ethernet  HWaddr 1A:CD:51:03:2A:55  inet addr:192.168.1.154  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fe80::18cd:51ff:fe03:2a55/64 Scope:Link\n          inet6 addr: 2603:8081:7700:1092::1bb7/128 Scope:Global\n          inet6 addr: 2603:8081:7700:1092:18cd:51ff:fe03:2a55/64 Scope:Global\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:12 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:20 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 RX bytes:1715 (1.6 KiB)  TX bytes:2275 (2.2 KiB)\nInterrupt:14 Base address:0xc000 lo        Link encap:Local Loopback  inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#qspi-passthrough","title":"QSPI Passthrough","text":"<p>This section shows an example of how to assign the QSPI IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p></p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc@0/spi@108d2000 xen,passthrough\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Go to xen folder and look at the provided QSPI passthrough files (dtb file and VM configuration file):</p> <pre><code>root@agilex5dka5e065bb32aes1:~/# cd xen\nroot@agilex5dka5e065bb32aes1:~/xen# ls *spi*\nspi@108d2000.cfg  spi@108d2000.dtb\nroot@agilex5dka5e065bb32aes1:~/xen# cat spi@108d2000.cfg\n#SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\n# Ramdisk\nramdisk = \"/home/root/xen/xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\ndevice_tree = \"spi@108d2000.dtb\"\niomem = [ \"0x108d2,1\", \"0x10900,100\" ]\nirqs = [ 35 ]\n</code></pre> <p>7. Start the VM, and connect to its console</p> <pre><code>xl create spi@108d2000.cfg\nxl console DomU1\n</code></pre> <p>8. In the VM console, login with 'root' account, then run a couple of commands to see QSPI is enabled:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# mtdinfo\nCount of MTD devices:           2\nPresent MTD devices:            mtd0, mtd1\nSysfs interface supported:      yes\nroot@agilex5dka5e065bb32aes1:~# cat /proc/mtd dev:    size   erasesize  name\nmtd0: 04200000 00010000 \"u-boot\"\nmtd1: 0be00000 00010000 \"root\"\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#rebuild-xen-gsrd","title":"Rebuild Xen GSRD","text":"<p>The instructions are the same as for the GSRD, except that the environment variable BUILD_HYP=1 needs to be set for building the Xen enabled GSRD version. This environment variable is only used by the Yocto GSRD script.</p> Yocto Build Prerequisites <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd_modular.xen\nmkdir agilex5_gsrd_modular.xen\ncd agilex5_gsrd_modular.xen\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-modular-devkit-som-legacy-baseline.zip\nunzip a5ed065es-modular-devkit-som-legacy-baseline.zip\nrm -f a5ed065es-modular-devkit-som-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b walnascar https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\nexport HYP_BUILD=1\n. agilex5_mk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_mk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_mk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_mk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_mk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_mk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_mk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#use-zephyr-on-domu","title":"Use Zephyr on DomU","text":"<p>This section shows how to build a simple Zephyr example and run in inside a Xen VM.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#build-zephyr-binary","title":"Build Zephyr Binary","text":"<p>For theis example the Zephyr binary was built on an Ubuntu 22.04 machine, with the required packages installed as indicated in https://docs.zephyrproject.org/latest/develop/getting_started/index.html.</p> <p>1. Create a virtual Python environment:</p> <pre><code>export TOP_FOLDER=`pwd`\npython3 -m venv $TOP_FOLDER/.zephyr_venv\nsource $TOP_FOLDER/.zephyr_venv/bin/activate\n</code></pre> <p>2. Install the Zephr project:</p> <pre><code>pip3 install wheel pip3 install west west init -m https://github.com/zephyrproject-rtos/zephyr --mr main zephyrproject cd zephyrproject\nwest update west zephyr-export\npip install -r zephyr/scripts/requirements.txt\n</code></pre> <p>3. Download the Altera\u00ae Zephyr repo and install SDK:</p> <pre><code>git clone -b socfpga_rel_24.3 https://github.com/altera-fpga/zephyr-socfpga\ncd zephyr-socfpga\nwest update\nwest zephyr-export\nwest sdk install\n</code></pre> <p>4. Work around an issue that happens at least on certain Ubuntu 22.04 installations:</p> <pre><code>pushd boards/arm64/xenvm\nrm xenvm_defconfig &amp;&amp; mv xenvm_gicv3_defconfig xenvm_defconfig\nrm xenvm_gicv3.yaml\nmv xenvm.dts xenvm_base.dts &amp;&amp; mv xenvm_gicv3.dts xenvm.dts &amp;&amp; sed -i 's/xenvm\\.dts/xenvm_base.dts/g' xenvm.dts\npopd\n</code></pre> <p>5. Build the sample application:</p> <pre><code>west build -b xenvm samples/hello_world -p\n</code></pre> <p>This will create the file $TOP_FOLDER/zephyrproject/zephyr-socfpga/build/zephyr/zephyr.bin</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#run-zephyr-vm","title":"Run Zephyr VM","text":"<p>1. Write the Xen GSRD binaries.</p> <p>2. Boot to XEN GSRD, does not matter if passthrough is enabled or not</p> <p>3. Copy the Zephyr binary to the target rootfs:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/zephyr.bin .\n</code></pre> <p>4. Still in the xen folder, create the Zephyr VM configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; zephyr.cfg\nkernel=\"zephyr.bin\"\nname=\"zephyr\"\nvcpus=1\nmemory=16\ngic_version=\"v3\"\non_crash=\"preserve\"\nEOT\n</code></pre> <p>5. Start the Zephyr VM:</p> <pre><code>xl start zephyr.cfg\n</code></pre> <p>6. Connect to VM console:</p> <pre><code>xl console zephyr\n</code></pre> <p>7. In the VM console, you will see the message output by the Zephyr:</p> <pre><code>Hello World! xenvm\n[00:00:00.000,000] &lt;inf&gt; xen_events: xen_events_init: events inited\n\n[00:00:00.000,000] &lt;inf&gt; uart_hvc_xen: Xen HVC inited successfully\n\n*** Booting Zephyr OS build v4.0.0-4569-g8cff70a95d6c ***\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/xen/ug-xen-agx5e-modular/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/","title":"HPS GHRD Linux Boot Tutorial Example Design: Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#overview","title":"Overview","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The key differences versus the GSRD are:</p> <ul> <li>Fabric is configured from U-Boot directly with the rbf file, with <code>fpga load</code> command, instead of using the <code>bootm</code> command with the core.rbf part of the kernel.itb file</li> <li>Single image boot is disabled in U-Boot, and it boots directly with the slected boot source, not trying them all</li> <li>The applications and drivers form <code>meta-intel-fpga-refdes</code> are not included. That includes acessing GPIOs in the fabric for LEDs, pushbuttons, dip switches, the webserver running on the board, etc.</li> </ul> <p>The following scenarios are covered:</p> <ul> <li>HPS Enablement Board: boot from SD card, and boot from QSPI</li> <li>HPS NAND Board: boot from eMMC flash</li> <li>HPS Test Board: boot from SD card</li> </ul> <p>The instructions on this page are based on the GSRD.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the guides from this page:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1.<ul> <li>HPS Enablement  Expansion Board. Included with the development kit</li> <li>HPS NAND Board. Enables eMMC storage for HPS. Orderable separately</li> <li>HPS Test Board. Supports SD card boot, and external Arm tracing. Orderable separately</li> <li>Mini USB Cable. Included with the development kit</li> <li>Micro USB Cable. Included with the development kit</li> <li>Ethernet Cable. Included with the development kit</li> <li>Micro SD card and USB card writer. Included with the development kit</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#development-kit","title":"Development Kit","text":"<p>Refer to Development Kit for details about the board, including how to install the HPS Boards, and how to set MSEL dispswitches.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>Refer to Release Notes for release readiness information and known issues.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-enablement-board","title":"HPS Enablement Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS Enablement Board. Both booting from SD card and booting from QSPI are covered.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-sd-card","title":"Boot from SD Card","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_boot.enablement\nmkdir agilex5_boot.enablement\ncd agilex5_boot.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\ncat &lt;&lt; EOF &gt; config-fragment-agilex5\n# Enable Ethernet connectivity so we can get an IP address\nCONFIG_MARVELL_PHY=y\nEOF\nmake defconfig\n# Apply custom Configs in file\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex5\nmake oldconfig\nmake -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Install Yocto Dependencies <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from QSPI.</p> <p>NOTE:  This section assumes that the Boot from SD Card section has been already built and the environment setup in that section is still available.</p> <p>This section presents how to build the binaries and boot from QSPI with the HPS Enablement Board. While the example is based on the GSRD, it contains the following differences:</p> <ul> <li>U-Boot tries to boot only from QSPI flash, does not try SD card</li> <li>U-Boot does not use a script to boot, instead it used the <code>BOOTCMD</code> environment variable directly</li> <li>kernel.itb file contains only one set of core.rbf, kernel and device tree files, targeted for this scenario</li> </ul> <p>1. Prepare the top folder</p> <pre><code>rm -rf $TOP_FOLDER/qspi-boot\nmkdir $TOP_FOLDER/qspi-boot\n</code></pre> <p>2. Build U-Boot:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from QSPI\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# mtd info\nCONFIG_MTDIDS_DEFAULT=\"nor0=nor0\"\nCONFIG_MTDPARTS_DEFAULT=\"mtdparts=nor0:66m(u-boot),190m(root)\"\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# do not keep env on sd card\nCONFIG_ENV_IS_IN_FAT=n\n# disable NAND related settings from defconfig\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"mtdparts;ubi part root;ubi readvol \\${loadaddr} kernel;ubi detach;setenv bootargs earlycon panic=-1 ubi.mtd=1 root=ubi0:rootfs rootfstype=ubifs rw rootwait;bootm \\${loadaddr}#board-0;\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build <code>kernel.itb</code> FIT file containing kernel, device tree and fpga fabric configuration file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -f core.rbf devicetree.dtb Image.lzma kernel.its kernel.itb\nln -s ../ghrd.core.rbf core.rbf\nln -s ../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb devicetree.dtb\nxz --format=lzma --extreme -k -c ../linux-socfpga/arch/arm64/boot/Image &gt; Image.lzma\ncat &lt;&lt; EOF &gt; kernel.its\n// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2024 Intel Corporation\n *\n */\n/dts-v1/;\n/ {\n    description = \"FIT image with kernel, DTB and FPGA core binary\";\n    #address-cells = &lt;1&gt;;\n    images {\n        kernel {\n            description = \"Linux Kernel\";\n            data = /incbin/(\"./Image.lzma\");\n            type = \"kernel\";\n            arch = \"arm64\";\n            os = \"linux\";\n            compression = \"lzma\";\n            load = &lt;0x86000000&gt;;\n            entry = &lt;0x86000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fdt-0 {\n            description = \"Device Tree\";\n            data = /incbin/(\"./devicetree.dtb\");\n            type = \"flat_dt\";\n            arch = \"arm64\";\n            compression = \"none\";\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fpga-0 {\n            description = \"FPGA bitstream\";\n            data = /incbin/(\"./core.rbf\");\n            type = \"fpga\";\n            arch = \"arm64\";\n            compression = \"none\";\n            load = &lt;0x8A000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n    };\n    configurations {\n        default = \"board-0\";\n        board-0 {\n            description = \"board_0\";\n            kernel = \"kernel\";\n            fdt = \"fdt-0\";\n            fpga = \"fpga-0\";\n            signature {\n                algo = \"crc32\";\n                key-name-hint = \"dev\";\n                sign-images = \"fdt-0\", \"kernel\", \"fpga-0\";\n            };\n        };\n    };\n};\nEOF\n./u-boot-socfpga/tools/mkimage -f kernel.its kernel.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/kernel.itb</code></li> </ul> <p>4. Create U-Boot binary <code>u-boot.bin</code> with a size of exactly 2MB:</p> <pre><code>cp u-boot-socfpga/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Build the <code>rootfs.ubifs</code> file:</p> <pre><code>rm -rf rootfs rootfs.ubifs\nmkdir rootfs tar -xzvf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz -C rootfs mkfs.ubifs -r rootfs -F -e 65408 -m 1 -c 6500 -o rootfs.ubifs </code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/rootfs.ubifs</code></li> </ul> <p>6. Build the <code>root.ubi</code> file:</p> <pre><code>cat &lt;&lt; EOF &gt; ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nvol_id=1\nvol_name=script\nvol_size=128KiB \nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3    \nvol_name=dtb   \nvol_size=256KiB \nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOF\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/root.ubi</code></li> </ul> <p>7. Build the QSPI flash image:</p> <pre><code>ln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof fpga.sof\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\nln -s root.ubi hps.bin\ncat &lt;&lt; EOF &gt; flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n    &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"UBOOT\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"HPS\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"UBOOT\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash_image.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/flash_image.hps.jic</code></li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <p><pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"qspi-boot/flash_image.hps.jic\"\n</code></pre> Note: You need to wipe the micro SD card or remove it from the board before start running.</p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-nand-board","title":"HPS NAND Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS NAND Board. Boot source is eMMC Flash.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-emmc","title":"Boot from eMMC","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_boot.emmc\nmkdir agilex5_boot.emmc\ncd agilex5_boot.emmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk_emmc.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk_emmc.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_emmc.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create eMMC Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_emmc.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Create Helper JIC <p>In this section we are building a helper JIC which will boot from QSPI and will allow us to program the eMMC from U-Boot.</p> <p>1. Create the jic helper folder to contain all related build artifacts:</p> <pre><code>rm -rf $TOP_FOLDER/helper-jic\nmkdir $TOP_FOLDER/helper-jic\n</code></pre> <p>2. Build a modified U-Boot, which boots from QSPI and stops at command line prompt:</p> <pre><code>cd $TOP_FOLDER/helper-jic\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"echo hello\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\n# boot from QSPI\nCONFIG_ENV_IS_IN_FAT=n\nCONFIG_ENV_IS_NOWHERE=y\nCONFIG_SYS_SPI_U_BOOT_OFFS=0x00300000\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build the helper JIC:</p> <pre><code>cd $TOP_FOLDER/helper-jic\nrm -f flash.pfg fpga.sof u-boot.bin spl.hex *.jic *.rbf\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof fpga.sof\nln -s u-boot-socfpga/u-boot.itb u-boot.bin\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\ncat &lt;&lt; EOF &gt; flash.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU128\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00300000\" e_addr=\"0x004CFFFF\" fixed_e_addr=\"1\" id=\"u-boot\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE5SR0&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"u-boot\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash.pfg\n</code></pre> <p>The following file will be created:</p> <ul> <li><code>$TOP_FOLDER/helper-jic/flash.hps.jic</code></li> </ul> Write eMMC Image <p>1. Write the helper JIC to QSPI:</p> <ul> <li>Power down board</li> <li>Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</li> <li>Power up the board</li> <li>Write JIC image to QSPI: <pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;helper-jic/flash.hps.jic\"\n</code></pre> </li></ul> <p>2. Boot to U-Boot prompt with the helper JIC:</p> <ul> <li>Power down board</li> <li>Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</li> <li>Power up the board</li> <li>Wait for U-Boot to boot, press any key to get to U-Boot console</li></ul> <p>3. Use <code>ifconfig</code> on your host machine to determine the IP of your TFTP server</p> <p>4. Copy the eMMC image <code>$TOP_FOLDER/sd_card/sdcard.img</code> to your TFTP server folder</p> <p>5. Use the following U-Boot commands to download and write the eMMC image:</p> <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your_tftp_server_ip&gt;\ntftp ${loadaddr} sdcard.img\nsetexpr blkcnt ${filesize} / 0x200\nmmc write ${loadaddr} 0 ${blkcnt}\n</code></pre> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-test-board","title":"HPS Test Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS Test Board. Boot source is SD Card.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-sd-card_1","title":"Boot from SD Card","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_boot.test\nmkdir agilex5_boot.test\ncd agilex5_boot.test\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-debug2-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-debug2-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-debug2-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk_debug.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk_debug.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_debug.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_debug.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://win32diskimager.org/. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#direct-atf-to-linux-boot-on-hps-enablement-board","title":"Direct ATF to Linux Boot on HPS Enablement Board","text":"<p>Starting from 24.3.1 release, the Agilex\u2122 5 device is provided with the support of direct booting from ATF to Linux. In this boot flow, ATF acts as a First Stage Bootloader (BL2) and also as a Second Stage Bootloader (BL31). This last one is in charge of loading and launching Linux OS, so U-Boot is not used in this boot flow.</p> <p> </p> <p>In this boot flow, the BL2 (FSBL) is included in the bitstream together with the SDM FW and hardware design (first phase only in HPS boot first mode). When booting from QSPI, this bitstream is stored in the QSPI memory. In this boot flow, the BL31 (SSBL) is packed with the Linux kernel and device tree into a FIP format image. This format provides to ATF the information about the components included in the image in a partition header. The resulting FIP image is added to the final flash image used to boot from (QSPI, SDCard, NAND or eMMC). </p> <p>When creating the flash image, it's necessary to provide the location in where ATF expects to find the FIP image (fip.bin). This is hardcoded in the ATF code (plat/intel/soc/common/include/platform_def.h) for each one of the flash devices in which this boot flow is supported as indicated in the next table:</p> Flash Device Definition Location in Flash device QSPI PLAT_QSPI_DATA_BASE 0x3C00000 SDCard PLAT_SDMMC_DATA_BASE 0x0 eMMC PLAT_SDMMC_DATA_BASE 0x0 <p>The following sections provide instructions about how to generate the binaries to exercise this boot flow booting from different boot sources.  The instructions provided to build the binaries to boot form any flash device are expected to be executed togheter becuase therre are some dependencies among them. In all the cases the environment set up is needed. For dependencies, check at the beggining of each one of the sections.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-sd-card_2","title":"Boot from SD Card","text":"<p>Here we provide all the steps needed to create the binaries that allow you to exercise the ATF to Linux boot flow from a SD Card device. This includes building the hardware design, ATF (BL2, BL31), Linux file system, and Linux. These are some notes about the build instructions:</p> <ul> <li>Excercise the HPS boot first flow.</li> <li>When building ATF, we indicate the device used to boot from. We also indicate the SDRAM memory locations where the Linux kernel image and device tree will be loaded and launched from. In this boot flow, Linux is referred to as BL33.</li> <li>The FIP image (fip.bin) is created using the ATF fiptool, indicating the binaries that integrate this image.</li> <li>The SD Card created will include 2 partitions. One in which the fip.bin file is located (raw format and type A2) and the other for the file system (ext3 format).</li> <li> <p>If wanted to perform FPGA configuration (2nd phase from Linux) from Linux create overlays.dtb as indicated in Agilex\u2122 7 SoC Fabric Configuration from Linux Example</p> <p> </p> </li> </ul> Toolchain Setup (ATF-To-Linux) <pre><code>sudo rm -rf agilex5_boot.atf2linux_sd_qspi\nmkdir agilex5_boot.atf2linux_sd_qspi &amp;&amp; cd agilex5_boot.atf2linux_sd_qspi\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd_sdqspi &amp;&amp; mkdir agilex5_soc_devkit_ghrd_sdqspi &amp;&amp; cd agilex5_soc_devkit_ghrd_sdqspi\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/agilex5_soc_devkit_ghrd_sdqspi/output_files/legacy_baseline.sof</li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware-sdcard\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware arm-trusted-firmware-sdcard\ncd arm-trusted-firmware-sdcard\n# Workaround for HSD: 15018072763. Will be fixed in 25.3\nsed -i  's/struct cdns_idmac_desc cdns_desc\\[CONFIG_CDNS_DESC_COUNT\\];/struct cdns_idmac_desc cdns_desc\\[CONFIG_CDNS_DESC_COUNT\\]  __aligned(8);/g' drivers/cadence/emmc/cdns_sdmmc.c\nmake realclean\n# Setting Bootsource as SDMMC\nmake bl2 bl31 PLAT=agilex5 ARM_LINUX_KERNEL_AS_BL33=1  PRELOADED_BL33_BASE=0x82000000 ARM_PRELOADED_DTB_BASE=0x90000000 SOCFPGA_BOOT_SOURCE_SDMMC=1\n# Create Fiptool tool\nmake -C tools/fiptool clean\nmake fiptool\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware-sdcard/build/agilex5/release/bl2.bin</li> <li>$TOP_FOLDER/arm-trusted-firmware-sdcard/build/agilex5/release/bl31.bin</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga-sdcard\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga linux-socfpga-sdcard\ncd linux-socfpga-sdcard\n# Create a device tree for this flow\ncat &lt;&lt; EOF &gt; arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_atfboot.dts\n#include \"socfpga_agilex5_socdk.dts\"\n/ {\n    model = \"SoCFPGA Agilex5 SoCDK\";\n  compatible = \"intel,socfpga-agilex5-socdk\", \"intel,socfpga-agilex5\";\n  chosen {\n      stdout-path = \"serial0:115200n8\";\n      bootargs = \"console=ttys0,115200 earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait\";\n    };\n};\nEOF\n# Build socfpga_agilex5_socdk_atfboot.dtb\nsed -i '/socfpga_agilex5_socdk.dtb \\\\/a socfpga_agilex5_socdk_atfboot.dtb \\\\' arch/arm64/boot/dts/intel/Makefile\n\ncat &lt;&lt; EOF &gt; config-fragment-agilex5\n# Enable DHCP \nCONFIG_IP_PNP_DHCP=y\n# enable kernel debugging with RiscFree\nCONFIG_DEBUG_INFO=y\nCONFIG_GDB_SCRIPTS=y\nCONFIG_INITRAMFS_ROOT_UID=0\nCONFIG_INITRAMFS_ROOT_GID=0\nCONFIG_INITRAMFS_COMPRESSION_GZIP=y\n# Include these configs if wanted to perform fpga reconfiguration using overlays (enable device tree overlays and fpga bridges)\n# Taken from https://altera-fpga.github.io/latest/embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/\nCONFIG_OF_RESOLVE=y\nCONFIG_OF_OVERLAY=y\nCONFIG_OF_CONFIGFS=y\nCONFIG_FPGA_MGR_STRATIX10_SOC=y\nCONFIG_FPGA_BRIDGE=y\nCONFIG_FPGA_REGION=y\nCONFIG_OF_FPGA_REGION=y\nCONFIG_OVERLAY_FS=y\nCONFIG_ALTERA_SYSID=y\n# Needed for netwrok connectivity\nCONFIG_MARVELL_PHY=y\nEOF\nmake clean &amp;&amp; make mrproper\nmake defconfig\n# Apply custom Configs in file\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex5\n\nmake oldconfig\nmake -j 64 Image dtbs\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/linux-socfpga-sdcard/arch/arm64/boot/Image</li> <li>$TOP_FOLDER/linux-socfpga-sdcard/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_atfboot.dtb</li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'IMAGE_FSTYPES = \"tar.gz cpio jffs2\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver devmem2\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</li> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.jffs2</li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -rf jic_sdcard\nmkdir jic_sdcard &amp;&amp; cd jic_sdcard\n# Convert fsbl\naarch64-none-linux-gnu-objcopy -v -I binary -O ihex --change-addresses 0x00000000 $TOP_FOLDER/arm-trusted-firmware-sdcard/build/agilex5/release/bl2.bin fsbl.hex\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd_sdqspi/output_files/legacy_baseline.sof legacy_baseline.sof\n# Create .jic file\nquartus_pfg -c legacy_baseline.sof \\\ndesign_atf.jic \\\n-o hps_path=fsbl.hex \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0  \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/jic_sdcard/design_atf.hps.jic</li> <li>$TOP_FOLDER/jic_sdcard/design_atf.core.rbf</li> </ul> Build SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card\nmkdir sd_card &amp;&amp; cd sd_card\n## Create FIP image\n$TOP_FOLDER/arm-trusted-firmware-sdcard/tools/fiptool/fiptool create \\\n--soc-fw $TOP_FOLDER/arm-trusted-firmware-sdcard/build/agilex5/release/bl31.bin \\\n--nt-fw $TOP_FOLDER/linux-socfpga-sdcard/arch/arm64/boot/Image \\\n--nt-fw-config $TOP_FOLDER/linux-socfpga-sdcard/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_atfboot.dtb fip.bin\n\n# Build now the SDCard\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar -xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\nsudo cp $TOP_FOLDER/jic_sdcard/design_atf.core.rbf home/root/\nsudo rm -rf lib/modules/*\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fip.bin,num=1,format=raw,size=64M,type=a2 \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 128M -n sdimage_atf.img\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/sd_card/sdimage_atf.img</li> </ul> <p>You can exercise ATF to Linux boot flow from SD Card using the following binaries generated:</p> <ul> <li>$TOP_FOLDER/sd_card/sdimage_atf.img</li> <li>$TOP_FOLDER/jic_sdcard/design_atf.hps.jic</li> </ul> <p>When booting with the binaries generated, this is the log that you will see. This is the log is just a refenrece and captured by the time the page was created and in the future the versions in the components may change.</p> <pre><code>NOTICE:  DDR: Reset type is 'Power-On'\nNOTICE:  IOSSM: Calibration success status check...\nNOTICE:  IOSSM: All EMIF instances within the IO96 have calibrated successfully!\nNOTICE:  DDR: Calibration success\nNOTICE:  DDR: DDR size configured is (2048 MiB)\nNOTICE:  DDR: Mismatch with hardware size (8192 MiB).\nNOTICE:  ###DDR:init success###\nNOTICE:  SOCFPGA: SDMMC boot\nNOTICE:  BL2: v2.11.1(release):QPDS24.1STD_REL_GSRD_PR-dirty\nNOTICE:  BL2: Built : 11:05:13, Mar 25 2025\nNOTICE:  BL2: Booting BL31\nNOTICE:  SOCFPGA: CPU ID = 0\nNOTICE:  BL31: v2.11.1(release):QPDS24.1STD_REL_GSRD_PR-dirty\nNOTICE:  BL31: Built : 11:05:18, Mar 25 2025\nNOTICE:  BL31: Initializing runtime services\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.51-g7dddbad0a3a7-dirty (rolando@rolando3-linux-lab) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 11.2.1 20220111, GNU ld (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 2.37.20220122) #1 SMP PREEMPT Mon Mar 31 17:31:03 CDT 2025\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] earlycon: uart0 at MMIO32 0x0000000010c02000 (options '115200n8')\n[    0.000000] printk: bootconsole [uart0] enabled\n:\n[    0.000000] Kernel command line: console=ttys0,115200 earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait\n:\n[    8.026580] socfpga-dwmac 10830000.ethernet eth0: No Safety Features support found\n[    8.034175] socfpga-dwmac 10830000.ethernet eth0: IEEE 1588-2008 Advanced Timestamp supported\n[    8.043140] socfpga-dwmac 10830000.ethernet eth0: registered PTP clock\n[    8.050111] socfpga-dwmac 10830000.ethernet eth0: FPE workqueue start\n[    8.056545] socfpga-dwmac 10830000.ethernet eth0: configuring for phy/rgmii link mode\n[   12.156912] socfpga-dwmac 10830000.ethernet eth0: Link is Up - 1Gbps/Full - flow control rx/tx\n[   18.401711] dw-apb-uart 10c02000.serial: failed to request DMA\n\nPoky (Yocto Project Reference Distro) 5.1.3 agilex5_dk_a5e065bb32aes1 /dev/ttyS0\n\nagilex5_dk_a5e065bb32aes1 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for testing and development purposes only. It is recommended that you create your own distribution for production use.\n\nroot@agilex5_dk_a5e065bb32aes1:~# \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-qspi_1","title":"Boot from QSPI","text":"<p>This section provides instructions to build binaries to exercise ATF to Linux direct boot flow booting from a QSPI device.</p> <p>NOTE: This section depends on some steps from the ATF to Linux from SD Card section. So, to build the binaries in this section, the instructions in the following sections need to be executed earlier:</p> <ul> <li>Toolchain Setup (ATF-To-Linux)</li> <li>Build Hardware Design SD_QSPI (ATF-To-Linux)</li> <li>Build Linux File System  (ATF-To-Linux)</li> </ul> <p>ATF requires to be rebuilt to enable booting from QSPI by setting SOCFPGA_BOOT_SOURCE_QSPI to '1'. Linux also need to be rebuild since this time we are including a JFFS2 file system and since booting from QSPI we need to change some parameters in the device tree. The FIP image is created in the same way but this time the FIP image is put into the QSPI image using a specific .pfg file. In this .pfg file, we are indicating that the fip file will be located at 0x3C00000 location in the QSPI since this is also indicated by the PLAT_QSPI_DATA_BASE definition in the ATF.</p> <p> </p> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\n# Building ATF\nrm -rf arm-trusted-firmware-qspi\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware arm-trusted-firmware-qspi\ncd arm-trusted-firmware-qspi\n\nmake realclean\n# Setting Bootsource as QSPI\nmake bl2 bl31 PLAT=agilex5 ARM_LINUX_KERNEL_AS_BL33=1  PRELOADED_BL33_BASE=0x82000000 ARM_PRELOADED_DTB_BASE=0x90000000 SOCFPGA_BOOT_SOURCE_QSPI=1\n# Create Fiptool tool\nmake -C tools/fiptool clean\nmake fiptool\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware-qspi/build/agilex5/release/bl2.bin </li> <li>$TOP_FOLDER/arm-trusted-firmware-qspi/build/agilex5/release/bl31.bin</li> <li>$TOP_FOLDER/arm-trusted-firmware-qspi/tools/fiptool/fiptool</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga-qspi\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga linux-socfpga-qspi\ncd linux-socfpga-qspi\n\n# Create a device tree for this flow in which we create the command line to get the file system from QSPI\ncat &lt;&lt; EOF &gt; arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_atfboot.dts\n#include \"socfpga_agilex5_socdk.dts\"\n/ {\n    model = \"SoCFPGA Agilex5 SoCDK\";\n    compatible = \"intel,socfpga-agilex5-socdk\", \"intel,socfpga-agilex5\";\n    chosen {\n       stdout-path = \"serial0:115200n8\";\n       bootargs = \"console=ttys0,115200 earlycon panic=-1 root=/dev/mtdblock1 rw rootfstype=jffs2 rootwait\";\n    };\n};\nEOF\n## Modify QSPI clock frequency to 50 MHz to match ATF and modify the QSPI partitions ranges to fit the current images\nsed -i  's/spi-max-frequency = &lt;100000000&gt;;/spi-max-frequency = &lt;50000000&gt;;/g' arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dts\n\n## Adjust the partitions so the commponents in QSPI can fit\nsed -i  's/reg = &lt;0x0 0x04200000&gt;;/reg = &lt;0x0 0x0700000&gt;;/g' arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dts\nsed -i  's/root: partition@4200000/root: partition@7000000/g' arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dts\nsed -i  's/reg = &lt;0x04200000 0x0be00000&gt;/reg = &lt;0x07000000 0x09000000&gt;/g' arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dts\n\n# Include the build socfpga_agilex5_socdk_atfboot.dtb in the Makefile\nsed -i '/socfpga_agilex5_socdk.dtb \\\\/a socfpga_agilex5_socdk_atfboot.dtb \\\\' arch/arm64/boot/dts/intel/Makefile\n\ncat &lt;&lt; EOF &gt; config-fragment-agilex5\n# Enable DHCP \nCONFIG_IP_PNP_DHCP=y\n# enable kernel debugging with RiscFree\nCONFIG_DEBUG_INFO=y\nCONFIG_GDB_SCRIPTS=y\nCONFIG_INITRAMFS_ROOT_UID=0\nCONFIG_INITRAMFS_ROOT_GID=0\nCONFIG_INITRAMFS_COMPRESSION_GZIP=y\n# Include these configs if wanted to perform fpga reconfiguration using overlays (enable device tree overlays and fpga bridges)\n# Taken from https://altera-fpga.github.io/latest/embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/\nCONFIG_OF_RESOLVE=y\nCONFIG_OF_OVERLAY=y\nCONFIG_OF_CONFIGFS=y\nCONFIG_FPGA_MGR_STRATIX10_SOC=y\nCONFIG_FPGA_BRIDGE=y\nCONFIG_FPGA_REGION=y\nCONFIG_OF_FPGA_REGION=y\nCONFIG_OVERLAY_FS=y\nCONFIG_ALTERA_SYSID=y\n# Enabling JFFS2 File system\nCONFIG_JFFS2_FS=y\n# Needed for netwrok connectivity\nCONFIG_MARVELL_PHY=y\nEOF\nmake clean &amp;&amp; make mrproper\nmake defconfig\n# Apply custom Configs in file\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex5\n\nmake oldconfig\nmake -j 64 Image dtbs\n</code></pre> <p>The output files from this stage are:</p> <ul> <li>$TOP_FOLDER/linux-socfpga-qspi/arch/arm64/boot/Image</li> <li>$TOP_FOLDER/linux-socfpga-qspi/arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dtb</li> </ul> Buid QSPI Image <pre><code>cd $TOP_FOLDER\nrm -rf jic_qspi\nmkdir jic_qspi &amp;&amp; cd jic_qspi\n\n## Create .pfg to create the .jic\ncat &lt;&lt; EOF &gt; qspi_flash_image_agilex_boot.pfg\n&lt;pfg version=\"1\"&gt;\n  &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n  &lt;output_files&gt;\n      &lt;output_file name=\"flash_image_atf_qspi\" directory=\".\" type=\"JIC\"&gt;\n          &lt;file_options/&gt;\n          &lt;secondary_file type=\"MAP\" name=\"flash_image_atf_qspi_jic\"&gt;\n              &lt;file_options/&gt;\n          &lt;/secondary_file&gt;\n          &lt;secondary_file type=\"SEC_RPD\" name=\"flash_image_atf_qspi_jic\"&gt;\n              &lt;file_options bitswap=\"1\"/&gt;\n          &lt;/secondary_file&gt;\n          &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n      &lt;/output_file&gt;\n  &lt;/output_files&gt;\n  &lt;bitstreams&gt;\n      &lt;bitstream id=\"Bitstream_1\"&gt;\n          &lt;path hps_path=\"./fsbl.hex\"&gt;./legacy_baseline.sof&lt;/path&gt;\n      &lt;/bitstream&gt;\n  &lt;/bitstreams&gt;\n  &lt;raw_files&gt;\n      &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;fip.bin&lt;/raw_file&gt;\n      &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;rootfs.bin&lt;/raw_file&gt;\n  &lt;/raw_files&gt;\n  &lt;flash_devices&gt;\n      &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n          &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03C00000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"fip\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x07000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"Rootfs\" size=\"0\"/&gt;\n      &lt;/flash_device&gt;\n      &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n  &lt;/flash_devices&gt;\n  &lt;assignments&gt;\n      &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n          &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n      &lt;/assignment&gt;\n      &lt;assignment page=\"0\" partition_id=\"fip\"&gt;\n          &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n      &lt;/assignment&gt;\n      &lt;assignment page=\"0\" partition_id=\"Rootfs\"&gt;\n          &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n      &lt;/assignment&gt;\n  &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# Convert bl2.bin\naarch64-none-linux-gnu-objcopy -v -I binary -O ihex --change-addresses 0x00000000 $TOP_FOLDER/arm-trusted-firmware-qspi/build/agilex5/release/bl2.bin fsbl.hex\n\n# Build FIP Image  \n$TOP_FOLDER/arm-trusted-firmware-qspi/tools/fiptool/fiptool create \\\n--soc-fw $TOP_FOLDER/arm-trusted-firmware-qspi/build/agilex5/release/bl31.bin \\\n--nt-fw $TOP_FOLDER/linux-socfpga-qspi/arch/arm64/boot/Image \\\n--nt-fw-config $TOP_FOLDER/linux-socfpga-qspi/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_atfboot.dtb fip.bin\n\n# Create the jic file\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd_sdqspi/output_files/legacy_baseline.sof legacy_baseline.sof\nln -s $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.jffs2 rootfs.bin\nquartus_pfg -c qspi_flash_image_agilex_boot.pfg\n</code></pre> <p>After building, you can use the following binary to exercise the ATF to Linux boot flow booting from QSPI:</p> <ul> <li>$TOP_FOLDER/jic_qspi/flash_image_atf_qspi.jic</li> </ul> <p>When booting with the binaries generated, this is the log that you will see. This is the log is just a refenrece and captured by the time the page was created and in the future the versions in the components may change.</p> <pre><code>NOTICE:  DDR: Reset type is 'Power-On'\nNOTICE:  IOSSM: Calibration success status check...\nNOTICE:  IOSSM: All EMIF instances within the IO96 have calibrated successfully!\nNOTICE:  DDR: Calibration success\nNOTICE:  ###DDR:init success###\nNOTICE:  SOCFPGA: QSPI boot\nNOTICE:  BL2: v2.11.1(release):QPDS24.1STD_REL_GSRD_PR-dirty\nNOTICE:  BL2: Built : 13:04:50, Mar 25 2025\nNOTICE:  BL2: Booting BL31\nNOTICE:  SOCFPGA: Boot Core = 0\nNOTICE:  SOCFPGA: CPU ID = 0\nNOTICE:  BL31: v2.11.1(release):QPDS24.1STD_REL_GSRD_PR-dirty\nNOTICE:  BL31: Built : 13:04:57, Mar 25 2025\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.51-g7dddbad0a3a7-dirty (rolando@rolando3-linux-lab) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 11.2.1 20220111, GNU ld (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 2.37.20220122) #1 SMP PREEMPT Mon Mar 31 17:55:55 CDT 2025\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] earlycon: uart0 at MMIO32 0x0000000010c02000 (options '115200n8')\n[    0.000000] printk: bootconsole [uart0] enabled\n:\n[    0.000000] Kernel command line: console=ttys0,115200 earlycon panic=-1 root=/dev/mtdblock1 rw rootfstype=jffs2 rootwait\n:\n[    5.420883] socfpga-dwmac 10830000.ethernet eth0: PHY [stmmac-2:00] driver [Generic PHY] (irq=POLL)\n[    5.430051] socfpga-dwmac 10830000.ethernet eth0: No Safety Features support found\n[    5.437626] socfpga-dwmac 10830000.ethernet eth0: IEEE 1588-2008 Advanced Timestamp supported\n[    5.446552] socfpga-dwmac 10830000.ethernet eth0: registered PTP clock\n[    5.453515] socfpga-dwmac 10830000.ethernet eth0: FPE workqueue start\n[    5.459947] socfpga-dwmac 10830000.ethernet eth0: configuring for phy/rgmii link mode\n[    9.565492] socfpga-dwmac 10830000.ethernet eth0: Link is Up - 1Gbps/Full - flow control rx/tx\n[   15.047704] dw-apb-uart 10c02000.serial: failed to request DMA\n\nPoky (Yocto Project Reference Distro) 5.1.3 agilex5_dk_a5e065bb32aes1 /dev/ttyS0\n\nagilex5_dk_a5e065bb32aes1 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for testing and development purposes only. It is recommended that you create your own distribution for production use.\n\nroot@agilex5_dk_a5e065bb32aes1:~# \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-emmc_1","title":"Boot from eMMC","text":"<p>This section provides instructions to build binaries to exercise ATF to Linux direct boot flow booting from a eMMC card.</p> <p>The GHRD must be re-built as this time it's required a hardware design specific to boot from eMMC.  ATF also requires to be rebuilt to enable booting from eMMC by setting SOCFPGA_BOOT_SOURCE_SDMMC to '1' and setting MMC_DEVICE_TYPE to '0' (eMMC used instead of SD Card). Linux also need to be re-built because we need to addapt the device tree to use the correct configuration to boot from eMMC. The FIP image and the eMMC image are created in the same way than for the SD Card use case.</p> <p> </p> Toolchain Setup (ATF-To-Linux) <pre><code>sudo rm -rf agilex5_boot.atf2linux_emmc\nmkdir agilex5_boot.atf2linux_emmc &amp;&amp; cd agilex5_boot.atf2linux_emmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd_emmc &amp;&amp; mkdir agilex5_soc_devkit_ghrd_emmc &amp;&amp; cd agilex5_soc_devkit_ghrd_emmc\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/agilex5_soc_devkit_ghrd_emmc/output_files/legacy_baseline.sof</li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\n# Building ATF\nrm -rf arm-trusted-firmware-emmc\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware arm-trusted-firmware-emmc\ncd arm-trusted-firmware-emmc\n# Indicate that we will boot from eMMC instead of SDCard\nsed -i 's/\\#define MMC_DEVICE_TYPE.*/\\#define MMC_DEVICE_TYPE                       0  \\/\\* MMC = 0, SD = 1 \\*\\//g' plat/intel/soc/agilex5/include/socfpga_plat_def.h\n# Workaround for HSD: 15018072763. Will be fixed in 25.3\nsed -i  's/struct cdns_idmac_desc cdns_desc\\[CONFIG_CDNS_DESC_COUNT\\];/struct cdns_idmac_desc cdns_desc\\[CONFIG_CDNS_DESC_COUNT\\]  __aligned(8);/g' drivers/cadence/emmc/cdns_sdmmc.c\n\nmake realclean\n# Setting Bootsource as SDMMC\nmake bl2 bl31 PLAT=agilex5 ARM_LINUX_KERNEL_AS_BL33=1  PRELOADED_BL33_BASE=0x82000000 ARM_PRELOADED_DTB_BASE=0x90000000 SOCFPGA_BOOT_SOURCE_SDMMC=1\n# Create Fiptool tool\nmake -C tools/fiptool clean\nmake fiptool\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware-emmc/build/agilex5/release/bl2.bin </li> <li>$TOP_FOLDER/arm-trusted-firmware-emmc/build/agilex5/release/bl31.bin</li> <li>$TOP_FOLDER/arm-trusted-firmware-emmc/tools/fiptool/fiptool</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga-emmc\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga linux-socfpga-emmc\ncd linux-socfpga-emmc\n\n# Create a device tree for this flow in which we create the command line to get the file system from QSPI\ncat &lt;&lt; EOF &gt; arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_atfboot.dts\n#include \"socfpga_agilex5_socdk_emmc.dts\"\n/ {\n    model = \"SoCFPGA Agilex5 SoCDK\";\n    compatible = \"intel,socfpga-agilex5-socdk\", \"intel,socfpga-agilex5\";\n    chosen {\n       stdout-path = \"serial0:115200n8\";\n       bootargs = \"console=ttys0,115200 earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait\";\n    };\n};\nEOF\n# Build socfpga_agilex5_socdk_atfboot.dtb\nsed -i '/socfpga_agilex5_socdk.dtb \\\\/a socfpga_agilex5_socdk_atfboot.dtb \\\\' arch/arm64/boot/dts/intel/Makefile\n\ncat &lt;&lt; EOF &gt; config-fragment-agilex5\n# Enable DHCP \nCONFIG_IP_PNP_DHCP=y\n# enable kernel debugging with RiscFree\nCONFIG_DEBUG_INFO=y\nCONFIG_GDB_SCRIPTS=y\nCONFIG_INITRAMFS_ROOT_UID=0\nCONFIG_INITRAMFS_ROOT_GID=0\nCONFIG_INITRAMFS_COMPRESSION_GZIP=y\n# Include these configs if wanted to perform fpga reconfiguration using overlays (enable device tree overlays and fpga bridges)\n# Taken from https://altera-fpga.github.io/latest/embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/\nCONFIG_OF_RESOLVE=y\nCONFIG_OF_OVERLAY=y\nCONFIG_OF_CONFIGFS=y\nCONFIG_FPGA_MGR_STRATIX10_SOC=y\nCONFIG_FPGA_BRIDGE=y\nCONFIG_FPGA_REGION=y\nCONFIG_OF_FPGA_REGION=y\nCONFIG_OVERLAY_FS=y\nCONFIG_ALTERA_SYSID=y\n# Needed for netwrok connectivity\nCONFIG_MARVELL_PHY=y\nEOF\nmake clean &amp;&amp; make mrproper\nmake defconfig\n# Apply custom Configs in file\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex5\n\nmake oldconfig\nmake -j 64 Image dtbs\n</code></pre> <p>The output files from this stage are:</p> <ul> <li>$TOP_FOLDER/linux-socfpga-emmc/arch/arm64/boot/Image</li> <li>$TOP_FOLDER/linux-socfpga-emmc/arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dtb</li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -rf jic_emmc\nmkdir jic_emmc &amp;&amp; cd jic_emmc\n# Convert fsbl\naarch64-none-linux-gnu-objcopy -v -I binary -O ihex --change-addresses 0x00000000 $TOP_FOLDER/arm-trusted-firmware-emmc/build/agilex5/release/bl2.bin fsbl.hex\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd_emmc/output_files/legacy_baseline.sof legacy_baseline.sof\n# Create .jic file\nquartus_pfg -c legacy_baseline.sof \\\nemmc_atf.jic \\\n-o hps_path=fsbl.hex \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0  \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/jic_emmc/emmc_atf.hps.jic</li> <li>$TOP_FOLDER/jic_emmc/emmc_atf.core.rbf</li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'IMAGE_FSTYPES = \"tar.gz cpio jffs2\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver devmem2\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</li> </ul> Build eMMC Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf emmc_image\nmkdir emmc_image &amp;&amp; cd emmc_image\n## Create FIP image\n$TOP_FOLDER/arm-trusted-firmware-emmc/tools/fiptool/fiptool create \\\n--soc-fw $TOP_FOLDER/arm-trusted-firmware-emmc/build/agilex5/release/bl31.bin \\\n--nt-fw $TOP_FOLDER/linux-socfpga-emmc/arch/arm64/boot/Image \\\n--nt-fw-config $TOP_FOLDER/linux-socfpga-emmc/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_atfboot.dtb fip.bin\n\n# Build now the SDCard\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar -xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\nsudo cp $TOP_FOLDER/jic_emmc/emmc_atf.core.rbf home/root/\nsudo rm -rf lib/modules/*\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fip.bin,num=1,format=raw,size=64M,type=a2 \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 128M -n emmc_atf.img\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/emmc_image/emmc_atf.img</li> </ul> <p>You can exercise ATF to Linux boot flow from SD Card using the following binaries generated:</p> <ul> <li>$TOP_FOLDER/emmc_image/emmc_atf.img</li> <li>$TOP_FOLDER/jic_emmc/emmc_atf.hps.jic</li> </ul> <p>When booting with the binaries generated, this is the log that you will see. This is the log is just a refenrece and captured by the time the page was created and in the future the versions in the components may change.</p> <pre><code>NOTICE:  DDR: Reset type is 'Power-On'\nNOTICE:  IOSSM: Calibration success status check...\nNOTICE:  IOSSM: All EMIF instances within the IO96 have calibrated successfully!\nNOTICE:  DDR: Calibration success\nNOTICE:  DDR: ECC is enabled\nNOTICE:  IOSSM: Memory initialized successfully on IO96B\nNOTICE:  ###DDR:init success###\nNOTICE:  DFI interface selected successfully to SDEMMC\nNOTICE:  SOCFPGA: SDMMC boot\nNOTICE:  BL2: v2.12.1(release):410b93702-dirty\nNOTICE:  BL2: Built : 20:10:16, Jul 31 2025\nNOTICE:  BL2: Booting BL31\nNOTICE:  SOCFPGA: Boot Core = 0\nNOTICE:  SOCFPGA: CPU ID = 0\nNOTICE:  SOCFPGA: Setting CLUSTERECTRL_EL1\nNOTICE:  BL31: v2.12.1(release):410b93702-dirty\nNOTICE:  BL31: Built : 20:10:21, Jul 31 2025\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.12.19-g7b497655d942-dirty (rolando@rolando3-linux-lab) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 11.2.1 20220111, GNU ld (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 2.37.20220122) #1 SMP PREEMPT Thu Jul 31 19:25:32 CDT 2025\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] earlycon: uart0 at MMIO32 0x0000000010c02000 (options '115200n8')\n[    0.000000] printk: legacy bootconsole [uart0] enabled\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] NUMA: Faking a node at [mem 0x0000000080000000-0x00000000ffffffff]\n[    0.000000] NODE_DATA(0) allocated [mem 0xffbf1bc0-0xffbf41ff]\n[    0.000000] Zone ranges:\n[    0.000000]   DMA      [mem 0x0000000080000000-0x00000000ffffffff]\n[    0.000000]   DMA32    empty\n[    0.000000]   Normal   empty\n[    0.000000] Movable zone start for each node\n[    0.000000] Early memory node ranges\n[    0.000000]   node   0: [mem 0x0000000080000000-0x0000000081ffffff]\n[    0.000000]   node   0: [mem 0x0000000082000000-0x00000000ffffffff]\n[    0.000000] Initmem setup node 0 [mem 0x0000000080000000-0x00000000ffffffff]\n[    0.000000] cma: Reserved 32 MiB at 0x00000000fba00000 on node -1\n[    0.000000] psci: probing for conduit method from DT.\n[    0.000000] psci: PSCIv1.1 detected in firmware.\n[    0.000000] psci: Using standard PSCI v0.2 function IDs\n[    0.000000] psci: MIGRATE_INFO_TYPE not supported.\n[    0.000000] psci: SMC Calling Convention v1.5\n[    0.000000] percpu: Embedded 25 pages/cpu s61720 r8192 d32488 u102400\n[    0.000000] Detected VIPT I-cache on CPU0\n[    0.000000] CPU features: detected: GIC system register CPU interface\n[    0.000000] CPU features: detected: Virtualization Host Extensions\n[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or 1530923\n[    0.000000] alternatives: applying boot alternatives\n[    0.000000] Kernel command line: console=ttys0,115200 earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait\n:\n[    1.666798] EXT4-fs (mmcblk0p2): mounting ext3 file system using the ext4 subsystem\n[    1.682241] EXT4-fs (mmcblk0p2): mounted filesystem c3b5fe0a-760b-4d2d-89dc-022dc29cde2f r/w with ordered data mode. Quota mode: none.\n[    1.694467] VFS: Mounted root (ext3 filesystem) on device 179:2.\n[    1.703706] devtmpfs: mounted\n[    1.718302] Freeing unused kernel memory: 10496K\n[    1.723362] Run /sbin/init as init process\n[    2.063314] udevd[108]: starting version 3.2.14\n[    3.807993] random: crng init done\n[    3.849113] udevd[109]: starting eudev-3.2.14\n[    4.124172] EXT4-fs (mmcblk0p2): re-mounted c3b5fe0a-760b-4d2d-89dc-022dc29cde2f r/w. Quota mode: none.\n[    4.785687] socfpga-dwmac 10810000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-0\n[    4.796266] socfpga-dwmac 10810000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-1\n[    4.807002] socfpga-dwmac 10810000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-2\n[    4.818280] socfpga-dwmac 10810000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-3\n[    4.829721] socfpga-dwmac 10810000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-4\n[    4.840131] socfpga-dwmac 10810000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-5\n[    4.851595] socfpga-dwmac 10810000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-6\n[    4.862012] socfpga-dwmac 10810000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-7\n[    5.044042] socfpga-dwmac 10810000.ethernet eth0: PHY [stmmac-0:00] driver [Marvell 88E1510] (irq=POLL)\n[    5.054381] socfpga-dwmac 10810000.ethernet eth0: No Safety Features support found\n[    5.062117] socfpga-dwmac 10810000.ethernet eth0: IEEE 1588-2008 Advanced Timestamp supported\n[    5.071233] socfpga-dwmac 10810000.ethernet eth0: registered PTP clock\n[    5.077845] socfpga-dwmac 10810000.ethernet eth0: configuring for phy/rgmii link mode\n[    9.345961] socfpga-dwmac 10810000.ethernet eth0: Link is Up - 1Gbps/Full - flow control rx/tx\n[   15.171626] dw-apb-uart 10c02000.serial: failed to request DMA\n\nPoky (Yocto Project Reference Distro) 5.1.4 agilex5_dk_a5e065bb32aes1 /dev/ttyS0\n\nagilex5_dk_a5e065bb32aes1 login: \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/","title":"Agilex\u2122 5E HPS Enhanced System Example Design Overview","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#introduction","title":"Introduction","text":"<p>The Agilex\u2122 5E HPS Enhanced System Example Design Shell builds on top of the Base GSRD and serves as a reference    shell starting point for system designer building solutions like PTP1588 which require ethernet interface or other designs which need DDR/LPDDR connected to fabric EMIF.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#glossary","title":"Glossary","text":"Term Description GSRD Golden System Reference Design GHRD Golden Hardware Reference Design CSR Configuration Space Register HPS Hard Processor Subsystem QSFP Quad Small Form-factor Pluggable DHCP Dynamic Host Configuration Protocol FSBL First Stage Bootloader"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1. Refer to the board documentation for more information about the development kit.</li> </ul> <ul> <li>HPS Enablement Expansion Board. Included with the development kit.</li> </ul> <ul> <li>Mini and Micro USB Cable. Included with the development kit.</li> </ul> <ul> <li>QSFP Loopback module : Amphenol QSFP + Loopback SF-100GLB0W00-0DB - 630510003</li> </ul> <ul> <li>Micro SD card and USB card writer. Included with the development kit.</li> </ul> <ul> <li>Host PC with 64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> </ul> <ul> <li>Linux OS installed on host PC, preferably Ubuntu 22.04LTS , while other versions and distributions may work too.</li> </ul> <ul> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> </ul> <ul> <li>Quartus\u00ae Prime Pro Edition software version 25.1 is used to recompile the hardware design. If only writing binaries is required, then the Quartus\u00ae Prime Pro Edition Programmer version 25.1 is sufficient.</li> </ul> <ul> <li>Local Ethernet network, with DHCP server Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#binaries","title":"Binaries","text":"<p>Prebuilt binaries are located here.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#sources","title":"Sources","text":"Component Location Branch Commit ID/Tag GHRD https://github.com/altera-fpga/agilex5e-ed-hps-enhanced/tree/rel/25.1/src/hw rel/25.1 QPDS25.1_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.12.11-lts QPDS25.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.12.0 QPDS25.1_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2025.01 QPDS25.1_REL_GSRD_PR Yocto Project: https://git.yoctoproject.org/poky/ styhead latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga/ styhead QPDS25.1_REL_GSRD_PR Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes styhead QPDS25.1_REL_GSRD_PR GSRD Build Script: gsrd-socfpga https://github.com/altera-fpga/agilex5e-ed-hps-enhanced/tree/rel/25.1/src/sw rel/25.1 QPDS25.1_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>Please refer this link for Release Notes and Known Issues. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#agilextm-5e-hps-enhanced-system-example-design-architecture","title":"Agilex\u2122 5E HPS Enhanced System Example Design Architecture","text":"<p>The hardware architecture of the Agilex\u2122 5E HPS Enhanced System Example Design supports the following interfaces on top of Base GSRD:</p> <ul> <li>Fabric Memory EMIF. </li> <li>Ethernet Interfaces.</li> </ul> <p>The Golden Hardware Reference Design (GHRD) includes simple Traffic Generators (TG) which are controlled from HPS Linux test applications viz.,</p> <p>Figure 1: Enhanced HPS Design</p> <p></p> <p>The Shell have two EMIF and one Ethernet subsystems for each along with two memory and one Ethernet traffic generators-cum-monitors respectively.</p> <p>[Note: Only one ethernet subsytem or ethernet Port0 enabled in this release and Port1 will be enabled in future release.]</p> <p>EMIF Channel Mapping:</p> Mem channel DDR Type DDR Frequency 0 DDR4 200Mhz 1 (Default) LPDDR4 200Mhz"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#traffic-exerciser-application-software-architecture","title":"Traffic Exerciser Application Software Architecture","text":"<p>The Traffic generators are controlled by the host side driver running as an application in Linux user-space software. The Linux user-space application uses UIO interfaces <code>/dev/uio0</code> and <code>/dev/uio1</code> to access the Traffic Generator (or exerciser) IPs. It controls the traffic generator via a memory mapped CSR registers. The CSR access by HPS software uses the LWHPS2FPGA interface. </p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#hardware-setup","title":"Hardware Setup","text":"<p>The hardware setup connection details are captured in the below image.</p> <p></p> <p>Note: Please refer base GSRD Installing HPS Daughtercard section for [1].</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#hps-lw-h2f-register-map","title":"HPS LW H2F Register Map","text":"Address Offset Size (Bytes) Peripheral Description GHRD-aligned address space 0x2001_0000 8 System ID Hardware configuration system ID (0xacd5cafe) 0x2001_0060 16 Button PIO Push Button 0x2001_0070 16 DIPSW PIO DIP Switch 0x2001_0080 16 LED PIO LED connections on board Application-specific address space 0x2300_1000 - 0x2300_1FFF 512 DDR4 TG DDR4 Memory TG Base offset 0x2300_9000 - 0x2300_9FFF 512 LPDDR4 TG LPDDR4 Memory TG Base offset 0x2400_0000 - 0x2401_FFFF 16384 HSSI HSSI Base offset"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#user-space-csr","title":"User Space CSR","text":"<p>The CSR register details are captured here.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on the use case. </p>  User Flow 1: Testing with Prebuild Binaries.  User Flow 2: Testing Complete Flow. User Flow Description Required for Userflow#1 Required for Userflow#2 Environment Setup Tools Download and Installation Yes Yes Install dependency packages for SW compilation No Yes Package Download No Yes Compilation Simulation No No HW compilation No Yes SW compilation No Yes Programming Programming Hardware binary Yes Yes Programming Software binary Yes Yes Linux boot Yes Yes Testing Run Mem TG Test Yes Yes Run Eth TG Test Yes Yes"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#tools-download-and-installation","title":"Tools Download and Installation","text":"<p>1. Quartus Prime Pro</p> <ul> <li>Download the Quartus\u00ae Prime Pro Edition software version 25.1 from the FPGA Software Download Center webpage of the Intel website. Follow the on-screen instructions to complete the installation process. Choose an installation directory that is relative to the Quartus\u00ae Prime Pro Edition software installation directory.</li> </ul> <ul> <li>Set up the Quartus tools in the PATH, so they are accessible without full path.</li> </ul> <pre><code>   export QUARTUS_ROOTDIR=~/altera_pro/25.1/quartus/\n   export PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Win32 Disk Imager</p> <ul> <li>Please download and install the latest Win32 Disk Imager. 3. Create the top folder to store all the build artifacts:</li> </ul> <pre><code>  # Create the top folder to store all the build artifacts\nsudo rm -rf artifacts.enablement\n    mkdir artifacts.enablement\n    cd artifacts.enablement\n    export TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL: <pre><code>  cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\n  tar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\n  rm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\n  export PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\n  export CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#installing-dependency-packages-for-sw-compilation","title":"Installing dependency packages for SW compilation","text":"<p>Please follow Base GSRD Yocto Build Prerequisites section to install the dependency packages.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#package-download","title":"Package Download","text":"<pre><code># Create the top folder to store all the build artifacts:\ncd $TOP_FOLDER\nrm -rf agilex5e-ed-hps-enhanced/\ngit clone https://github.com/altera-fpga/agilex5e-ed-hps-enhanced.git\ncd agilex5e-ed-hps-enhanced/src/sw\ngit submodule update --init -r\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#compilation-flow","title":"Compilation Flow","text":"<p>Note: If want to use Prebuild Binaries, please skip this compilation step and go to programming step directly as per HW/SW binary availability. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#hardware-compilation","title":"Hardware Compilation","text":"<p><pre><code>cd $TOP_FOLDER/agilex5e-ed-hps-enhanced/src/hw\n\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof output_files/legacy_baseline_hps_debug.sof -o hps_path=software/hps_debug/hps_wipe.ihex\n</code></pre> The following file will be generated:</p> <p><code>$TOP_FOLDER/agilex5e-ed-hps-enhanced/src/hw/output_files/legacy_baseline.sof</code></p> <p><code>$TOP_FOLDER/agilex5e-ed-hps-enhanced/src/hw/output_files/legacy_baseline_hps_debug.sof</code></p>  Build Core RBF  <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\n\nquartus_pfg -c agilex5e-ed-hps-enhanced/src/hw/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created: <code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#software-compilation","title":"Software Compilation","text":"<p>This section provides a comprehensive guide to bringing up the HPS (Hard Processor System) software for the Agilex\u2122 5E HPS Enhanced System Example Design. </p>  Setup Yocto  <pre><code>cd $TOP_FOLDER/agilex5e-ed-hps-enhanced/src/sw\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre>  Optional: Follow these steps, if you have a custom GHRD  <p>Follow the procedure below to add the generated ghrd_a5ed065bb32ae6sr0.core.rbf file.</p> <p>Update the recipe <code>$WORKSPACE/meta-sm-gsrd-enhanced/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows</p> <pre><code>cd $TOP_FOLDER CORE_RBF=$WORKSPACE/meta-sm-gsrd-enhanced/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf rm -rf $CORE_RBF ln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") FILE=\"$WORKSPACE/meta-sm-gsrd-enhanced/recipes-bsp/ghrd/hw-ref-design.bbappend\" OLD_URI='SRC_URI\\[agilex5_dk_a5e065bb32aes1_gsrd_core_enhanced.sha256sum\\] += \"[^\"]*\"' NEW_URI=\"SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core_enhanced.sha256sum] += \\\"$CORE_SHA\\\"\" sed -i \"s|$OLD_URI|$NEW_URI|\" \"$FILE\" </code></pre>  Build Yocto  <pre><code>bitbake_image\n</code></pre>  Gather files <pre><code>package\n</code></pre> <p>The following files will be created:</p> <p><code>$TOP_FOLDER/agilex5e-ed-hps-enhanced/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></p> <p><code>$TOP_FOLDER/agilex5e-ed-hps-enhanced/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></p> <p><code>$TOP_FOLDER/agilex5e-ed-hps-enhanced/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></p>  Build QSPI Image  <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5e-ed-hps-enhanced/src/hw/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=agilex5e-ed-hps-enhanced/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <p><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></p>  Build HPS RBF  <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI through the JIC file.</p> <p><pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5e-ed-hps-enhanced/src/hw/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=agilex5e-ed-hps-enhanced/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> The following file is created: <code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#programming-the-binaries","title":"Programming the Binaries","text":"<p>Note:</p> <ul> <li>Download the Prebuild Binaries into this path $TOP_FOLDER, if you are leveraging on User Flow 1.</li> </ul> <ul> <li>Leave all jumpers and switches in their default configuration.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#programming-software-binary","title":"Programming Software Binary","text":"Write SD Card  <ol> <li> <p>Extract the SD card image(sdimage.tar.gz) archive and obtain the file gsrd-console-image-agilex5.wic.</p> </li> <li> <p>Write the extracted SD card image (gsrd-console-image-agilex5_devkit.wic) to the micro-SD card using the included USB writer in the host computer:</p> </li> </ol> <p>On Linux, use the dd utility as shown next:</p> <pre><code># Determine the device associated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre> <p>On Windows, use the Win32DiskImager program, available at https://win32diskimager.org/. For this, first rename the gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#programming-hardware-binary","title":"Programming Hardware binary","text":"Write QSPI Flash  <ol> <li>Identify the FPGA device position in jtag chain.</li> </ol> <pre><code>$ jtagconfig\n\n1) Agilex 5E065B Premium DK [1-1.1.1]\n4BA06477   ARM_CORESIGHT_SOC_600\n  0364F0DD   A5E(C065BB32AR0|D065BB32AR0)\n020D10DD   VTAP10\n# Here, FPGA device in position #2\ncd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic@2\" #  If FPGA device in position #1 no need to mention the position number, by default it will take position #1.\"\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#linux-boot","title":"Linux Boot","text":"<ol> <li> <p>Open the serial port of Board by using serial communication utility.</p> <p>Note: Follow the instructions in the Base GSRD configure-serial-console section, to configure and setup serial connection.</p> </li> <li> <p>Power cycle the board.</p> </li> <li> <p>Monitor the serial communication windows and wait for Linux to boot, use root as user name, and no password is required.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#testing","title":"Testing","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#run-mem-tg-test","title":"Run Mem TG Test","text":"<p>Memory Traffic Generator is used to exercise the EMIF memory attached to the FPGA. <pre><code>python3 memtg.py [-h] [-I INTERFACE] -D DEVICE {tg_test} ...\n</code></pre></p> <pre><code>python3 memtg.py tg_test [-h] [-c {on,off}] [-m {0,1} [{0,1} ...]] [-l LOOPS [LOOPS ...]] [-w WRITES [WRITES ...]]\n[-r READS [READS ...]] [-b {1,2,4,8,16} [{1,2,4,8,16} ...]] [-s STRIDE [STRIDE ...]]\n[-p {fixed,prbs7,prbs15,prbs31,rot1} [{fixed,prbs7,prbs15,prbs31,rot1} ...]]\n[-f MEM_FREQUENCY [MEM_FREQUENCY ...]] [-a]\n</code></pre> Option Name Description Default -h --help Displays available options for the command - -I --interface Interface details - -D --device Device name or Device index for the interface - -m --mem_channel Multiple target memory banks for test to run on 1 -r --reads Number of unique read transactions per loop 1 -w --writes Number of unique write transactions per loop 1 -b --bls Burst length of each request 1 -s --stride Address stride for each sequential transaction 1 -p --data Memory traffic data pattern fixed -l --loops Number of read/write loops to be run 1 -f --mem_frequency Memory traffic clock frequency in MHz 0 -c --continuous Run TG test to run continuously. Press ctrl+c to exit off -a --check_id Display the TG ID - <p>Note : </p> <p>1. User can leaverage <code>-f</code> option to modify the Mem TG clock frequency and default frequency is 200Mhz.</p> <p>2. Use -I hps and -D uio0 options for running Mem TG test.</p> <p>3. Parameters for each channel's option need to be specified separately. For example, in the case of dual channel test where \"-m 0 1\" is used, then the parameters for -r, -w, -p, etc. must be specified in the following manner \"-r   -w   -p   ...\" <p>Example :-</p> <p>1. Single Channel Test Configuration:</p> <p>Sets up a memory test on channel <code>0</code> with <code>100,000</code> read and write transactions per loop, using a memory frequency of <code>200 MHz</code>, running for <code>10</code> loops, with an address stride of <code>4</code> and a burst length of <code>8</code>.</p> <pre><code>  python3 ffrd_exercisor_sw/memtg.py -I hps -D uio0 tg_test -m 0 -r 100000 -w 100000 -f 200 --loops 10 -s 4 -b 8 -f 200\n#output\n[02:52:25] Starting test run...!\n  Memory clock from command line: [200] MHz.\n  Press CTRL+C to exit.\n\n=================================\nMem Channel: 0\nMem Clock Cycles: 17651846\nWrite BW : 23.20 Gb/s\n  Read BW  : 23.20 Gb/s\n</code></pre> <p>2.  Dual Channel Test Configuration:</p> <p>When performing a dual-channel test with the <code>memtg.py</code> tool, need to specify parameters for each channel individually. This allows for precise control over the operations and configurations for each memory channel</p> <pre><code>    python3 ffrd_exercisor_sw/memtg.py -I hps -D uio0 tg_test -m 0 1 -r 100000 100000 -w 100000 100000 -f 200 200 --loops 10 10 -s 4 4 -b 8 8\n#output\n[02:47:26] Starting test run...!                                                                                                                                                          Memory clock from command line: [200, 200] MHz.                                                                                                    Press CTRL+C to exit.                                                                       =================================                                                            Mem Channel: 0                                                                           Mem Clock Cycles: 17651998                                                                                                                                                                                      Write BW : 23.20 Gb/s                                                                         Read BW  : 23.20 Gb/s                                                                              =================================                                                                                                                                                                               Mem Channel: 1                                                                                                                                                                                                  Mem Clock Cycles: 17025971                                                                                                                                                                                      Write BW : 24.08 Gb/s                                                                                                                                                                                           Read BW  : 24.08 Gb/s          </code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#run-eth-tg-test","title":"Run Eth TG Test","text":"<p>HSSI (High Speed Serial Interface) module is used to access Ethernet TG(Traffic Generator) which generates traffic on Ethernet MAC with different data patterns, programmable packet length and continuous or fixed traffic.</p> <pre><code>python3 hssi_10g.py [-h] [-I INTERFACE] -D DEVICE [--port [{0,1,2,3,4,5,6} ...]] [--num_packets NUM_PACKETS]\n[--random_length {random,fixed}] [--random_payload {random,incremental}] [--packet_length PACKET_LENGTH]\n[--continuous {on,off}] [--contmonitor CONTMONITOR] [-a]\n</code></pre> Option Name Description Default -h --help show this help message and exit - -I --interface INTERFACE find interfaces supported using --list or -l argument - -D --device DEVICE Device name or Device index for the interface. - --port [{0,1,2,3,4,5,6} ...] QSFP Tx/Rx ports 0 --num_packets NUM_PACKETS Number of packets 1 --random_length {random,fixed} packet length randomization fixed --random_payload {random,incremental} payload randomization random --packet_length PACKET_LENGTH packet length 64 --continuous {on,off} continuous mode off --contmonitor CONTMONITOR time period(in seconds) for performance monitor 0 -a --check_id Display the TG ID - <p><code>Note</code> : </p> <p>1. For this release QSFP port 0 is only enabled. </p> <p>2. Use -I hps and -D uio1 option for running Eth TG test.</p> <p>Example :- </p> <p>1. Verify Ethernet traffic self lookback with a random payload and random packet_length running for a long time</p> <p><pre><code>python3 ffrd_exercisor_sw/hssi_10g.py -I hps -D uio1 --port 0 --num_packets 10000 --random_payload random --random_length random --continuous on --contmonitor 600\n##output\ntesting HSSI 10G\nPress CTRL+C to exit...!\n\n10G loopback test\nport: 0\nnum_packets: 10000\nrandom_length: random\n  random_payload: random\n  packet_length: random\n  continuous mode: on\n  monitor duration: 600 sec\n\nHSSI performance:\n        Time Elapsed               : 600 s\n        Selected clock frequency   : 156.25 MHz\n        TX Packet Count            : 1134241360\nRX Good Packet             : 1134241360\nRX Bad Packet              : 0\nTx_end_tstamp              : 16819507448771\nTx_sta_tstamp              : 16722864165119\nRx_end_tstamp              : 16819507448841\nRx_sta_tstamp              : 16722864165189\n</code></pre> 2. Verify Ethernet traffic self-lookback with a certain lower packet number and packet_length <pre><code>python3 ffrd_exercisor_sw/hssi_10g.py -I hps -D uio1 --port 0 --packet_length 1504 --num_packets 1000\n##output\n10G loopback test\nport: 0\nnum_packets: 1000\nrandom_length: fixed\n  random_payload: random\n  packet_length: 1504\ncontinuous mode: off\n  monitor duration: 0 sec\n\nHSSI performance:\n        Selected clock frequency   : 156.25 MHz\n        TX Packet Count            : 1000\nRX Good Packet             : 1000\nRX Bad Packet              : 0\nTx_end_tstamp              : 38444895915567\nTx_sta_tstamp              : 38444895719631\nRx_end_tstamp              : 38444895915637\nRx_sta_tstamp              : 38444895719702\nAchieved Tx throughput     : 9.59 Gb/s\n        Achieved Rx throughput     : 9.6 Gb/s\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/egsrd/ug-ehps-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/","title":"HPS GSRD User Guide for the Agilex\u2122 5 E-Series Premium Dev Kit","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#gsrd-overview","title":"GSRD Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex\u2122 5 E-Series Premium  Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Premium Development Kit GSRD:</p> <ul> <li> <p>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.</p> <ul> <li>HPS Enablement Expansion Board. Included with the development kit.</li> <li>HPS NAND Board. Enables eMMC storage for HPS. Orderable separately.</li> <li>HPS Test Board. Supports SD card boot, and external Arm tracing. Orderable separately.</li> <li>Mini USB Cable. Included with the development kit.</li> <li>Micro USB Cable. Included with the development kit.</li> <li>Ethernet Cable. Included with the development kit.</li> <li>Micro SD card and USB card writer. Included with the development kit.</li> </ul> </li> </ul> <ul> <li> <p>Host PC with:</p> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> </ul> <ul> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex\u2122 5 Premium Development Kit GSRD binaries are located at https://releases.rocketboards.org/2025.08/:</p> HPS Daughter Card Boot Source Link Enablement Board SD Card https://releases.rocketboards.org/2025.08/gsrd/agilex5_dk_a5e065bb32aes1_gsrd Enablement Board QSPI https://releases.rocketboards.org/2025.08/qspi/agilex5_dk_a5e065bb32aes1_qspi NAND Board eMMC https://releases.rocketboards.org/2025.08/emmc/agilex5_dk_a5e065bb32aes1_emmc Test Board SD Card https://releases.rocketboards.org/2025.08/debug/agilex5_dk_a5e065bb32aes1_debug"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#development-kit","title":"Development Kit","text":"<p>This release targets the Agilex 5 FPGA E-Series 065B Premium Development Kit. Refer to board documentation for more information about the development kit.</p> <p></p> Installing HPS Daughtercard <p>This section shows how to install the included HPS Enablement Daughtercard.  The installation for the other optional HPS Boards is similar.</p> <p>1. Identify the correct thumb screws and washers needed, they are in a plastic bag: </p> <p>2. Locate the area on the development board where the HPS Daughtercard needs to be installed: </p> <p>3. Place the plastic washers on top of the three hex mounting posts: </p> <p>4. Place HPS Board on top of the posts and washers: </p> <p>5. Place the hex thumb screws on the two posts, as shown below. Note the 3rd one on the bottom is best unplaced as fully screwing that in may move the board. Also note the thumb screw close to the Ethernet connector is hard to screw, recommend to use small pliers and patience to make it secure. It is important that the HPS Board is secure, and does not move: </p> <p>Note: If you need to swap HPS Boards frequently,  it is recommended to remove the hex posts, and install the plastic washers between the PCB and the posts. This way you do not need to be careful for the washers not to move when you place the HPS Board on top of the posts. Note there are also plastic washers underneath the development board PCB, make sure to leave those in place when performing this operation</p> Changing MSEL <p>MSEL signals instruct the FPGA device on which configuration scheme to use. Configuration schemes used by the scenarios presented in this guide are JTAG and QSPI. MSEL is changed through dipswitch SW27. Only change the settings while the board is powered off.</p> <p>Configuration OFF-OFF-OFF-OFF corresponds to JTAG:</p> <p></p> <p>Configuration OFF-ON-ON-OFF corresponds to QSPI:</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Dual core Arm Cortex-A76 processor</li> <li>Dual core Arm Cortex-A55 processor</li> <li>HPS Peripherals connected to HPS Enablement Expansion Board:<ul> <li>Micro SD Card</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>I3C</li> <li>UART</li> <li>USB 3.1</li> </ul> </li> </ul> </li> <li>Multi-Ported Front End (MPFE) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>Three user LED outputs</li> <li>Four user DIP switch inputs</li> <li>Four user push-button inputs</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <p> </p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>  MPU Address Maps <p>This section presents the address maps as seen from the MPU side.  </p>  HPS-to-FPGA Address Map <p>The three FPGA windows in the MPU address map provide access to 256 GB of FPGA space. First window is 1 GB from 00_4000_0000, second window is 15 GB from 04_4000_0000, third window is 240 GB from 44_0000_0000. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU, which starts at the lightweight HPS-to-FPGA base address of 0x00_2000_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0001_0000 32 Unique system ID led_pio 0x0001_0080 16 LED outputs button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs JTAG Master Address Map <p>There are three JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface and another for FPGA fabric to SDRAM.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0001_0000 32 Unique system ID led_pio 0x0001_0080 16 LED outputs button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs  Interrupt Routing <p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[0] 4 DIP switch inputs button_pio f2h_irq0[1] 4 Push button inputs"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#exercising-prebuilt-binaries","title":"Exercising Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Install the appropriate HPS Daughtercard.</p> <p>3. Connect mini USB cable from vertical connector on HPS Daughtercard to host PC. This is used for the HPS serial console.</p> <p>4. Connect micro USB cable from development board to host PC. This is used by the tools for JTAG communication.</p> <p>5. Connect Ethernet cable from HPS Board to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>1. Install a serial terminal emulator application on your host PC:  </p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Power down your board if powered up. This is important, as once powered up, with the micro USB JTAG cable connected, a couple more USB serial ports will enumerate, and you may choose the wrong port.</p> <p>3. Connect mini-USB cable from the vertical mini-USB connector on the HPS Board to the host PC</p> <p>4. On the host PC, an USB serial port will enumerate. On Windows machines it will be something like <code>COM4</code>, while on Linux machines it will be something like <code>/dev/tty/USB0</code>.</p> <p>5. Configure your serial terminal emulator to use the following settings:  </p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>6. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-enablement-board","title":"HPS Enablement Board","text":"<p>This section presents how to use HPS Enablement Board to boot from SD card, and also from QSPI.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-sd-card","title":"Booting from SD Card","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#write-sd-card-image","title":"Write SD CardWrite QSPI FlashBoot LinuxRun Sample ApplicationsControl LEDsConnect to Board Using SSHVisit Board Web Page","text":"<p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2025.08/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the gsrd-console-image-agilex5_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. For this, first rename the gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p> </p> <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\ntar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>1. Boot to Linux</p> <p>2. Change current folder to <code>intelFPGA</code> folder <pre><code>cd intelFPGA\n</code></pre> 3. Run the hello world application <pre><code>./hello\n</code></pre> 4. Run the <code>syscheck</code> application <pre><code>./syscheck\n</code></pre> Press <code>q</code> to exit the <code>syscheck</code> application.</p> <p>1. Boot to Linux</p> <p>2. Control LEDs by using the following sysfs entries:</p> <ul> <li>/sys/class/leds/fpga_led0/brightness</li> <li>/sys/class/leds/fpga_led1/brightness</li> <li>/sys/class/leds/fpga_led2/brightness</li> <li>/sys/class/leds/hps_led1/brightness</li> </ul> <p>using commands such as: <pre><code>cat /sys/class/leds/fpga_led0/brightness\necho 0 &gt; /sys/class/leds/fpga_led0/brightness\necho 1 &gt; /sys/class/leds/fpga_led1/brightness\n</code></pre></p> <p>Because of how the LEDs are connected, for the above commands <code>0</code> means LED is turned on, <code>1</code> means LED is turned off.</p> <p>1. Boot to Linux  </p> <p>2. Determine the board IP address using the <code>ifconfig</code> command: <pre><code>root@agilex5devkit:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 192.168.1.153  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 fe80::f0eb:c8ff:fec4:eed7  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether f2:eb:c8:c4:ee:d7  txqueuelen 1000  (Ethernet)\nRX packets 649  bytes 45132 (44.0 KiB)\nRX errors 0  dropped 226  overruns 0  frame 0\nTX packets 56  bytes 8789 (8.5 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 23  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 100  bytes 8408 (8.2 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 100  bytes 8408 (8.2 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> 3. Connect to the board over SSH using <code>root</code> username, no password will be requested: <pre><code>ssh root@192.168.1.153\n</code></pre> Note: Make sure to replace the above IP address to the one matching the output of running <code>ifconfig</code> on youir board.</p> <p>1. Boot to Linux  </p> <p>2. Determine board IP address using <code>ifconfig</code> like in the previous scenario  </p> <p>3. Start a web browser and enter the IP address in the address bar  </p> <p>4. The web browser will display a page served by the web server running on the board.  </p> <p></p> <ul> <li>You will able to see which LED are ON and OFF in LED Status.</li> <li>You can Start and Stop the LED from scrolling. Set the delay(ms) in the LED Lightshow box. </li> <li>You can controll each LED with ON and OFF button.</li> <li>Blink each LED by entering the delay(ms) and click on the BLINK button.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-qspi","title":"Booting from QSPI","text":"<p>This section presents how to boot from QSPI. One notable aspect is that you need to wipe the SD card partitioning information, as otherwise U-Boot SPL could find a valid SD card image, and try to boot from that first.</p> Wipe SD Card <p>Either write 1MB of zeroes at the beginning of the SD card, or remove the SD card from the HPS Daughter Card. You can use <code>dd</code> on Linux, or <code>Win32DiskImager</code> on Windows to achieve this.</p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2025.08/qspi/agilex5_dk_a5e065bb32aes1_qspi/agilex_flash_image.hps.jic.tar.gz\ntar xf agilex_flash_image.hps.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;agilex_flash_image.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>Note: On first boot, the UBIFS rootfilesystem is initialized, and that takes a few minutes. This will not happen on next reboots. See a sample log below:</p> <pre><code>[   17.033558] UBIFS (ubi0:4): Mounting in unauthenticated mode\n[   17.039470] UBIFS (ubi0:4): background thread \"ubifs_bgt0_4\" started, PID 130\n[   17.061510] UBIFS (ubi0:4): start fixing up free space\n[   20.644496] random: crng init done\n[   27.120040] platform soc:leds: deferred probe pending\n[  243.190874] UBIFS (ubi0:4): free space fixup complete\n[  243.315909] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[  243.323290] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[  243.332653] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-nand-board","title":"HPS NAND Board","text":"<p>This section presents how to use HPS NAND Board to boot from eMMC.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-emmc","title":"Booting from eMMC","text":"Configure Board <p>For this scenario, we are using the HPS NAND Board, which can be configured through dipswitch SW3 to enable either eMMC or NAND. Set SW3 to ON to enable eMMC.</p> Write eMMC Flash <p>We are writing the eMMC Flash by using U-Boot commands. We are getting to U-Boot prompt by booting from QSPI using a JIC image which contains U-Boot, thereby not relying on what is already in eMMC.</p> <p>1. Download, and extract the eMMC image <pre><code>wget https://releases.rocketboards.org/2025.08/emmc/agilex5_dk_a5e065bb32aes1_emmc/sdimage.tar.gz\ntar xf sdimage.tar.gz\n</code></pre> 2. Split the eMMC image into 1GB chunks and copy them to your TFT folder: <pre><code>split --bytes=1G gsrd-console-image-agilex5_devkit.wic\nmv xa* &lt;your_tfp_folder&gt;\n</code></pre> This will put the two chunks called <code>xaa</code> and <code>xab</code> on your TFTP folder. 3. Power down the board. </p> <p>4. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>5. Power up the board</p> <p>6. Download the helper JIC used to write the eMMC image, extract it and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2025.08/emmc/agilex5_dk_a5e065bb32aes1_emmc/uboot.jic.tar.gz\ntar xf uboot.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;uboot.jic\"\n</code></pre> 7. Determine your host IP address using <code>ifconfig</code> to use it as the IP address of the TFTP server</p> <p>8. Power down the board</p> <p>9. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>10. Power up the board</p> <p>11. Stop U-Boot at the boot countdown, to drop to U-Boot console</p> <p>12. At the U-Boot console, run the following commands to write the SD card image: <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;tftp_server_ip_address&gt;\ntftp ${loadaddr} xaa\nsetexpr blkcnt1 ${filesize} / 0x200\nmmc write ${loadaddr} 0 ${blkcnt1}\ntftp ${loadaddr} xab\nsetexpr blkcnt2 ${filesize} / 0x200\nmmc write ${loadaddr} ${blkcnt1} ${blkcnt2}\n</code></pre> Note: If you already have a valid image in eMMC, the U-Boot SPL which runs from QSPI will be able to see that and load it instead of the U-Boot from QSPI. To prevent this from happening, you can wipe out the eMMC card partitioning, then issue a reset for U-Boot to reboot into the QSPI helper JIC:</p> <pre><code>mw.w ${loadaddr} 0x0 0x80000\nmmc rescan\nmmc write ${loadaddr} 0x0 0x400\nreset\n</code></pre> Write QSPI Flash <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download the JIC and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2025.08/emmc/agilex5_dk_a5e065bb32aes1_emmc/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz tar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Board will boot to Linux. Enter <code>root</code> as username, no password will be requested</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-test-board","title":"HPS Test Board","text":"<p>This section presents how to use HPS Test Board to boot from SD card.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-sd-card_1","title":"Booting from SD Card","text":"Configure Board <p>For this scenario we are using the HPS Test Board. There is single dipswitch on that board called SW1, which needs to be set to the ON position.</p> Write SD Card <p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2025.08/debug/agilex5_dk_a5e065bb32aes1_debug/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the SD card image to the micro SD card using the included USB writer in the host computer, and <code>dd</code> utility on Linux, or  Win32DiskImager on Windows, available at https://sourceforge.net/projects/win32diskimager. Please refer to the Booting from SD Card section for more details about this.</p> Write QSPI Flash <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download the JIC and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2025.08/debug/agilex5_dk_a5e065bb32aes1_debug/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz tar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\njtagconfig --setparam 1 JtagClock 16M\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFF-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Board will boot to Linux. Enter <code>root</code> as username, no password will be requested</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#rebuilding-the-gsrd","title":"Rebuilding the GSRD","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#yocto-build-prerequisites","title":"Yocto Build Prerequisites","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-enablement-board_1","title":"HPS Enablement Board","text":"<p>This section presents how to build the binaries for HPS Enablement Board.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-sd-card-boot-binaries","title":"Build SD Card Boot Binaries","text":"<p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.enablement\nmkdir agilex5_gsrd.enablement\ncd agilex5_gsrd.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-qspi-boot-binaries","title":"Build QSPI Boot Binaries","text":"<p>The diagram below shows how booting from QSPI JIC is built. The hardware project compilation and Yocto build remain the same, and the QSPI JIC is built based on the resulted files: </p> <p>1. Create the folder to contain all the files:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf qspi_boot\nmkdir qspi_boot\ncd qspi_boot\n</code></pre> <p>2. Get the <code>ubinize.cfg</code> file which contains the details on how to build the <code>root.ubi</code> volume, and <code>agilex5_devkit_flash_image_hps.pfg</code> which contains the instructions for Programming File Generator on how to create the .jic file:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/qspi/agilex5_dk_a5e065bb32aes1_qspi/ubinize.cfg\nwget https://releases.rocketboards.org/2025.08/qspi/agilex5_dk_a5e065bb32aes1_qspi/agilex5_devkit_flash_image_hps.pfg\nsed -i 's/ghrd_a5ed065bb32ae6sr0\\.sof/legacy_baseline.sof/g' agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>3. Link to the files that are needed from building the hardware design, and yocto:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nor.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof .\n</code></pre> <p>4. Process the u-boot.itb file to be exactly 2MB in size:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the <code>root.ubi</code> file and rename it to <code>hps.bin</code> as Programming File Generator needs the <code>.bin</code> extension:</p> <pre><code>ubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>6. Create the JIC file:</p> <pre><code>quartus_pfg -c agilex5_devkit_flash_image_hps.pfg\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-nand-board_1","title":"HPS NAND Board","text":"<p>This section presents how to build the binaries for HPS NAND Board, for booting from eMMC.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-emmc-binaries","title":"Build eMMC binaries","text":"<p>The following diagram shows how to build the eMMC binaries that target the HPS NAND Daughtercard: </p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.emmc\nmkdir agilex5_gsrd.emmc\ncd agilex5_gsrd.emmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-emmc-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf</code> </p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_emmc_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_emmc_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_emmc_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_emmc_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_emmc_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_emmc_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul> Building QSPI Helper JIC <p>We are writing the eMMC Flash by using U-Boot commands. We are getting to U-Boot prompt by booting from QSPI using a helper JIC image which contains U-Boot, thereby not relying on what is already in eMMC. The following diagram illustrates how the helper JIC is built, base on the GHRD and Yocto compilation results: </p> <p>1. Create folder to contain the helper JIC artifacts</p> <pre><code>cd $TOP_FOLDER\nrm -rf jic-helper\nmkdir jic-helper\n</code></pre> <p>2. Retrieve the .pfg file instructing the Quartus Programming File Generator on how to create the JIC file, and tweak it a little bit to make it smaller:</p> <pre><code>cd jic-helper\nwget https://releases.rocketboards.org/2025.08/emmc/agilex5_dk_a5e065bb32aes1_emmc/uboot-only.pfg\nsed -i 's/directory=/hps=\"1\" directory=/g' uboot-only.pfg\nsed -i 's/type=\"JIC\"/type=\"PERIPH_JIC\"/g' uboot-only.pfg\nsed -i 's/MT25QU02G/MT25QU01G/g' uboot-only.pfg\nsed -i 's/ghrd_a5ed065bb32ae6sr0\\.sof/legacy_baseline.sof/g' uboot-only.pfg\n</code></pre> <p>3. Bring in the files that are needed:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof .\n</code></pre> <p>4. Process <code>u-boot.itb</code> file to be exactly 2MB in size, and have a <code>.bin</code> extension as needed by Quartus Programming File Generator:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the JIC file:</p> <pre><code>quartus_pfg -c uboot-only.pfg\n</code></pre> <p>The following file will be created:</p> <ul> <li><code>$TOP_FOLDER/jic-helper/agilex_flash_image.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-test-board_1","title":"HPS Test Board","text":"<p>This section presents how to build the binaries for HPS Test Board.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-sd-card-binaries","title":"Build SD Card Binaries","text":"<p>The following diagram shows how the binaries are built for the HPS Test Daughtercard:  </p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.test\nmkdir agilex5_gsrd.test\ncd agilex5_gsrd.test\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-debug2-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-debug2-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-debug2-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>Replace the file <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_debug2_ghrd.core.rbf</code> with the rebuilt core.rbf file:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_debug2_ghrd.core.rbf\nrm -f $CORE_RBF\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd_zephyr/ug-zgsrd-agx5e-premium/","title":"HPS Zephyr GSRD User Guide for the Agilex\u2122 5 E-Series Premium Dev Kit","text":"<p> NOTE: This page is not available in this release. The latest release in which Zephyr is supported corresponds to 24.3. Please refer to the following page to access the latest documentation: Zephyr GSRD User Guide. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/","title":"Helloworld and OCM memory test design on Nios\u00ae V/c Processor","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#nios-vc-helloworld-ocm-memory-test-design-overview","title":"Nios V/c Helloworld OCM Memory test Design Overview","text":"<p>This design prints a simple Hello World message and performs a simple OCM memory test for the Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK- A5E065BB32AES1. Refer to the board documentation for more information about the development kit.</li> <li>Mini and Micro USB Cable. Included with the development kit.</li> <li>Host PC with 64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the design.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#binaries","title":"Binaries","text":"<ul> <li>Prebuilt binaries are located here.</li> <li>The sof and elf files required to run the design can be found in \"ready_to_test\" folder </li> <li>Program the sof and download the elf file on board</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#nios-vc-helloworld-ocm-memory-test-design-archiecture","title":"Nios\u00ae V/c Helloworld OCM Memory test Design Archiecture","text":"<p>This example design includes a Nios\u00ae V/c processor connected to the On Chip RAM-II, JTAG UART IP, Parallel-IO and System ID peripheral core. The objective of the design is to accomplish data transfer between the processor and soft IP peripherals.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#nios-vc-processor","title":"Nios\u00ae V/c Processor","text":"<ul> <li>Microcontroller- Balanced (For interrupt driven baremetal and RTOS code)</li> <li>Nios\u00ae V/c processor is highly customizable and can be tailored to meet specific application requirements, providing flexibility and scalability in embedded system designs.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#ip-cores","title":"IP Cores","text":"<p>The following IPs are used in this Platform Designer component of the design: - Nios\u00ae V/c soft processor core</p> <ul> <li>On Chip RAM-II</li> </ul> <ul> <li>JTAG UART</li> </ul> <ul> <li>Parallel-IO</li> </ul> <ul> <li>System ID</li> </ul> <ul> <li>Clock Bridge, Reset Controller</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#hardware-setup","title":"Hardware Setup","text":"<p>Refer to Agilex\u2122 5 FPGA Premium Development Kit User Guide to setup the hardware connection.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#nios-v-address-map","title":"Nios V Address Map","text":"Address Offset Size (Bytes) Peripheral Description 0x0000_0000 1MB On-Chip RAM To store application 0x0010_0008 8 JTAG UART Communication between a host PC and the Nios V processor system 0x0010_0000 8 System ID Hardware configuration system ID (0x000000a5)"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on use case. </p>  User Flow 1: Testing with Prebuild Binaries.  User Flow 2: Testing Complete Flow. User Flow Description Required for User flow 1 Required for User flow 2 Environment Setup Tools Download and Installation Yes Yes Compilation Hardware compilation No Yes Software compilation No Yes Programing Program Hardware Binary SOF Yes Yes Program Software Image ELF Yes Yes Testing Open JTAG UART Terminal Yes Yes Run simulation Yes Yes"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#tools-download-and-installation","title":"Tools Download and Installation","text":"<ol> <li>Quartus Prime Pro</li> </ol> <ul> <li>Download the Quartus\u00ae Prime Pro Edition software version 25.1 from the FPGA Software Download Center webpage of the Intel website. Follow the on-screen instructions to complete the installation process. Choose an installation directory that is relative to the Quartus\u00ae Prime Pro Edition software installation directory.</li> <li>Set up the Quartus tools in the PATH, so they are accessible without full path. <pre><code>    export QUARTUS_ROOTDIR=~/intelFPGA_pro/25.1/quartus/\n    export PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#compilation","title":"Compilation","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#hardware-compilation","title":"Hardware Compilation","text":"<ul> <li>Invoke the <code>quartus_py</code> shell in the terminal</li> <li>Run the following command in the terminal from top level project directory:</li> </ul> <pre><code>quartus_py ./scripts/build_sof.py\n</code></pre> <ul> <li>The quartus tool will compile the design and generate the output files</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#software-compilation","title":"Software Compilation","text":"<p>Note: Clean the app build project before regenerating elf - To create software app, run the following commands in the terminal: <pre><code>niosv-bsp -c --quartus-project=hw/top.qpf --qsys=hw/qsys_top.qsys --type=hal --script=sw/bsp-update-small-driver.tcl sw/bsp/settings.bsp\nniosv-app --bsp-dir=sw/bsp --app-dir=sw/app --srcs=sw/app/main.c\nniosv-shell\ncmake -S ./sw/app -B sw/app/build -G \"Unix Makefiles\"\nmake -C sw/app/build\nelf2hex sw/app/build/app.elf -b 0x0 -w 32 -e 0xfffff sw/app/build/onchip_mem.hex -r4\n</code></pre> Note:The software can be compiled using the Ashling Visual Studio Code Extension for Altera FPGAs</p> <p>For information on the build process, please refer to the following document- Ashling VSCode Extension</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#programing","title":"Programing","text":"<p>Note: Reduce the JTAG clock frequency to 6MHz using the following command, before programming the sof file <pre><code>jtagconfig --setparam 1 JtagClock 6M\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#program-hardware-binary-sof","title":"Program Hardware Binary SOF","text":"<ul> <li>Program the generated sof and then download the elf file on the board</li> </ul> <pre><code>quartus_pgm --cable=1 -m jtag -o 'p;ready_to_test/top.sof'\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#testing","title":"Testing","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#open-jtag-uart-terminal","title":"Open JTAG UART Terminal","text":"<ul> <li>Verify the output on the terminal by using the following command in the terminal:</li> </ul> <pre><code>juart-terminal -d 1 -c 1 -i 0 \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_c/niosv_c_helloworld_ocm_mem_test/ug-helloworld-ocm-mem-test-agx5e-premium/#running-simulation","title":"Running simulation","text":"<p>Simulation is enabled for this design where the memory is initialized with the application hex. Use the following commands to run the simulation: <pre><code>cp ./sw/app/build/onchip_mem.hex ./qsys_top_tb/qsys_top_tb/sim/mentor \ncd hw/qsys_top_tb/qsys_top_tb/sim/mentor/\nvsim &amp;\nsource msim_setup.tcl\nld_debug\nrun -all\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/","title":"Nios\u00ae V/g TinyML LiteRT for Microcontroller Design","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#nios-vg-tinyml-litert-example-design-overview","title":"Nios\u00ae V/g TinyML LiteRT Example Design Overview","text":"<p>This design demonstrates the TinyML application using LiteRT for microcontrollers software with Nios\u00ae V/g processor in the Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit (ES1) DK-A5E065BB32AES1.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1. Refer to the board documentation for more information about the development kit.</li> <li>Mini and Micro USB Cable. Included with the development kit.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#binaries","title":"Binaries","text":"<ul> <li>Prebuilt binaries are located here.</li> <li>The sof and elf files required to run the design can be found in \"ready_to_test\" folder </li> <li>Program the sof and download the elf file on board</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#nios-vg-tinyml-litert-design-archiecture","title":"Nios\u00ae V/g TinyML LiteRT Design Archiecture","text":"<p>This example design includes a Nios\u00ae V processor connected to the On Chip RAM-II, JTAG UART IP and System ID peripheral core. The objective of the design is to accomplish data transfer between the processor and soft IP peripherals.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#nios-vg-processor","title":"Nios\u00ae V/g Processor","text":"<ul> <li>Balanced (For interrupt driven baremetal and RTOS code)</li> <li>Nios\u00ae V/g processor is highly customizable and can be tailored to meet specific application requirements, providing flexibility and scalability in embedded system designs.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#ip-cores","title":"IP Cores","text":"<p>The following IPs are used in this Platform Designer component of the design: - Nios\u00ae V/g soft processor core</p> <ul> <li>On Chip RAM-II</li> </ul> <ul> <li>JTAG UART</li> </ul> <ul> <li>System ID</li> </ul> <ul> <li>Clock Bridge, Reset Controller</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#hardware-setup","title":"Hardware Setup","text":"<p>Refer to Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit User Guide to setup the hardware connection.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#nios-v-address-map","title":"Nios V Address Map","text":"Address Offset Size (Bytes) Peripheral Description 0x0 3M On-Chip RAM To store application 0x0041_0040 8 JTAG UART Communication between a host PC and the Nios V processor system 0x0041_0048 8 System ID Hardware configuration system ID (0x00000009)"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on use case. </p>  User Flow 1: Testing with Prebuild Binaries.  User Flow 2: Testing Complete Flow. User Flow Description Required for User flow 1 Required for User flow 2 Environment Setup Tools Download and Installation Yes Yes Compilation Hardware compilation No Yes Software compilation No Yes Programing Program Hardware Binary SOF Yes Yes Program Software Image ELF Yes Yes Testing Open JTAG UART Terminal Yes Yes"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#tools-download-and-installation","title":"Tools Download and Installation","text":"<ol> <li>Quartus Prime Pro</li> </ol> <ul> <li>Download the Quartus\u00ae Prime Pro Edition software version 25.1 from the FPGA Software Download Center webpage of the Intel website. Follow the on-screen instructions to complete the installation process. Choose an installation directory that is relative to the Quartus\u00ae Prime Pro Edition software installation directory.</li> <li>Set up the Quartus tools in the PATH, so they are accessible without full path. <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/25.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#compilation","title":"Compilation","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#hardware-compilation","title":"Hardware Compilation","text":"<ul> <li>Invoke the <code>quartus_py</code> shell in the terminal</li> <li>Run the following command in the terminal from top level project directory:</li> </ul> <pre><code>quartus_py ./scripts/build_sof.py\n</code></pre> <ul> <li>The quartus tool will compile the design and generate the output files</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#software-compilation","title":"Software Compilation","text":"<ul> <li>To create software app, run the following commands in the terminal: <pre><code>niosv-bsp -c --quartus-project=hw/top.qpf --qsys=hw/qsys_top.qsys --type=hal --bsp-dir=sw/tflite_bsp --script=sw/bsp_script.tcl sw/tflite_bsp/settings.bsp\nniosv-app -b=sw/tflite_bsp -a=sw/tflite_app -S=sw/tflite_app/image_classification/,sw/tflite_app/image_classification/model/,sw/tflite_app/signal,sw/tflite_app/tensorflow,sw/tflite_app/tensorflow/lite/,sw/tflite_app/tensorflow/lite/c/,sw/tflite_app/tensorflow/lite/core/api/,sw/tflite_app/tensorflow/lite/kernels/,sw/tflite_app/tensorflow/lite/kernels/internal,sw/tflite_app/tensorflow/lite/kernels/internal/reference/,sw/tflite_app/tensorflow/lite/kernels/internal/reference/integer_ops,sw/tflite_app/tensorflow/lite/micro,sw/tflite_app/tensorflow/lite/micro/kernels/,sw/tflite_app/tensorflow/lite/micro/memory_planner,sw/tflite_app/tensorflow/lite/schema --incs=sw/tflite_app,sw/tflite_app/image_classification,sw/tflite_app/image_classification/model/,sw/tflite_app/tensorflow,sw/tflite_app/tensorflow/lite,sw/tflite_app/third_party/flatbuffers/include,sw/tflite_app/third_party/gemmlowp,sw/tflite_app/third_party/kissfft,sw/tflite_app/third_party/ruy\ncmake -S sw/tflite_app -B sw/tflite_app/build/Release -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release\nmake -C sw/tflite_app/build/Release\n</code></pre> Note:The software can be compiled using the Ashling Visual Studio Code Extension for Altera FPGAs</li> </ul> <p>For information on the build process, please refer to the following document- Ashling VSCode Extension</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#programing","title":"Programing","text":"<p>Note: Reduce the JTAG clock frequency to 6MHz using the following command, before programming the sof file <pre><code>jtagconfig --setparam 1 JtagClock 6M\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#program-hardware-binary-sof","title":"Program Hardware Binary SOF","text":"<ul> <li>Program the generated sof and then download the elf file on the board</li> </ul> <pre><code>quartus_pgm --cable=1 -m jtag -o 'p;ready_to_test/top.sof'\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#program-software-image-elf","title":"Program Software Image ELF","text":"<ul> <li>Download the elf file on the board <pre><code>niosv-download -g ready_to_test/tflite_app.elf -c 1\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#testing","title":"Testing","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_g/tinyml_liteRT/ug-tinyml-liteRT-agx5e-premium/#open-jtag-uart-terminal","title":"Open JTAG UART Terminal","text":"<ul> <li>Verify the output on the terminal by using the following command in the terminal:</li> </ul> <pre><code>juart-terminal -c 1 -i 0 \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/","title":"Nios\u00ae V/m Processor Baseline GHRD Design","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#nios-vm-baseline-golden-hardware-reference-design-ghrd-overview","title":"Nios\u00ae V/m Baseline Golden Hardware Reference Design (GHRD) Overview","text":"<p>This design demonstrates the baseline Golden Hardware Reference Design (GHRD) for a Nios\u00ae V/m processor with basic bare minimum peripherals required for any application execution for the Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK- A5E065BB32AES1. Refer to the board documentation for more information about the development kit.</li> <li>Mini and Micro USB Cable. Included with the development kit.</li> <li>Host PC with 64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GHRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#binaries","title":"Binaries","text":"<ul> <li>Prebuilt binaries are located here.</li> <li>The sof and elf files required to run the design can be found in \"ready_to_test\" folder </li> <li>Program the sof and download the elf file on board</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#nios-vm-baseline-golden-hardware-reference-design-ghrd-archiecture","title":"Nios\u00ae V/m Baseline Golden Hardware Reference Design (GHRD) Archiecture","text":"<p>This example design includes a Nios\u00ae V/m processor connected to the On Chip RAM-II, JTAG UART IP, Parallel-IO and System ID peripheral core. The objective of the design is to accomplish data transfer between the processor and soft IP peripherals.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#nios-vm-processor","title":"Nios\u00ae V/m Processor","text":"<ul> <li>Microcontroller- Balanced (For interrupt driven baremetal and RTOS code)</li> <li>Nios\u00ae V/m processor is highly customizable and can be tailored to meet specific application requirements, providing flexibility and scalability in embedded system designs.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#ip-cores","title":"IP Cores","text":"<p>The following IPs are used in this Platform Designer component of the design: - Nios\u00ae V/m soft processor core</p> <ul> <li>On Chip RAM-II</li> </ul> <ul> <li>JTAG UART</li> </ul> <ul> <li>Parallel-IO</li> </ul> <ul> <li>System ID</li> </ul> <ul> <li>Clock Bridge, Reset Controller</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#hardware-setup","title":"Hardware Setup","text":"<p>Refer to Agilex\u2122 5 FPGA Premium Development Kit User Guide to setup the hardware connection.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#nios-v-address-map","title":"Nios V Address Map","text":"Address Offset Size (Bytes) Peripheral Description 0x0000_0000 1MB On-Chip RAM To store application 0x0011_0068 8 JTAG UART Communication between a host PC and the Nios V processor system 0x0011_0050 16 PIO 0 LED connections on board 0x0011_0040 16 PIO 1 LED connections on board 0x0011_0060 8 System ID Hardware configuration system ID (0x000000a5)"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on use case. </p>  User Flow 1: Testing with Prebuild Binaries.  User Flow 2: Testing Complete Flow. User Flow Description Required for User flow 1 Required for User flow 2 Environment Setup Tools Download and Installation Yes Yes Compilation Hardware compilation No Yes Software compilation No Yes Programing Program Hardware Binary SOF Yes Yes Program Software Image ELF Yes Yes Testing Open JTAG UART Terminal Yes Yes Run simulation Yes Yes"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#tools-download-and-installation","title":"Tools Download and Installation","text":"<ol> <li>Quartus Prime Pro</li> </ol> <ul> <li>Download the Quartus\u00ae Prime Pro Edition software version 25.1 from the FPGA Software Download Center webpage of the Intel website. Follow the on-screen instructions to complete the installation process. Choose an installation directory that is relative to the Quartus\u00ae Prime Pro Edition software installation directory.</li> <li>Set up the Quartus tools in the PATH, so they are accessible without full path. <pre><code>    export QUARTUS_ROOTDIR=~/intelFPGA_pro/25.1/quartus/\n    export PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#compilation","title":"Compilation","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#hardware-compilation","title":"Hardware Compilation","text":"<ul> <li>Invoke the <code>quartus_py</code> shell in the terminal</li> <li>Run the following command in the terminal from top level project directory:</li> </ul> <pre><code>quartus_py ./scripts/build_sof.py\n</code></pre> <ul> <li>The quartus tool will compile the design and generate the output files</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#software-compilation","title":"Software Compilation","text":"<p>Note: Clean the app build project before regenerating elf - To create software app, run the following commands in the terminal: <pre><code>niosv-bsp -c --quartus-project=hw/top.qpf --qsys=hw/qsys_top.qsys --type=hal sw/bsp/settings.bsp\nniosv-app --bsp-dir=sw/bsp --app-dir=sw/app --srcs=sw/app/main.c\nniosv-shell\ncmake -S ./sw/app -B sw/app/build\nmake -C sw/app/build\nelf2hex sw/app/build/app.elf -b 0x0 -w 32 -e 0xfffff sw/app/build/onchip_mem.hex -r4\n</code></pre> Note:The software can be compiled using the Ashling Visual Studio Code Extension for Altera FPGAs</p> <p>For information on the build process, please refer to the following document- Ashling VSCode Extension</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#programing","title":"Programing","text":"<p>Note: Reduce the JTAG clock frequency to 6MHz using the following command, before programming the sof file <pre><code>jtagconfig --setparam 1 JtagClock 6M\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#program-hardware-binary-sof","title":"Program Hardware Binary SOF","text":"<ul> <li>Program the generated sof and then download the elf file on the board</li> </ul> <pre><code>quartus_pgm --cable=1 -m jtag -o 'p;ready_to_test/top.sof'\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#program-software-image-elf","title":"Program Software Image ELF","text":"<ul> <li>Download the elf file on the board</li> </ul> <pre><code>niosv-download -g ready_to_test/app.elf -c 1\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#testing","title":"Testing","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#open-jtag-uart-terminal","title":"Open JTAG UART Terminal","text":"<ul> <li>Verify the output on the terminal by using the following command in the terminal:</li> </ul> <pre><code>juart-terminal -d 1 -c 1 -i 0 \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/niosv/niosv_m/niosv_m_baseline_ghrd/ug-baseline-ghrd-agx5e-premium/#running-simulation","title":"Running simulation","text":"<p>Simulation is enabled for this design where the memory is initialized with the application hex. Use the following commands to run the simulation: <pre><code>cp ./sw/app/build/onchip_mem.hex ./qsys_top_tb/qsys_top_tb/sim/mentor \ncd hw/qsys_top_tb/qsys_top_tb/sim/mentor/\nvsim &amp;\nsource msim_setup.tcl\nld_debug\nrun -all\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/pcie_rp/ug-pcie_rp-agx5e-premium/","title":"HPS PCIe Root Port System Example Design for the Agilex 7 I-Series Premium  Development Kit","text":"<p> NOTE: This page is not available in this release. The latest release in which HPS PCIe Root Port System Example Design is supported corresponds to 25.1. Please refer to the following page to access the latest documentation: HPS PCIe Root Port System Example Design. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/","title":"SoC FPGA Remote Debug Tutorial Example Design: Agilex\u2122 5 E-Series Premium Dev Kit","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#introduction","title":"Introduction","text":"<p>Intel offers an integrated set of System Level Debug (SLD) tools, including:</p> <ul> <li>SignalTap II Logic Analyzer</li> <li>In-System Sources and Probes (ISSP),</li> <li>In-System Memory Content Editor)</li> </ul> <p>Typically, the System-Level Debugging (SLD) communication solution was interfacing with the outside world through the JTAG. Then either an USB or Ethernet Blaster could be used to interface JTAG to the host PC.</p> <p></p> <p></p> <p>Another alternative approach is also available, to interface the SLD to the outside world directly through Ethernet, without requiring either an USB or Ethernet Blaster.</p> <p></p> <p>This page presents an example on how enable this remote debug feature on top of the GSRD.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#architecture","title":"Architecture","text":"<p>In the traditional approach the SLD communication solution was based on the Altera JTAG Interface (AJI) which interfaced with the JTAG TAP controller (hard atom in Altera devices which implements the JTAG protocol). The SLD tools used the JTAG channel for communication between software and hardware.</p> <p></p> <p>The remote FPGA debugging solution consists of the following:</p> <ul> <li>JTAG-Over Protocol (JOP) Component: Platform Designer component which enables access to debug information through an Avalon\u00ae-MM slave bus</li> <li>Etherlink: HPS application exporting debug information over Ethernet, available on github: https://github.com/altera-fpga/remote-debug-for-intel-fpga</li> </ul> <p></p> <p>The JOP component requires reset and clocking and also provides an Avalon\u00ae-MM slave bus through which is configured and debug information is accessed.</p> <p>Th Etherlink application runs on HPS, accesses the JOP component slave bus to access the debug information, and provides a TCP/IP link from the host PC running the Quartus Pro debug tools to the board.</p> <p>The etherlink works with the standard UIO Linux kernel driver.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#example","title":"Example","text":"<p>This section shows an example of how to use the Remote Debug feature. Communication is established from the board to the host PC through Ethernet, so that the board appears as another JTAG device, listed by jtagconfig utility.</p> <p>The example is based on the GSRD, with the following changes:</p> <ul> <li>Adding JOP component to the GHRD</li> <li>Adding JOP to the Linux device tree</li> </ul> <p>Notes:</p> <ul> <li>UIO driver is enabled as module in the default kernel configuration file</li> <li>etherlink is already part of the rootfs, built by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Altera Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1.<ul> <li>HPS Enablement Expansion Board. Included with the development kit.</li> <li>SD/MMC HPS Daughtercard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intell\u00ae FPGA Download Cable II</li> </ul> </li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for more information about the development kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex5.remote_debug\nmkdir agilex5.remote_debug\ncd agilex5.remote_debug\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#build-hardware-design","title":"Build Hardware Design","text":"<p>1. Generate the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-oobe-legacy-baseline.zip\n</code></pre> <p>2. Open the project in Quartus, open the <code>qsys_top.qsys</code> file in Platform Designer.</p> <p>3. In the IP Catalog search for jop and double-click the component to add it to the system:</p> <p></p> <p>4. Configure the JOP component as follows:</p> <p></p> <p>5. Connect the reset and clock to JOP component, also connect it's slave bus to the HPS LW bridge, and map it at offset 0x0002_0000:</p> <p></p> <p>6. Alternatively, steps 2-6 can be peformed from command line, using the provided tcl script:</p> <pre><code>cd $TOP_FOLDER\nrm -f agilex5-ghrd-add-jop.tcl\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-5/e-series/premium/remote-debug/collateral/agilex5-ghrd-add-jop.tcl\ncd agilex5_soc_devkit_ghrd\nqsys-script --qpf=top.qpf --script=../agilex5-ghrd-add-jop.tcl --system-file=qsys_top.qsys\ncd agilex5_soc_devkit_ghrd\n</code></pre> <p>7. Finish compilation of the GHRD from command line:</p> <pre><code>cd $TOP_FOLDER/agilex5_soc_devkit_ghrd\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#build-corerbf-file","title":"Build Core.RBF File","text":"<p>This section shows how to create the core RBF file, which is needed by the Yocto recipes:</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#build-yocto","title":"Build Yocto","text":"<p>Perform the following steps to build Yocto:</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> <p>3. Enable the JOP UIO driver in the Linux device tree, by editing the file <code>meta-intel-fpga-refdes</code> to inlcude the changes shown below:</p> <pre><code>diff --git a/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi b/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi\nindex 9e043ef..ceac3aa 100644\n--- a/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi\n+++ b/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi\n@@ -49,6 +49,11 @@\n                                resetvalue = &lt;0&gt;;\n                };\n */\n+               jop@20020000 {\n+                       compatible = \"generic-uio\";\n+                       reg = &lt;0x20020000 0x4000&gt;;\n+                       reg-names = \"jop\";\n+               };\n                soc_leds: leds {\n                        compatible = \"gpio-leds\";\n</code></pre> <p>Note that the range of memory where the JOP is located is <code>0x20020000</code> .. <code>0x20023fff</code>.</p> <p>This can be done with the provided patch file:</p> <pre><code>rm -f agilex5-dts-add-jop.patch\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-5/e-series/premium/remote-debug/collateral/agilex5-dts-add-jop.patch\npushd meta-intel-fpga-refdes\npatch -p1 &lt; ../agilex5-dts-add-jop.patch\npopd\n</code></pre> <p>4. Update the recipe to not use a broken version of =etherlink=:</p> <pre><code>sed -i 's/3a3eb126321429c0845276ef9c200df7786dbf74/b6a13b03fe7e9566063eae65d99bd8bc1190ce62/g' meta-intel-fpga-refdes/recipes-tools/remote-debug-app/remote-debug-app_1.0.bb\n</code></pre> <p>5. Update your Yocto recipes to use the core RBF file you have built, similar to how the GSRD does it:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>6. Build the Yocto recipes:</p> <pre><code>bitbake_image\n</code></pre> <p>7. Gather the Yocto binaries:</p> <pre><code>package\n</code></pre> <p>The following relevant files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#build-qspi-image","title":"Build QSPI Image","text":"<p>Run the following commands to build the QSPI image:</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#run-example","title":"Run Example","text":"<p>The instructions from this section present how to run the remote debug example. Refer to the GSRD for more detailed instructions on how to set up the board, serial port, and write the binaries.</p> <p>1. Write the QSPI image <code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code> to flash.</p> <p>2. Extract and write the SD card image <code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code> to the SD card</p> <p>3. Boot board and log into Linux.</p> <p>4. Determine board IP address by running the <code>ifconfig</code> command:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 10.122.105.175  netmask 255.255.255.0  broadcast 10.122.105.255\n        inet6 fe80::7097:4bff:fe41:b7c2  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 72:97:4b:41:b7:c2  txqueuelen 1000  (Ethernet)\nRX packets 218  bytes 23619 (23.0 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 78  bytes 11072 (10.8 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 22  </code></pre> <p>5. Remove pre-existing instances of the driver, and load it again:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# rmmod uio_pdrv_genirq\nroot@agilex5dka5e065bb32aes1:~# modprobe uio_pdrv_genirq of_id=\"generic-uio\"\n</code></pre> <p>6. Start the etherlink application, specifying which port to accept connections on as shown below:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# etherlink --port=33301\nINFO: Etherlink Server Configuration:\nINFO:    H2T/T2H Memory Size  : 4096\nINFO:    Listening Port       : 33301\nINFO:    IP Address           : 0.0.0.0\nINFO: UIO Platform Configuration:\nINFO:    Driver Path: /dev/uio0\nINFO:    Address Span: 16384\nINFO:    Start Address: 0x0\nINFO: Server socket is listening on port: 33301\n</code></pre> <p>7. On the host, establish the JTAG communication to the board through Ethernet, using the board IP and the selected port number:</p> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0\n</code></pre> <p>8. Also on the host, run the 'jtagconfig' command to show the newly added connection:</p> <pre><code>$ jtagconfig\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0]\n020D10DD   VTAP10\n</code></pre> <p>At this point, the connection can be used by the tools which need a JTAG connection, like SignalTap.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/","title":"HPS Remote System Update Example for the Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on the Agilex\u2122 5 E-Series Premium Development Kit (DK-A5E065BB32AES1), including the following.</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>Refer to the  Hard Processor System Remote System Update User Guide: Agilex\u2122 5 SoCs document for details about the Remote System Update.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p> <p>Note: librsu uses main branch.</p> <p>Note: RSU functionality is first fully enabled in U-Boot in 24.3 release, while Linux functionality is enabled starting on 24.2 release.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus\u00ae Prime Pro Edition Version 25.1.1  for compiling the hardware projects, generating the flash images and writing to flash </li> <li>cmake/3.24.0  (build configuration tool) or or above to build LibRSU library.</li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li>Agilex\u2122 5 E-Series Premium Development Kit (DK-A5E065BB32AES1)  for running the example. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are these.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul> <p>Note: To build binaries for a different development kit than the one used in this page, please refer to the Building the Hardware Projects section in the corresponding  GSRD page for that development kit, which is the section that may differ from the instructions presented here.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#installing-cmake","title":"Installing cmake","text":"<p>In case that you have installed a cmake version earlier than 3.24.0, you need to unistall this and install a new version. Here are the steps to achieve that. Note that this only need to performed once in your PC:</p> <pre><code>sudo apt remove cmake\nDownload cmake-x.y.z-linux-x86_64.sh from https://cmake.org/download\nsudo cp ~/Downloads/cmake-x.y.z-linux-x86_64.sh /opt/\nsudo chmod +x /opt/cmake-x.y.z-linux-x86_64.sh\nmkdir ~/cmake_install/  &amp;&amp; cd ~/cmake_install/\nsudo bash /opt/cmake-x.y.z-linux-x86_64.sh\nsudo ln -s ~/cmake_install/cmake-x.y.z-linux-x86_64/bin/* /usr/local/bin/\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex5-rsu mkdir agilex5-rsu cd agilex5-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next.</p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below.</p> <pre><code>cd $TOP_FOLDER # Build 4 versions of the hardware design\nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw rm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-oobe-legacy-baseline.zip\ncd ..\n# Crteate script to update project settings\ncat &lt;&lt;EOT &gt; update-qsf.tcl\nproject_open top -revision legacy_baseline\nset_global_assignment -name RSU_MAX_RETRY_COUNT 3\nset_global_assignment -name HPS_INITIALIZATION \"AFTER INIT_DONE\"\nproject_close\nEOT\n# Create script to update wdog configuration\ncat &lt;&lt;EOT &gt; update-wdog.tcl\npackage require -exact qsys 25.1.1\nload_component agilex_hps\nset_component_parameter_value Rst_sdm_wd_config {2}\nset_component_parameter_value Rst_watchdog_en {1}\nsave_component\nsave_system hps_subsys.qsys\nEOT\nfor version in {0..3}\ndo\nrm -rf ghrd.$version\ncp -r agilex5_soc_devkit_ghrd ghrd.$version\ncd ghrd.$version\n# Customizing to the current copy of the GHRD\nquartus_sh -t ../update-qsf.tcl\n# Customize WDT \nqsys-script --qpf=top.qpf --script=../update-wdog.tcl --system-file=hps_subsys.qsys\n# update sysid with the loop iterator 'value'\ncat &lt;&lt;EOT &gt; update-sysid.tcl\npackage require -exact qsys 25.1.1\nload_component sysid\nset_component_parameter_value id {0xABAB000$version}\nsave_component\nsave_system peripheral_subsys.qsys\nEOT\nqsys-script --qpf=top.qpf --script=update-sysid.tcl --system-file=peripheral_subsys.qsys\n# Finsish customization and now building the hardware design\nmake legacy_baseline-build\ncd ..\ndone\nrm -rf agilex5_soc_devkit_ghrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created.</p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/output_files/legacy_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/output_files/legacy_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/output_files/legacy_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/output_files/legacy_baseline.sof </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\n# checkout the branch used for this document, comment out to use default\ngit checkout -b test -t origin/socfpga_v2.12.1\nmake -j 48 PLAT=agilex5 bl31\ncd ..\n</code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone https://github.com/altera-fpga/u-boot-socfpga cd u-boot-socfpga # comment out next line to use the latest default branch \ngit checkout -b test -t origin/socfpga_v2025.04 # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# Use 'Image' for kernel image instead of 'kernel.itb'\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\n# Enabling Watchdog automatically if it's not done already\nCONFIG_WATCHDOG_AUTOSTART=y\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable; mmc rescan; run mmcload; run linux_qspi_enable; run rsu_status; setenv bootargs console=ttyS0,115200 root=${mmcroot} rw rootwait;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul> <p>Note: You can control the U-Boot erase granularity to be 4 KB or 64 KB with the CONFIG_SPI_FLASH_USE_4K_SECTORS configuration. A value of y implies an erase granularity of 4 KB otherwise the erase granularity will be 64 KB.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\n# checkout the branch used for this document, comment out to use default\ngit checkout -b test -t origin/socfpga-6.12.19-lts\n# configure the RSU driver to be built into the kernel\nmake clean &amp;&amp; make mrproper\nmake defconfig\n./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y\n./scripts/config --set-val CONFIG_MARVELL_PHY y\nmake oldconfig\nmake -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb\ncd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb - kernel device tree </li> </ul> <p>Note: You can control the Linux erase granularity to be 4 KB or 64 KB with the CONFIG_MTD_SPI_NOR_USE_4K_SECTORS configuration. A value of y implies an erase granularity of 4 KB otherwise the erase granularity will be 64 KB.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is being included in this page. You can see it below. </p> <pre><code>&lt;pfg version=\"1\"&gt;\n&lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n&lt;output_files&gt;\n&lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n&lt;file_options/&gt;\n&lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n&lt;file_options bitswap=\"1\"/&gt;\n&lt;/secondary_file&gt;\n&lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n&lt;/output_file&gt;\n&lt;/output_files&gt;\n&lt;bitstreams&gt;\n&lt;bitstream id=\"Bitstream_1\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.0/output_files/legacy_baseline.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;bitstream id=\"Bitstream_2\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.1/output_files/legacy_baseline.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;/bitstreams&gt;\n&lt;flash_devices&gt;\n&lt;flash_loader&gt;A5ED065BB32AR0&lt;/flash_loader&gt;\n&lt;flash_device type=\"QSPI02G\" id=\"Flash_Device_1\"&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0020FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n&lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00210000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x02000000\" e_addr=\"0x02FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03000000\" e_addr=\"0x03FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n&lt;/flash_device&gt;\n&lt;/flash_devices&gt;\n&lt;assignments&gt;\n&lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n&lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n&lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;/assignments&gt;\n&lt;/pfg&gt;\n</code></pre> <p>You can also downloaded and use it to generate the flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER # Get the .pfg file\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-5/e-series/premium/rsu/collateral/initial_image.pfg\n\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/altera_pro/25.1/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg </code></pre> <p>Here are the complete instructions on how to manually create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER qpfgw &amp; </code></pre> </li> <li> <p>Select the Device family as Agilex 5, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bitswap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file legacy_baseline.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/output_files/legacy_baseline.sof image. This is the initial application image. The tab now looks like below.</p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. This opens the window to browse for the FSBL and select authentication and encryption settings. </p> <p> </p> </li> <li> <p>Click the Bootloader  (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the QSPI02G in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (legacy_baseline.sof). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0090FFFF in order to reserve 7MB for the factory image. This end address was calculated by adding 8MB to the end of the BOOT_INFO partition. Click OK. </p> <p>Note: There is a requirement that the starting address of the SPT0 partition is aligned to 64KB. In order to warranty this, the End Address of the FACTORY_IMAGE must finish at an address ending with 0xXXXXFFFF.</p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be tried after all the application images failed. </p> </li> <li> <p>Select the QSPI02G flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(legacy_baseline.sof). This becomes the initial application image. Select the Page as 1. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x01000000 and End Address = 0x01FFFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.    The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image</p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions) and set the start and end addresses as follows. </p> <p>* P2: Start Address = 0x02000000 and End Address = 0x02FFFFFF.     * P3: Start Address = 0x03000000 and End Address = 0x03FFFFFF. </p> <p>Note: Make sure that all the partitions created for the applications fit in the appropriate QSPI partition or partitions defined in device corresponding device tree in U-Boot and Linux. In the case of Linux, also make sure that the QSPI partition or partitions defined in the device tree to store the applications partitions are also defined in the qspi.rc file in LIBRSU.</p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER quartus_pfg -c initial_image.pfg </code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -rf images/application2.rpd\nquartus_pfg -c hw/ghrd.2/output_files/legacy_baseline.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON\n</code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/factory_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/legacy_baseline.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created. </p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/decision_firmware_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/legacy_baseline.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decision firmware update image is created. </p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The first official version in which RSU is supported is 25.1 release. Because of this the Combined Application is supported starting on 25.1.1 release.</p> <p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/output_files/legacy_baseline.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/output_files/legacy_baseline.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul> <p>Notes:</p> <ul> <li>The first SOF file contains the factory image, from which data is taken to fill out the new decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from this SOF file is not used.</li> <li>The app_image parameter contains the SOF that is used for the application image section of the combined image.</li> <li>The hps_path parameter is unused, and may be removed in the future.</li> <li>The app_image_hps_path parameter contains the HPS FSBL hex file to be used for the application imge section of the combined image.</li> <li>When using HPS first, the additional parameter \"-o hps=1\" needs to be added, and the following files are created combined_application.hps.rpd (combined application image)  and combined_application.core.rbf (corresponding fabric configuration file).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b walnascar https://git.yoctoproject.org/poky git clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga git clone -b walnascar   https://github.com/openembedded/meta-openembedded # work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build echo 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf  bitbake core-image-minimal </code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf zlib-1.3.1 wget http://zlib.net/zlib-1.3.1.tar.gz tar xf zlib-1.3.1.tar.gz rm zlib-1.3.1.tar.gz cd zlib-1.3.1/ export CROSS_PREFIX=${CROSS_COMPILE} ./configure make export ZLIB_PATH=`pwd` cd .. </code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.3.1/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.3.1/libz.so* - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application. </p> <pre><code>cd $TOP_FOLDER rm -rf librsu git clone https://github.com/altera-fpga/librsu cd librsu # checkout the branch used for this document, comment out to use default \ngit checkout -b test -t origin/main cmake -S . -B build -G\"Ninja\" -DPLATFORM=linux-aarch64 &amp;&amp; cmake --build build\ncd .. </code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/librsu/build/lib/libuniLibRSU.so.1 - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/librsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/librsu/build/bin/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example. The rsu_client application requires to be linked with the libuniLibRSU.so.1 library. This can be performed from Linux running in the Agilex 5 device using the ldconfig command. In this example, we are accomplishing this by adding the S99linkRSULib.sh script into the /etc/rcS.d/ directoyy in the file system. This script will be executed automatically at boot time. Notice that this only needs to be done once, after the SD card gets programmed.</p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2021.04/gsrd/\\\ntools/make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n# Creating  initial script to execute it during Linux boot up so we can link rsu_client with \ncat &lt;&lt; EOF &gt; S99linkRSULib.sh\n#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-only\n### BEGIN INIT INFO\n# Provides: banner\n# Required-Start:\n# Required-Stop:\n# Default-Start:     S\n# Default-Stop:\n### END INIT INFO\necho \"Calling ldconfig to Lin rsu_client with libuniLibRSU.so.1\"\nldconfig\nEOF\n# prepare the fat contents \nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\nsudo sed -i 's/agilex5_dk_a5e065bb32aes1/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\n# This also could be copy to /usr/bin/ so it can be accessed from anywhere\nsudo cp $TOP_FOLDER/librsu/build/bin/rsu_client home/root/\nsudo cp $TOP_FOLDER/librsu/build/lib/libuniLibRSU.so.1 usr/lib/\nsudo cp $TOP_FOLDER/librsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\n# We need to link rsu_client with libuniLibRSU.so.1. So we do it during Linux bootup\nsudo cp ../S99linkRSULib.sh etc/rcS.d/\nsudo chmod +x etc/rcS.d/S99linkRSULib.sh\ncd ..\n# create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_agilex5_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_agilex5_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card. </p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Agilex SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to JTAG. </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer.</p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\" </code></pre> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to QSPI. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_agilex5_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Agilex SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <p>Note: RSU functionality in U-Boot is enabled starting on 24.3 release.</p> <ol> <li> <p>Power up the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2025.04-35102-g135e53726d-dirty (Jan 28 2025 - 13:23:54 -0600)\nReset state: Cold\nMPU           800000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nis_ddr_csr_clkgen_locked: ddr csr io96b_0 clkgenA is successfully locked\nio96b_cal_status: Calibration for IO96B instance 0x18400400 done at 0 msec!\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\n:\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 0\nNOTICE:  BL31: v2.12.1(release): QPDS25.1.1_REL_GSRD_PR\nNOTICE:  BL31: Built : 13:23:25, Nov 23 2024\n\nU-Boot 2025.04-35102-g135e53726d-dirty (Jan 28 2025 - 13:23:54 -0600)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  50 devices, 25 uclasses, devicetree: separate\nWDT:   Started watchdog@10d00200 with servicing every 1000ms (10s timeout)\nWDT:   Started watchdog@10d00300 with servicing every 1000ms (10s timeout)\nWDT:   Started watchdog@10d00400 with servicing every 1000ms (10s timeout)\nWDT:   Started watchdog@10d00500 with servicing every 1000ms (10s timeout)\nWDT:   Started watchdog@10d00600 with servicing every 1000ms (10s timeout)\nMMC:   mmc0@10808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@10c02000\nOut:   serial0@10c02000\nErr:   serial0@10c02000\n:\nHit any key to stop autoboot:  0 \nSOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options. </p> <pre><code>SOCFPGA # rsu \nrsu - Agilex SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name &lt;name&gt; - find slot by name and display the slot number slot_count - display the slot count slot_disable &lt;slot&gt; - remove slot from CPB slot_enable &lt;slot&gt; - make slot the highest priority slot_erase &lt;slot&gt; - erase slot slot_get_info &lt;slot&gt; - display slot information slot_load &lt;slot&gt; - load slot immediately slot_load_factory - load factory immediately slot_priority &lt;slot&gt; - display slot priority slot_program_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program buffer into slot, and make it highest priority slot_program_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program raw buffer into slot slot_program_factory_update_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program factory update buffer into slot, and make it highest priority slot_rename &lt;slot&gt; &lt;name&gt; - rename slot slot_delete &lt;slot&gt; - delete slot slot_create &lt;name&gt; &lt;address&gt; &lt;size&gt; - create slot slot_size &lt;slot&gt; - display slot size slot_verify_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against buffer slot_verify_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against raw buffer status_log - display RSU status update &lt;flash_offset&gt; - Initiate firmware to load bitstream as specified by flash_offset notify &lt;value&gt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt &lt;address&gt; - restore SPT from an address save_spt &lt;address&gt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb &lt;address&gt; - restore CPB from an address save_cpb &lt;address&gt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00920000 RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00210000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000210000 Length: 0x00700000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code> SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\nSOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 16777216. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 16777216. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 16777216. </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased. SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n2248704 bytes read in 103 ms (20.8 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Power cycle the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting the specific image to be loaded, in this case using the following command.</p> <pre><code>SOCFPGA # rsu slot_load 1 \n</code></pre> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands. </p> <pre><code>SOCFPGA # rsu update 0x01000000 \nRSU: RSU update to 0x0000000001000000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log to confirm it.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202:  both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report.</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code>SOCFPGA # mw.l 10D00204 0 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value. </p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf0061234 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it. </p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n2478080 bytes read in 113 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nSlot 2 was programmed with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2. </p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x02000000 0x10000 \nSF: 16384 bytes @ 0x2000000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf004d003 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status. </p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 512 KB). </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x10000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d00f Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot. </p> <p><pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> 6. Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image : 0x01000000 Last Fail Image : 0x00100000 State : 0xf004d010 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre>   The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted Current Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d011 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre>   The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected. </p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created. </p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <p><pre><code>SOCFPGA # rsu clear_error_status \n</code></pre>   Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds. </p> <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. </p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x918000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF Bad SPT0 magic number 0xFFFFFFFF no valid SPT0 and SPT1 found Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the highest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails. </p> <pre><code>SOCFPGA # rsu slot_count \ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#using-the-combined-application-image","title":"Using the Combined Application Image","text":"<p>This section shows an example of using a combined application image, from U-Boot. Similar commands can be used from Linux.</p> <p>The combined application images are used the exact same way as regular application images, just that they first update the decision firmware and decision firmware data if necessary, before the device is configured with the functionality from the application SOF.</p> <p>Note: The combined application images do not have absolute pointers inside like the regular application images, the factory update images, or the decision firmware update images. Because of this, they can be written to flash with any of the U-Boot and LibRSU APIs that write to slots.</p> <ol> <li> <p>Program the RSU initial image created with the previous version ($TOP_FOLDER/initial_image_prev.jic).</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_prev.jic\"\n</code></pre> </li> <li> <p>Power cyle the board, stop to U-Boot prompt and query the decision firmware information from U-Boot, this should be a previous version.</p> <pre><code>SOCFPGA # rsu display_dcmf_version\nDCMF0 version = 25.1.0\nDCMF1 version = 25.1.0\nDCMF2 version = 25.1.0\nDCMF3 version = 25.1.0\n</code></pre> </li> <li> <p>Find an unused slot (slot 1, P2), erase it, write the combined application image to it, verify that it was programmed successfully  and check it is now the highest priority.</p> <pre><code>SOCFPGA # rsu slot_erase 1\nSlot 1 erased.\nSOCFPGA # fatload mmc 0:1 ${loadaddr} combined_application.rpd\n151552 bytes read in 9 ms (16.1 MiB/s)\nSOCFPGA # rsu slot_program_buf 1 ${loadaddr} ${filesize}\nSlot 1 was programmed with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_verify_buf 1 ${loadaddr} ${filesize}\nSlot 1 was verified with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_get_info 1\nNAME: P2\nOFFSET: 0x0000000002000000\nSIZE: 0x01000000\nPRIORITY: 1\n</code></pre> </li> <li> <p>Pass control to the combined application update image.</p> <pre><code>SOCFPGA # rsu slot_load 1\n</code></pre> </li> <li> <p>The combined application image checks the currently used decision firmware copy, it sees that it is older, then it updates the decision firmware and decision firmware data, then it loads the actual application image section. Everything takes a few seconds.</p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware is updated, and the application image is running fine.</p> <pre><code>SOCFPGA # rsu status_log\nCurrent Image : 0x02000000\nLast Fail Image : 0x00000000\nState : 0x00000000\nVersion : 0x00000202\nError location : 0x00000000\nError details : 0x00000000\nRetry counter : 0x00000000\nSOCFPGA # rsu display_dcmf_version\nDCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\n</code></pre> </li> <li> <p>Power cycle the board, the same combined application image is loaded, as it is the highest priority. But it takes a couple of seconds less, as the decision firmware does not need to be updated.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <p>Note: RSU functionality in Linux is enabled starting on 24.2 release.</p> <ol> <li> <p>Power up the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message. </p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\nOperation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status.  It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting a specific image to be loaded, using the following commands.</p> <pre><code>./rsu_client --request 1 reboot </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202:both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report .</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux.</p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number. </p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux and display the status:  It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB. </p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot.</p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB. </p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is required to have the status available in Linux. </p> <ol> <li> <p>Power up the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions. </p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --    slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is not rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status: </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash.</p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status. </p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> </li> </ol> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.  Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> <ol> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails. </p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created. </p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine. </p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5, Agilex\u2122 3 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p> <p>Note:  Agilex\u2122 3 HPS Remote System Update User Guide will be released soon.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/","title":"HPS TSN RGMII System Example Design User Guide","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#introduction","title":"Introduction","text":"<p>IEEE Ethernet is a core technology which is a backbone for IT operations and was designed to provide best effort communication suitable for IT operations. Operational Technology vendors have innovatively used Core IEEE Ethernet technology with proprietary solutions for enabling time-bounded communication. To address the need for precision timing, traffic shaping, and time-bounded communication over networks, IEEE introduced a suite of standards known as Time Sensitive Networking (TSN).</p> <p>Agilex\u2122 5 E-Series is designed as an end point for Industrial automation application with support for the following TSN protocols:</p> <ul> <li>Time Synchronization Protocols:<ul> <li>IEEE 1588-2008 Advanced Timestamp (Precision Time Protocol - PTP):<ul> <li>Function: Provides sub-microsecond accuracy for time synchronization between computing systems over a local area network.</li> <li>Key Features: 2-step synchronization, PTP offload, and timestamping.</li> <li>Use Case: Synchronizing industrial devices to operate in unison, ensuring coordinated actions across factory or plant operations.</li> </ul> </li> <li>IEEE 802.1AS (Timing and Synchronization):<ul> <li>Function: A profile of PTP (version 2) that ensures precise time synchronization in a hierarchical master-slave architecture.</li> <li>Key Features: Prioritizes accuracy and variability of timing, crucial for industrial and automotive systems.</li> <li>Use Case: Synchronizing devices to a common time for optimal operation and collaboration.</li> </ul> </li> </ul> </li> </ul> <ul> <li>Credit Based Shaper Protocol:<ul> <li>IEEE 802.1Qav (Time-Sensitive Streams Forwarding and Queuing):<ul> <li>Function: Provides low-latency, time-synchronized delivery of audio and video streams over Ethernet networks.</li> <li>Key Features: Credit-based shaper ensuring end-to-end guaranteed bandwidth with fairness to best-effort traffic.</li> <li>Use Case: Ensuring dedicated bandwidth for audio-video bridging (AVB) streams with minimal latency.</li> </ul> </li> </ul> </li> </ul> <ul> <li>Traffic Scheduling Protocols:<ul> <li>IEEE 802.1Qbv (Time-Scheduled Traffic Enhancements):<ul> <li>Function: Enables the transmission of frames at specific scheduled times within microsecond ranges.</li> <li>Key Features: Critical for time-sensitive scheduled traffic in industrial applications.</li> <li>Use Case: Facilitating precise, time-critical communication for industrial devices like PLCs and drives.</li> </ul> </li> <li>IEEE 802.1Qbu (Frame Preemption):<ul> <li>Function: Allows high-priority frames to preempt lower-priority frames, reducing latency and jitter.</li> <li>Key Features: Utilizes Express Media Access Control (eMAC) and Preemptable Media Access Control (pMAC).</li> <li>Use Case: Ensuring high-priority frames arrive with fixed latency, crucial for applications requiring consistent timing.</li> </ul> </li> </ul> </li> </ul> <p>These TSN standards collectively enable precise timing, traffic shaping, and time-bounded communication, making them indispensable for applications requiring high reliability and determinism. </p> <p>The details of TSN is not in the scope of this document. Here are some reference to the TSN specifications</p> <ul> <li>IEEE Std 802.1AS\u2122-2011 \"Timing and Synchronization for Time-Sensitive Applications in Bridged Local Area Networks\"</li> <li>IEEE Std 802.1Qav\u2122-2009 \u201cForwarding and Queuing Enhancements for Time-Sensitive Streams\u201d</li> <li>IEEE Std 802.1Qbv\u2122-2015 \u201cEnhancements for Scheduled Traffic\u201d</li> <li>IEEE Std 802.1Qbu\u2122-2016 \u201cFrame Preemption\u201d</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#tsn-hps-rgmii-system-example-design-overview","title":"TSN HPS RGMII System Example Design Overview","text":"<p>The Time Sensitive Network (TSN) through Hard Processor System (HPS) IO System Example Design (SED) is a reference design running on the Agilex\u2122 5 E-Series 065B Premium Development Kit. This System Example Design comprises the following components:</p> <ul> <li>Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:</li> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> <p>TSN Solution Architecture for this SED is illustrated as:</p> <p></p> <p>[Note:] This is a pre-production release of Agilex\u2122 5 TSN HPS RGMII System Example Design, on Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit with speed grade -6S. This corresponds to Engineering Samples Silicon quality.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>This system example design is based on the Agilex 5 E-Series Premium Development Kit GSRD. It is recommended that you familiarize yourself with the GSRD development flow before proceeding with this design. The TSN through HPS IO System Example Design will be implemented on the HPS Enablement Expansion Board (also referred as HPS Daughter Card), which is included with the development kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#development-kit","title":"Development Kit","text":"<p>This Example Design targets the Agilex 5 FPGA E-Series 065B Premium Development Kit, utilizing the HPS.  Refer to GSRD#Development Kit for details about the board, including how to install the HPS Daughter Card.</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit</li> <li>HPS Enablement Expansion Board. Included with the development kit.</li> <li>Mini USB Cable</li> <li>Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> <p>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit:</p> <p></p> <p>HPS Enablement Expandsion Board Card:</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#development-environment","title":"Development Environment","text":"<p>Host PC with:</p> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too.</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition version. Used to recompile the hardware design. If only writing binaries is required, then the smaller Altera\u00ae Quartus\u00ae Prime Pro Edition Programmer is sufficient.</li> <li>The prebuilt binaries were built using Quartus version 25.1.1</li> <li>The instructions for rebuilding the binaries use Quartus version 25.1.1</li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#release-contents","title":"Release Contents","text":"<p>This page documents the following:</p> <ul> <li>Binary Release - see Programming the Binaries section for release content details</li> <li>Source Code Release - see Programming Software Image section for release content details</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex 5 Premium Development Kit 25.1.1 Example Design binaries are located at https://releases.rocketboards.org/2025.08/</p> HPS Daughter Card Boot Source Link Enablement Board SD Card https://releases.rocketboards.org/2025.08/gsrd/agilex5_dk_a5e065bb32aes1_gsrd"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#sources","title":"Sources","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-opensource/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#tsn-rgmii-architecture","title":"TSN RGMII Architecture","text":"<p>This system example design showcases Ethernet design through the HPS IO on the HPS Enablement Expansion Board,  with support for TSN features including IEEE 802.1AS, IEEE 802.1Qav, IEEE 802.1Qbv, IEEE 802.1Qbu.</p> <p></p> <ul> <li> <p>HPS Peripherals connected to HPS Enablement Expansion Board:</p> <ul> <li>Micro SD Card</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>UART</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on use case.     </p> <ul> <li>User Flow 1: Testing with Prebuilt Binaries.<p></p> </li> </ul> <ul> <li>User Flow 2: Testing Complete Flow.</li> </ul> User Flow Description Required for Userflow#1 Required for Userflow#2 Environment Setup Tools Download and Installation Yes Yes Install dependencies for SW compilation No Yes Compilation Simulation No No Hardware Compilation No Yes Software Compilation No Yes Programming Programming the binaries Yes Yes Linux boot Yes Yes Testing Run Ping Test Yes Yes Testing Run Test Application Yes Yes"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#tools-download-and-installation","title":"Tools Download and Installation","text":"<ol> <li> <p>Quartus Prime Pro      - Please download and install the Quartus\u00ae Prime Pro Edition version 25.1.1 version software. </p> </li> <li> <p>Win32 Disk Imager     - Please download and install the latest Win32 Disk Imager, available at https://win32diskimager.org/</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#download-and-setup-the-build-toolchain","title":"Download and setup the build toolchain","text":"<p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.enablement\nmkdir agilex5_gsrd.enablement\ncd agilex5_gsrd.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <p>Note that this is installed in the <code>TOP_FOLDER</code>. You may installed this is in other location, but note the path and export it accordingly</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\n</code></pre> <pre><code>export PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu- </code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path Note: The following must be re-done for fresh terminal session</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#install-dependencies-for-sw-compilation","title":"Install dependencies for SW compilation","text":"<p>Make sure you have Yocto system requirements met: Yocto Requirements.</p> <p>The command to install the required packages on Ubuntu 22.04-LTS is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to <code>/bin/dash</code>:</p> <pre><code>sudo ln -sf /bin/bash /bin/sh\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#compilation-flow","title":"Compilation Flow","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#hardware-compilation-flow","title":"Hardware Compilation Flow","text":"<pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#build-core-rbf","title":"Build Core RBF","text":"<pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#software-compilation-flow","title":"Software Compilation Flow","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#customize-yocto","title":"Customize Yocto","text":"<p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:</p> <p>* Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</p> <p>* Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code>     The above are achieved by the following instructions:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#building-hps-bootable-configuration-files","title":"Building HPS Bootable Configuration Files","text":"<p>Ensure you have completed the Hardware Compilation Flow and Software Compilation Flow successfully before continuing below.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#build-qspi-image","title":"Build QSPI Image","text":"<pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#build-hps-rbf","title":"Build HPS RBF","text":"<p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#programming-the-binaries","title":"Programming the Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the System Example Design release.</p> <p>Note: Please download Prebuilt Binaries from here, if you are leveraging userflow#1.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Install the appropriate HPS Daughtercard.</p> <p>3. Connect mini USB cable from vertical connector on HPS Daughtercard to host PC. This is used for the HPS serial console.</p> <p>4. Connect micro USB cable from development board to host PC. This is used by the tools for JTAG communication.</p> <p>5. Connect Ethernet cable from HPS Daughter Card to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>1. Install a serial terminal emulator application on your host PC:</p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Power down your board if powered up. This is important, as once powered up, with the micro USB JTAG cable connected, a couple more USB serial ports will enumerate, and you may choose the wrong port.</p> <p>3. Connect mini-USB cable from the vertical mini-USB connector on the HPS Daughter Card to the host PC</p> <p>4. On the host PC, an USB serial port will enumerate. On Windows machines it will be something like <code>COM4</code>, while on Linux machines it will be something like <code>/dev/tty/USB0</code>.</p> <p>5. Configure your serial terminal emulator to use the following settings:</p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>6. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#write-qspi-flash","title":"Write QSPI Flash","text":"<p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write QSPI Flash:</p>  Using pre-built image  <ul> <li>Download and extract the JIC image, then write it to QSPI</li> </ul> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2025.08/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\n\ntar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\n</code></pre>  Using compiled image  <ul> <li>Write JIC image to QSPI:</li> </ul> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#programming-software-image","title":"Programming Software Image","text":"For Prebuilt: <ul> <li>Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2025.08/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</li> </ul> For compiled image: <ul> <li>Extract sdcard image from the archive located at <code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#write-sd-card","title":"Write SD Card","text":"<p>1. Write the gsrd-console-image-agilex5_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next:</li> </ul> <pre><code># Determine the device associated with the SD card on the host computer.\ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre> <ul> <li>On Windows, use the Win32DiskImager program. For this, first rename the extension of gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#linux-boot","title":"Linux Boot","text":"<p>1. Power down board    2. Set MSEL dipswitch SW27 to ASX4 (QSPI): OFF-ON-ON-OFF    3. Power up the board    4. Wait for Linux to boot, use <code>root</code> as user name, and no password will be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#testing","title":"Testing","text":"<p>For the purpose of demonstration, 2 development kits (refer to GSRD) will be required with Ethernet connected back to back from one board to another. </p> <p>Note: Ethernet port is on the HPS Enablement Expansion Board attached.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#ping-test","title":"Ping Test","text":"<p>Use ifconfig to configure the IP address on both the Devkit DUT and start testing.</p> <p>Example:-</p> <p>Devkit #1 : $ ifconfig eth0 192.168.1.100</p> <p>Devkit #2 : $ ifconfig eth0 192.168.1.200</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#running-iperf-test","title":"Running iperf Test:","text":"<ol> <li> <p>Execute below command on Devkit #1 DUT.</p> <p><code>iperf3 -s eth0</code></p> </li> <li> <p>Execute below command on Devkit #2 DUT.</p> <p><code>iperf3 eth0 -c 192.168.1.100 -b 0 -l 1500</code></p> <p>Note : Update the Devkit #1 DUT IP address in above command.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#run-tsn-application","title":"Run TSN Application","text":"<p>The following examples are demonstrated using 2 units of the Agilex 5 platform.  Please take note of the notation \"[Board A or B]\". The following steps assumes both platforms are connected to each other via an Ethernet connection.</p> <p>1. Boot to Linux</p> <p>2. Navigate to the <code>tsn</code> directory</p> <pre><code>cd tsn\n</code></pre> Configuration for Both Boards Step I: Setup Environment Path on Both Boards <p>3. Board A</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib64/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> <p>4. Board B</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib64/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> TXRX-TSN App Step II: Run Configuration Script <p>5. Board A: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up TAPRIO qdisc.</p> <pre><code>./run.sh agilex5 eth0 vs1a setup\n</code></pre> <p>6. Board B: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up ingress qdiscs.</p> <pre><code>./run.sh agilex5 eth0 vs1b setup\n</code></pre> Step III: Start the Application <p>7. Board B: Run the application.</p> <pre><code>./run.sh agilex5 eth0 vs1b run\n</code></pre> <p>8. Board A: Immediately after starting the application on Board B, run the application on Board A.</p> <pre><code>./run.sh agilex5 eth0 vs1a run\n</code></pre> Post-Test Procedure <p>Once the test is completed, copy the following files from Board B (listener) to the host machine:</p> <ul> <li>afpkt-rxtstamps.txt</li> <li>afxdp-rxtstamps.txt</li> </ul> Generating Latency Plot Using Excel <p>Import 'afpkt-rxtstamps.txt' and 'afxdp-rxtstamps.txt' to excel in 2 seperate sheets.</p> <p></p> <p>Plot Column 1 for each sheets using Scatter chart,</p> <p></p> <p>This will generate plot for AFPKT and AFXDP with latency(on Y-axis) against packet count (on X-axis).</p> <p>The latency for this design example can be seen as below: </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#run-time-synchronization-commands","title":"Run Time Synchronization commands","text":"<p>You may use the following command guide to perform time synchronization on the Agilex\u2122 5 system using PTP4L and PHC2SYS, and to obtain delay values</p> <p>End-to-End PTP master and slave synchronization</p> <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -E -2 -m\n</code></pre> <pre><code>-i  eth0: This option specifies the `eth0` as the network interface to use for PTP.\n-s  This option enables the slave-only mode. \n-H  This option enables hardware time stamping. \n-E  This option selects the end-to-end (E2E) delay measurement mechanism. This is the default.The E2E mechanism is also referred to as the delay \u201crequest-response\u201d mechanism.\n-2  Use Ethernet Layer (L2)\n-m  This option enables printing of messages to the standard output.\n</code></pre> </li> </ul> <ul> <li>Boards A (as master):<pre><code>ptp4l -i eth0  -H -E -2 -m\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul> <p>Peer-to-Peer PTP synchronization:</p> <ul> <li>Board B (as slave):     <pre><code>slave: ptp4l -i eth0  -s -H -P -2 -m\n</code></pre><p>-P: This option enables the use of the Peer Delay Mechanism.</p> </li> </ul> <ul> <li>Board A (as master):     <pre><code>master: ptp4l -i eth0  -H -P -2 -m\n</code></pre></li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul> <p>gPTP synchronization:</p> <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>Board A (as master): <pre><code>ptp4l -i eth0  -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m --transportSpecific 1 -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hvio/ug-tsncfg2-agx5e-premium/","title":"HPS TSN - RGMII HVIO System Example Design User Guide for the Agilex\u2122 5 E-Series Premium Dev Kit","text":"<p> NOTE: This page is not available in this release. The latest release in which HPS TSN RGMII HVIO System Example Design User Guide is supported corresponds to 24.3.1. Please refer to the following page to access the latest documentation: HPS TSN RGMII HVIO System Example Design User Guide. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/","title":"HPS TSN - SGMII XCVR System for the Agilex\u2122 5 E-Series Premium Dev Kit","text":"<p> NOTE: This page is not available in this release. The latest release in which HPS TSN SGMII XCVR System Example Design User Guide is supported corresponds to 24.3. Please refer to the following page to access the latest documentation: HPS TSN SGMII XCVR System Example Design User Guide. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/","title":"USB 3.1 Gen-1 Controller Tutorial Example Design User Guide","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#introduction","title":"Introduction","text":"<p>The USB 3.1, an advancement in the Universal Serial Bus (USB) standard, introduces significant improvements in data transfer speed, power delivery, and overall performance. USB 3.1 Gen 1 controller on Agilex\u2122 5 E-Series supports a maximum data transfer rate of 5 Gigabits per second (5 Gbps) in Super Speed. It is compatible with USB 2.0 devices and utilizes both Type-A and the versatile Type-C connectors.</p> <p>In addition to enhanced speed, USB 3.1 offers better power efficiency and improved data encoding, making it ideal for high-bandwidth applications such as 4K video transfer and fast external storage. The USB 3.1 is a key enabler for faster and more efficient data communication in embedded and HPS devices.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#overview","title":"Overview","text":"<p>The Hard Processor System (HPS) in the Agilex\u2122 5 E-Series Premium Dev Kit provides a USB 3.1 Gen 1 Controller that supports host, device, and dual role device (DRD) mode functions for high-speed applications. Both the USB 2.0 protocol and USB 3.1 protocol are supported.</p> <p>This page provides instructions on how to enable the Host Mode, Device Mode, and Dual Role Device (DRD) Mode.</p> <p></p> <p>For the enablement of the three modes, there are modifications to be made respectively on the Golden Hardware System Design (GHRD) and/or Yocto Build, please refer to the table below to understand the modification required for each mode.</p> USB 3.1 Mode GHRD Yocto Host Use Default, No Changes Use Default, No Changes Device Use Default, No Changes Patch on Yocto Required Dual Role Device Quartus Design Changes Required Patch on Yocto Required <p>These are the subsections included in this page:</p> <ol> <li> <p>The Enablement of USB 3.1 in Host Mode</p> <p>1.1 GHRD and Yocto</p> <p>1.2 Boot-Up and Testing - Transfer a file to a Removable Storage</p> </li> <li> <p>The Enablement of USB 3.1 in Device Mode</p> <p>2.1 GHRD</p> <p>2.2 Yocto</p> <p>2.3 Boot-Up and Testing - Using the Dev Kit as a Removable Storage</p> </li> <li> <p>The Enablement of USB 3.1 in Dual-Role Device (DRD) Mode</p> <p>3.1 GHRD</p> <p>3.2 Yocto</p> <p>3.3 Boot-Up and Testing - Using the Dev Kit in DRD Mode</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#binary-versions","title":"Binary Versions","text":"<p>Please take note that all the instructions on this page are based on the release versions listed in Prebuilt Binaries and Component Versions. The instructions MAY NOT be applicable to other Quartus release. Also, take note that all tests are based on Booting the Golden System Reference Design (GSRD) from SD Card.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex\u2122 5 Premium Development Kit GSRD binaries for 25.1.1 release are located at https://releases.rocketboards.org/2025.08/</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions are used to build the binaries presented in this page:</p> Component Location Branch Commit ID/Tag Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd master QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto https://git.yoctoproject.org/poky walnascar latest Yocto: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#prerequisites","title":"Prerequisites","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#development-kit","title":"Development Kit","text":"<p>This tutorial example design is based on the Agilex 5 E-Series Premium Development Kit GSRD. It is recommended that you familiarize yourself with the GSRD development flow before proceeding with this tutorial. The HPS Enablement Expansion Board (also referred as HPS Daughter Card) is included with the development kit.</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1.<ul> <li>HPS Enablement  Expansion Board. Included with the development kit</li> <li>HPS NAND Board. Enables eMMC storage for HPS. Orderable separately</li> <li>HPS Test Board. Supports SD card boot, and external Arm tracing. Orderable separately</li> <li>Mini USB Cable. Included with the development kit</li> <li>Micro USB Cable. Included with the development kit</li> <li>Ethernet Cable. Included with the development kit</li> <li>Micro SD card and USB card writer. Included with the development kit</li> </ul> </li> </ul> <p>Refer to Agilex\u2122 5 E-series Premium Development Kit for details about the board, including how to install the HPS Boards, and how to set MSEL dispswitches.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#development-environment","title":"Development Environment","text":"<ul> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#test-environment","title":"Test Environment","text":"<ul> <li>Test PC with<ul> <li>Can be Windows OS or Linux OS</li> <li>USB Ports</li> </ul> </li> <li>USB Type-C thumbdrive larger than 5GB storage</li> <li>USB Type-C cable to connect to the dev kit and Test PC</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#release-notes","title":"Release Notes","text":"<p>Refer to Agilex 5 E-series PDK GSRD Release Notes for release readiness information and known issues.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#1-the-enablement-of-usb-31-in-host-mode","title":"1. The Enablement of USB 3.1 in Host Mode","text":"<p>The USB 3.1 Host Mode is enabled by default in the GSRD, thus no modification required.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#11-ghrd-and-yocto","title":"1.1 GHRD and Yocto","text":"<p>1. Refer to HPS GSRD User Guide for the Agilex\u2122 5 E-Series Premium Dev Kit for the instructions to create the GSRD reference design.</p> <p>2. To boot the premium dev kit from SD Card, follow the instructions in Build SD Card Boot Binaries to create the SD Image.</p> <p>3. The GSRD SD Card image boots up the dev kit in Host mode.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#12-boot-up-and-testing-transfer-a-file-to-a-removable-storage","title":"1.2 Boot-Up and Testing - Transfer a file to a Removable Storage","text":"<p>1. Boot up the dev kit with the SD Card and Quartus Programmer with the ghrd.hps.rbf, login the Linux with \u201croot\u201d.</p> <p>2. Plug in the dev kit\u2019s USB Type-C port with a USB Type-C thumbdrive.</p> <p></p> <p>Note: For certain models of thumbdrive, plug-in with one orientation would show it as \"high speed USB device\", flipping the thumbdrive's orientation would show it as \"SuperSpeed USB device\".</p> <p>3. The thumbdrive appears as /dev/sda1.</p> <p>4. Mount the thumbdrive as a new mountpoint mp1.</p> <pre><code>mkdir /mnt/mp1\nmount -t auto /dev/sda1 /mnt/mp1\ndd if=/dev/random of=/tmp/test.txt bs=1M count=200\n</code></pre> <p>5. Create a sample file \u201ctest.txt\u201d in /tmp, copy the text.txt to the mounted drive</p> <pre><code>touch /tmp/host_test.txt\ncp /tmp/host_test.txt /mnt/mp1\n</code></pre> <p>6. Remove the test file from the mounted drive.</p> <pre><code>ls /mnt/mp1/host_test.txt\nrm /mnt/mp1/host_test.txt\n</code></pre> <p>7. At the end of the test, unmount the mounted drive.</p> <pre><code>umount \u2013l /mnt/mp1\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#2-the-enablement-of-usb-31-in-device-mode","title":"2. The Enablement of USB 3.1 in Device Mode","text":"<p>To enable the USB 3.1 in Device Mode, the GHRD requires no changes, but the modification in the Yocto Build is required.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#21-ghrd","title":"2.1 GHRD","text":"<p>1. Refer to the instructions in Setup Environment and Build Hardware Design sections of HPS GSRD User Guide for the Agilex\u2122 5 E-Series Premium Dev Kit - Build SD Card Boot Binaries to build the GHRD.</p> <p>2. When the GHRD is successfully built, the sof file is generated:</p> <ul> <li>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</li> </ul> <p>3. Follow the instruction in the page to convert the sof file to the ghrd.hps.rbf and ghrd.core.rbf files. The ghrs.core.rbf will be included in the SD Card image in the Yocto build section.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#22-yocto","title":"2.2 Yocto","text":"<p>For the modification of Yocto Build, follow the instructions below:</p> <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> <p>2. Apply the Device Mode Enablement Patch</p> <p>a. Download the patch:  Device_Mode_Yocto_Patch</p> <p>The patch changes the value of dr_mode in the &amp;usb31 node from \"host\" to \"peripheral\" in device tree file socfpga_agilex5_socdk.dts.</p> <pre><code> &amp;usb31 {\nstatus = \"okay\";\ndr_mode = \"peripheral\";\n};\n</code></pre> <p>b. Copy and apply the patch with the instuctions:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/\ncp 0001-update-yocto-build-for-USB3.1-Device-Mode-v1.patch .\ngit am 0001-update-yocto-build-for-USB3.1-Device-Mode-v1.patch\n</code></pre> <p>Note: You may ignore the whitespace error message when applying the patch.</p> <p>3. Follow the \"Customize Yocto\" section and \"Build Yocto\" section in Build SD Card Boot Binaries for the instructions to run bitbake_image and package to generate the SD Card Image:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</li> <li>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</li> <li>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#23-boot-up-and-testing-using-the-dev-kit-as-a-removable-storage","title":"2.3 Boot-Up and Testing - Using the Dev Kit as a Removable Storage","text":"<p>1. Boot up the dev kit with the SD Card and Quartus Programmer with the ghrd.hps.rbf, login the Linux with \u201croot\u201d.</p> <p>2. Run the following commands to set up the dev kit as a Storage Device.</p> <pre><code>dd if=/dev/random of=/tmp/test.img bs=1024 count=4096\nmkfs.vfat /tmp/test.img\n</code></pre> <p>3. Load the kernel driver for gadget storage.</p> <pre><code>insmod $(find / -name g_mass_storage.ko) file=/tmp/test.img removable=1\n</code></pre> <p></p> <p>4. Plug in the dev kit\u2019s USB Type-C port with the USB Cable, connect the other end to the Test PC. Observe that the dev kit is being seen by Test PC as a storage.</p> <p></p> <p>Note: For certain models of thumbdrive, plug-in with one orientation would show it as \"high speed USB device\", flipping the thumbdrive's orientation would show it as \"SuperSpeed USB device\".</p> <p>5. On the Test PC, write a file \u201cdevice_test.txt\u201d in the dev kit storage.</p> <p>6. On the dev kit, create a new mountpoint mp2.</p> <pre><code>mkdir /mnt/mp2\nmount /tmp/test.img /mnt/mp2\n</code></pre> <p>7.  You should be able to read the file from both the dev kit and Test PC.</p> <pre><code>ls /mnt/mp2/device_test.txt\n</code></pre> <p>8. At the end of the test, unmount the mounted drive.</p> <pre><code>umount \u2013l /mnt/mp2\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#3-the-enablement-of-usb-31-in-dual-role-device-drd-mode","title":"3. The Enablement of USB 3.1 in Dual-Role Device (DRD) Mode","text":"<p>To enable the USB 3.1 in Dual Role Device (DRD) Mode, the modifications of both the Quartus Project and the Yocto Build are required.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#31-ghrd","title":"3.1 GHRD","text":"<p>1. Setup Environment</p> <pre><code>sudo rm -rf agilex5_gsrd.enablement\nmkdir agilex5_gsrd.enablement\ncd agilex5_gsrd.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Build Hardware Design</p> <p>Note: Use Quartus Prime Pro Version 25.1.1</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\n</code></pre> <p>3. Launch GHRD Project in Quartus</p> <p></p> <p>4. Launch Qsys File in Platform Designer</p> <p></p> <p>5. Add new Parallel IO (PIO) in the Peripheral Subsystem</p> <p>a. On the Filter tab, click on the subsys_periph to open the peripheral subsystem view.</p> <p></p> <p>b. Search for \"Parallel IO\", double click to add the component to the Subsystem.</p> <p></p> <p>c. Setting of PIO:</p> <p></p> <p>d. Add the PIO to the Peripheral Subsystem.</p> <p></p> <p></p> <p>e. Rename the PIO to usb31_pio_0 and make the connections:</p> Pin Connection clk periph_clk rst periph_rst_in s1 pb_cpu_0, offset set to 0x0001 0090 external connection exported as usb31_pio_0_external_connection irq exported as usb31_pio_0_irq <p>6. Setting in the Top System</p> <p>a. Back to the Top System View</p> <p></p> <p>b. You should see the usb31_pio_0_external_connection and usb31_pio_0_irq exported in the subsys_periph block.</p> <p></p> <p>c. Make the following connections:</p> Pin Connection usb31_pio_0_irq f2h_irq0_in usb31_pio_0_external_connection exported as subsys_periph_usb31_pio_0_external_connection <p>d. Take note that the usb31_pio_0_irq must be connected to IRQ [3], as this pin is defined in Yocto device tree file.</p> <p></p> <p>7. Synthesize Design in Platform Designer</p> <p>Platform Designer changes are completed. Click \u201cSync System Infos\u201d and \u201cGenerate HDL\u201d for design synthesis.</p> <p></p> <p>8. Modify Verilog File</p> <p>a. In Quartus, open the legacy_baseline_top.v file.</p> <p>b. Add a new wire for fpga_usb31_pio</p> <pre><code>module ghrd_agilex5_top (\ninput wire fpga_clk_100,\noutput wire [4-1:0] fpga_led_pio,\ninput  wire [4-1:0] fpga_dipsw_pio,\ninput  wire [4-1:0] fpga_button_pio,\n// Add the line below\ninput  wire [  1:0] fpga_usb31_pio,\n</code></pre> <p>c. Comment the original usb31_io_vbus_det and usb31_io_usb31_id</p> <pre><code>    // comment the 2 lines below:\n// input  wire usb31_io_vbus_det,\n// input  wire usb31_io_usb31_id,\n</code></pre> <p>d. Add the exported external connection to the qsys_top instance</p> <pre><code>// Qsys Top instance    \nqsys_top soc_inst (\n// comment the 2 lines below:\n// .usb31_io_vbus_det                    (usb31_io_vbus_det),\n// .usb31_io_usb31_id                    (usb31_io_usb31_id),\n// add the line below:\n.subsys_periph_usb31_pio_0_external_connection_export    (fpga_usb31_pio),\n</code></pre> <p>9. Modify QSF File</p> <p>a. In Quartus, open the legacy_baseline.qsf file.</p> <p>b. Search for the lines below, comment and add in the lines respectively.</p> <pre><code># comment these lines with #\n# set_location_assignment PIN_CF118 -to usb31_io_usb31_id\n# set_instance_assignment -name IO_STANDARD \"3.3-V LVCMOS\" -to usb31_io_usb31_id\n# set_location_assignment PIN_CF121 -to usb31_io_vbus_det\n# set_instance_assignment -name IO_STANDARD \"3.3-V LVCMOS\" -to usb31_io_vbus_det\n# add in these lines:\nset_location_assignment PIN_CF118 -to fpga_usb31_pio[0]\nset_instance_assignment -name IO_STANDARD \"3.3-V LVCMOS\" -to fpga_usb31_pio[0]\nset_location_assignment PIN_CF121 -to fpga_usb31_pio[1]\nset_instance_assignment -name IO_STANDARD \"3.3-V LVCMOS\" -to fpga_usb31_pio[1]\n</code></pre> <p>10. Compilation of the Design</p> <p>a. After the files are update, you may proceed with Compilation of the Design.</p> <ul> <li>If there are new changes in Platform Designer, you need to re-run \"Analysis &amp; Synthesis\".</li> <li>Check \"Assembler (Generate Programming Files)\" to generate the SOF.</li> </ul> <p></p> <p>The following files are created: - $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</p> <p>b. To convert the SOF to RBF, run the command below</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/agilex5_soc_devkit_ghrd/ghrd_a5ed065bb32ae6sr0.core.rbf</li> <li>$TOP_FOLDER/agilex5_soc_devkit_ghrd/ghrd_a5ed065bb32ae6sr0.hps.rbf</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#32-yocto","title":"3.2 Yocto","text":"<p>For modification of Yocto Build, follow the instructions below:</p> <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> <p>2. Apply the Device Mode Enablement Patch</p> <p>a. Download the patch:  DRD_Mode_Yocto_Patch</p> <p>The patch changes the value of dr_mode in the &amp;usb31 node from \"host\" to \"otg\" in the device tree file socfpga_agilex5_socdk.dts.</p> <pre><code> &amp;usb31 {\nstatus = \"okay\";\nextcon = &lt;&amp;extcon_usb&gt;;\ndr_mode = \"otg\";\n};\n</code></pre> <p>b. Copy and apply the patch with instuctions:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/\ncp 0001-update-yocto-build-for-USB3.1-DRD-mode-v1.patch .\ngit am 0001-update-yocto-build-for-USB3.1-DRD-mode-v1.patch\n</code></pre> <p>Note: You may ignore the whitespace error message when applying the patch.</p> <p>c. Edit the device tree file socfpga_agilex5_ghrd.dtsi.</p> <pre><code>vim $TOP_FOLDER/gsrd-socfpga//meta-intel-fpga-refdes/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi\n\n## Add in new nodes for **usb_pio** and **extcon_usb**, save the file:\nusb_pio: gpio@20010090 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0x20010090 0x10&gt;;\ninterrupts = &lt;GIC_SPI 20 IRQ_TYPE_EDGE_RISING&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;3&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\nextcon_usb: extcon-usb {\ncompatible = \"linux,extcon-usb-gpio\";\nid-gpio = &lt;&amp;usb_pio 0 GPIO_ACTIVE_HIGH&gt;;\nvbus-gpio = &lt;&amp;usb_pio 1 GPIO_ACTIVE_HIGH&gt;;\n};\n</code></pre> <p>3. Follow the \"Customize Yocto\" section and \"Build Yocto\" section in Build SD Card Boot Binaries for the instructions to run bitbake_image and package to generate the SD Card Image:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</li> <li>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</li> <li>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/#33-boot-up-and-testing-using-the-dev-kit-in-drd-mode","title":"3.3 Boot-Up and Testing - Using the Dev Kit in DRD Mode","text":"<p>1. Boot up the dev kit with the SD Card and Quartus Programmer with the ghrd.hps.rbf, login the Linux with \u201croot\u201d.</p> <p>2. Plug in the dev kit\u2019s USB Type-C port with a USB Type-C thumbdrive.</p> <p></p> <p>Note: For certain models of thumbdrive, plug-in with one orientation would show it as \"high speed USB device\", flipping the thumbdrive's orientation would show it as \"SuperSpeed USB device\".</p> <p>3. The thumbdrive should be appeared as /dev/sda1.</p> <p>4. Mount the thumbdrive as a new mountpoint mp1.</p> <pre><code>mkdir /mnt/mp1\nmount -t auto /dev/sda1 /mnt/mp1\ndd if=/dev/random of=/tmp/test.txt bs=1M count=200\n</code></pre> <p>5. Create a sample file \u201ctest.txt\u201d in /tmp, copy the text.txt to the mounted drive</p> <pre><code>touch /tmp/test.txt\ncp /tmp/test.txt /mnt/mp1\n</code></pre> <p>6. Remove the test file from the mounted drive.</p> <pre><code>ls /mnt/mp1/test.txt\nrm /mnt/mp1/test.txt\n</code></pre> <p>7. Run the following commands to set up the dev kit as a Storage Device.</p> <pre><code>dd if=/dev/random of=/tmp/test.img bs=1024 count=4096\nmkfs.vfat /tmp/test.img\n</code></pre> <p>8. Load the kernel driver for gadget storage.</p> <pre><code>insmod $(find / -name g_mass_storage.ko) file=/tmp/test.img removable=1\n</code></pre> <p></p> <p>9. Plug in the dev kit\u2019s USB Type-C port with the USB Cable, connect the other end to the Test PC. Observe that the dev kit is being seen by Test PC as a storage.</p> <p></p> <p>10. On the Test PC, write a file \u201cdevtest.txt\u201d in the dev kit storage.</p> <p>11. On the dev kit, create a new mountpoint mp2.</p> <pre><code>mkdir /mnt/mp2\nmount /tmp/test.img /mnt/mp2\n</code></pre> <p>12.  You should be able to read the file from both the dev kit and Test PC.</p> <pre><code>ls /mnt/mp2/devtest.txt\n</code></pre> <p>13.  At the end of the tests, unmount the mounted drives.</p> <pre><code>umount \u2013l /mnt/mp1\numount \u2013l /mnt/mp2\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/","title":"HPS Xen Hypervisor GSRD for the Agilex\u2122 5 E-Series Premium Dev Kit","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#introduction","title":"Introduction","text":"<p>This page presents the Xen GSRD, which is based on the Linux GSRD for the Agilex\u2122 5 E-Series Premium Development Kit. The Xen GSRD uses the HPS Enablement Board, and SD card for storing the root filesystem.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#xen-overview","title":"Xen Overview","text":"<p>Xen is a free open-source Type-1 hypervisor which enables efficient and secure virtualization of hardware resources to run multiple operating systems on a single physical machine. </p> <p></p> <p>In Xen's architecture, there are two domains. Dom0 is the privileged management domain that runs the hypervisor and has full access to physical hardware, acting as the bridge between the hypervisor and other virtual machines. DomUs are unprivileged guest domains that run operating systems or applications, relying on Dom0 for resource allocation. Dom0 and DomUs operate independently, ensuring isolation and security.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Premium Development Kit GSRD:</p> <ul> <li> <p>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1, with the following included accessories:</p> <ul> <li>HPS Enablement Expansion Board. </li> <li>Mini USB Cable.</li> <li>Micro USB Cable.</li> <li>Ethernet Cable.</li> <li>Micro SD card and USB card writer.</li> </ul> </li> </ul> <ul> <li> <p>Host PC with:</p> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>SSH server installer, to enable using 'scp' command from target board to host PC</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> </ul> </li> </ul> <ul> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for more information about the development kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex\u2122 5 Premium Development Kit Xen binaries are located at https://releases.rocketboards.org/2025.08/xen/agilex5_dk_a5e065bb32aes1_xen/.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#exercise-prebuilt-binaries","title":"Exercise Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the Xen example, on the Agilex 5 FPGA E-Series 065B Premium Development Kit, with the HPS Enablement Expansion board.</p> <p>Running the boot from SD card section of the GSRD is a prerequisite step for running the Xen examples, as not all steps are as detailed on this page as in the GSRD page. Refer to the following links for help on getting started:</p> Link Description Board Documentation Board user guide, schematics, etc GSRD Development Kit Section Details about the development kit GSRD Board Setup Section Setting up the development kit GSRD Serial Console Section Setting up serial console GSRD Write SD Card Section Writing SD card image"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#write-binaries","title":"Write Binaries","text":"<p>This section shows presents downloading and flashing the SD card image and JIC files, and downloading the xen rootfs cpio archive to be used by DomUs VMs.</p> <p>1. Download and write to SD card the image https://releases.rocketboards.org/2025.08/xen/agilex5_dk_a5e065bb32aes1_xen/sdimage.tar.gz</p> <p>2. Download and write to QSPI flash the JIC file https://releases.rocketboards.org/2025.08/xen/agilex5_dk_a5e065bb32aes1_xen/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz</p> <p>3. Set MSEL to QSPI, and power cycle the board to boot to Linux.</p> <p>4. On the host computer, download the xen rootf cpio archive:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/xen/agilex5_dk_a5e065bb32aes1_xen/xen-image-minimal-agilex5.cpio.gz\n</code></pre> <p>5. On the Linux on target board, copy over the above downloaded file in 'xen' folder:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/xen-image-minimal-agilex5.cpio.gz .\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#boot-xen-gsrd","title":"Boot Xen GSRD","text":"<p>This section shows how to boot the Xen GSRD. By default, if no other operation is done, the board boots into normal, non-Xen enabled GSRD on a power cycle. In order to boot with the Xen Hypervisor, you need to stop the U-Boot countdown, and boot Linux manually using the commands shown in the below sections. This is provided for convenience, and when used in a real production system, U-Boot can be configured to boot the required Xen configuration automatically.</p> <p></p> Boot Without Passthrough <p>1. Set MSEL to QSPI, and power cycle the board</p> <p>2. Press any key during U-Boot countdown to stop it</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> Boot With Passthrough <p>The instructions are the same as without passthrough, just that the following command needs to be added befote the 'booti' command:</p> Device Passthrough Command QSPI fdt set /soc@0/spi@108d2000 xen,passthrough Ethernet fdt set /soc@0/ethernet@10830000 xen,passthrough"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#manage-vms","title":"Manage VMs","text":"<p>This section shows how to use the 'xl' Xen utility to manage VMs running on DomUs. Only a few options are used, refer to 'xl' command help for more options.</p> <p>1. Boot Xen GSRD as shown above. It can be either with or without passthrough</p> <p>2. Create VM1 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_1.cfg\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>3. Start VM1:</p> <pre><code>xl create test_vm_1.cfg\n</code></pre> <p>4. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>5. Connect to VM1 console:</p> <pre><code>xl console DomU1\n</code></pre> <p>6. Run some commands in VM1:</p> <pre><code>pwd\nls -la\n</code></pre> <p>7. Exit from VM1 console by pressing CTRL + ]. Note this works only from serial console, and not over SSH connection.</p> <p>8. Create VM2 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_2.cfg\n# Guest name\nname = \"DomU2\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>9. Start VM2:</p> <pre><code>xl create test_vm_2.cfg\n</code></pre> <p>10. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>11. Shutdown VM1:</p> <pre><code>xl shutdown DomU1\n</code></pre> <p>The above command politely asks DomU1 to shut down by using the ACPI shutdown signal and letting the OS shut down.</p> <p>Alternatively, when needed, you can also use 'destroy' commands which acts as a hard power cycle:</p> <pre><code>xl destroy DomU1\n</code></pre> <p>12. List VMs again, it will not show VM1 anymore</p> <pre><code>xl list\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#ethernet-passthrough","title":"Ethernet Passthrough","text":"<p>This section shows an example of how to assign the Ethernet IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc@0/ethernet@10830000 xen,passthrough\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Run 'ifconfig' to confirm Dom0 Linux does not have Ethernet anymore:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 2172  bytes 134772 (131.6 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 2172  bytes 134772 (131.6 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> <p>7. Go to xen folder and look at the provided Ethernet passthrough files (dtb file and VM configuration file)</p> <pre><code>root@agilex5dka5e065bb32aes1:~/# cd xen\nroot@agilex5dka5e065bb32aes1:~/xen# ls *ethernet*\nethernet@10830000.cfg  ethernet@10830000.dtb\nroot@agilex5dka5e065bb32aes1:~/xen# cat ethernet@10830000.cfg\n# SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"/home/root/xen/xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\ndevice_tree = \"ethernet@10830000.dtb\"\ndtdev = [ \"/soc@0/ethernet@10830000\" ]\niomem = [ \"0x10830,4\",\"0x10d12,1\" ]\nirqs = [ 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 267, 268, 269, 270, 271, 272 ]\n</code></pre> <p>8. Start the VM:</p> <pre><code>xl create ethernet\\@10830000.cfg\n</code></pre> <p>9. Connect to VM console </p> <pre><code>xl console DomU1\n</code></pre> <p>10. In the VM console, login with 'root' account, then do an 'ifconfig' or other commands to confirm Ethernet is working:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\neth0      Link encap:Ethernet  HWaddr 1A:CD:51:03:2A:55  inet addr:192.168.1.154  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fe80::18cd:51ff:fe03:2a55/64 Scope:Link\n          inet6 addr: 2603:8081:7700:1092::1bb7/128 Scope:Global\n          inet6 addr: 2603:8081:7700:1092:18cd:51ff:fe03:2a55/64 Scope:Global\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:12 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:20 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 RX bytes:1715 (1.6 KiB)  TX bytes:2275 (2.2 KiB)\nInterrupt:14 Base address:0xc000 lo        Link encap:Local Loopback  inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#qspi-passthrough","title":"QSPI Passthrough","text":"<p>This section shows an example of how to assign the QSPI IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p></p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc@0/spi@108d2000 xen,passthrough\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Go to xen folder and look at the provided QSPI passthrough files (dtb file and VM configuration file):</p> <pre><code>root@agilex5dka5e065bb32aes1:~/# cd xen\nroot@agilex5dka5e065bb32aes1:~/xen# ls *spi*\nspi@108d2000.cfg  spi@108d2000.dtb\nroot@agilex5dka5e065bb32aes1:~/xen# cat spi@108d2000.cfg\n#SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\n# Ramdisk\nramdisk = \"/home/root/xen/xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\ndevice_tree = \"spi@108d2000.dtb\"\niomem = [ \"0x108d2,1\", \"0x10900,100\" ]\nirqs = [ 35 ]\n</code></pre> <p>7. Start the VM, and connect to its console</p> <pre><code>xl create spi@108d2000.cfg\nxl console DomU1\n</code></pre> <p>8. In the VM console, login with 'root' account, then run a couple of commands to see QSPI is enabled:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# mtdinfo\nCount of MTD devices:           2\nPresent MTD devices:            mtd0, mtd1\nSysfs interface supported:      yes\nroot@agilex5dka5e065bb32aes1:~# cat /proc/mtd dev:    size   erasesize  name\nmtd0: 04200000 00010000 \"u-boot\"\nmtd1: 0be00000 00010000 \"root\"\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#physical-core-assignment-to-virtual-machines","title":"Physical Core Assignment to Virtual Machines","text":"<p>When Xen creates a new virtual machine, the Xen scheduler will assign a physical core to be used by this VM depending on load and configuration. However, you can assign specific cores through CPU pinning. Here is described how you can assign a specific core to any of the VM created.</p> <p>In order to exercise this, you can use any of the test procedures described previously, but the following example will show you how to do it using the procedure described in Manage VMs (booting without passthrough).</p> <p>1.  Boot to Linux and create DomU1 and DomU2 VMs keeping both alive. You can check that both of them exist using the following command:</p> <pre><code>root@agilex5dka5e065bb32aes1:~/xen# xl list\nName                 ID   Mem VCPUs      State   Time(s)\nDomain-0              0  2048     2     r-----      45.0\nDomU1                 1  1024     1     -b----      23.7\nDomU2                 2  1024     1     r-----      15.7\n</code></pre> <p>2. Check the current core assignment for each one of the VMs created using the xl vcpu-list command:</p> <pre><code>root@agilex5dka5e065bb32aes1:~/xen# xl vcpu-list\nName             ID  VCPU   CPU State   Time(s) Affinity (Hard / Soft)\nDomain-0         0     0    0   r--      27.5    0 / all\nDomain-0         0     1    1   -b-      21.3    1 / all\nDomU1            1     0    3   -b-      30.6    all / all\nDomU2            2     0    2   -b-      30.6    all / all\n</code></pre> <p>The output of this command indicates in the CPU column whcih is the current physical core assigned to each one of the VM. In this case we can see that DomU1 is running in the physical core 3 while DomU2 is runninng in the physical core 2.  Also observe the Affinity column, in whcih for the DomU1 and Dom2, the Hard Affinity is not restricted to any specific core as it is indicated with all.</p> <p>3. You can change the core assigned to the VMs using the xl vcpu-pin command. The syntax of this command is as follow:</p> <p>xl vcpu-pin <p>The parameters of this command can been retrieved from the information provided by the xl vcpu-list command.</p> <p>4. In this exercise, let's restrict the physical core that can be assinged to the DomU1 and DomU2 inverting the core observed in the step 2. In this case we will assign the physical core 2 to DomU1 and the physical core 3 to DomU2.</p> <pre><code>root@agilex5dka5e065bb32aes1:~/xen# xl vcpu-pin 1 0 2\nroot@agilex5dka5e065bb32aes1:~/xen# xl vcpu-pin 2 0 3\nroot@agilex5dka5e065bb32aes1:~/xen#  xl vcpu-list\nName             ID  VCPU   CPU State   Time(s) Affinity (Hard / Soft)\nDomain-0         0     0    0   r--      36.1    0 / all\nDomain-0         0     1    1   -b-      30.6    1 / all\nDomU1            1     0    2   -b-      64.2    2 / all\nDomU2            2     0    3   -b-      64.2    3 / all\n</code></pre> <p>From the previous campture you can verify that now the core 2 is being assigned to DOMU1  and the core 3 is being assigned to DomU2. Also observe that in the Affinity column these cores are the only ones that can be used by these VMs.</p> <p>If you want to go beyond, you can compile the following getCore application and take it to any created VM. The output of this application tells you in which physical core this is being executed. The easier way to transfer this to a VM is by using the Ethernet Passthrough example.  You can build the application in your development computer,  and then take it to your VM created in your board through TFTP or SCP applications.</p> <p><pre><code>/* getCore.c app to get the physical core used to execute it.\n   This can be compiled with the following command after the appropiate setup of ARM Tool chain\n   gcc -g -o getCore getCore.c */\n#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\nunsigned long int read_mpidr(void)\n{\nunsigned long int value;\nasm volatile(\"mrs %[result], mpidr_el1\" : [result] \"=r\" (value));\nreturn value;\n}\nunsigned int getCore(){  unsigned long mpidr;\nunsigned int core;\nmpidr = read_mpidr();\ncore = (mpidr &gt;&gt; 8) &amp; 0xFF;    return core;\n}\nint main()\n{\nunsigned int core;    core = getCore();\nprintf(\"=== My Debug example started on Core %d ===\\n\", core); return 0;\n}\n</code></pre> In any of the VMs created, you can execute  this application before and after calling the xl vcpu-pin command to assign an exclusive core and observe that the physical core in which the application is running is changed as expected. This is shown in the following capture. In this capture only one VM is being created. You can see that initially the core 2 was assigned to the DomU1 VM and when the getCore application was run in this VM, it indicates that  this was run in that core. Then in Domain-0 , the xl vcpu-pin 1 0 3 is used to assign the core 3 to the DomU1 VM and when the getCore application is run there we can confirm that this is being executed in the core 3.</p> <pre><code>#In Domain-0\nroot@agilex5dka5e065bb32aes1:~/xen# xl vcpu-list\nName           ID  VCPU   CPU State   Time(s) Affinity (Hard / Soft)\nDomain-0       0     0    0   r--      20.5     0 / all\nDomain-0       0     1    1   -b-      16.7     1 / all\nDomU1          1     0    2   -b-      36.5     all / all\n\nroot@agilex5dka5e065bb32aes1:~/xen# xl console DomU1 &lt;Now in DomU1&gt;\nroot@agilex5dka5e065bb32aes1:~/# tftp -gr getCore 10.10.0.1\nroot@agilex5dka5e065bb32aes1:~/# chmod +x ./getCore\nroot@agilex5dka5e065bb32aes1:~/# ./getCore\n=== My Debug example started on Core 2 ===\n# Exit from DomU1 with Ctrl+] and return to Domain-0\nroot@agilex5dka5e065bb32aes1:~/xen# xl vcpu-pin 1 0 3\nroot@agilex5dka5e065bb32aes1:~/xen# xl vcpu-list\nName          ID  VCPU   CPU State   Time(s) Affinity (Hard / Soft)\nDomain-0      0     0    0   -b-      34.1  0 / all\nDomain-0      0     1    1   r--      32.7  1 / all\nDomU1         1     0    3   -b-      60.6  3 / all\n# Return to DomU1\nroot@agilex5dka5e065bb32aes1:~/# xl console DomU1\nroot@agilex5dka5e065bb32aes1:~/# ./getCore        === My Debug example started on Core 3 ===\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#memory-isolation-in-vms","title":"Memory Isolation in VMs","text":"<p>When creating a secondary virtual machine (i.e. DomUx), this runs as a guest and is given access only to the resources given by Xen. Typically, only the RAM is assigned to a VM, like in the VMs created at Manage VMs. When Xen creates this VM, it creates a virtualized memory map based on the  resources assigned to this and Xen keeps the mapping in internal tables. These resources could be RAM memory or peripheral that could be configured as passthrough. The main VM (i.e. Dom0) will show the full memory map as defined in the device Technical Refernece Manual unless any peripheral is transfer to a secondary VM also using PassThrough mechanism. Xen Hypervisor provide complete isolation between different VMs. Xen uses Guest Physical Addresses (GPAs) to represent the physical address space inside a guest OS. Each DomU is given its own GPA (Guest Physical Addresses ) space, which Xen maps to different  MFN (Machine Frame Numbers) in the host\u2019s actual memory. Even though  the VM memory map observed through /proc/iomem inside multiple DomUs may look identical, the GPAs are backed by different host memory pages, ensuring isolation between VMs (unless a shared memory region is explicitly defined as part of the VMs configuration).</p> <p>The following example demonstrates the memory isolation feature in the VMs. This is based on the Manage VMs using only Dom0 and DomU1. This example, demonstrates the memory layout for each one of these VMs using cat /proc/iomem. The exercise also access one memory location that is included in the local memory layout, using devmem2, to confirm that this is accessible from the same VM. Finally, the exercise tries to access a memory location that belongs to the other VM, verifying that this is not possible as they are isolated from each other.</p> <p>In Dom0 read the memory layout and read the 1st  memory location in GICD: <pre><code>root@agilex5dka5e065bb32aes1:~/xen/# cat /proc/iomem 00000000-0007ffff : 0.sram sram@0\n10808000-10808fff : 10808000.mmc0 mmc0@10808000\n10830000-108334ff : 10830000.ethernet ethernet@10830000\n108d2000-108d20ff : 108d2000.spi spi@108d2000\n10900000-109fffff : 108d2000.spi spi@108d2000\n10b00000-10b3ffff : 10b00000.usb usb@10b00000\n10c03200-10c032ff : 10c03200.gpio gpio@10c03200\n10c03300-10c033ff : 10c03300.gpio gpio@10C03300\n10d00200-10d002ff : 10d00200.watchdog watchdog@10d00200\n10d00300-10d003ff : 10d00300.watchdog watchdog@10d00300\n10d00400-10d004ff : 10d00400.watchdog watchdog@10d00400\n10d00500-10d005ff : 10d00500.watchdog watchdog@10d00500\n10d00600-10d006ff : 10d00600.watchdog watchdog@10d00600\n10d10000-10d10fff : 10d10000.clock-controller clock-controller@10d10000\n10d11000-10d11fff : 10d11000.rstmgr rstmgr@10d11000\n10da0000-10da0fff : 10da0000.i3c i3c@10da0000\n10da1000-10da1fff : 10da1000.i3c i3c@10da1000\n10db0000-10db04ff : 10db0000.dma-controller dma-controller@10db0000\n10dc0000-10dc04ff : 10dc0000.dma-controller dma-controller@10dc0000\n11000000-11007fff : usb1@11000000\n  11000000-11007fff : xhci-hcd.0.auto usb1@11000000\n1100c100-110fffff : 11000000.usb1 usb1@11000000\n16002000-16002fff : 16002000.pmu-tcu pmu-tcu@16002000\n16042000-16042fff : 16042000.pmu-tbu pmu-tbu@16042000\n16062000-16062fff : 16062000.pmu-tbu pmu-tbu@16062000\n16082000-16082fff : 16082000.pmu-tbu pmu-tbu@16082000\n160a2000-160a2fff : 160a2000.pmu-tbu pmu-tbu@160A2000\n160c2000-160c2fff : 160c2000.pmu-tbu pmu-tbu@160C2000\n160e2000-160e2fff : 160e2000.pmu-tbu pmu-tbu@160E2000\n1d000000-1d00ffff : GICD\n1d060000-1d15ffff : GICR\n20000000-2fffffff : System RAM\n80000000-81ffffff : reserved\n98000000-f7ffffff : System RAM\n  98010000-99e9ffff : Kernel code\n  99ea0000-9a17ffff : reserved\n  9a180000-9a71ffff : Kernel data\n  a0000000-a0006fff : reserved\n  a0200000-a81fffff : reserved\n  f2000000-f7ffffff : reserved\n9c0000000-9dfffffff : System RAM\n  9dd440000-9df9fffff : reserved\n  9dfaa8000-9dfaa8fff : reserved\n  9dfaa9000-9dfadafff : reserved\n  9dfadd000-9dfadefff : reserved\n  9dfadf000-9dfadffff : reserved\n  9dfae0000-9dfae0fff : reserved\n  9dfae1000-9dfbe4fff : reserved\n  9dfbe5000-9dfc09fff : reserved\n  9dfc0a000-9dfffffff : reserved\n\nroot@agilex5dka5e065bb32aes1:~/xen/# devmem2 0x1d000000\n/dev/mem opened.\nMemory mapped at address 0xffffa178b000.\nRead at address  0x1D000000 (0xffffa178b000): 0x00000012\n</code></pre></p> <p>In DomU1 read the memory layout and read the 1st  memory location in GICD: <pre><code>root@agilex5dka5e065bb32aes1:~# cat /proc/iomem 03001000-03010fff : GICD\n03020000-0401ffff : GICR\n40000000-7fffffff : System RAM\n  40010000-41e9ffff : Kernel code\n  41ea0000-4217ffff : reserved\n  42180000-4271ffff : Kernel data\n  48000000-4e3e4fff : reserved\n  7ca00000-7fbfffff : reserved\n  7fc65000-7fc67fff : reserved\n  7fc68000-7fce8fff : reserved\n  7fce9000-7fd01fff : reserved\n  7fd04000-7fd06fff : reserved\n  7fd07000-7fe0afff : reserved\n  7fe0b000-7fffffff : reserved\nroot@agilex5dka5e065bb32aes1:~# devmem2 0x03001000\n/dev/mem opened.\nMemory mapped at address 0xffffb8980000.\nRead at address  0x03001000 (0xffffb8980000): 0x00000012\n</code></pre></p> <p>In DomU1 read the read the 1st  memory location in GICD using the memory address indicated in Dom0  to confirm that this is not accessible: <pre><code>root@agilex5dka5e065bb32aes1:~# devmem2 0x1d000000\n/dev/mem opened.\nMemory mapped at address 0xffff87bfe000.\nKilled\n</code></pre> In Dom0 read the read the 1st  memory location in GICD using the memory address indicated in DomU1 to confirm that this is not accessible: <pre><code>root@agilex5dka5e065bb32aes1:~/xen/# devmem2 0x03001000\n/dev/mem opened.\nMemory mapped at address 0xffffb738b000.\nKilled\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#rebuild-xen-gsrd","title":"Rebuild Xen GSRD","text":"<p>This section presents how to build the Xen GSRD binaries. The instructions are the same as for the GSRD, except that the environment variable BUILD_HYP=1 needs to be set for building the Xen enabled GSRD version. This environment variable is only used by the Yocto GSRD script.</p> Yocto Build Prerequisites <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd_premium.xen\nmkdir agilex5_gsrd_premium.xen\ncd agilex5_gsrd_premium.xen\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b walnascar https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\nexport HYP_BUILD=1\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#use-zephyr-on-domu","title":"Use Zephyr on DomU","text":"<p>This section shows how to build a simple Zephyr example and run in inside a Xen VM.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#build-zephyr-binary","title":"Build Zephyr Binary","text":"<p>For theis example the Zephyr binary was built on an Ubuntu 22.04 machine, with the required packages installed as indicated in https://docs.zephyrproject.org/latest/develop/getting_started/index.html.</p> <p>1. Create a virtual Python environment:</p> <pre><code>export TOP_FOLDER=`pwd`\npython3 -m venv $TOP_FOLDER/.zephyr_venv\nsource $TOP_FOLDER/.zephyr_venv/bin/activate\n</code></pre> <p>2. Install the Zephr project:</p> <pre><code>pip3 install wheel pip3 install west west init -m https://github.com/zephyrproject-rtos/zephyr --mr main zephyrproject cd zephyrproject\nwest update west zephyr-export\npip install -r zephyr/scripts/requirements.txt\n</code></pre> <p>3. Download the Altera\u00ae Zephyr repo and install SDK:</p> <pre><code>git clone -b socfpga_rel_24.3 https://github.com/altera-fpga/zephyr-socfpga\ncd zephyr-socfpga\nwest update\nwest zephyr-export\nwest sdk install\n</code></pre> <p>4. Work around an issue that happens at least on certain Ubuntu 22.04 installations:</p> <pre><code>pushd boards/arm64/xenvm\nrm xenvm_defconfig &amp;&amp; mv xenvm_gicv3_defconfig xenvm_defconfig\nrm xenvm_gicv3.yaml\nmv xenvm.dts xenvm_base.dts &amp;&amp; mv xenvm_gicv3.dts xenvm.dts &amp;&amp; sed -i 's/xenvm\\.dts/xenvm_base.dts/g' xenvm.dts\npopd\n</code></pre> <p>5. Build the sample application:</p> <pre><code>west build -b xenvm samples/hello_world -p\n</code></pre> <p>This will create the file $TOP_FOLDER/zephyrproject/zephyr-socfpga/build/zephyr/zephyr.bin</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#run-zephyr-vm","title":"Run Zephyr VM","text":"<p>1. Write the Xen GSRD binaries.</p> <p>2. Boot to XEN GSRD, does not matter if passthrough is enabled or not</p> <p>3. Copy the Zephyr binary to the target rootfs:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/zephyr.bin .\n</code></pre> <p>4. Still in the xen folder, create the Zephyr VM configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; zephyr.cfg\nkernel=\"zephyr.bin\"\nname=\"zephyr\"\nvcpus=1\nmemory=16\ngic_version=\"v3\"\non_crash=\"preserve\"\nEOT\n</code></pre> <p>5. Start the Zephyr VM:</p> <pre><code>xl create zephyr.cfg\n</code></pre> <p>6. Connect to VM console:</p> <pre><code>xl console zephyr\n</code></pre> <p>7. In the VM console, you will see the message output by the Zephyr:</p> <pre><code>Hello World! xenvm\n[00:00:00.000,000] &lt;inf&gt; xen_events: xen_events_init: events inited\n\n[00:00:00.000,000] &lt;inf&gt; uart_hvc_xen: Xen HVC inited successfully\n\n*** Booting Zephyr OS build v4.0.0-4569-g8cff70a95d6c ***\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/xen/ug-xen-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/","title":"HPS GSRD User Guide for the Agilex\u2122 7 FPGA F-Series Development Kit (2x F-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#overview","title":"Overview","text":"<p>This page presents the Golden System Reference Design for the Altera\u00ae Agilex\u2122 F-Series FPGA Development Kit (2x F-Tile) ordering code DK-DEV-AGF023FA. The GSRD demonstrates the following: </p> <ul> <li>FPGA side <ul> <li>LEDs connected to GPIO soft IP modules </li> </ul> </li> <li>HPS side <ul> <li>Linux, booted by U-Boot and ATF </li> <li>Board web server </li> <li>Sample applications </li> <li>Hello world </li> <li>Controlling FPGA LEDs: blink, scroll, toggle </li> <li>System check application </li> </ul> </li> </ul> <p>Note: There was older version of this board, with ordering code DK-DEV-AGF027F1ES. Refer to the following version of this page for  instructions on how to build the GSRD for it: https://altera-fpga.github.io/rel-25.1/embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/.</p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the GSRD: </p> <ul> <li>Intel\u00ae Agilex\u2122 F-Series FPGA Development Kit (2x F-Tile), ordering code DK-DEV-AGF023FA<ul> <li>SD/MMC HPS Daughtercard </li> <li>Mini USB cable for serial output </li> <li>Micro USB cable for on-board Intel FPGA Download Cable II </li> <li>Micro SD card (4GB or greater) </li> </ul> </li> <li>Host PC with <ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too </li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows) </li> <li>Micro SD card slot or Micro SD card writer/reader </li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> </ul> </li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board) </li> </ul> <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC. </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#prebuilt-binaries-for-dk-dev-agf023fa","title":"Prebuilt Binaries for DK-DEV-AGF023FA","text":"<p>The GSRD binaries are located at https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_dev_agf023fa_gsrd/</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>: </p> File Description linux-socfpga-v6.12.19-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2025.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.12.1-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#exercise-gsrd","title":"Exercise GSRD","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#boot-linux","title":"Boot Linux","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#configure-board","title":"Configure Board","text":"<p>Set up the board switches: </p> Switch Setting SW1[1:4] ON/OFF/OFF/OFF SW2 ON SW3[1:4] OFF/OFF/ON/OFF SW4[1:4] OFF/OFF/OFF/OFF SW5 OFF SW6 OFF <p>For more details about the settings, consult the Intel\u00ae Agilex\u2122 F-Series FPGA (Two F-Tiles) Development Kit User Guide. </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#write-qspi-image","title":"Write QSPI Image","text":"<p>1. Download and extract the jic file: </p> <pre><code>cd $TOP_FOLDER wget https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_dev_agf023fa_gsrd/ghrd_agfd023r24c2e1vc.hps.jic.tar.gz tar xf ghrd_agfd023r24c2e1vc.hps.jic.tar.gz </code></pre> <p>2. Power up the board </p> <p>3. Write the JIC file </p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agfd023r24c2e1vc.hps.jic\" </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#write-sd-card","title":"Write SD Card","text":"<p>This section explains how to create the SD card necessary to boot Linux, using the SD card image available with the pre-built Linux binaries package. Once the SD card has been created, insert the card into the SD slot of the Micro SD daughter card. </p>  Write SD Card on Linux  <p>1. Download the SD card image and extract it: </p> <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_dev_agf023fa_gsrd/sdimage.tar.gz tar xf sdimage.tar.gz </code></pre> <p>The extacted file is named <code>gsrd-console-image-agilex7.wic</code>. </p> <p>2. Determine the device associated with the SD card on the host by running the following command before and after inserting the card. </p> <pre><code>$ cat /proc/partitions </code></pre> <p>Let's assume it is /dev/sdx. </p> <p>3. Use dd utility to write the SD image to the SD card. </p> <pre><code>$ sudo dd if=gsrd-console-image-agilex7.wic of=/dev/sdx bs=1M </code></pre> <p>Note we are using sudo to be able to write to the card. </p> <p>4. Use sync utility to flush the changes to the SD card. </p> <pre><code>$ sudo sync </code></pre>   Write SD Card on Windows  <p>1. Download the SD card from https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_dev_agf023fa_gsrd/sdimage.tar.gz and extract it. </p> <p>The extacted file is named <code>gsrd-console-image-agilex7.wic</code>. </p> <p>2. Rename the wic file as <code>sdcard.img</code> </p> <p>3. Use Win32DiskImager to write the image to the SD card. The tool can be downloaded from https://sourceforge.net/projects/win32diskimager/files/latest/download</p> <p> </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#configure-serial-connection","title":"Configure Serial Connection","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, the SoC EDS Pro installer automatically installs the required drivers if necessary. </p> <p>The serial communication parameters are: </p> <ul> <li>Baud-rate: 115,200 </li> <li>Parity: none </li> <li>Flow control: none </li> <li>Stop bits: 1 </li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus. </p> <p>On Linux, the minicom utility can be used. Here is how to configure it: </p> <p>1. The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following: </p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB* </li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet. </li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared. </li> <li>Install minicom application on host PC, if not installed. </li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom </li> <li>Configure minicom. </li> </ul> <pre><code>$ sudo minicom -s </code></pre> <p>Under Serial Port Setup choose the following: </p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary) </li> <li>Bps/Par/Bits: 115200 8N1 </li> <li>Hardware Flow Control: No </li> <li>Software Flow Control: No </li> <li>Hit [ESC] to return to the main configuration menu </li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit. </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#boot-linux_1","title":"Boot Linux","text":"<p>1. Make sure to have the SD card inserted in the board slot. </p> <p>2. Start serial terminal (when using Minicom it will connect using the selected settings, for others connect manually). </p> <p>3. Set MSEL to ASx4/QSPI: </p> <p>4. Power up the board </p> <p>5. The device will be configurd, HPS will be loaded with the U-Boot SPL, which will then load ATF and U-Boot proper, then Linux will be booted. </p> <p>6. Login using 'root' and no password.</p> <p>7. Run 'ifconfig' command to determine the IP of the board: </p> <pre><code>root@agilex7dkdevagf023fa:~/intelFPGA# ifconfig eth0: flags=4163 mtu 1500 inet 192.168.1.161 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::7cac:dff:fe64:88d9 prefixlen 64 scopeid 0x20 ether 7e:ac:0d:64:88:d9 txqueuelen 1000 (Ethernet) RX packets 183 bytes 32164 (31.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 69 bytes 8864 (8.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 21 base 0x2000 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 100 bytes 8468 (8.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 100 bytes 8468 (8.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#run-sample-applications","title":"Run Sample Applications","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#prerequisites_1","title":"Prerequisites","text":"<p>1. Boot Linux on the target board as described in Booting Linux. You will not need to use the serial terminal if you plan on using ssh connection. </p> <p>2. Connect to the board using one of the following options: </p> <ul> <li>Connect using serial console, as described in Booting Linux </li> <li>Connect using ssh, as described in Connect Using SSH </li> </ul> <p>3. In serial console, or ssh client console, change current folder to be /home/root/intelFPGA. This is where the application binaries are stored. </p> <pre><code>root@agilex7dkdevagf023fa:~# cd /home/root/intelFPGA/ </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#display-hello-world-message","title":"Display Hello World Message","text":"<p>Run the following command to display the Hello World message on the console: </p> <pre><code>root@agilex7dkdevagf023fa:~/intelFPGA# ./hello Hello SoC FPGA!%ENDCOLOR </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#exercise-soft-pio-driver-for-led-control","title":"Exercise Soft PIO Driver for LED Control","text":"<p>The following green LEDs are exercised: </p> <ul> <li>USER LED0 </li> <li>USER LED1 </li> <li>USER LED2 </li> </ul> <p>Note: USER LED3 is always blinking, and cannot be controlled from software. </p> <p>1. In order to blink an LED in a loop, with a specific delay in ms, run the following command: </p> <pre><code>./blink &lt;led_number&gt; &lt;delay_ms&gt; </code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3. </li> <li>The delay_ms is a number that specifies the desired delay in ms between turning the LED on and off. </li> </ul> <p>2. In order to turn an individual LED on or off, run the following command: </p> <pre><code>./toggle &lt;led_number&gt; &lt;state&gt; </code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3. </li> <li>The state needs to be 0 to turn the LED off, and 1 to turn the LED on. </li> </ul> <p>3. In order to scroll the FPGA LEDs with a specific delay, please run the following command: </p> <pre><code>./scroll_client &lt;delay&gt; </code></pre> <p>The delay specifies the desired scrolling behavior: </p> <ul> <li>delay &gt; 0 - specify new scrolling delay in ms, and start scrolling </li> <li>delay &lt; 0 - stop scrolling </li> <li>delay = 0 - display current scroll delay </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#system-check-application","title":"System Check Application","text":"<p>System check application provides a glance of system status of basic peripherals such as: </p> <ul> <li>USB: USB device driver </li> <li>Network IP (IPv4): Network IP address </li> <li>HPS LEDs: HPS LED state </li> <li>FPGA LEDs: FPGA LED state </li> </ul> <p>Run the application by issuing the following command: </p> <pre><code>root@agilex7dkdevagf023fa:~/intelFPGA# ./syschk </code></pre> <p>The window will look as shown below - press 'q' to exit: </p> <pre><code> ALTERA SYSTEM CHECK lo : 127.0.0.1 usb1 : DWC OTG Controller eth0 : 192.168.1.161 serial@ffc02100 : disabled fpga_led2 : OFF serial@ffc02000 : okay hps_led2 : OFF fpga_led0 : ON hps_led0 : OFF fpga_led3 : ON fpga_led1 : OFF hps_led1 : OFF </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#connect-to-board-web-server-and-ssh-client","title":"Connect to Board Web Server and SSH Client","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#connect-to-web-server","title":"Connect to Web Server","text":"<p>1. Boot Linux as described in Booting Linux. </p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be network interfaces of them, either can be used. </p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter. </p> <p> </p> <p>4. In the section named Interacting with Agilex SoC Development Kit you can perform the following actions: </p> <ul> <li>See which LEDs are ON and which are off in the LED Status. Note that if the LEDs are setup to be scrolling, the displayed scrolling speed will not match the actual scrolling speed on the board. </li> <li>Stop LEDs from scrolling, by clicking START and STOP buttons. The delay between LEDs turning ON and OFF is set in the LED Lightshow box. </li> <li>Turn individual LEDs ON and OFF with the ON and OFF buttons. Note that this action is only available when the LED scrolling/lightshow is stopped. </li> <li>Blink individual LEDs by typing a delay value in ms then clicking the corresponding BLINK button. Note that this action is only available when the LED scrolling/lightshow is stopped. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#connect-using-ssh","title":"Connect Using SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection. </p> <p> </p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS: </p> <pre><code>$ sudo yum install openssh-clients </code></pre> <p>or the following command on Ubuntu: </p> <pre><code>$ sudo apt-get install openssh-client </code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action: </p> <pre><code>ssh root@192.168.1.161 </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#rebuild-gsrd-for-dk-dev-agf023fa","title":"Rebuild GSRD for DK-DEV-AGF023FA","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub. </p> <p> </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf agilex7f_fpga.gsrd mkdir agilex7f_fpga.gsrd cd agilex7f_fpga.gsrd export TOP_FOLDER=$(pwd) </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design: </p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf023fa-soc-devkit-oobe-baseline-all\ncd .. </code></pre> <p>The following files are created: </p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf023fa_soc_devkit_oobe_baseline.sof</code> - FPGA configuration file, without HPS FSBL </li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf023fa_soc_devkit_oobe_baseline_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf023fa_soc_devkit_oobe_baseline_hps_debug.sof \\\nghrd_agfd023r24c2e1vc.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFD023R24C2E1VC \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfd023r24c2e1vc.hps.jic\n</code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/ghrd_agfd023r24c2e1vc.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric </li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes. </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container. </p> <p>2. Clone the Yocto script and prepare the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga cd gsrd-socfpga . agilex7_dk_dev_agf023fa-gsrd-build.sh\nbuild_setup </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes: </p> <ul> <li>agilex7_dk_dev_agf023fa_gsrd_ghrd.core.rbf - core rbf file for configuring the fabric </li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location: </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_dev_agf023fa_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd_agfd023r24c2e1vc.core.rbf $CORE_RBF </code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location: </p> <pre><code>SRC_URI:agilex7_dk_dev_agf023fa ?= \"\\ \n${GHRD_REPO}/agilex7_dk_dev_agf023fa_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_dev_agf023fa_gsrd_core\\ \n \" </code></pre> <p>to look like this: </p> <pre><code>SRC_URI:agilex7_dk_dev_agf023fa ?= \"\\ \n file://agilex7_dk_dev_agf023fa_gsrd_ghrd.core.rbf \\ \n \" </code></pre> <p>using the following commands: </p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_dev_agf023fa_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_dev_agf023fa_gsrd_core\" NEW_URI=\"file:\\/\\/agilex7_dk_dev_agf023fa_gsrd_ghrd.core.rbf\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>3. In the same Yocto recipe update the SHA256 checksum for the file: </p> <pre><code>SRC_URI[agilex7_dk_dev_agf023fa_gsrd_core.sha256sum] = \"e11a2068f96882a07c6ad7c3614ab6f53a5122834e58defd0a975a61ac176ccf\" </code></pre> <p>by using the following commands: </p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_SHA=\"SRC_URI\\[agilex7_dk_dev_agf023fa_gsrd_core\\.sha256sum\\] = .*\" NEW_SHA=\"SRC_URI[agilex7_dk_dev_agf023fa_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_SHA/$NEW_SHA/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>: </p> <ul> <li>uboot.txt - distroboot script </li> <li>uboot_script.its - its file for creating FIT image from the above script </li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>: </p> <ul> <li>fit_kernel_agilex7_dk_dev_agf023fa.its - its file for creating the kernel.itb image </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#build-yocto","title":"Build Yocto","text":"<pre><code>bitbake_image </code></pre> <p>Gather files: </p> <pre><code>package </code></pre> <p>Once the build is completed successfully, you will see the following two folders are created: </p> <ul> <li><code>agilex7_dk_dev_agf023fa-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build </li> <li><code>agilex7_dk_dev_agf023fa-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_dev_agf023fa-gsrd-rootfs/tmp/deploy/images/agilex7_dk_dev_agf023fa/</code> folder, but also other relevant files. </li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex-gsrd-images</code> folder are: </p> File Description sdimage.tar.gz SD Card Image, to be written on SD card u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file, to be used for generating the bootable SOF file"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#create-jic-file","title":"Create JIC File","text":"<p>The bootable JIC image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf023fa_soc_devkit_oobe_baseline.sof \\\nghrd_agfd023r24c2e1vc.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_dev_agf023fa-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFD023R24C2E1VC \\\n-o mode=ASX4 \\\n-o hps=1 </code></pre> <p>The following files will be created: </p> <ul> <li>$TOP_FOLDER/ghrd_agfd023r24c2e1vc.hps.jic - JIC file to configure the device for HPS first, phase 1 </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/gsrd/ug-gsrd-agx7f-fpga/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/","title":"Nios\u00ae V/g TinyML LiteRT for Microcontroller Design","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#nios-vg-tinyml-litert-example-design-overview","title":"Nios\u00ae V/g TinyML LiteRT Example Design Overview","text":"<p>This design demonstrates the TinyML application using LiteRT for microcontrollers software with Nios\u00ae V/g processor in the  Agilex\u00ae 7 FPGA F-Series Development Kit P-Tile and E-Tile DK-DEV-AGF014EA.</p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#prerequisites","title":"Prerequisites","text":"<ul> <li>Agilex\u00ae 7 FPGA F-Series Development Kit, ordering code DK-DEV-AGF014EA. Refer to the board documentation for more information about the development kit.</li> <li>Mini and Micro USB Cable. Included with the development kit.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#binaries","title":"Binaries","text":"<ul> <li>Prebuilt binaries are located here.</li> <li>The sof and elf files required to run the design can be found in \"ready_to_test\" folder </li> <li>Program the sof and download the elf file on board</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#nios-vg-tinyml-litert-design-archiecture","title":"Nios\u00ae V/g TinyML LiteRT Design Archiecture","text":"<p>This example design includes a Nios\u00ae V processor connected to the On Chip RAM-II, JTAG UART IP and System ID peripheral core. The objective of the design is to accomplish data transfer between the processor and soft IP peripherals.</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#nios-vg-processor","title":"Nios\u00ae V/g Processor","text":"<ul> <li>General-Purpose Processor- High Performance (For interrupt driven baremetal and RTOS code)</li> <li>Nios\u00ae V/g processor is highly customizable and can be tailored to meet specific application requirements, providing flexibility and scalability in embedded system designs.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#ip-cores","title":"IP Cores","text":"<p>The following IPs are used in this Platform Designer component of the design: - Nios\u00ae V/g soft processor core</p> <ul> <li>On Chip RAM-II</li> </ul> <ul> <li>JTAG UART</li> </ul> <ul> <li>System ID</li> </ul> <ul> <li>Clock Bridge, Reset Controller</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#hardware-setup","title":"Hardware Setup","text":"<p>Refer to Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit User Guide to setup the hardware connection.</p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#nios-v-address-map","title":"Nios V Address Map","text":"Address Offset Size (Bytes) Peripheral Description 0x0 12M On-Chip RAM To store application 0x0101_0048 8 JTAG UART Communication between a host PC and the Nios V processor system 0x0101_0040 8 System ID Hardware configuration system ID (0x00000009)"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on use case. </p>  User Flow 1: Testing with Prebuild Binaries.  User Flow 2: Testing Complete Flow. User Flow Description Required for User flow 1 Required for User flow 2 Environment Setup Tools Download and Installation Yes Yes Compilation Hardware compilation No Yes Software compilation No Yes Programing Program Hardware Binary SOF Yes Yes Program Software Image ELF Yes Yes Testing Open JTAG UART Terminal Yes Yes"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#tools-download-and-installation","title":"Tools Download and Installation","text":"<ol> <li>Quartus Prime Pro</li> </ol> <ul> <li>Download the Quartus\u00ae Prime Pro Edition software version 25.1 from the FPGA Software Download Center webpage of the Intel website. Follow the on-screen instructions to complete the installation process. Choose an installation directory that is relative to the Quartus\u00ae Prime Pro Edition software installation directory.</li> <li>Set up the Quartus tools in the PATH, so they are accessible without full path. <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/25.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#compilation","title":"Compilation","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#hardware-compilation","title":"Hardware Compilation","text":"<ul> <li>Invoke the <code>quartus_py</code> shell in the terminal</li> <li>Run the following command in the terminal from top level project directory:</li> </ul> <pre><code>quartus_py ./scripts/build_sof.py\n</code></pre> <ul> <li>The quartus tool will compile the design and generate the output files</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#software-compilation","title":"Software Compilation","text":"<ul> <li>To create software app, run the following commands in the terminal: <pre><code>niosv-bsp -c --quartus-project=hw/niosv_tinyml.qpf --qsys=hw/sys.qsys --type=hal --bsp-dir=sw/tflite_bsp --script=sw/bsp_script.tcl sw/tflite_bsp/settings.bsp\nniosv-app -b=sw/tflite_bsp -a=sw/tflite_app -S=sw/tflite_app/image_classification/,sw/tflite_app/image_classification/model/,sw/tflite_app/signal,sw/tflite_app/tensorflow,sw/tflite_app/tensorflow/lite/,sw/tflite_app/tensorflow/lite/c/,sw/tflite_app/tensorflow/lite/core/api/,sw/tflite_app/tensorflow/lite/kernels/,sw/tflite_app/tensorflow/lite/kernels/internal,sw/tflite_app/tensorflow/lite/kernels/internal/reference/,sw/tflite_app/tensorflow/lite/kernels/internal/reference/integer_ops,sw/tflite_app/tensorflow/lite/micro,sw/tflite_app/tensorflow/lite/micro/kernels/,sw/tflite_app/tensorflow/lite/micro/memory_planner,sw/tflite_app/tensorflow/lite/schema --incs=sw/tflite_app,sw/tflite_app/image_classification,sw/tflite_app/image_classification/model/,sw/tflite_app/tensorflow,sw/tflite_app/tensorflow/lite,sw/tflite_app/third_party/flatbuffers/include,sw/tflite_app/third_party/gemmlowp,sw/tflite_app/third_party/kissfft,sw/tflite_app/third_party/ruy\ncmake -S sw/tflite_app -B sw/tflite_app/build/Release -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release\nmake -C sw/tflite_app/build/Release\n</code></pre> Note:The software can be compiled using the Ashling Visual Studio Code Extension for Altera FPGAs</li> </ul> <p>For information on the build process, please refer to the following document- Ashling VSCode Extension</p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#programing","title":"Programing","text":"<p>Note: Reduce the JTAG clock frequency to 6MHz using the following command, before programming the sof file <pre><code>jtagconfig --setparam 1 JtagClock 6M\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#program-hardware-binary-sof","title":"Program Hardware Binary SOF","text":"<ul> <li>Program the generated sof and then download the elf file on the board</li> </ul> <pre><code>quartus_pgm --cable=1 -m jtag -o 'p;ready_to_test/niosv_tinyml.sof'\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#program-software-image-elf","title":"Program Software Image ELF","text":"<ul> <li>Download the elf file on the board <pre><code>niosv-download -g ready_to_test/tflite_app.elf -c 1\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#testing","title":"Testing","text":""},{"location":"embedded-designs/agilex-7/f-series/fpga/niosv/niosv_g/tinyml_liteRT/ug-tinyml-litert-agx7f-fpga/#open-jtag-uart-terminal","title":"Open JTAG UART Terminal","text":"<ul> <li>Verify the output on the terminal by using the following command in the terminal:</li> </ul> <pre><code>juart-terminal -c 1 -i 0 \n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/","title":"HPS GHRD Linux Boot Tutorial Example Design: Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#intro","title":"Intro","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The key differences versus the GSRD are:</p> <ul> <li>Fabric is configured from U-Boot directly with the rbf file, with <code>fpga load</code> command, instead of using the <code>bootm</code> command with the core.rbf part of the kernel.itb file</li> <li>Single image boot is disabled in U-Boot, and it boots directly with the slected boot source, not trying them all</li> <li>The applications and drivers form <code>meta-intel-fpga-refdes</code> are not included. That includes acessing GPIOs in the fabric for LEDs, pushbuttons, dip switches, the webserver running on the board, etc.</li> </ul> <p>The examples provided in this page are focus on the Agilex\u2122 7 Transceiver-SoC Development kit P-Tile/E-Tile production (DK-SI-AGF014EB) which uses a Linear power regulators. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p> <p>Starting with SoC EDS Pro version 19.3, the following changes were made: The bootloader source code was removed from SoC EDS. Instead, the user needs to clone the git trees from https://github.com/altera-fpga/u-boot-socfpga.</p> <p>The same U-Boot branch is used for all SoC FPGA devices: Cyclone\u00ae V SoC, Arria\u00ae V SoC, Arria\u00ae 10 SoC, Stratix\u00ae 10 SoC, Agilex\u2122 7 and Agilex\u2122 5.</p> <p>Starting with Quartus\u00ae Pro 20.3, the SoC EDS was discontinued, and the functionality of the tools which were previously part of SoC EDS are provided separately.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#u-boot-build-flow","title":"U-Boot Build Flow","text":"<p>For Stratix\u00ae 10, Agilex\u2122 7 and Agilex\u2122 5 devices, all the handoff information created by the Quartus\u00ae Pro compilation is part of the configuration bitstream. The bsp-editor is not used, and the bootloader build flow does not depend on the Quartus\u00ae Pro outputs.</p> <p> </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#single-boot-image","title":"Single Boot Image","text":"<p>Starting with U-Boot 2021.07, the following changes were made to enable a single set of binaries to be used with multiple boards and hardware projects:</p> <ul> <li>The Quartus\u00ae hardware project defines a JTAG User Code which is used by the rest of the system as a board_id to indentify the hardware.</li> <li>U-Boot has a single defconfig enabling all possible HPS hardware, and depending on the timeouts to determine which hardware is not actually available.</li> <li>U-Boot has a single device tree FIT file enabling all possible HPS hardware, but with different configurations inside, selected according to the board_id.</li> <li>Linux FIT file also has a different configuration for each board_id. Each configuration includes the kernel, the specific device file, and an optional core.rbf file. If the core.rbf file is specified, the fabric is configured with that file.</li> </ul> <p>Refer to Single Image Boot for more details about this feature.</p> <p>The Agilex\u2122 7 GSRDs are also updated to use this feature. See the GSRD documentation for details:</p> <ul> <li>Agilex\u2122 7 F-Series SoC Development Kit GSRD User Guide (P-Tiles &amp; E-Tiles)</li> <li>GSRD for Agilex 7 F-Series FPGA DevKit (2x F-Tile)</li> <li>Agilex\u2122 7 I-Series FPGA Development Kit GSRD User Guide</li> <li>Agilex\u2122 7 M-Series HBM2e Development Kit GSRD User Guide</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#u-boot-branches","title":"U-Boot Branches","text":"<p>The official Intel SOCFPGA U-Boot repository is located at https://github.com/altera-fpga/u-boot-socfpga.</p> <p>Notes:</p> <ul> <li>A \"RC\" labeled branch is for internal active development use and customer early access without official customer support.</li> <li>Latest stable branch (no RC labeled) is strongly recommended for development and production use outside of Intel.</li> <li>See doc/README.socfpga for Quartus\u00ae Pro and Device support.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#u-boot-to-linux-boot-booting-from-sdcard-example","title":"U-Boot to Linux Boot - Booting From SDCard Example","text":"<p>This example shows a simple example of the U-Boot to Linux boot flow, booting Agilex\u2122 7 device  from SD card.</p> <p>Note the following:</p> <ul> <li>Hardware design was customized as follows:      -Disable SGMII and PR to reduce boot time    </li> </ul> <ul> <li>U-Boot was customized as follows:      - Disable NAND in the unified defconfig file, as we do not need it.      - Boot only from SD card, as opposed to trying SD, QSPI and NAND.      - Use Dwarf4 for debug information, to be compatible with current Arm DS debugger.      - Configure FPGA fabric from boot command using fpga load command explicitly (instead of using the bootm command to do it).      - Use booti command to boot Linux, with separate files for kernel and device tree. </li> </ul> <p>The above customizations may be useful for debugging purposes for example.</p> <p>The following build instructions produce a QSPI(.jic) and an SDCard Image (.img) which includes the components indicated in the following figure:</p> <p></p> <p>This example uses building U-Boot manually. See Agilex\u2122 7 F-Series SoC Development Kit GSRD User Guide (P-Tiles &amp; E-Tiles) for the full fledged booting from SD card example, where U-Boot is built through Yocto recipes.</p> <p>This example, and the current GSRD release target the production version of the Intel Agilex\u2122 7 F-Series Transceiver-SoC Development Kit. You can confirm you have a production version of the board by checking that it's serial number, on a sticker on the back of the board, is greater than AGF61SI0000576. Refer to https://www.intel.com/content/www/us/en/products/details/fpga/development-kits/agilex/f-series-transceiver.html for more details about the board.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Host machine running Linux. Ubuntu 22.04 was used, but other versions may work too.</li> <li>Internet connection to download the tools and clone the U-Boot git tree from github. If you are behind a firewall you will need your system administrator to enable you to get to the git trees.</li> <li>Agilex\u2122 7 Transceiver-SoC Development kit P-Tile E-Tile production (DK-SI-AGF014EB).</li> <li>Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> <p>Note that the examples presented on this page boot to Linux and they require Linux kernel, device tree and rootfilesystem to boot. However, you can omit the Linux binaries and just boot to U-Boot prompt if you want to.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#setting-up-environment","title":"Setting Up Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex7UbootToLinux.sdmmc\nmkdir agilex7UbootToLinux.sdmmc &amp;&amp; cd agilex7UbootToLinux.sdmmc export set TOP_FOLDER=`pwd` </code></pre> <p>Download and setup the the toolchain as follows:</p> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-hardware-design","title":"Build Hardware Design","text":"<pre><code>cd $TOP_FOLDER\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>After building the hardware design the following binary is created:</p> <ul> <li>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-arm-trusted-firmware","title":"Build Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware cd arm-trusted-firmware make bl31 PLAT=agilex cd .. </code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-u-boot","title":"Build U-Boot","text":"<pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga\n# enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin .\n\n# Create configuration custom file.\ncat &lt;&lt; EOF &gt; config-fragment-agilex\n# Use 'Image' for kernel image instead of 'kernel.itb'\nCONFIG_BOOTFILE=\"Image\"\n# - Disable NAND/UBI related settings from defconfig.\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# - Disable distroboot and use specific boot command.\nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; bridge disable;fpga load 0 \\${loadaddr} \\${filesize};bridge enable; setenv bootfile Image; run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# Enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex_defconfig\n# Use created custom configuration file to merge with the default configuration obtained in .config file.\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex\nmake -j 64\ncd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file. </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries. </li> </ul> <p>Note: The following commands are ran before starting Linux:</p> <ul> <li>run linux_qspi_enable: This passes the QSPI reference clock value to Linux. See QSPI Reference Clock section..</li> <li>run rsu_status: This performs some RSU operations that must be done before booting Linux. Only needed when enabling RSU. See: Agilex\u2122 7 HPS Remote System Update User Guide.</li> </ul> <p>Important: If the fabric is already configured, before running the 'fpga load' command, you must first run the 'bridge disable' command as shown in the above example. If the fabric is not already configured, the command will fail without any adverse effects.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#prepare-qspi-image","title":"Prepare QSPI Image","text":"<pre><code>quartus_pfg -c \\\nagilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following binaries are created:</p> <ul> <li>$TOP_FOLDER/ghrd.hps.jic - Image to be flashed in the QSPI device</li> <li>$TOP_FOLDER/ghrd.core.rbf - Phase2 fabric design</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#building-linux-kernel","title":"Building Linux Kernel","text":"<p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR  https://github.com/altera-fpga/linux-socfpga linux-socfpga\ncd linux-socfpga\nmake clean &amp;&amp; make mrproper\nmake defconfig\n# enable kernel debugging with RiscFree\n./scripts/config --set-val CONFIG_DEBUG_INFO  y\n./scripts/config --set-val CONFIG_GDB_SCRIPTS y\nmake oldconfig\nmake -j 64 Image dtbs\n</code></pre> <p>The following items are built in $TOP_FOLDER:</p> <ul> <li>linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb</li> <li>linux-socfpga/arch/arm64/boot/Image</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#building-yocto-rootfs","title":"Building Yocto Rootfs","text":"<p>This section presents how to build the Linux rootfs using Yocto recipes. Note that the yocto recipes actually build everything, but are only interested in the rootfs.</p> <p>First, make sure you have Yocto system requirements met: https://docs.yoctoproject.org/3.4.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar   https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf  echo 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver devmem2\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-sd-card-image","title":"Build SD Card Image","text":"<p>The following commands can be used to create the SD card image used in this example.</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir sdfs &amp;&amp;  cd sdfs\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb .\ncp $TOP_FOLDER/ghrd.core.rbf .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\nsudo rm -rf lib/modules/*\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P sdfs/*,num=1,format=fat32,size=56M \\\n-P rootfs/*,num=2,format=ext3,size=56M \\\n-s 128M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following items are included in the rootfs on the SD card. </p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel</li> <li>Linux device tree</li> <li>Linux Root File System</li> <li>Phase2 Fabric design</li> </ul> <p>After completting the binaries build, the following files will be needed to boot Linux:</p> <ul> <li>$TOP_FOLDER/ghrd.hps.jic</li> <li>$TOP_FOLDER/sd_card/sdcard.img</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#boot-linux","title":"Boot Linux","text":"<p>Write SD card image to SD card and insert it in the slot.</p> <p>1) Set MSEL to JTAG   2) Write the QSPI flash image:</p> <p>Use Quartus\u00ae Pro Programmer to program the QSPI flash:     <pre><code>cd $TOP_FOLDER/flash_image/\nquartus_pgm -m jtag -o \"pvi;./ghrd.hps.jic\"\n</code></pre>   3) Set MSEL to QSPI and power cycle the board. Linux will boot, log in with 'root' as username.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#other-examples","title":"Other Examples","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#boot-from-qspi","title":"Boot from QSPI","text":"<p>See  Agilex\u2122 7 Boot From QSPI</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#boot-with-nand-storage-on-hps","title":"Boot with NAND Storage on HPS","text":"<p>See Agilex\u2122 7 Boot From NAND</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#boot-with-emmc-storage-on-hps","title":"Boot with eMMC Storage on HPS","text":"<p>See HPS eMMC Boot Example</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#running-u-boot-with-the-debugger-from-command-line","title":"Running U-Boot with the Debugger from Command Line","text":"<p>This section presents examples of how to run U-Boot with the Arm Development Studio from command line. This offers a simple and convenient way to run U-Boot and use it for example to program onboard flash.</p> <p>1.- Use the binaries built for the U-Boot to Linux Boot - Booting From SDCard Example:   <pre><code>cd agilex7UbootToLinux.sdmmc\n</code></pre></p> <p>2.-  Run jtagconfig command to determine if the HPS is currently in the JTAG scanchain:   <pre><code>jtagconfig\n1) Agilex SI/SoC Dev Kit [3-4.3.4]\n  6BA00477   S10HPS/AGILEX_HPS\n  0341A0DD   AGFB014(F25A|R24AR0)\n</code></pre>   If HPS is not present, the line with S10HPS/AGILEX_HPS above will not appear.</p> <p>3.- Configure the FPGA with the debug SOF:   <pre><code> quartus_pgm -c 1 -m jtag -o \"p;@2\"\n</code></pre>   If the HPS is not present in the jtagconfig output above, please remove the \"agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof@2\" from the command line above.</p> <p>4.-  Create debugger script:   <pre><code>cat &lt;&lt;EOT &gt; run-u-boot.ds\ninterrupt\nrestore \"u-boot-socfpga/spl/u-boot-spl-dtb.bin\" binary 0xFFE00000\nloadfile \"u-boot-socfpga/spl/u-boot-spl\"\ncore 1\nset \\$PC = \\$ENTRYPOINT\ncore 2\nset \\$PC = \\$ENTRYPOINT\ncore 3\nset \\$PC = \\$ENTRYPOINT\ncore 0\nset \\$PC = \\$ENTRYPOINT\nthbreak board_boot_order\ncontinue\nwait\nset spl_boot_list[0]=0\nset \\$PC=\\$LR\nrestore \"u-boot-socfpga/u-boot.itb\" binary 0x2000000\ncontinue\nEOT\n</code></pre>   5.- Run the debugger from command line, using the connection parameters reported above by jtagconfig, shown in red below:   <pre><code>/opt/arm/developmentstudio-2022.2/bin/armdbg  \\\n--cdb-entry=\"Intel SoC FPGA::Agilex 7 SoC::Bare Metal Debug::Bare Metal Debug::Cortex-A53x4 SMP::Intel FPGA Download Cable\"  \\\n--cdb-entry-param=\"rvi_address=Agilex SI/SoC Dev Kit on localhost [3-4.3.4]:Agilex SI/SoC Dev Kit 3-4.3.4\"  \\\n--continue_on_error=true \\\n--stop_on_connect=false \\\n-s run-u-boot.ds\n</code></pre>   6.- The serial console will show SPL then U-Boot being run:   <pre><code>U-Boot SPL 2025.04-35102-g135e53726d-dirty (Jan 29 2025 - 11:04:08 -0600)\nReset state: Cold\nMPU          1200000 kHz\nL4 Main         400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nDDR: 8192 MiB\nSDRAM-ECC: Initialized success with 1715 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 \u2026 OK\n## Checking hash(es) for Image atf \u2026 crc32+ OK\n## Checking hash(es) for Image uboot \u2026 crc32+ OK\n## Checking hash(es) for Image fdt-0 \u2026 crc32+ OK\nNOTICE:  BL31: v2.12.1(release):QPDS25.1.1_REL_GSRD_PR\nNOTICE:  BL31: Built : 11:03:24, Jan 29 2025\n\nU-Boot 2025.04-35102-g135e53726d-dirty (Jan 29 2025 - 11:04:08 -0600)socfpga_agilex\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Agilex SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  28 devices, 23 uclasses, devicetree: separate\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:   \nWarning: ethernet@ff800000 (eth0) using random MAC address - 96:09:0f:73:d5:f5\neth0: ethernet@ff800000\nHit any key to stop autoboot:    \nSOCFPGA_AGILEX #\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#debugging-u-boot-with-arm-ds-eclipse","title":"Debugging U-Boot with Arm DS Eclipse","text":"<p>This section presents examples of how to debug U-Boot with from the Arm Development Studio Eclipse-based GUI.</p> <p>### Prerequisites  1.- Use the binaries built for the U-Boot to Linux Boot - Booting From SDCard Example:   <pre><code>cd agilex7UbootToLinux.sdmmc\n</code></pre></p> <p>2.- Run jtagconfig to determine if the HPS is currently in the JTAG scanchain:   <pre><code>jtagconfig\n1) Agilex SI/SoC Dev Kit [3-4.3.4]\n  6BA00477   S10HPS/AGILEX_HPS\n  0341A0DD   AGFB014(F25A|R24AR0)\n</code></pre></p> <p>If HPS is not present, the line with S10HPS/AGILEX_HPS above will not appear.</p> <p>3.- Configure the FPGA with the debug SOF:   <pre><code>  quartus_pgm -c 1 -m jtag -o \"p;agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof@2\"\n</code></pre></p> <p>If the HPS is not present in the jtagconfig output above, please remove the \"@2\" from the command line above.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#debugging-spl","title":"Debugging SPL","text":"<p>1.- Run the steps from Prerequisites section   2.- Start the Arm Development Studio Eclipse-based GUI:   <pre><code>/opt/arm/developmentstudio-2022.2/bin/armds_ide -data workspace &amp;\n</code></pre></p> <p>Note the above creates a new workspace in the agilex7UbootToLinux.sdmmc folder.   3.- In Eclipse, Go to Run &gt; Debug Configurations to open the Debug Configurations window.    4.- In the Debug Configurations window:    a) Select the Generic Arm C/C++ Application on the left panel and right-click it. From the menu that appears, select New Configuration.   b) Edit the Name field from New_configuration to something more descriptive, such as Debug Agilex 7 Bootloader.</p> <p>5.- In the Connection tab:   a) Go to Select target section and select Intel SoC FPGA &gt; Agilex &gt; Bare Metal Debug &gt; Cortex-A53x4 SMP   b) Select the Target Connection to be Intel FPGA Download Cable   c) Click the Bare Metal Debug &gt; Connection Browse button and select your cable.</p> <p>The Debug Configurations window should now look like this:    </p> <p>6.- Go to the Debugger tab, and do the following:   a) Select Connect Only   b) Check Execute debugger commands and enter the following commands:</p> <pre><code>```\ninterrupt\nrestore \"u-boot-socfpga/spl/u-boot-spl-dtb.bin\" binary 0xFFE00000\nloadfile \"u-boot-socfpga/spl/u-boot-spl\"\nset $PC = $ENTRYPOINT\n```\n</code></pre> <p>c) Uncheck Host working directory &gt; Use default and edit the value to add \"/../\" so that it looks in the parent folder of the workspace.</p> <p>The Debug Configurations window should now look like this:</p> <p></p> <p>7.- Click the Debug button. Arm Development Studio will run the commands, therefore downloading the SPL to board and starting it. The Eclipse window should now look like this: </p> <p></p> <p>8.- At this point you can use standard debug techniques to debug U-Boot SPL: viewing registers, variables, putting breakpoints, running step-by-step etc.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#debugging-u-boot","title":"Debugging U-Boot","text":"<p>1.- Run the steps from Prerequisites section   2.- Create the Debug Agilex Bootloader debug configuration as described in Debugging SPL section.   3.- Change the Execute debugger commands box to contain the following commands:</p> <p><pre><code>interrupt\nrestore \"u-boot-socfpga/spl/u-boot-spl-dtb.bin\" binary 0xFFE00000\nloadfile \"u-boot-socfpga/spl/u-boot-spl\"\nthb board_boot_order\ncore 1\nset $PC = $ENTRYPOINT\ncore 2\nset $PC = $ENTRYPOINT\ncore 3\nset $PC = $ENTRYPOINT\ncore 0\nset $PC = $ENTRYPOINT\ncontinue\nwait 60s\nset spl_boot_list[0]=0\nset $PC=$LR\nrestore \"u-boot-socfpga/u-boot.itb\" binary 0x2000000\nthb el3:0x1000\ncontinue\nwait 60s\nsymbol-file \"u-boot-socfpga/u-boot\"\nthb el2:relocate_code\ncontinue\nwait 60s\nsymbol-file \"u-boot-socfpga/u-boot\" ((gd_t*)$x18)-&gt;reloc_off\nthb board_init_r\ncontinue\nwait 60s\n</code></pre>   What the above does is:   a) Load and run SPL   b) Make SPL report boot from RAM was selected    c) Load ATF+U-Boot image and run it up until U-Boot starts running   d) Load U-Boot symbols   e) Run U-Boot until the relocation routine is called   f) Relocate the U-Boot symbols   g) Run U-Boot until the board_init_r function</p> <p>4.-  Click on the Debug button. All the above will be executed, and Eclipse will show the code stopped at board_init_r function. The Eclipse window should look like this:</p> <p></p> <p>5.- At this point you can use standard debug techniques to debug U-Boot SPL: viewing registers, variables, putting breakpoints, running step-by-step etc.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#direct-atf-to-linux-boot-flow","title":"Direct ATF to Linux Boot Flow","text":"<p>Starting from 24.2 release, the Agilex\u2122 7 device is provided with the support of direct booting from ATF to Linux. In this boot flow, ATF acts as a First Stage Bootloader (BL2) and also as a Second Stage Bootloader (BL31). This last one is in charge of loading and launching Linux OS, so U-Boot is not used in this boot flow.</p> <p></p> <p>In this boot flow, the BL2 (FSBL) is included in the bitstream together with the SDM FW and hardware design (first phase only in HPS boot first mode). When booting from QSPI, this bitstream is stored in the QSPI memory. In this boot flow, the BL31 (SSBL) is packed with the Linux kernel and device tree into a FIP format image. This format provides to ATF the information about the components included in the image in a partition header. The resulting FIP image is added to the final flash image used to boot from (QSPI or SDCard). </p> <p>When creating the flash image, it's necessary to provide the location in where ATF expects to find the FIP image (fip.bin). This is hardcoded in the ATF code (plat/intel/soc/common/include/platform_def.h) for each one of the flash devices in which this boot flow is supported as indicated in the next table:</p> Flash Device Definition Location in Flash device QSPI PLAT_QSPI_DATA_BASE 0x3C00000 SDCard PLAT_SDMMC_DATA_BASE 0x0 <p>NOTE: Direct ATF to Linux boot flow from NAND/eMMC is not supported for Agilex 7 devices.</p> <p>The following sections provide instructions about how to generate the binaries to exercise this boot flow booting from an SDcard and QSPI devices. The instructions provided to build the binaries to boot form SD Card and boot from QSPI are expected to be executed togheter, so you need to build these starting from the steps to generate the SD Card binaries.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#atf-to-linux-from-sd-card","title":"ATF to Linux from SD Card","text":"<p>The following recipe provides all the steps needed to create the binaries that allow you to exercise the ATF to Linux boot flow from a SD Card device. The recipe includes building the hardware design, ATF (BL2, BL31), Linux file system, and Linux. These are some notes about the build instructions:</p> <ul> <li>Excercise the HPS boot first flow.</li> <li>When building ATF, we indicate the device used to boot from. We also indicate the SDRAM memory locations where the Linux kernel image and device tree will be loaded and launched from. In this boot flow, Linux is referred to as BL33.</li> <li>The FIP image (fip.bin) is created using the ATF fiptool, indicating the binaries that integrate this image.</li> <li>The SD Card created will include 2 partitions. One in which the fip.bin file is located (raw format and type A2) and the other for the file system (ext3 format).</li> <li> <p>If wanted to perform FPGA configuration (2nd phase from Linux) from Linux create overlays.dtb as indicated in Agilex\u2122 7 SoC Fabric Configuration from Linux Example</p> <p></p> </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#toolchain-setup-atf-to-linux","title":"Toolchain Setup (ATF-To-Linux)","text":"<pre><code>sudo rm -rf atfToLinux_sdcard_qspi\nmkdir atfToLinux_sdcard_qspi &amp;&amp; cd atfToLinux_sdcard_qspi\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-hardware-design-atf-to-linux","title":"Build Hardware Design (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-arm-trusted-firmware-for-sdcard-atf-to-linux","title":"Build Arm Trusted Firmware for SDCard (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware-sdcard\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware arm-trusted-firmware-sdcard\ncd arm-trusted-firmware-sdcard make realclean\n# Setting Bootsource as SDMMC\nmake bl2 bl31 PLAT=agilex ARM_LINUX_KERNEL_AS_BL33=1 SOCFPGA_BOOT_SOURCE_SDMMC=1 PRELOADED_BL33_BASE=0x02000000 ARM_PRELOADED_DTB_BASE=0x10000000 # Create Fiptool tool\nmake -C tools/fiptool clean\nmake fiptool\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware-sdcard/build/agilex/release/bl2.bin</li> <li>$TOP_FOLDER/arm-trusted-firmware-sdcard/build/agilex/release/bl31.bin</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-linux-file-system-atf-to-linux","title":"Build Linux File System  (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'IMAGE_FSTYPES = \"tar.gz cpio jffs2\"' &gt;&gt; conf/local.conf\n# enable ssh and gdb access\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver devmem2\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz</li> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.jffs2</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-linux-for-sdcard-atf-to-linux","title":"Build Linux for SDCard (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga linux-socfpga-sdcard\ncd linux-socfpga-sdcard\n\n# Replace bootargs to use file system from SDcard instead of RAMFS (New device tree will be provided later 14023675777)\nsed -i 's/bootargs/bootargs_old/g' arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dts\nsed -i '/bootargs_old/i \\\\t\\tbootargs = \"earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait\";' arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dts\nsed -i '/bootargs_old/,+2d' arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dts\n## Disabling GMAC (14023884834)\necho -e \"&amp;gmac0 {\\n\\tstatus = \\\"disabled\\\";\\n};\" &gt;&gt; arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dts\n\ncat &lt;&lt; EOF &gt; config-fragment-agilex\n# enable kernel debugging with RiscFree\nCONFIG_DEBUG_INFO=y\nCONFIG_GDB_SCRIPTS=y\nCONFIG_INITRAMFS_ROOT_UID=0\nCONFIG_INITRAMFS_ROOT_GID=0\nCONFIG_INITRAMFS_COMPRESSION_GZIP=y\n# Include these configs if wanted to perform fpga reconfiguration using overlays (enable device tree overlays and fpga bridges)\n# Taken from https://altera-fpga.github.io/latest/embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/\nCONFIG_OF_RESOLVE=y\nCONFIG_OF_OVERLAY=y\nCONFIG_OF_CONFIGFS=y\nCONFIG_FPGA_MGR_STRATIX10_SOC=y\nCONFIG_FPGA_BRIDGE=y\nCONFIG_FPGA_REGION=y\nCONFIG_OF_FPGA_REGION=y\nCONFIG_OVERLAY_FS=y\nCONFIG_ALTERA_SYSID=y\nEOF\nmake clean &amp;&amp; make mrproper\nmake defconfig\n# Apply custom Configs in file\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex\n\nmake oldconfig\nmake -j 64 Image dtbs\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/linux-socfpga-sdcard/arch/arm64/boot/Image</li> <li>$TOP_FOLDER/linux-socfpga-sdcard/arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dtb</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-sd-card-image-with-fip-inside-atf-to-linux","title":"Build SD Card image with FIP inside (ATF-To-Linux)","text":"<pre><code>#--- Build FIP Image\ncd $TOP_FOLDER\nmkdir sd_card &amp;&amp; cd sd_card\n$TOP_FOLDER/arm-trusted-firmware-sdcard/tools/fiptool/fiptool create \\\n--soc-fw $TOP_FOLDER/arm-trusted-firmware-sdcard/build/agilex/release/bl31.bin \\\n--nt-fw $TOP_FOLDER/linux-socfpga-sdcard/arch/arm64/boot/Image \\\n--nt-fw-config $TOP_FOLDER/linux-socfpga-sdcard/arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dtb fip.bin\n\n#--- Build SDCard Image\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar -xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\nsudo rm -rf lib/modules/*\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fip.bin,num=1,format=raw,size=64M,type=a2 \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 128M -n sdimage_atf.img\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/sd_card/sdimage_atf.img</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-jic-image-for-sdcard-boot-atf-to-linux","title":"Build JIC image for SDCard Boot (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\n# Convert fsbl\naarch64-none-linux-gnu-objcopy -v -I binary -O ihex --change-addresses 0xffe00000 arm-trusted-firmware-sdcard/build/agilex/release/bl2.bin fsbl.hex\n# Create .jic file\nquartus_pfg -c agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\ndesign_atf.jic \\\n-o hps_path=fsbl.hex \\\n-o device=MT25QU128 \\\n-o flash_loader=AGFB014R24B2E2V  \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>You can exercise ATF to Linux boot flow from SD Card using the following binaries generated:</p> <ul> <li>$TOP_FOLDER/sd_card/sdimage_atf.img</li> <li>$TOP_FOLDER/design_atf.hps.jic</li> </ul> <p>When booting with the binaries generated, this is the log that you will see:   <pre><code>NOTICE:  SDMMC boot\nNOTICE:  BL2: 2.12.1(release):QPDS25.1.1_REL_GSRD_PR\nNOTICE:  BL2: Built : 11:48:31, Jan 29 2025\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: 2.12.1(release):QPDS25.1.1_REL_GSRD_PR\nNOTICE:  BL31: Built : 11:48:36, Jan 29 2025\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]\n[    0.000000] Linux version 6.12.19-lts-g346486b5245f-dirty (rolando@rolando2-linux-lab) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 11.2.1 20220111, GNU ld (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 2.37.20220122) #1 SMP PREEMPT Wed Jan 29 11:56:17 CST 2025\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000000000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000000000000..0x0000000001ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] earlycon: uart0 at MMIO32 0x00000000ffc02000 (options '115200n8')\n[    0.000000] printk: bootconsole [uart0] enabled\n\n:\nPoky (Yocto Project Reference Distro) 5.0.5 agilex7_dk_si_agf014eb /dev/ttyS0\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for\ntesting and development purposes only. It is recommended that you create your\nown distribution for production use.\n\nroot@agilex7_dk_si_agf014eb:~# \n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#atf-to-linux-from-qspi","title":"ATF to Linux from QSPI","text":"<p>This section provides instructions to build binaries to exercise ATF to Linux direct boot flow booting from a QSPI device.</p> <p>NOTE: This section depends on some steps from the ATF to Linux from SD Card section. So, to build the binaries in this section, the instructions in the following sections need to be executed earlier:</p> <ul> <li>Toolchain Setup (ATF-To-Linux)</li> <li>Build Hardware Design (ATF-To-Linux)</li> <li>Build Linux File System  (ATF-To-Linux)</li> </ul> <p>ATF requires to be rebuilt to enable booting from QSPI updating BOOT_SOURCE to BOOT_SOURCE_QSPI. Linux also need to be rebuild since this time we are including a JFFS2 file system and since booting from QSPI we need to change some parameters in the device tree. The FIP image is created in the same way but this time the FIP image is put into the QSPI image using a specific .pfg file. In this .pfg file we are indicating that the fip file will be located at 0x3C00000 location in the QSPI since this is also indicated by the PLAT_QSPI_DATA_BASE definition in the ATF.</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-arm-trusted-firmware-for-qspi-atf-to-linux","title":"Build Arm Trusted Firmware for QSPI (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\n# Building ATF\nrm -rf arm-trusted-firmware-qspi\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware arm-trusted-firmware-qspi\ncd arm-trusted-firmware-qspi\n\n# Select QSPI as boot source\nmake realclean\nmake bl2 bl31 PLAT=agilex ARM_LINUX_KERNEL_AS_BL33=1 SOCFPGA_BOOT_SOURCE_QSPI=1 PRELOADED_BL33_BASE=0x02000000 ARM_PRELOADED_DTB_BASE=0x10000000 DEBUG=0\n# Create Fiptool tool\nmake -C tools/fiptool clean\nmake fiptool\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware-qspi/build/agilex/release/bl2.bin </li> <li>$TOP_FOLDER/arm-trusted-firmware-qspi/build/agilex/release/bl31.bin</li> <li>$TOP_FOLDER/arm-trusted-firmware-qspi/tools/fiptool/fiptool</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#build-linux-for-qspi-atf-to-linux","title":"Build Linux for QSPI (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga-qspi\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga linux-socfpga-qspi\ncd linux-socfpga-qspi\n\n## Change QSPI CLK frequency to 50 MHZ to match ATF cfg (This may not be needed after 14023675777)\nsed -i  's/spi-max-frequency = &lt;100000000&gt;;/spi-max-frequency = &lt;50000000&gt;;/g' arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dts\nsed -i  's/root: partition@4200000/root: partition@7000000/g' arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dts\nsed -i  's/reg = &lt;0x04200000 0x0BE00000&gt;/reg = &lt;0x07000000 0x09000000&gt;/g' arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dts\n\n# Replace bootargs to use file system from QSPI instead of RAMFS (New device tree will be provided later 14023675777)\nsed -i 's/bootargs/bootargs_old/g' arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dts\nsed -i '/bootargs_old/i \\\\t\\tbootargs = \"earlycon panic=-1 root=/dev/mtdblock1 rw rootfstype=jffs2 rootwait\";' arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dts\nsed -i '/bootargs_old/,+2d' arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dts\n\n## Disabling GMAC (14023884834)\necho -e \"&amp;gmac0 {\\n\\tstatus = \\\"disabled\\\";\\n};\" &gt;&gt; arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dts\n\ncat &lt;&lt; EOF &gt; config-fragment-agilex\n# enable kernel debugging with RiscFree\nCONFIG_DEBUG_INFO=y\nCONFIG_GDB_SCRIPTS=y\n# Include these configs if wanted to perform fpga reconfiguration using overlays (enable device tree overlays and fpga bridges)\n# Taken from https://altera-fpga.github.io/latest/embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/  \nCONFIG_OF_RESOLVE=y\nCONFIG_OF_OVERLAY=y\nCONFIG_OF_CONFIGFS=y\nCONFIG_FPGA_MGR_STRATIX10_SOC=y\nCONFIG_FPGA_BRIDGE=y\nCONFIG_FPGA_REGION=y\nCONFIG_OF_FPGA_REGION=y\nCONFIG_OVERLAY_FS=y\nCONFIG_ALTERA_SYSID=y\n# Enabling JFFS2 File system\nCONFIG_JFFS2_FS=y\nEOF\nmake clean &amp;&amp; make mrproper\nmake defconfig\n# Apply custom Configs in file\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex\n\nmake oldconfig\nmake -j 64 Image dtbs\n</code></pre> <p>The output files from this stage are:</p> <ul> <li>$TOP_FOLDER/linux-socfpga-qspi/arch/arm64/boot/Image</li> <li>$TOP_FOLDER/linux-socfpga-qspi/arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dtb</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#create-pfg-file-for-qspi-boot-atf-to-linux","title":"Create pfg file for QSPI Boot (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\ncat &lt;&lt; EOF &gt; qspi_flash_image_agilex_boot.pfg\n&lt;pfg version=\"1\"&gt;\n  &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n  &lt;output_files&gt;\n      &lt;output_file name=\"flash_image_atf_qspi\" directory=\".\" type=\"JIC\"&gt;\n          &lt;file_options/&gt;\n          &lt;secondary_file type=\"MAP\" name=\"flash_image_atf_qspi_jic\"&gt;\n              &lt;file_options/&gt;\n          &lt;/secondary_file&gt;\n          &lt;secondary_file type=\"SEC_RPD\" name=\"flash_image_atf_qspi_jic\"&gt;\n              &lt;file_options bitswap=\"1\"/&gt;\n          &lt;/secondary_file&gt;\n          &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n      &lt;/output_file&gt;\n  &lt;/output_files&gt;\n  &lt;bitstreams&gt;\n      &lt;bitstream id=\"Bitstream_1\"&gt;\n          &lt;path hps_path=\"./fsbl.hex\"&gt;./agf014eb_si_devkit_oobe_baseline.sof&lt;/path&gt;\n      &lt;/bitstream&gt;\n  &lt;/bitstreams&gt;\n  &lt;raw_files&gt;\n      &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;fip.bin&lt;/raw_file&gt;\n      &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;rootfs.bin&lt;/raw_file&gt;\n  &lt;/raw_files&gt;\n  &lt;flash_devices&gt;\n      &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n          &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03C00000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"fip\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x07000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"Rootfs\" size=\"0\"/&gt;\n      &lt;/flash_device&gt;\n      &lt;flash_loader&gt;agfb014r24b2e2v&lt;/flash_loader&gt;\n  &lt;/flash_devices&gt;\n  &lt;assignments&gt;\n      &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n          &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n      &lt;/assignment&gt;\n      &lt;assignment page=\"0\" partition_id=\"fip\"&gt;\n          &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n      &lt;/assignment&gt;\n      &lt;assignment page=\"0\" partition_id=\"Rootfs\"&gt;\n          &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n      &lt;/assignment&gt;\n  &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n</code></pre> <p>The following file will be created:</p> <ul> <li>$TOP_FOLDER/qspi_flash_image_agilex_boot.pfg</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#create-qspi-jic-image-for-qspi-boot-atf-to-linux","title":"Create QSPI JIC image for QSPI Boot (ATF-To-Linux)","text":"<pre><code>cd $TOP_FOLDER\n# Create FIP image\n./arm-trusted-firmware-qspi/tools/fiptool/fiptool create --soc-fw arm-trusted-firmware-qspi/build/agilex/release/bl31.bin \\\n--nt-fw $TOP_FOLDER/linux-socfpga-qspi/arch/arm64/boot/Image \\\n--nt-fw-config $TOP_FOLDER/linux-socfpga-qspi/arch/arm64/boot/dts/intel/socfpga_agilex_socdk_atfboot.dtb fip.bin\n\n# Convert bl2.bin\naarch64-none-linux-gnu-objcopy -v -I binary -O ihex --change-addresses 0xffe00000 arm-trusted-firmware-qspi/build/agilex/release/bl2.bin fsbl.hex\n\n# Create the local links to .sof and rootfs\nln -s $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof .\nln -s $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.jffs2 rootfs.bin\n#Create final .jic\nquartus_pfg -c qspi_flash_image_agilex_boot.pfg\n</code></pre> <p>After building, you can use the following binary to exercise the ATF to Linux boot flow booting from QSPI:</p> <ul> <li>$TOP_FOLDER/flash_image_atf_qspi.jic</li> </ul> <p>When booting with flash_image_atf_qspi.jic, this is the log that you will see:</p> <pre><code>NOTICE:  QSPI boot\nNOTICE:  BL2: v2.12.1(release):QPDS25.1.1_REL_GSRD_PR\nNOTICE:  BL2: Built : 11:57:29, Jan 29 2025\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: v2.12.1(release):QPDS24.3_REL_GSRD_PR\nNOTICE:  BL31: Built : 11:57:34, Jan 29 2025\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]\n[    0.000000] Linux version 6.6.37-g346486b5245f-dirty (rolando@rolando2-linux-lab) (aarch64-none-linux-gnu-gcc (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 11.2.1 20220111, GNU ld (GNU Toolchain for the Arm Architecture 11.2-2022.02 (arm-11.14)) 2.37.20220122) #1 SMP PREEMPT Wed Jan 29 12:03:28 CST 2025\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000000000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000000000000..0x0000000001ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] earlycon: uart0 at MMIO32 0x00000000ffc02000 (options '115200n8')\n[    0.000000] printk: bootconsole [uart0] enabled\n\n:\nPoky (Yocto Project Reference Distro) 5.0.5 agilex7_dk_si_agf014eb /dev/ttyS0\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for\ntesting and development purposes only. It is recommended that you create your\nown distribution for production use.\n\nroot@agilex7_dk_si_agf014eb:~#\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#managing-secure-l3-registers-on-stratix-10-agilextm-and-n5x","title":"Managing Secure L3 Registers on Stratix\u00ae 10, Agilex\u2122 and N5X\u00ae","text":"<p>On Stratix\u00ae 10, Agilex\u2122 7 and N5X\u00ae HPS there are specific peripherals which are critical for system operation which can only be accessed from software running at EL3.</p> <p>The following HPS software components run at EL3 on these devices and can access Secure L3 registers:</p> <ul> <li>U-Boot SPL: initial values for the secure L3 registers are set here through the device tree 'secreg' entries. The user can customize them as needed by editing the device tree.</li> <li>Arm Trusted Firmware (ATF): Both U-Boot and Linux call the ATF SMC (Secure Monitor Call) handler to access a restricted subset of secure L3 registers needed for routine system operation.</li> </ul> <p>This section presents the following:</p> <ul> <li>How to use the 'secreg' device tree entries to customize initial secure L3 registers values set by U-Boot SPL</li> <li>How to access registers from the restricted subset from U-Boot, for debug purposes.</li> <li>How to access other secure EL3 register from U-Boot, by by changing the ATF source code to add add them to the restricted subset.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#setting-initial-values-of-secure-l3-registers","title":"Setting Initial Values of Secure L3 Registers","text":"<p>The initial values for the Secure L3 registes are set from U-Boot SPL. The register values are specified in secreg entries in the U-Boot device tree file.</p> <p>Refer to u-boot-socfpga/blob/HEAD/doc/device-tree-bindings/misc/socfpga_secreg.txt for documentation the secreg. The  socfpga_v2021.04 version shows the following:   <pre><code>* Firewall and privilege register settings in device tree\n\nRequired properties:\n--------------------\n- compatible: should contain \"intel,socfpga-secreg\"\n- intel,offset-settings: 32-bit offset address of block register, and then\n                       followed by 32-bit value settings.\nExample:\n--------\n      socfpga_secreg: socfpga-secreg {\n          compatible = \"intel,socfpga-secreg\";\n          #address-cells = &lt;1&gt;;\n          #size-cells = &lt;1&gt;;\n          u-boot,dm-pre-reloc;\n\n          i_sys_mgr@ffd12000 {\n              reg = &lt;0xffd12000 0x00000228&gt;;\n              intel,offset-settings =\n                  &lt;0x00000020 0xff010000&gt;,\n                  &lt;0x00000024 0xffffffff&gt;;\n              u-boot,dm-pre-reloc;\n          };\n      };\n</code></pre> Notes about the example:</p> <ul> <li>The u-boot,dm-pre-reloc; statement in the example informs U-Boot the driver will be loaded in SPL.</li> <li>The i_sys_mgr@ffd12000 statement in the example is informative only to enable readers to quickly see what IP is being set up, it is not actually used by the code.</li> <li>The reg =&lt;0xffd12000 0x00000228&gt; entry specifies the IP module base address 0xffd12000 and span of 0x00000228 bytes.</li> <li>The &lt;0x00000020 0xff010000&gt;, specifies that the register at offset 0x00000020 from the IP module base address will be set to value 0xff010000.</li> </ul> <p>These are the files which currently define the initial value of the Secure L3 registers:</p> <ul> <li>Common: u-boot-socfpga/arch/arm/dts/socfpga_soc64_u-boot.dtsi.</li> <li>Stratix\u00ae 10: u-boot-socfpga/arch/arm/dts/socfpga_stratix10-u-boot.dtsi.</li> <li>Agilex\u2122 7: arch/arm/dts/socfpga_agilex-u-boot.dtsi</li> <li>N5X\u00ae: u-boot-socfpga/arch/arm/dts/socfpga_n5x-u-boot.dtsi</li> </ul> <p>You can edit the above files accordingly to change the default values, or set the initial value of more registers.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#accessing-secure-l3-registers-from-u-boot-command-line","title":"Accessing Secure L3 Registers from U-Boot Command Line","text":"<p>A small subset of critical EL3 restricted access registers are made visible through the ATF SMC handler. The current list of registers is defined in arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c..</p> <p>The secure L3 registers accessible through the ATF SMC handler can also optionally be accessed from U-Boot command line for debug purposes. The feature can be enabled by setting CONFIG_CMD_SMC=y in the U-Boot configuration file.</p> <p>Once the feature is enabled, the following command will be avaible from U-Boot command line interface:</p> <p><pre><code>SOCFPGA # smc\nsmc - Issue a Secure Monitor Call\n\nUsage:\nsmc  [arg1 \u2026 arg6] [id]\n  - fid Function ID\n  - arg SMC arguments, passed to X1-X6 (default to zero)\n  - id  Secure OS ID / Session ID, passed to W7 (defaults to zero)\n</code></pre> The U-Boot environment already includes predefined ids to facilitate the usage of the command:   <pre><code>smc_fid_rd=0xC2000007\nsmc_fid_upd=0xC2000009\nsmc_fid_wr=0xC2000008\n</code></pre> The command can be used as follows:   <pre><code>smc ${smc_fid_rd} &lt;address&gt;\nsmc ${smc_fid_wr} &lt;address&gt; &lt;value&gt;\nsmc ${smc_fid_upd} &lt;address&gt; &lt;mask&gt; &lt;value&gt;\n</code></pre> See below using the new command to access the BOOT_SCRATCH_COLD0 register (note there is no need to access that register, this is just an example):</p> <p>1.- Read the register:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd12200\nRes:  0 400000 4291895808 0\n</code></pre> Note:</p> <ul> <li>First value from Res is the return code, 0 means operation succesfull.</li> <li>Second value represents the read register value in decimal 400000=0x00061a80.</li> <li>Third value is the address in decimal 4291895808=0xffd12200.</li> </ul> <p>2.- Write the register with a new value:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_wr} 0xffd12200 0x00061a81\nRes:  0 400001 4291895808 0\n</code></pre></p> <p>3.-  Read back the register to confirm it has been updated:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd12200\nRes:  0 400001 4291895808 0\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#enabling-access-to-more-secure-l3-registers-for-debug-purposes","title":"Enabling Access to more Secure L3 Registers for Debug Purposes","text":"<p>By default, only a small subset of critical EL3 restricted access registers are made visible through the ATF SMC handler. The current list of registers is defined in arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c. For debug purposes, you can add more registers to the restricted register list that can be accessed through the ATF SMC handler.</p> <p>Warning: Changing the list of EL3 restricted access registers in ATF is risky, and must be done only for debug purposes only! Do not forget to remove the code once debugging has completed!</p> <p>When trying to access a register which is not made visible by the ATF SMC handler, an error will be reported. See below example trying to read the noc_fw_soc2fpga_soc2fpga_scr register:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd21200\nRes:  4 0 4291957248 0\n</code></pre> Note:</p> <ul> <li>The non-zero (4) return code means the operation was not succesfull.</li> </ul> <p>After editing the file arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c to add this register to the list, and recompiling ATF, the operation is succesfull:</p> <p><pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd21200\nRes:  0 268304641 4291957248\n</code></pre> Note:</p> <ul> <li>Return code is zero, operation was succesfull.</li> <li>Read value is decimal 268304641=0xFFE0101.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#boot-scratch-register-usage","title":"Boot Scratch Register Usage","text":"<p>On Stratix\u00ae 10 SoC, Agilex\u2122 7 and N5X\u00ae devices, the boot scratch registers are part of the System Manager and are used to pass values between various software components. The table below summarizes the usage.</p> <p>Note:</p> <ul> <li>If no device is provided it means that it applies for all.</li> <li>If a cell is not specified for a device, then this could be used as a scratch memory.</li> </ul> Address Name Usage SDM U-Boot ATF Linux 0xFFD1 2200 boot_scratch_cold0 Bits[31] N5X. DDR retention Sets this bit Read  (is_ddr_retention_enabled) 0xFFD1 2200 boot_scratch_cold0 Bits[30:28] N5X, Agilex7M. DDR reset type Sets this field Read  (get_reset_type) 0xFFD1 2200 boot_scratch_cold0 Bits[27:0] SOC 64-bit storing qspi ref clock(kHz) Sets this field Sets value cm_set_qspi_controller_clk_hz  Reads value cm_get_qspi_controller_clk_hz 0xFFD1 2204 boot_scratch_cold1 osc1 clock freq Sets and read(cm_get_osc_clk_hz) 0xFFD1 2208 boot_scratch_cold 2 fpga clock freq Sets and read (cm_get_fpga_clk_hz) 0xFFD1 220C boot_scratch_cold3 reserved for customer use 0xFFD1 2210  0xFFD1 2214 boot_scratch_cold4  boot_scratch_cold5 Secondary CPU RELEASE ADDRESS Main core clears it (lowlevel_init) Main CPU Write (bl31_platform_setup) 0xFFD1 2218  0xFFD1 221C boot_scratch_cold6  boot_scratch_cold7 64-bit signature with L2 reset indication done. Writes signature (l2_reset_cpu) Reads the register (lowlevel_init) Writes register (socfpga_system_reset2) Reads register (plat_get_my_entrypoint) 0xFFD1 2220 boot_scratch_cold8 Bit[31:31] N5X, Agilex 7M. DBE status Set by SDM Check if bit is set (is_ddr_dbe_triggered) 0xFFD1 2220 boot_scratch_cold8 Bit[30:30] N5X, Agilex 7M. DDR Init Progress Set and clear bit(ddr_init_inprogress) Read status (is_ddr_init_hang) 0xFFD1 2220 boot_scratch_cold8 Bit[29:29] Agilex 7M. OCRAM_DBE  Error status 0xFFD1 2220 boot_scratch_cold8 Bits[28:27] Agilex 7M. Number of IO96B instances Sets this field (update_io96b_assigned_to_hps) 0xFFD1 2220 boot_scratch_cold8 Bit[19:19] Agilex 7, Agilex 7M, S10. CPU power domain is about to be turned on. Handled call under event (socfpga_pwr_domain_on) 0xFFD1 2220 boot_scratch_cold8 Bit[18:18] Agilex 7, S10. ACF DDR Data rate Set this bit Read this value (sdram_mmr_init_full) 0xFFD1 2220 boot_scratch_cold8 Bit[17,16,1] ECC_DDR1 Error Flag, ECC_DDR0 Error Flag, ECC_OCRAM Error Flag 0xFFD1 2220 boot_scratch_cold8 Checks if any of the flags are set (socfpga_system_reset2) Set via ATF SMC 0xFFD1 2224 boot_scratch_cold9 Write (via ATF SMC) <p>Links:</p> <ul> <li>Stratix\u00ae 10 HPS Registers</li> <li>Agilex\u2122 7 HPS Registers</li> <li>Review device-specific Boot User Guide for more information about these registers.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#qspi-reference-clock","title":"QSPI Reference Clock","text":"<p>The QSPI peripheral clocks are provided by the SDM, based on the SDM input clocks and configuration clock settings defined in the Quartus\u00ae Pro project. However, the HPS needs to know the QSPI reference clock, so that it can properly set the dividers in the QSPI controller to create the desired external QSPI clock frequency.</p> <p>The HPS obtains the QSPI controller reference clock frequency when it obtains exclusive access to the QSPI from the SDM. The frequency reported by the SDM is stored in the U-Boot environment variable called ${qspi_clock}.</p> <p>Before booting Linux, U-Boot loads the Linux device tree in memory, then runs the command linux_qspi_enable which sets the QSPI controller reference clock appropriately using the value from the ${qspi_clock} environment variable.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#reconfiguring-core-fabric-from-u-boot","title":"Reconfiguring Core Fabric from U-Boot","text":"<p>The GSRD configures the FPGA core fabric only once, from U-Boot, by using the bootm command. The example in this page configures the fabric only once, from U-Boot, using fpga load command.</p> <p>Important: If the FPGA fabric is already configured and bridges are enabled, you must call the bridge disable command from U-Boot before issuing the bootm or fppga load commands to reconfigure the fabric. Only do this if you are using an arm-trusted-firmware version more recent than the following:</p> <ul> <li>v2.7.1 = https://github.com/altera-opensource/arm-trusted-firmware/commit/0a5edaed853e0dc1e687706ccace8e844b2a8db7</li> <li>v2.8.0 = https://github.com/altera-opensource/arm-trusted-firmware/commit/bf933536d4582d63d0e29434e807a641941f3937</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#enabling-bridges-from-u-boot","title":"Enabling Bridges from U-Boot","text":"<p>U-Boot offers the bridge command for controlling the bridges.</p> <p>The bridge command can be used with either 'enable' or 'disable' parameter, followed by an optional 'mask' parameter indicating which of the bridges needs to be enabled or disabled. When the 'mask' parameter is omitted, all bridges are either enabled or disabled.</p> <p>See bellow the help message for the command:   <pre><code># bridge\nbridge - SoCFPGA HPS FPGA bridge control\n\nUsage:\nbridge enable [mask] - Enable HPS-to-FPGA (Bit 0), LWHPS-to-FPGA (Bit 1), FPGA-to-HPS (Bit 2), F2SDRAM0 (Bit 3), F2SDRAM1 (Bit 4), F2SDRAM2 (Bit 5) bridges \nbridge disable [mask] - Disable HPS-to-FPGA (Bit 0), LWHPS-to-FPGA (Bit 1), FPGA-to-HPS (Bit 2), F2SDRAM0 (Bit 3), F2SDRAM1 (Bit 4), F2SDRAM2 (Bit 5) bridges\nBit 3, Bit 4 and Bit 5 bridges only available in Stratix 10\n</code></pre> The** 'mask'** is a hexadecimal number, with 3 bits available for Agilex\u2122 7, and 6 bits for Stratix\u00ae 10, as indicated above.</p> <p>The following table shows examples of enabling and disabling various bridges:</p> Command Description bridge enable Enable all bridges bridge disable Disable all bridges bridge enable 1 Enable HPS-to-FPGA bridge bridge enable 2 Enable LWHPS-to-FPGA bridge bridge enable 4 Enable FPGA-to-HPS bridge bridge enable 7 Enable HPS-to-FPGA, LWHPS-to-FPGA, FPGA-to-HPS bridges bridge enable 35 Enable HPS-to-FPGA, FPGA-to-HPS, F2SDRAM1, F2SDRAM2 bridges(Stratix\u00ae 10 only) bridge disable 30 Disable F2SDRAM1, F2SDRAM2 bridges (Stratix\u00ae 10 only)"},{"location":"embedded-designs/agilex-7/f-series/soc/boot-examples/ug-linux-boot-agx7-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/","title":"HPS eMMC Boot Example  for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":"<p>Note: This example is not availble in this release. Refer to https://altera-fpga.github.io/rel-24.3.1/embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/ for the latest available version.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/","title":"SoC Fabric Configuration from Linux Example for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#introduction","title":"Introduction","text":"<p>When using HPS Boot First method, the FPGA device is first configured with a small Phase 1 bitstream, which configures the periphery, and brings up HPS. Then, at a later time, HPS configures the FPGA fabric using a larger Phase 2 bitstream. </p> <p>The HPS can configure the fabric either from U-Boot or Linux. The Golden System Reference Design (GSRD) configures the fabric from U-Boot. The examples in this page demonstrate how to configure the FPGA fabric from Linux, using device tree overlays. </p> <p>Two different examples are provided: </p> <ul> <li>Example building components separately </li> <li>based on the Building Bootloader for Agilex\u2122 7 example. </li> <li>Manages overlays directly. </li> <li>Example building everything with Yocto </li> <li>Based on the GSRD for Agilex\u2122 7 F-Series Transceiver-SoC DevKit (P-Tile and E-Tile). </li> <li>Manages overlays with the dtbt utility </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<ul> <li>Altera\u2122 Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit P-Tile E-Tile ordering code DK-SI-AGF014EB:  <ul> <li>OOBE/SD HPS Daughtercard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel\u00ae FPGA Download Cable II</li> <li>SDM QSPI Bootcard with MT25QU02G flash device </li> </ul> </li> <li>Host PC with:  <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u2122 Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for details about the board.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#example-building-components-separately","title":"Example Building Components Separately","text":"<p>This example is build on top of the Building Bootloader for Agilex\u2122 7 example, with the modification that the fabric is not configured from U-Boot anymore, but from Linux, with a device tree overlay. </p> <p>The device tree overlay and the Phase 2 configuration bitstream core.rbf are stored in the Linux rootfs folder /lib/firmware, where the Linux overlay framework expects them to be by default. </p> <p>Full instructions for building and running the example are provided. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#build-example","title":"Build Example","text":"<p>1. Set Up Environment: </p> <pre><code>sudo rm -rf agilex7.fabric_config.separate mkdir agilex7.fabric_config.separate cd agilex7.fabric_config.separate export TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Build Hardware Design: </p> <pre><code>cd $TOP_FOLDER rm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>3. Build Arm* Trusted Firmware: </p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware cd arm-trusted-firmware make bl31 PLAT=agilex cd .. </code></pre> <p>4. Build U-Boot: </p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga cd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk # use 'Image' for kernel image instead of 'kernel.itb'\nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb \nCONFIG_BOOTFILE=\"Image\" \n# - Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n \nCONFIG_SPL_NAND_SUPPORT=n \nCONFIG_CMD_NAND_TRIMFFS=n \nCONFIG_CMD_NAND_LOCK_UNLOCK=n \nCONFIG_NAND_DENALI_DT=n \nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n \nCONFIG_SPL_NAND_FRAMEWORK=n \nCONFIG_CMD_NAND=n \nCONFIG_MTD_RAW_NAND=n \nCONFIG_CMD_UBI=n \nCONFIG_CMD_UBIFS=n \nCONFIG_MTD_UBI=n \nCONFIG_ENV_IS_IN_UBI=n \nCONFIG_UBI_SILENCE_MSG=n \nCONFIG_UBIFS_SILENCE_MSG=n \n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; bridge disable;fpga load 0 \\${loadaddr} \\${filesize};bridge enable; setenv bootfile Image; run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_SPL_DOS_PARTITION=y \nCONFIG_CMD_PART=y \nCONFIG_SPL_CRC32=y \nCONFIG_LZO=y \nCONFIG_CMD_DHCP=y \n# Enable more QSPI flash manufacturers \nCONFIG_SPI_FLASH_MACRONIX=y \nCONFIG_SPI_FLASH_GIGADEVICE=y \nCONFIG_SPI_FLASH_WINBOND=y \nCONFIG_SPI_FLASH_ISSI=y \nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper make socfpga_agilex_defconfig # Use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin . # build\nmake -j 64 cd .. </code></pre> <p>5. Build JIC and Core RBF Files: </p> <pre><code>cd $TOP_FOLDER rm -f ghrd.hps.jic ghrd.core.rbf quartus_pfg -c \\ \nagilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\ \nghrd.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=AGFB014R24B2E2V \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o hps=1 </code></pre> <p>6. Build Linux: </p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\nmake clean &amp;&amp; make mrproper make defconfig # enable device tree overlays and fpga bridges \n./scripts/config --set-val CONFIG_OF_RESOLVE y ./scripts/config --set-val CONFIG_OF_OVERLAY y ./scripts/config --set-val CONFIG_OF_CONFIGFS y ./scripts/config --set-val CONFIG_FPGA_MGR_STRATIX10_SOC y ./scripts/config --set-val CONFIG_FPGA_BRIDGE y ./scripts/config --set-val CONFIG_FPGA_REGION y ./scripts/config --set-val CONFIG_OF_FPGA_REGION y ./scripts/config --set-val CONFIG_OVERLAY_FS y # enable SYSID driver \n./scripts/config --set-val CONFIG_ALTERA_SYSID y make oldconfig make -j 64 Image dtbs </code></pre> <p>7. Create Device Treee Overlay: </p> <pre><code>cd $TOP_FOLDER rm -f overlay.dtb overlay.dts cat &lt;&lt; EOF &gt; overlay.dts \n/dts-v1/; \n/plugin/; \n/ { \n fragment@0 { \n target-path = \"/fpga-region\"; \n #address-cells = &lt;0x2&gt;; \n #size-cells = &lt;0x2&gt;; \n __overlay__ { \n #address-cells = &lt;0x2&gt;; \n #size-cells = &lt;0x2&gt;; \n ranges = &lt;0x0 0x0 0x0 0xF9000000 0x0 0x00200000&gt;; \n firmware-name = \"overlay.rbf\"; \n config-complete-timeout-us = &lt;30000000&gt;; \n sysid_qsys_0: sysid@0 { \n compatible = \"altr,sysid-23.4\", \"altr,sysid-1.0\";\n reg = &lt;0x0 0x0 0x0 0x00000010&gt;; \n id = &lt;3405707982&gt;;\n timestamp = &lt;0&gt;; \n }; \n }; \n }; \n};\nEOF\ndtc -I dts -O dtb -o overlay.dtb overlay.dts </code></pre> <p>Explanation: </p> <ul> <li><code>Fragment@0</code>: Node Name of the Overlay. </li> <li><code>target-path</code>: This refers to base_fpga_region located in arch/arm64/boot/dts/intel/socfpga_agilex.dtsi. This will invoke the following driver: drivers/fpga/of-fpga-region.c </li> <li>Fragment@0 <code>#address-cells/#size-cells</code>: This specifies the number of cells (32-bit size) to be used for the child's address map. For overlays, we need to set this value to avoid \"default_addr_size\" errors. </li> <li>overlay <code>#address-cells/#size-cells</code>: These fields should match those in arch/arm64/boot/dts/intel/socfpga_agilex.dtsi. </li> <li><code>Ranges</code>: According to the device tree standard, this allows mapping child addresses to parent addresses. In this case: <ul> <li>The first number <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> represents the child's address. </li> <li>The second pair <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> represents the parent's address. </li> <li>The third pair <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> specifies the memory region's size. </li> </ul> </li> <li><code>firmware-name = \"overlay.rbf\"</code>: This should contain the fabric's file name. </li> <li><code>sysid_qsys_0: sysid@0</code>: This specifies the device name as well as its alias. </li> <li><code>reg = &lt;0x0 0x0 0x0 0x00000010&gt;</code>: This refers to the addresses specified in the parent range field. <ul> <li><code>&lt;0x0 0x0 0x0 0x00000010&gt;</code>: This represents the child's address. </li> <li><code>&lt;0x0 0x0 0x0 0x00000010&gt;</code>: This is the size of the memory region. </li> </ul> </li> </ul> <p>8. Build Root Filesystem: </p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b walnascar https://git.yoctoproject.org/poky git clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga git clone -b walnascar https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>9. Build SD Card Image: </p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py sed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py chmod +x make_sdimage_p3.py mkdir fat &amp;&amp; cd fat cp $TOP_FOLDER/u-boot-socfpga/u-boot.itb . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb . cd .. mkdir rootfs &amp;&amp; cd rootfs sudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz sudo rm -rf lib/modules/* sudo mkdir -p lib/firmware sudo cp $TOP_FOLDER/ghrd.core.rbf lib/firmware/overlay.rbf sudo cp $TOP_FOLDER/overlay.dtb lib/firmware/overlay.dtb cd .. sudo python3 make_sdimage_p3.py -f \\ \n-P fat/*,num=1,format=fat32,size=48M \\ \n-P rootfs/*,num=2,format=ext3,size=32M \\ \n-s 100M \\ \n-n sdcard.img cd .. </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#run-example","title":"Run Example","text":"<p>1. Write QSPI image <code>$TOP_FOLDER/ghrd.hps.jic</code> </p> <p>2. Write SD card image <code>$TOP_FOLDER/sd_card/sdcard.img</code> </p> <p>3. Power up board </p> <p>4. Log into Linux using 'root' as username, no password will be required. </p> <p>5. Create the overlay folder </p> <pre><code>root@agilex7_dk_si_agf014eb:~# mkdir /sys/kernel/config/device-tree/overlays/0 </code></pre> <p>6. Configure the overlay: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# echo overlay.dtb &gt; /sys/kernel/config/device-tree/overlays/0/path [ 35.750389] fpga_manager fpga0: writing overlay.rbf to Stratix10 SOC FPGA Manager [ 36.170960] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges [ 36.181456] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/firmware-name [ 36.192486] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/config-complete-timeout-us </code></pre> <p>7. Locate the sysid in the sysfs: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# find / -name sysid /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid </code></pre> <p>8. Display the sysid id information: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# cat /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid/id | xargs printf \"0x%08x\\n\" 0xacd5cafe </code></pre> <p>9. Remove the overlay: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# rmdir /sys/kernel/config/device-tree/overlays/0 </code></pre> <p>10. Confirm that the overlay was removed: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# find / -name sysid </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#example-building-everything-with-yocto","title":"Example Building Everything with Yocto","text":"<p>This example is build on top of the GSRD for Agilex 7 F-Series Transceiver-SoC DevKit (P-Tile and E-Tile), with the modification that the fabric is not configured from U-Boot anymore, instead through a device tree overlay. </p> <p>Full instructions for building and running the example are provided. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#build-example_1","title":"Build Example","text":"<p>1. Set up environment: </p> <pre><code>sudo rm -rf agilex7.fabric_config.yocto mkdir agilex7.fabric_config.yocto cd agilex7.fabric_config.yocto export TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Compile the hardware design: </p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>3. Build the core.rbf </p> <pre><code>cd $TOP_FOLDER rm -f ghrd.hps.jic ghrd.core.rbf quartus_pfg -c \\ \nagilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof \\ \nghrd.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=AGFB014R24B2E2V \\ \n-o mode=ASX4 \\ \n-o hps=1 rm ghrd.hps.jic </code></pre> <p>4. Clone Yocto script and start the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga cd gsrd-socfpga . agilex7_dk_si_agf014eb-gsrd-build.sh build_setup </code></pre> <p>5. Get and apply the patch, containing the following changes: </p> <ul> <li>U-Boot boot script is changed to load configuration 0 from the kernel.itb, which does not configure the fabric at boot time </li> <li>Overlay file agilex_fabric_config_overlay.dts was added, pointing to core.rbf file for fabric configuration, and adding the sysid driver </li> <li>core.rbf file is also copied into the /lib/firmware folder where the Linux device tree framwork expects it </li> </ul> <pre><code>rm -f agilex7-fabric-config-yocto.patch\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/f-series/soc/fabric-config/collateral/agilex7-fabric-config-yocto.patch patch -d meta-intel-fpga-refdes -p1 &lt; agilex7-fabric-config-yocto.patch\n</code></pre> <p>For reference, the patch looks like this:</p> <pre><code>diff --git a/recipes-bsp/device-tree/device-tree.bb b/recipes-bsp/device-tree/device-tree.bb\nindex 6516834..3382020 100644\n--- a/recipes-bsp/device-tree/device-tree.bb\n+++ b/recipes-bsp/device-tree/device-tree.bb\n@@ -24,6 +24,7 @@ SRC_URI:append:agilex7_dk_si_agf014ea = \" \\\n                   file://agilex7_pr_persona0.dts \\\n                    file://agilex7_pr_persona1.dts \\\n                    file://socfpga_ilc.dtsi \\\n+                   file://fabric_config_overlay.dts \\\n                   \"\n\nSRC_URI:append:agilex7_dk_si_agf014eb = \" \\\n@@ -32,6 +33,7 @@ SRC_URI:append:agilex7_dk_si_agf014eb = \" \\\n                   file://agilex7_pr_persona0.dts \\\n                    file://agilex7_pr_persona1.dts \\\n                    file://socfpga_ilc.dtsi \\\n+                   file://fabric_config_overlay.dts \\\n                   \"\n\nSRC_URI:append:agilex7_dk_si_agi027fb = \" \\\ndiff --git a/recipes-bsp/device-tree/files/fabric_config_overlay.dts b/recipes-bsp/device-tree/files/fabric_config_overlay.dts\nnew file mode 100644\nindex 0000000..cd5b0df\n--- /dev/null\n+++ b/recipes-bsp/device-tree/files/fabric_config_overlay.dts\n@@ -0,0 +1,23 @@\n+/dts-v1/;\n+/plugin/;\n+/ {\n+                fragment@0 {\n+                                target-path = \"/fpga-region\";\n+                                #address-cells = &lt;0x2&gt;;\n+                                #size-cells = &lt;0x2&gt;;\n+                                __overlay__ {\n+                                                #address-cells = &lt;0x2&gt;;\n+                                                #size-cells = &lt;0x2&gt;;\n+                                                ranges =&lt;0x0 0x0 0x0 0xF9000000 0x0 0x00200000&gt;;\n+                                                firmware-name = \"ghrd.core.rbf\";\n+                                                config-complete-timeout-us = &lt;30000000&gt;;\n+\n+                                                sysid_qsys_0: sysid@0 {\n+                                                    compatible = \"altr,sysid-23.4\", \"altr,sysid-1.0\";\n+                                                    reg = &lt;0x0 0x0 0x0 0x00000010&gt;;\n+                                                    id = &lt;3405707982&gt;;\n+                                                    timestamp = &lt;0&gt;;\n+                                                };\n+                                };\n+                };\n+};\ndiff --git a/recipes-bsp/ghrd/hw-ref-design.bb b/recipes-bsp/ghrd/hw-ref-design.bb\nindex eccd99d..dbd6f34 100644\n--- a/recipes-bsp/ghrd/hw-ref-design.bb\n+++ b/recipes-bsp/ghrd/hw-ref-design.bb\n@@ -222,6 +222,7 @@ do_install () {\n           install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_${ARM64_GHRD_CORE_RBF} ${D}/boot/ghrd_pr.core.rbf\n            install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_persona0.rbf ${D}${base_libdir}/firmware/persona0.rbf\n            install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_persona1.rbf ${D}${base_libdir}/firmware/persona1.rbf\n+           install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_gsrd_${ARM64_GHRD_CORE_RBF} ${D}${base_libdir}/firmware/${ARM64_GHRD_CORE_RBF}\n       else\n            install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_gsrd_${ARM64_GHRD_CORE_RBF} ${D}/boot/${ARM64_GHRD_CORE_RBF}\n        fi\ndiff --git a/recipes-bsp/u-boot/files/uboot.txt b/recipes-bsp/u-boot/files/uboot.txt\nindex 8577186..3a0288f 100644\n--- a/recipes-bsp/u-boot/files/uboot.txt\n+++ b/recipes-bsp/u-boot/files/uboot.txt\n@@ -6,7 +6,7 @@ if test ${target} = \"mmc0\"; then\n       mmc rescan;\n        fatload ${devtype} ${devnum}:${distro_bootpart} ${loadaddr} ${bootfile};\n        setenv bootargs \"earlycon panic=-1 root=${mmcroot} rw rootwait\";        \n-       bootm ${loadaddr}#board-${board_id};\n+       bootm ${loadaddr}#board-0;\n       exit;\n    fi\n fi\n</code></pre> <p>6. Customize Yocto Build </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd.core.rbf $CORE_RBF OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\" CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") NEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb sed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>7. Build Yocto: </p> <pre><code>bitbake_image package </code></pre> <p>8. Build JIC file: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\ \nghrd.jic \\ \n-o hps_path=gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\ \n-o device=MT25QU128 \\ \n-o flash_loader=AGFB014R24B2E2V \\ \n-o mode=ASX4 \\ \n-o hps=1 </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#run-example_1","title":"Run Example","text":"<p>1. Write QSPI image <code>$TOP_FOLDER/ghrd.hps.jic</code> </p> <p>2. Write SD card image <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/gsrd-console-image-agilex7.wic</code> </p> <p>3. Power up board </p> <p>4. Log into Linux using 'root' as username, no password will be required. </p> <p>5. Apply the overlay: </p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -a agilex_fabric_config_overlay.dtbo -p /boot/devicetree Set dtbo search path to /boot/devicetree Applying dtbo: agilex_fabric_config_overlay.dtbo [ 36.789770] fpga_manager fpga0: writing ghrd.core.rbf to Stratix10 SOC FPGA Manager [ 36.915647] dw_mmc ff808000.mmc: Unexpected interrupt latency [ 37.220846] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges [ 37.231343] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/firmware-name [ 37.242381] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/config-complete-timeout-us [ 37.254582] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/sysid_qsys_0 </code></pre> <p>6. List the applied overlays: </p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -l 1 fabric_config_overlay.dtbo applied /sys/kernel/config/device-tree/overlays/1-fabric_config_overlay.dtbo\n</code></pre> <p>7. Locate the sysid in the sysfs: </p> <pre><code>root@agilex7dksiagf014eb:~# find / -name sysid /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid </code></pre> <p>8. Display the sysid id information: </p> <pre><code>root@agilex7dksiagf014eb:~# cat /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid/id | xargs printf \"0x%08x\\n\" 0xacd5cafe </code></pre> <p>9. Remove the overlay: </p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -r fabric_config_overlay.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\nRemoving dtbo: 1-fabric_config_overlay.dtbo\n</code></pre> <p>10. Confirm that the overlay was removed: </p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -l </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/","title":"HPS GSRD User Guide for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#overview","title":"Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile).</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the GSRD:</p> <ul> <li>Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) ordering code DK-SI-AGF014EB</li> <li>SD/MMC HPS Daughtercard<ul> <li>SDM QSPI Bootcard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel FPGA Download Cable II</li> <li>Micro SD card (4GB or greater)</li> </ul> </li> <li>Host PC with<ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Micro SD card slot or Micro SD card writer/reader</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board)</li> </ul> </li> </ul> <p>You can determine your board version by referring to the following table from https://www.intel.com/content/www/us/en/docs/programmable/683752/current/overview.html</p> Development Kit Version Ordering Code Device Part Number Starting Serial Number Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 2 P-Tiles &amp; E-Tiles) DK-SI-AGF014EB AGFB014R24B2E2V (Power Solution 2) 00205001 Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 1 P-Tiles &amp; E-Tiles) DK-SI-AGF014EA AGFB014R24B2E2V (Power Solution 1) 0001101 Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (ES P-Tiles &amp; E-Tiles) DK-SI-AGF014E3ES AGFB014E3ES (Power Solution 1) 0001001 <p>The DK-SI-AGF014E3ES and DK-SI-AGF014EA are deprecated, and not supported anymore. Refer to previous versions of this page for more information about them.</p> <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#prebuilt-binaries","title":"Prebuilt Binaries","text":"SD Card Boot <p>The release files are accessible at https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agf014eb_gsrd/</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>:</p> File Description linux-socfpga-v6.12.19-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2025.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.12.1-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p> NAND Boot <p>The release files are accessible at https://releases.rocketboards.org/2025.08/nand/agilex7_dk_si_agf014eb_nand/</p> <p>To load the binaries in the development kit see Write NAND Binaries.</p> QSPI Boot <p>The release files are accessible at https://releases.rocketboards.org/2025.08/qspi/agilex7_dk_si_agf014eb_qspi/.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Quad Arm Cortex-A53 MPCore Processor</li> <li>HPS Peripherals connected to Out-of-Box Experience (OOBE) Daughter Card:</li> <li>Micro SD for HPS storage</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>I2C</li> <li>USB UART</li> <li>USB 2.0 OTG</li> <li>Two Push buttons and Three LEDs</li> </ul> </li> <li>Hard Memory Controller (HMC) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>Three user LED outputs</li> <li>Four user DIP switch inputs</li> <li>Four user push-button inputs</li> <li>Interrupt Latency Counter</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> <li>JTAG to Avalon Master Bridges connected to:<ul> <li>FPGA-to-SDRAM 0/\u00bd Interfaces</li> <li>FPGA-to-HPS AXI Bridge</li> </ul> </li> </ul> <p></p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#mpu-address-maps","title":"MPU Address Maps","text":"<p>This section presents the address maps as seen from the MPU (Cortex-A53) side.</p> HPS-to-FPGA Address Map <p>The MPU region provide windows of 4 GB into the FPGA slave address space. The lower 1.5 GB of this space is mapped to two separate addresses - firstly from 0x8000_0000 to 0xDFFF_FFFF and secondly from 0x20_0000_0000 to 0x20_5FFF_FFFF. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU (Cortex-A53), which starts at the lightweight HPS-to-FPGA base address of 0xF900_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0000_0000 8 Unique system ID led_pio 0x0000_1080 16 LED outputs button_pio 0x0000_1060 16 Push button inputs dipsw_pio 0x0000_1070 16 DIP switch inputs ILC 0x0000_1100 256 Interrupt latency counter (ILC)"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#jtag-master-address-map","title":"JTAG Master Address Map","text":"<p>There are two JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0000_0000 256K On-chip RAM sysid 0x0004_0000 8 Unique system ID led_pio 0x0004_0080 16 LED outputs button_pio 0x0004_0060 16 Push button inputs dipsw_pio 0x0004_0070 16 DIP switch inputs ILC 0x0004_0100 256 Interrupt latency counter (ILC)"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#interrupt-routing","title":"Interrupt Routing","text":"<p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[0] 4 DIP switch inputs button_pio f2h_irq0[1] 4 Push button inputs <p>The interrupt sources are also connected to an interrupt latency counter (ILC) module in the system, which enables System Console to be aware of the interrupt status of each peripheral in the FPGA portion of the SoC.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#typical-hps-boot-flow","title":"Typical HPS Boot Flow","text":"<p>The GSRD boot flow includes the following stages:</p> <p>1. SDM</p> <p>2. U-Boot SPL</p> <p>3. ATF</p> <p>4. U-Boot</p> <p>5. Linux</p> <p>6. Application</p> <p></p> <p>The following table presents a short description of the different boot stages:</p> Stage Description SDM Secure Device Manager boots first U-Boot SPL Configures IO, FPGA, brings up SDRAM ATF Arm Trusted Firmware, provides SMC handler U-Boot Loads Linux kernel Linux Operating system Application User application <p>For more information, please refer to Intel Agilex\u2122 Hard Processor System Technical Reference Manual (Booting and Configuration chapter).</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#exercise-prebuilt-gsrd","title":"Exercise Prebuilt GSRD","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#configure-board","title":"Configure Board","text":"<p>This section presents the necessary board settings in order to run the GSRD on the development board.</p> <p>First, confirm the following:</p> <ul> <li>SD Card/OOBE Daughter card is installed on HPS Daughter card socket</li> </ul> <p>Then the board switches need to be configured as follows:</p> <ul> <li>SW1: ON-OFF-OFF-ON</li> <li>SW2: all OFF</li> <li>SW3: OFF-OFF-ON-ON-ON-ON</li> <li>SW4: OFF-OFF-OFF-ON</li> <li>SW5: all OFF</li> <li>SW6: OFF-OFF-OFF-ON</li> <li>SW9: OFF-OFF</li> <li>SW10: OFF-ON</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#configure-serial-connection","title":"Configure Serial Connection","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, the SoC EDS Pro installer automatically installs the required drivers if necessary.</p> <p>The serial communication parameters are:</p> <ul> <li>Baud-rate: 115,200</li> <li>Parity: none</li> <li>Flow control: none</li> <li>Stop bits: 1</li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus.</p> <p>On Linux, the minicom utility can be used. Here is how to configure it:</p> <p>The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following:</p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB*</li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet.</li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared.</li> <li>Install minicom application on host PC, if not installed.</li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom</li> <li>Configure minicom.</li> </ul> <pre><code>$ sudo minicom -s\n</code></pre> <p>Under Serial Port Setup choose the following:</p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary)</li> <li>Bps/Par/Bits: 115200 8N1</li> <li>Hardware Flow Control: No</li> <li>Software Flow Control: No</li> <li>Hit [ESC] to return to the main configuration menu</li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>This section presents how to write the QSPI Falsh and SD Card image files, configure the board and boot Linux.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-qspi-image","title":"Write QSPI Image","text":"<p>The QSPI JIC image contains the FPGA configuration bitstream, and the U-Boot SPL.</p> <p>1. Download and extract the image file:</p> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agf014eb_gsrd/ghrd_agfb014r24b2e2v.jic.tar.gz\ntar xf ghrd_agfb014r24b2e2v.jic.tar.gz\n</code></pre> <p>2. Configure MSEL to JTAG:</p> <ul> <li>SW1: ON-ON-ON-ON</li> </ul> <p>3. Power cycle the board</p> <p>4. Write the image using the following commands:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agfb014r24b2e2v.jic\"\n</code></pre> <p>5. Configure MSEL back to QSPI:</p> <ul> <li>SW1: ON-OFF-OFF-ON</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-sd-card-image","title":"Write SD Card Image","text":"<p>This section explains how to create the SD card necessary to boot Linux, using the SD card image available with the pre-built Linux binaries package. Once the SD card has been created, insert the card into the SD slot of the Micro SD daughter card.</p> Write SD Card on Linux <p>1. Download the SD card image and extract it:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agf014eb_gsrd/sdimage.tar.gz\ntar xf sdimage.tar.gz\n</code></pre> <p>The extacted file is named <code>gsrd-console-image-agilex7.wic</code>.</p> <p>2. Determine the device associated with the SD card on the host by running the following command before and after inserting the card.</p> <pre><code>$ cat /proc/partitions\n</code></pre> <p>Let's assume it is /dev/sdx.</p> <p>3. Use dd utility to write the SD image to the SD card.</p> <pre><code>$ sudo dd if=gsrd-console-image-agilex7.wic of=/dev/sdx bs=1M\n</code></pre> <p>Note we are using sudo to be able to write to the card.</p> <p>4. Use sync utility to flush the changes to the SD card.</p> <pre><code>$ sudo sync\n</code></pre>  Write SD Card on Windows <p>1. Download the SD card image and extract it: https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agf014eb_gsrd/sdimage.tar.gz</p> <p>The extacted file is named <code>gsrd-console-image-agilex7.wic</code>.</p> <p>2. Rename the wic file as <code>sdcard.img</code></p> <p>3. Use Win32DiskImager to write the image to the SD card. The tool can be downloaded from https://sourceforge.net/projects/win32diskimager/files/latest/download</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-linux","title":"Boot Linux","text":"<p>This section presents how to boot Linux on the board. The required steps are:</p> <p>1. Start serial terminal (when using Minicom it will connect using the selected settings, for others connect manually).</p> <p>2. Power up the board.</p> <p>3. U-Boot SPL is ran</p> <p>4. U-Boot is ran</p> <p>5. Linux boots.</p> <p>6. Login using 'root' and no password.</p> <p>7. Run 'ifconfig' command to determine the IP of the board</p> <pre><code>root@agilex7dksiagf014eb:~# ifconfig\neth0: flags=4163 mtu 1500\ninet 192.168.1.163 netmask 255.255.255.0 broadcast 192.168.1.255\n inet6 fe80::20cd:5eff:fe36:dbaf prefixlen 64 scopeid 0x20\n ether 22:cd:5e:36:db:af txqueuelen 1000 (Ethernet)\nRX packets 14 bytes 2126 (2.0 KiB)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 43 bytes 7513 (7.3 KiB)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 21 base 0x2000\n\neth1: flags=4099 mtu 1500\nether 5a:4d:ca:de:cd:f6 txqueuelen 1000 (Ethernet)\nRX packets 0 bytes 0 (0.0 B)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 0 bytes 0 (0.0 B)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 22 base 0xc000\n\nlo: flags=73 mtu 65536\ninet 127.0.0.1 netmask 255.0.0.0\n inet6 ::1 prefixlen 128 scopeid 0x10\n loop txqueuelen 1000 (Local Loopback)\nRX packets 100 bytes 8468 (8.2 KiB)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 100 bytes 8468 (8.2 KiB)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\n</code></pre> <p>Note: there are two IP addresses, one coming from the Ethernet port on the HPS Daughtercard, and one from the Ethernet port on the DevKit, which is connected throgh SGMII.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#run-sample-applications","title":"Run Sample Applications","text":"<p>The GSRD includes a number of sample Linux applications that help demonstrate some of the features of the platform:</p> <ul> <li>Display Hello World message</li> <li>Control LEDs</li> <li>Detect interrupts from push buttons and DIP switches</li> </ul> <p>The sample applications can be used as a starting point for users to write their own applications that interact with software IP through Linux drivers.</p> Prerequisites  <p>1. Boot Linux on the target board as described in Boot Linux. You will not need to use the serial terminal if you plan on using ssh connection.</p> <p>2. Connect to the board using one of the following options:</p> <ul> <li>Connect using serial console, as described in Boot Linux</li> <li>Connect using ssh, as described in Connect With SSH</li> </ul> <p>3. In serial console, or ssh client console, change current folder to be /home/root/intelFPGA. This is where the application binaries are stored.</p> <pre><code>root@agilex7dksiagf014eb:~# cd /home/root/intelFPGA/\nroot@agilex7dksiagf014eb:~/intelFPGA#\n</code></pre> Display Hello World Message <p>Run the following command to display the Hello World message on the console:</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# ./hello\nHello SoC FPGA!\n</code></pre> Exercise Soft PIO Driver for LED Control <p>The following LEDs are exercised:</p> User FPGA LED Number Corresponding Board LED 0 D21 1 D23 2 D25 <p>Note: User FPGA LED #3 / D27 is quickly blinking, and cannot be controlled from software.</p> <p>1. In order to blink an LED in a loop, with a specific delay in ms, run the following command:</p> <pre><code>./blink &lt;led_number&gt; &lt;delay_ms&gt;\n</code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The delay_ms is a number that specifies the desired delay in ms between turning the LED on and off.</li> </ul> <p>2. In order to turn an individual LED on or off, run the following command:</p> <pre><code>./toggle &lt;led_number&gt; &lt;state&gt;\n</code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The state needs to be 0 to turn the LED off, and 1 to turn the LED on.</li> </ul> <p>3. In order to scroll the FPGA LEDs with a specific delay, please run the following command:</p> <pre><code>./scroll_client &lt;delay&gt;\n</code></pre> <p>The delay specifies the desired scrolling behavior:</p> <ul> <li>delay &gt; 0 - specify new scrolling delay in ms, and start scrolling</li> <li>delay &lt; 0 - stop scrolling</li> <li>delay = 0 - display current scroll delay</li> </ul> System Check Application <p>System check application provides a glance of system status of basic peripherals such as:</p> <ul> <li>USB: USB device driver</li> <li>Network IP (IPv4): Network IP address</li> <li>HPS LEDs: HPS LED state</li> <li>FPGA LEDs: FPGA LED state</li> </ul> <p>Run the application by issuing the following command:</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# ./syschk\n</code></pre> <p>The application will look as follows, press 'q' to exit:</p> <pre><code> ALTERA SYSTEM CHECK\n\nlo : 127.0.0.1 usb1 : DWC OTG Controller\neth0 : 192.168.1.163\n serial@ffc02100 : disabled\nfpga_led2 : OFF serial@ffc02000 : okay\nhps_led2 : OFF\nfpga_led0 : OFF\nhps_led0 : OFF\nfpga_led3 : OFF\nfpga_led1 : OFF\nhps_led1 : OFF\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#register-interrupts","title":"Register Interrupts","text":"<p>The following are exercised:</p> <ul> <li>User FPGA DIP switches</li> <li>SW2.SW0</li> <li>SW2.SW1</li> <li>SW2.SW2</li> <li>SW2.SW3</li> <li>User FPGA push buttons</li> <li>0: S1</li> <li>1: S2</li> <li>2: S3</li> <li>3: S4</li> </ul> <p>In order to register an interrupt handler to a specific GPIO, you will first need to determine the GPIO number used.</p> <p>1. Open the Linux Device Tree socfpga_agilex7_ghrd.dtsi file and look up the labels for the DIP switches and Push button GPIOs:</p> <pre><code> button_pio: gpio@f9001060 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0xf9001060 0x10&gt;;\ninterrupt-parent = &lt;&amp;intc&gt;;\ninterrupts = &lt;0 18 4&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;2&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\ndipsw_pio: gpio@f9001070 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0xf9001070 0x10&gt;;\ninterrupt-parent = &lt;&amp;intc&gt;;\ninterrupts = &lt;0 17 4&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;3&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\n</code></pre> <p>2. Run the following to determine the GPIO numbers for the DIP switches</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# grep -r \"gpio@f9001070\" /sys/class/gpio/gpiochip*/label\n/sys/class/gpio/gpiochip1928/label:/soc/gpio@f9001070\n</code></pre> <p>This means that the GPIOs 1928 .. 1931 are allocated to the DIP switches (there are 4 of them).</p> <p>3. Run the followinig to determine the GPIO numbers for the pushbuttons</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# grep -r \"gpio@f9001060\" /sys/class/gpio/gpiochip*/label\n/sys/class/gpio/gpiochip1960/label:/soc/gpio@f9001060\n</code></pre> <p>This means that the GPIOs 1960 \u2026 1963 are allocated to the push buttons (there are 4 of them).</p> <p>4. Register interrupt for one of the dipswiches, using the appropriate GPIO number, as determined in a previous step:</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# modprobe gpio_interrupt gpio_number=1928 intr_type=3\n[ 893.594901] gpio_interrupt: loading out-of-tree module taints kernel.\n[ 893.602212] Interrupt for GPIO:1928\n[ 893.602212] registered\n</code></pre> <p>5. Toggle the dipswitch a few times, you will see messages from the interrupt handler</p> <pre><code>[ 933.872016] Interrupt happened at gpio:1028\n[ 936.630233] Interrupt happened at gpio:1928\n[ 938.737038] Interrupt happened at gpio:1928\n[ 939.951513] Interrupt happened at gpio:1928\n</code></pre> <p>6. Remove the driver</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# rmmod gpio_interrupt\n</code></pre> <p>7. Register the pushbutton interrupt, using the appropriate GPIO number as determine on a previous step</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# modprobe gpio_interrupt gpio_number=1960 intr_type=2\n[ 1138.025297] Interrupt for GPIO:1960\n[ 1138.025297] registered\n</code></pre> <p>8. Push the pusbutton a few times, you will see interrupt handler messages</p> <pre><code>[ 1141.672192] Interrupt happened at gpio:1960\n[ 1142.110673] Interrupt happened at gpio:1960\n[ 1142.499468] Interrupt happened at gpio:1960\n[ 1142.884199] Interrupt happened at gpio:1960\n</code></pre> <p>9. Once done, remove the handler</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# rmmod gpio_interrupt\n</code></pre> <p>Note: If you are on the ssh console, you will need to run the program dmesg after pressing the button in order to see the messages:</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# dmesg\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#connect-to-web-server","title":"Connect to Web Server","text":"<p>The GSRD includes a web server running on the target board that can be used to exercise some of the board features:</p> <ul> <li>Turning LEDs ON and OFF</li> <li>Scrolling LEDs in a sequence</li> <li>Displaying the current status of the LEDs</li> </ul> <p>The web page served by the web server also contains links to some relevant information on the Intel website.</p> <p>Perform the following steps to connect to the web server running on the board:</p> <p>1. Boot Linux as described in Booting Linux.</p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be network interfaces of them, either can be used.</p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter.</p> <p></p> <p>4. Scroll the webpage down to the section named Interacting with Agilex\u2122 SoC Development Kit.</p> <p></p> <p>You will be able to perform the following actions:</p> <ul> <li>See which LEDs are ON and which are off in the LED Status. Note that if the LEDs are setup to be scrolling, the displayed scrolling speed will not match the actual scrolling speed on the board.</li> <li>Stop LEDs from scrolling, by clicking START and STOP buttons. The delay between LEDs turning ON and OFF is set in the LED Lightshow box.</li> <li>Turn individual LEDs ON and OFF with the ON and OFF buttons. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> <li>Blink individual LEDs by typing a delay value in ms then clicking the corresponding BLINK button. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#connect-with-ssh","title":"Connect With SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection.</p> <p></p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS:</p> <pre><code>$ sudo yum install openssh-clients\n</code></pre> <p>or the following command on Ubuntu:</p> <pre><code>$ sudo apt-get install openssh-client\n</code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-qspi","title":"Boot from QSPI","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-qspi-image_1","title":"Write QSPI Image","text":"<p>1. Configure MSEL to JTAG:</p> <p>2. Power cycle the board</p> <p>3. Write the image using the following commands:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;flash_image.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-linux_1","title":"Boot Linux","text":"<p>1. Configure MSEL back to QSPI</p> <p>2. Important: Remove SD card (or write zero to first few MBs) to confirm Linux is booting without it.</p> <p>3. Power cycle. Board will boot up to Linux prompt, where you can login as 'root' without a password.</p> <p>Note: First time Linux is booted, the UBIFS rootfs will be initialized, the step taking approximately 3 minutes, as shown in the log below: <pre><code>[   12.272151] platform soc:leds: deferred probe pending\n&lt;-- ... 3 minute 'gap' here\n[  216.905453] UBIFS (ubi0:4): free space fixup complete\n[  217.035839] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[  217.043228] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[  217.052599] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size 8650240 bytes (8 MiB, 133 LEBs)\n[  217.064650] UBIFS (ubi0:4): reserved for root: 0 bytes (0 KiB)\n[  217.070469] UBIFS (ubi0:4): media format: w4/r0 (latest is w5/r0), UUID 4A5F6BFC-BA49-47C9-A17A-425E35F3A52F, small LPT model\n[  217.271031] VFS: Mounted root (ubifs filesystem) on device 0:20\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-nand","title":"Boot from NAND","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-nand-binaries","title":"Write NAND Binaries","text":"<p>1. Copy files to your TFTP server folder:</p> <pre><code>cp -f $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot.itb&lt;your-tftp-server-folder&gt;\ncp -f $TOP_FOLDER/nand-bin/root.ubi &lt;your-tftp-server-folder&gt;\n</code></pre> <p>2. Run U-Boot with the debugger, similar to how it is described at Run U-Boot from Debugger just change the script to use the binaries directly from <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/</code> and use the new name for the sof: <code>agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof</code>.</p> <p>3. Stop at U-Boot prompt, and run the following instructions to download and write NAND binaries to flash:</p> <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your-tftp-server-ip&gt;\n\ntftp $loadaddr u-boot.itb\nnand erase.part u-boot\nnand write $loadaddr u-boot $filesize\ntftp $loadaddr root.ubi\nnand erase.part clean root\nnand write.trimffs $loadaddr root $filesize\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-qspi-image_2","title":"Write QSPI Image","text":"<p>1. Power off board</p> <p>2. Set MSEL to JTAG</p> <p>3. Power on board</p> <p>4. Write jic image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agfb014r24b2e2v.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-linux_2","title":"Boot Linux","text":"<p>1. Make sure board is powered off.</p> <p>2. Set MSEL to QSPI</p> <p>3. Power up the board.</p> <p>4. Linux will boot, enter 'root' as user name to log in.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#partial-reconfiguration","title":"Partial Reconfiguration","text":"<p>Partial reconfiguration (PR) allows you to reconfigure a portion of the FPGA dynamically, while the rest of the FPGA design continues to function.  This section presents how to run the PR scenarios included with the GSRD.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#reference-information","title":"Reference Information","text":"<p>Refer to the following fore more details about Partial Reconfiguration</p> <ul> <li>User Guide<ul> <li>Intel Quartus Prime Pro Edition User Guide: Partial Reconfiguration</li> </ul> </li> <li>Partial Reconfiguration for Intel FPGA Devices YouTube videos:<ul> <li>Part1: Introduction &amp; Project Assignments</li> <li>Part2: Design Guidelines &amp; Host Requirements</li> <li>Part3: PR Host IP &amp; Implementations</li> <li>Part4: Output Files &amp; Demonstration</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#hardware-design","title":"Hardware Design","text":"<p>The updated GHRD contains the following components which enable PR:</p> <ul> <li>A PR region was created in the FPGA fabric, with the following associated IP<ul> <li>PR Freeze Controller - to help control the PR</li> <li>Avalon-MM PR Freeze Bridge - to help isolate the IP in the PR region during the PR process</li> </ul> </li> <li>The base revision of the project has the following in the PR region:<ul> <li>SysID located at 0xF900_0800: with id=0xfacecafe</li> <li>OCRAM located at 0xF900_0900</li> </ul> </li> <li>An alternate revision of the project contains the following in the PR region:<ul> <li>SysID located at 0xF900_0900: with id=0xcafeface</li> <li>OCRAM located at 0xF900_0800</li> </ul> </li> </ul> <p>The following diagram presents an overview of the PR region and associated IP and how it is connected to HPS:</p> <p></p> <p>Throughout this page, the content of the PR region for the base revision is called \"persona0\" while the content of the PR region for the other revision is called \"persona1\". The diagram below illustrates the differences between the two personas:</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#pr-files","title":"PR Files","text":"<p>The files on the Linux rootfs used for running the PR scenarios are shown below:</p> File Description /sbin/dtbt Tool used for managing the overlays. Available at https://github.com/altera-fpga/dtbt /boot/devicetree/agilex7_pr_fpga_static_region.dtbo overlay for the static region, needs to be applied before persona overlays /boot/devicetree/agilex7_pr_persona0.dtbo overlay for persona0 /boot/devicetree/agilex7_pr_persona0.dtbo overlay for persona1 /lib/firmware/persona0.rbf bitstream used by persona0 overlay /lib/firmware/persona1.rbf bitstream used by persona1 overlay <p>The DTS files for the overlays are available at https://github.com/altera-fpga/meta-intel-fpga-refdes/blob/walnascar/recipes-bsp/device-tree/files/:</p> <ul> <li>agilex7_pr_fpga_static_region.dts</li> <li>agilex7_pr_persona0.dts</li> <li>agilex7_pr_persona1.dts</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#run-pr-scenarios","title":"Run PR Scenarios","text":"<p>1. Boot Linux</p> <p>2. Add the overlay for the static region:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -a agilex7_pr_fpga_static_region.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\n[ 292.932872] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges\nApplying dtbo: agilex_pr_fpga_static_region.dtbo\n[ 292.944184] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/external-fpga-config\n[ 292.960109] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/clocks\n[ 292.970529] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/clock-names\n[ 292.981470] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/clk_0\n[ 292.991034] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/freeze_controller_0\n[ 293.007735] of-fpga-region soc:base_fpga_region:fpga_pr_region0: FPGA Region probed\n[ 293.028076] altera_freeze_br f9000450.freeze_controller: fpga bridge [freeze] registered\n</code></pre> <p>3. Add the overlay for persona0:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -a agilex7_pr_persona0.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\n[ 398.171799] fpga_manager fpga0: writing persona0.rbf to Stratix10 SOC FPGA Manager\nApplying dtbo: agilex_pr_persona0.dtbo\n[ 398.321356] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_clk_100\n[ 398.332459] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_sysid_qsys_0\n</code></pre> <p>4. Locate the sysid and display the associated id:</p> <pre><code>root@agilex7dksiagf014eb:~# find / -name sysid\n/sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000800.sysid/sysid\nroot@agilex7dksiagf014eb:~# cat /sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000800.sysid/sysid/id | xargs printf \"0x%08x\\n\"\n0xcafeface\n</code></pre> <p>5. List the applied overlays:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -l\n2 agilex_pr_persona0.dtbo applied /sys/kernel/config/device-tree/overlays/2-agilex_pr_persona0.dtbo\n1 agilex_pr_fpga_static_region.dtbo applied /sys/kernel/config/device-tree/overlays/1-agilex_pr_fpga_static_region.dtbo\n</code></pre> <p>6. Remove persona0 overlay:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -r agilex7_pr_persona0.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\nRemoving dtbo: 2-agilex_pr_persona0.dtbo\n</code></pre> <p>7. Add the persona1 overlay:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -a agilex7_pr_persona1.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\n[ 531.975623] fpga_manager fpga0: writing persona1.rbf to Stratix10 SOC FPGA Manager\nApplying dtbo: agilex_pr_persona1.dtbo\n[ 532.124433] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_clk_100\n[ 532.135530] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_sysid_qsys_0\n</code></pre> <p>8. Locate the sysid and display the associated id:</p> <pre><code>root@agilex7dksiagf014eb:~# find / -name sysid\n/sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000900.sysid/sysid\nroot@agilex7dksiagf014eb:~# cat /sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000900.sysid/sysid/id | xargs printf \"0x%08x\\n\"\n0xfacecafe\n</code></pre> <p>9. Remove persona1:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -r agilex7_pr_persona1.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\nRemoving dtbo: 2-agilex_pr_persona1.dtbo\n</code></pre> <p>10. List the applied overlays:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -l\n1 agilex_pr_fpga_static_region.dtbo applied /sys/kernel/config/device-tree/overlays/1-agilex_pr_fpga_static_region.dtbo\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#rebuild-the-gsrd","title":"Rebuild the GSRD","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-sd-card_1","title":"Boot from SD Card","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd\nmkdir agilex7f_gsrd\ncd agilex7f_gsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof \\\nghrd.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf</li> <li>agilex7_dk_si_agf014eb_nand_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona0.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona1.rbf: not applicable</li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd.core.rbf $CORE_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n file://agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=xxxxxxxxx \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the file:</p> <pre><code>SRC_URI[agilex7_dk_si_agf014eb_gsrd_core.sha256sum] = \"5d633ee561d5cc8c22b51211a144654fdc0be47ee14b07ac134074cbff84eb8b\"\n</code></pre> <p>by using the following commands:</p> <pre><code>sed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014eb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014eb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-agilex-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof \\\nghrd.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-qspi_1","title":"Boot from QSPI","text":"<p>This section presents how to boot from QSPI.</p> <p>Much of the same binaries as when booting from SD card can be used to boot from QSPI, because:</p> <ul> <li>The QSPI resides on the DevKit board, and not on the HPS daughtercard, so there are no board changes:</li> <li>The same GHRD configuration can be used</li> <li>The same U-Boot devce tree can be used</li> <li>The same Linux device tree can be used</li> <li>U-Boot uses distroboot, which will try first booting from SD/MMC, then from QSPI, then from NAND, so the same U-Boot can be used.</li> </ul> <p>As the QSPI has a much smaller size than the SD card (256MB vs 2GB) the rootfs is smaller, and less functionality is provided. The purpose of this section is just to show Linux booting.</p> <p>Note: The HPS speed for accessing SDM QSPI is limited to ~8MB/s. It is up to you to decide whether this level of performance is sufficient for your application. If not, it is recommended you use an SD card or eMMC device to store the HPS components such as the rootfs. Note that the QSPI speed limitation does not apply when SDM accesses the QSPI, it is just for HPS accessing SDM QSPI.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#qspi-flash-layout","title":"QSPI Flash Layout","text":"MTD Partition UBI Volume Volume Name Type Image/Individual File Group File Size 0 (qspi_uboot) N/AN/A N/AN/A RAWRAW bitstream (FPGA image, SDM firmware)u-boot.itb N/AN/A 64MB2MB 1 (qspi_root) 01234 envscriptkerneldtbrootfs UBIUBIUBIUBIUBIFS u-boot.envu-boot.scrkernel.itbkernel.dtbrootfs.ubifs root.ubi 256KB128KB24MB256KB160MB"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image_1","title":"Create QSPI Image","text":"<p>1. Create a folder to contain all the qspi binaries, and create symlinks to actual location for all files:</p> <pre><code>cd $TOP_FOLDER\nrm -rf qspi-boot &amp;&amp; mkdir qspi-boot &amp;&amp; cd qspi-boot\nln -s $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof fpga.sof\nln -s $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex spl.hex\nln -s $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/console-image-minimal-agilex7_nor.ubifs rootfs.ubifs\n</code></pre> <p>2. Create U-Boot image:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncp $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot.itb u-boot.bin\n</code></pre> <p>3. Create hps.ubi file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncat &lt;&lt;EOT &gt;ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOT\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>4. Create the QSPI image using the provided Quartus Programming File Generator (PFG) file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/f-series/soc/gsrd/collateral/agilex7f_gsrd.pfg\nquartus_pfg -c agilex7f_gsrd.pfg\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-pfg-file","title":"Create PFG File","text":"<p>This section presents how to manually re-create the Programming File Generator file provided at https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/f-series/soc/gsrd/collateral/agilex7f_gsrd.pfg</p> <p>1. Start Quartus Programming File Generator GUI:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nqpfgw &amp;\n</code></pre> <p>2. In PFG Output Files tab:</p> <ul> <li>Select Device Family as \"Agillex\"</li> <li>Select Configuration Mode as \"Active Serial x4\"</li> <li>Edit Name as \"flash_image\"</li> <li>Check JTAG Indirect Configuration File (.jic)</li> <li>Check Memory Map File (.map)</li> </ul> <p></p> <p>3. In PFG Input Files tab:</p> <ul> <li>Click Add Bitstream\", then browse to \"fpga.sof\" link, and add click *Open to add it.</li> <li>Click Bitstream_1&gt;fpga.sof then click Properties the click HPS Bootloader, browse to \"spl.hex\" then click Open to add it.  Note: By the time the fpga.sof file is read the following error is displayed, this was addressed by adding the spl.hex file to the Bitstream: File fpga.sof is incomplete- HPS is present but bootloader information is missing.</li> <li>Click Add Raw Data then change the extension filter to .bin then browse to \"u-boot.bin\" and click Open to add it.</li> <li>Click on the \"u-boot.bin\" then click \"Prpperties\" then select Bit swap option to \"On\"</li> <li>Repeat the above 2 steps for the following files:</li> <li>hps.bin</li> </ul> <p>The Input Files tab will now look something like this:</p> <p></p> <p>4. In the PFG Configuration Device tab:</p> <ul> <li>Click Add Device, select the Micron MT25QU02G device then click Add</li> <li>Click the MT25QU02G device, then click Add Partition, select the options as following then click OK:</li> </ul> <p></p> <ul> <li>Click the MT25QU02G device, then click Add Partition, select the options as following then click OK:</li> </ul> <p> ting</p> <ul> <li>Repeat the above step for the rest of binary files, choosing the following offsets:</li> <li>hps: 0x04200000</li> <li>Click Flash Loader &gt; Select then browse to the device used on the devkit then click OK:</li> </ul> <p></p> <p>The Configuration Device tab will now look something like this:</p> <p></p> <p>5. Go to File &gt; Save As and save the configuration file as \"flash_image_qspi.pfg\".</p> <p>6. [Optional] Open the file \"flash_image_qspi.pfg\" with a text editor and change absolute paths to relative paths.</p> <p>The file will look like this:</p> <pre><code>&lt;pfg version=\"1\"&gt;\n&lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n&lt;output_files&gt;\n&lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n&lt;file_options/&gt;\n&lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n&lt;/output_file&gt;\n&lt;/output_files&gt;\n&lt;bitstreams&gt;\n&lt;bitstream id=\"Bitstream_1\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;/bitstreams&gt;\n&lt;raw_files&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n&lt;/raw_files&gt;\n&lt;flash_devices&gt;\n&lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"u-boot\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"hps\" size=\"0\"/&gt;\n&lt;/flash_device&gt;\n&lt;flash_loader&gt;AGFB014R24B&lt;/flash_loader&gt;\n&lt;/flash_devices&gt;\n&lt;assignments&gt;\n&lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n&lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;assignment partition_id=\"u-boot\"&gt;\n&lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"0\" partition_id=\"hps\"&gt;\n&lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;/assignments&gt;\n&lt;/pfg&gt;\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-nand_1","title":"Boot From NAND","text":"<p>This section presents how to boot from NAND, including how to build all binaries.</p> <p>Build instructions are the same as for standard SD or QSPI boot. The U-Boot, ATF and Linux binaries are all the same. The only difference is that the GHRD is configured for the NAND HPS Daughtercard, then recompiled.</p> <p>Note: As the NAND used on the devkit has a smaller size than the SD card (1GB vs 2GB) the rootfs is smaller, and less functionality is provided. The purpose of this section is just to show Linux booting.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#nand-flash-layout","title":"NAND Flash Layout","text":"MTD Partition UBI Volume Volume Name Type Image/File Flash Offset Size Size in Hex 0 (u-boot) N/A N/A RAW u-boot.itb 0x00000000 2MB 0x00200000 1 (root) 0 env UBI u-boot.env root.ubi 0x00200000 onwards 256KB 0x40000 1 script UBI u-boot.scr 128KB 0x00020000 2 kernel UBI kernel.itb 64MB 0x04000000 3 dtb UBI kernel.dtb 256KB 0x00040000 4 rootfs UBIFS rootfs.ubifs &lt;957MB &lt;0x3BD70000"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-environment_1","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd.nand\nmkdir agilex7f_gsrd.nand\ncd agilex7f_gsrd.nand\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-hardware-design_1","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-nand-baseline-all\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_nand_baseline.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_nand_baseline_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-core-rbf_1","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_nand_baseline_hps_debug.sof \\\nghrd.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-yocto_1","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#customize-yocto_1","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_nand_ghrd.core.rbf</li> <li>agilex7_dk_si_agf014eb_pr_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona0.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona1.rbf: not applicable</li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_nand_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd.core.rbf $CORE_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n file://agilex7_dk_si_agf014eb_nand_ghrd.core.rbf;sha256sum=xxxxxxxxxxxxx \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_nand_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_nand_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the file:</p> <pre><code>SRC_URI[agilex7_dk_si_agf014eb_nand_core.sha256sum] = \"f7a9a7f60f6c1c1c0197292573c844be625d9cd3e96c1c1105e1a6057aad699c\"\n</code></pre> <p>by using the following command:</p> <pre><code>sed -i \"/agilex7_dk_si_agf014eb_nand_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-yocto_1","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014eb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014eb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images</code> folder are:</p> File Description gsrd-console-image-agilex7_nand.ubifs UBI root partition image u-boot-agilex7-socdk-gsrd-atf/u-boot.itb U-Boot FIT image u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image_2","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_nand_baseline.sof \\\nghrd.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code> - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li><code>$TOP_FOLDER/ghrd.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-nand-binaries","title":"Build NAND Binaries","text":"<p>1. Gather the files into a single folder, using symlinks:</p> <pre><code>cd $TOP_FOLDER\nrm -rf nand-bin &amp;&amp; mkdir nand-bin &amp;&amp; cd nand-bin\nln -s $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/gsrd-console-image-agilex7_nand.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/socfpga_agilex7_socdk_nand.dtb .\n</code></pre> <p>2. Install <code>mtd-tools</code> if not already installed. On Ubuntu the command is:</p> <pre><code>sudo apt-get install mtd-tools\n</code></pre> <p>3. Create UBI configuration file for the root partition:</p> <pre><code>cat &lt;&lt;EOT &gt;ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=64MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nimage=socfpga_agilex7_socdk_nand.dtb\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=400MiB\nvol_flag=autoresize\nEOT\n</code></pre> <p>4. Create the <code>root.ubi</code> file:</p> <pre><code>ubinize -o root.ubi -p 128KiB -m 2048 -s 2048 ubinize.cfg\n</code></pre> <p>This is what the above parameters mean:</p> <ul> <li>-p: physical eraseblock size of the flash</li> <li>-m: minimum input/output unit size of the flash</li> <li>-s: sub-pages and sub-page size, ubinize will take into account and put the VID header to same NAND page as the EC header</li> </ul> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/nand-bin/root.ubi</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#partial-reconfiguration_1","title":"Partial Reconfiguration","text":"<p>Partial reconfiguration (PR) allows you to reconfigure a portion of the FPGA dynamically, while the rest of the FPGA design continues to function.</p> <p>This section shows how to build everything needed to demonstrate the PR scenarios. Note that most of the binaries are the same as for the other boot scenarios (SD card, QSPI, NAND) just the following files are changed:</p> <ul> <li>New GHRD variant, creating different configuration bitstreams</li> <li>Updated core.rbf, persona0.rbf, persona1.rbf compared to prebuilt default files used by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-environment_2","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd.pr\nmkdir agilex7f_gsrd.pr\ncd agilex7f_gsrd.pr\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-hardware-design_2","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-pr-all\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_pr_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_pr.sof</code>- FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_pr_persona1.rbf</code> - persona 1 PR bitstream</li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_pr_persona0.rbf</code> - persona 0 PR bitstream</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-core-rbf_2","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c \"$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_pr_hps_debug.sof\" \\\nghrd.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-yocto_2","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#customize-yocto_2","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_nand_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_ghrd.core.rbf</li> <li>agilex7_dk_si_agf014eb_pr_persona0.rbf</li> <li>agilex7_dk_si_agf014eb_pr_persona1.rbf</li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_pr_ghrd.core.rbf\nPER0_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_pr_persona0.rbf\nPER1_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_pr_persona1.rbf\nln -s $TOP_FOLDER/ghrd.core.rbf $CORE_RBF\nln -s $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_pr_persona0.rbf $PER0_RBF\nln -s $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_pr_persona1.rbf $PER1_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n file://agilex7_dk_si_agf014eb_pr_ghrd.core.rbf;sha256sum=xxxxxxxxxxx \\\n file://agilex7_dk_si_agf014eb_pr_persona0.rbf;sha256sum=xxxxxxxxxxx \\\n file://agilex7_dk_si_agf014eb_pr_persona1.rbf;sha256sum=xxxxxxxxxxx\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nPER0_SHA=$(sha256sum $PER0_RBF | cut -f1 -d\" \")\nPER1_SHA=$(sha256sum $PER1_RBF | cut -f1 -d\" \")\nOLD_CORE_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_pr_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core\"\nNEW_CORE_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_pr_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nOLD_PER0_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0\"\nNEW_PER0_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_pr_persona0.rbf;sha256sum=$PER0_SHA\"\nOLD_PER1_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1\"\nNEW_PER1_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_pr_persona1.rbf;sha256sum=$PER1_SHA\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\nsed -i \"s/$OLD_PER0_URI/$NEW_PER0_URI/g\" $RECIPE\nsed -i \"s/$OLD_PER1_URI/$NEW_PER1_URI/g\" $RECIPE\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the files:</p> <pre><code>SRC_URI[name=agilex7_dk_si_agf014eb_pr_core.sha256sum] = \"69245470a36274f1f002cb275748664902d9262f577cae4bba92813cb48fdeaf\"\nSRC_URI[agilex7_dk_si_agf014eb_pr_persona0.sha256sum] = \"6556cc83a8e8a38fb1e52945d91bd651466e9553f8e60c04df5e71ee36dc45f2\"\nSRC_URI[agilex7_dk_si_agf014eb_pr_persona1.sha256sum] = \"8a0cdcb38aead468a62eb0cba68af05a4e242bd79a617f49176647d766b70b28\"\n</code></pre> <p>by using the following commands:</p> <pre><code>sed -i '/agilex7_dk_si_agf014eb_pr_core\\.sha256sum/d' $RECIPE\nsed -i '/agilex7_dk_si_agf014eb_pr_persona0\\.sha256sum/d' $RECIPE\nsed -i '/agilex7_dk_si_agf014eb_pr_persona1\\.sha256sum/d' $RECIPE\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-yocto_2","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014eb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014eb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-agilex-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image_3","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_pr.sof \\\nghrd.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/","title":"Nios\u00ae V/g Processor Floating Point Unit (FPU) Design","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#nios-vg-processor-floating-point-unit-design-overview","title":"Nios\u00ae V/g Processor Floating Point Unit Design Overview","text":"<p>This example design is about applying the floating point unit in Nios V/g processor. The example application evaluates the floating point rate of Nios V/g processor by using Linpack benchmark</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#prerequisites","title":"Prerequisites","text":"<ul> <li>Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tile and E-Tile), ordering code DK-SI-AGF014EB. Refer to the board documentation for more information about the development kit.</li> <li>Mini and Micro USB Cable. Included with the development kit.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#binaries","title":"Binaries","text":"<ul> <li>Prebuilt binaries are located here.</li> <li>The sof and elf files required to run the design can be found in \"ready_to_test\" folder </li> <li>Program the sof and download the elf file on board</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#design-archiecture","title":"Design Archiecture","text":"<p>This example design includes a Nios\u00ae V/g processor connected to the On Chip RAM-II, JTAG UART IP and System ID peripheral core. The objective of the design is to accomplish data transfer between the processor and soft IP peripherals for showcasing the FPU feature of the Nios V/g IP core.  The application demonstrates the Floating Point Unit (FPU) feature of Nios V/g IP core using Linpack Benchmark- http://www.netlib.org/utk/people/JackDongarra/faq-linpack.html</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#nios-vg-processor","title":"Nios\u00ae V/g Processor","text":"<ul> <li>Balanced (For interrupt driven baremetal and RTOS code)</li> <li>Nios\u00ae V/g processor is highly customizable and can be tailored to meet specific application requirements, providing flexibility and scalability in embedded system designs.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#ip-cores","title":"IP Cores","text":"<p>The following IPs are used in this Platform Designer component of the design:</p> <ul> <li>Nios\u00ae V/g soft processor core</li> </ul> <ul> <li>On Chip RAM-II</li> </ul> <ul> <li>JTAG UART</li> </ul> <ul> <li>System ID</li> </ul> <ul> <li>Clock Bridge, Reset Controller</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#hardware-setup","title":"Hardware Setup","text":"<p>Refer to Agilex\u00ae 7 FPGA F-Series Transceiver-SoC Development Kit User Guide to setup the hardware connection.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#nios-v-address-map","title":"Nios V Address Map","text":"Address Offset Size (Bytes) Peripheral Description 0x0000_0000 1MB On-Chip RAM To store application 0x0011_0068 8 JTAG UART Communication between a host PC and the Nios V processor system 0x0011_0060 8 System ID Hardware configuration system ID (0x000000a5) 0x0011_0040 32 Timer Timer IP to calculate the computation time"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on use case. </p>  User Flow 1: Testing with Prebuild Binaries.  User Flow 2: Testing Complete Flow. User Flow Description Required for User flow 1 Required for User flow 2 Environment Setup Tools Download and Installation Yes Yes Compilation Hardware compilation No Yes Software compilation No Yes Programing Program Hardware Binary SOF Yes Yes Program Software Image ELF Yes Yes Testing Open JTAG UART Terminal Yes Yes"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#tools-download-and-installation","title":"Tools Download and Installation","text":"<ol> <li>Quartus Prime Pro</li> </ol> <ul> <li>Download the Quartus\u00ae Prime Pro Edition software version 25.1 from the FPGA Software Download Center webpage of the Intel website. Follow the on-screen instructions to complete the installation process. Choose an installation directory that is relative to the Quartus\u00ae Prime Pro Edition software installation directory.</li> <li>Set up the Quartus tools in the PATH, so they are accessible without full path. <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/25.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#compilation","title":"Compilation","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#hardware-compilation","title":"Hardware Compilation","text":"<ul> <li>Invoke the <code>quartus_py</code> shell in the terminal</li> <li>Run the following command in the terminal from top level project directory:</li> </ul> <pre><code>quartus_py ./scripts/build_sof.py\n</code></pre> <ul> <li>The quartus tool will compile the design and generate the output files</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#software-compilation","title":"Software Compilation","text":"<p>Note:   It is recommended to clean the app/build project before regenerating elf (cmake and make). - To create software app, run the following commands in the terminal: <pre><code>niosv-bsp -c --quartus-project=hw/quartus_ag.qpf --qsys=hw/qsys_ag.qsys --type=hal sw/bsp/settings.bsp --cmd=\"set_setting hal.sys_clk_timer {none}\" --cmd=\"set_setting hal.timestamp_timer {timer_0}\"\nniosv-app --bsp-dir=sw/bsp --app-dir=sw/app --srcs=sw/app/linpack.c\nniosv-shell\ncmake -S ./sw/fpu -B sw/fpu/build -G \"Unix Makefiles\"\nmake -C sw/fpu/build\nelf2hex sw/app/build/app.elf -b 0x0 -w 32 -e 0xfffff \n</code></pre></p> <p>Note:The software can be compiled using the Ashling Visual Studio Code Extension for Altera FPGAs</p> <p>For information on the build process, please refer to the following document- Ashling VSCode Extension</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#programing","title":"Programing","text":"<p>Note: Reduce the JTAG clock frequency to 6MHz using the following command, before programming the sof file <pre><code>jtagconfig --setparam 1 JtagClock 6M\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#program-hardware-binary-sof","title":"Program Hardware Binary SOF","text":"<ul> <li>Program the generated sof and then download the elf file on the board</li> </ul> <pre><code>quartus_pgm --cable=1 -m jtag -o 'p;ready_to_test/quartus_ag.sof'\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#program-software-image-elf","title":"Program Software Image ELF","text":"<ul> <li>Download the elf file on the board <pre><code>niosv-download -g ready_to_test/app.elf -c 1\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#testing","title":"Testing","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/niosv/niosv_g/fpu_test/ug-fpu-agx7f-fpga/#open-jtag-uart-terminal","title":"Open JTAG UART Terminal","text":"<ul> <li>Verify the output on the terminal by using the following command in the terminal:</li> </ul> <pre><code>juart-terminal -c 1 -i 0 \n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/","title":"SoC FPGA Remote Debug Tutorial Example Design User Guide: Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#introduction","title":"Introduction","text":"<p>Altera offers an integrated set of System Level Debug (SLD) tools, including:</p> <ul> <li>SignalTap II Logic Analyzer</li> <li>In-System Sources and Probes (ISSP),</li> <li>In-System Memory Content Editor)</li> </ul> <p>Typically, the System-Level Debugging (SLD) communication solution was interfacing with the outside world through the JTAG. Then either an USB or Ethernet Blaster could be used to interface JTAG to the host PC.</p> <p></p> <p></p> <p>Another alternative approach is also available, to interface the SLD to the outside world directly through Ethernet on board, without requiring either an USB or Ethernet Blaster.</p> <p></p> <p>This page presents an example on how enable this remote debug feature on top of the GSRD.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#architecture","title":"Architecture","text":"<p>In the traditional approach the SLD communication solution was based on the Altera JTAG Interface (AJI) which interfaced with the JTAG TAP controller (hard atom in Altera devices which implements the JTAG protocol). The SLD tools used the JTAG channel for communication between software and hardware.</p> <p></p> <p>The remote FPGA debugging solution consists of the following:</p> <ul> <li>JTAG-Over Protocol (JOP) Component: Platform Designer component which enables access to debug information through an Avalon\u00ae-MM slave bus</li> <li>Etherlink: HPS application exporting debug information over Ethernet, available on github: https://github.com/altera-opensource/remote-debug-for-intel-fpga</li> </ul> <p></p> <p>The JOP component requires reset and clocking and also provides an Avalon\u00ae-MM slave bus through which is configured and debug information is accessed.</p> <p>Th Etherlink application runs on HPS, accesses the JOP component slave bus to access the debug information, and provides a TCP/IP link from the host PC running the Quartus Pro debug tools to the board.</p> <p>The etherlink works with the standard UIO Linux kernel driver.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#example","title":"Example","text":"<p>This section shows an example of how to use the Remote Debug feature. Communication is established from the board to the host PC through Ethernet, so that the board appears as another JTAG device, listed by jtagconfig utility.</p> <p>The example is based on the GSRD, with the following changes:</p> <ul> <li>Adding JOP component to the GHRD</li> <li>Adding JOP to the Linux device tree</li> </ul> <p>Notes:</p> <ul> <li>UIO driver is enabled as module in the default kernel configuration file</li> <li>etherlink is already part of the rootfs, built by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Altera Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 1 P-Tiles &amp; E-Tiles) ordering code DK-SI-AGF014EB.<ul> <li>SD/MMC HPS Daughtercard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel\u00ae FPGA Download Cable II</li> <li>Micro SD card</li> </ul> </li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for more details about the devkit.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7.remote_debug\nmkdir agilex7.remote_debug\ncd agilex7.remote_debug\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>The hardware design is based on the GSRD, just that the JOP component is added, and connected to clock, reset and the LWH2F bridge. The following instructions are used:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-generate-design\ncd agilex_soc_devkit_ghrd\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/f-series/soc/remote-debug/collateral/agilex7-ghrd-add-jop.tcl\nqsys-script --qpf=ghrd_agfb014r24b2e2v.qpf --script=agilex7-ghrd-add-jop.tcl --system-file=qsys_top.qsys\ncd ..\nmake agf014eb-si-devkit-oobe-baseline-package-design\nmake agf014eb-si-devkit-oobe-baseline-prep\nmake agf014eb-si-devkit-oobe-baseline-build\nmake agf014eb-si-devkit-oobe-baseline-sw-build\nmake agf014eb-si-devkit-oobe-baseline-test\nmake agf014eb-si-devkit-oobe-baseline-install-sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul> <p>For reference, the JOP component can be added manually to a Platform Designer system as follows:</p> <p>1. In the IP Catalog search for jop and double-click the component to add it to the system:</p> <p></p> <p>2. Configure the JOP component as follows:</p> <p></p> <p>3. Connect the reset and clock to JOP component, also connect it's slave bus to the HPS LW bridge, and map it to the desired offset:</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#build-corerbf-file","title":"Build Core.RBF File","text":"<p>This section shows how to create the core RBF file, which is needed by the Yocto recipes:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#build-yocto","title":"Build Yocto","text":"<p>Perform the following steps to build Yocto:</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>3. Enable the JOP UIO driver in the Linux device tree, by editing the file <code>meta-intel-fpga-refdes</code> to inlcude the changes shown below:</p> <pre><code>diff --git a/recipes-bsp/device-tree/files/socfpga_ilc.dtsi b/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\nindex 387d8bd..156dbb8 100644\n--- a/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\n+++ b/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\n@@ -14,5 +14,10 @@\n            status = \"disabled\";\n            altr,sw-fifo-depth = &lt;32&gt;;\n        };\n+        jop@f9008000{\n+                                compatible = \"generic-uio\";\n+                                reg = &lt;0xf9008000 0x5000&gt;;\n+                                reg-names = \"jop\";\n+                };\n    };\n };\n</code></pre> <p>Note that the range of memory where the JOP is located is <code>0xf9008000</code> .. <code>0xf900dfff</code>.</p> <p>This can be done with the provided patch file:</p> <pre><code>rm -f agilex7-dts-add-jop.patch\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/f-series/soc/remote-debug/collateral/agilex7-dts-add-jop.patch\npushd meta-intel-fpga-refdes\npatch -p1 &lt; ../agilex7-dts-add-jop.patch\npopd\n</code></pre> <p>4. Update the recipe to not use a broken version of =etherlink=:</p> <pre><code>sed -i 's/3a3eb126321429c0845276ef9c200df7786dbf74/b6a13b03fe7e9566063eae65d99bd8bc1190ce62/g' meta-intel-fpga-refdes/recipes-tools/remote-debug-app/remote-debug-app_1.0.bb\n</code></pre> <p>5. Update your Yocto recipes to use the core RBF file you have built, similar to how the GSRD does it:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>6. Build the Yocto recipes:</p> <pre><code>bitbake_image\n</code></pre> <p>7. Gather the Yocto binaries:</p> <pre><code>package\n</code></pre> <p>The following relevant files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#build-qspi-image","title":"Build QSPI Image","text":"<p>Run the following commands to build the QSPI image:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#run-example","title":"Run Example","text":"<p>The instructions from this section present how to run the remote debug example. Refer to the GSRD for more detailed instructions on how to set up the board, serial port, and write the binaries.</p> <p>1. Write the QSPI image <code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic</code> to flash.</p> <p>2. Extract and write the SD card image <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/sdimage.tar.gz</code> to the SD card</p> <p>3. Boot board and log into Linux.</p> <p>4. Determine board IP address by running the <code>ifconfig</code> command:</p> <pre><code>root@agilex7dksiagf014eb:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 10.122.105.175  netmask 255.255.255.0  broadcast 10.122.105.255\n        inet6 fe80::7097:4bff:fe41:b7c2  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 72:97:4b:41:b7:c2  txqueuelen 1000  (Ethernet)\nRX packets 218  bytes 23619 (23.0 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 78  bytes 11072 (10.8 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 22  </code></pre> <p>5. Remove pre-existing instances of the driver, and load it again:</p> <pre><code>root@agilex7dksiagf014eb:~# rmmod uio_pdrv_genirq\nroot@agilex7dksiagf014eb:~# modprobe uio_pdrv_genirq of_id=\"generic-uio\"\ns```\n6\\. Start the etherlink application, specifying which port to accept connections on as shown below:\n\n```bash\n\nroot@agilex7dksiagf014eb:~# etherlink --port=33301\nINFO: Etherlink Server Configuration:\nINFO:    H2T/T2H Memory Size  : 4096\nINFO:    Listening Port       : 33301\nINFO:    IP Address           : 0.0.0.0\nINFO: UIO Platform Configuration:\nINFO:    Driver Path: /dev/uio0\nINFO:    Address Span: 20480\nINFO:    Start Address: 0x0\nINFO: Server socket is listening on port: 33301\n</code></pre> <p>7. On the host, establish the JTAG communication to the board through Ethernet, using the board IP and the selected port number:</p> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0\n</code></pre> <p>8. Also on the host, run the 'jtagconfig' command to show the newly added connection:</p> <pre><code>$ jtagconfig\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0]\n020D10DD   VTAP10\n</code></pre> <p>At this point, the connection can be used by the tools which need a JTAG connection, like SignalTap.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/","title":"HPS Remote System Update Tutorial Example Design: Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on the Agilex\u2122 7 Transceiver-SoC Development kit P-Tile E-Tile production Linear power solution (DK-SI-AGF014EB), including the following.</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> </ul> <ul> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>f22Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> </ul> <ul> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>Refer to Agilex\u2122 7 Hard Processor System Remote System Update User Guide for details about the Remote System Update. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p> <p>Note: intel-rsu repository uses master branch.</p> <p>For RSU example previous 24.2 version, please refer to Agilex 7 SoC HPS Remote System Update.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus\u00ae Prime Pro Edition Version 25.1.1  for compiling the hardware projects, generating the flash images and writing to flash </li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li>Agilex 7 Transceiver-SoC Development kit P-Tile E-Tile Production Linear power solution(DK-SI-AGF014EB)  for running the example. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are these.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul> <p>Note: To build binaries for a different development kit than the one used in this page, please refer to the Building the Hardware Projects section in the corresponding  GSRD page for that development kit, which is the section that may differ from the instructions presented here.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex-rsu mkdir agilex-rsu cd agilex-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next.</p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below.</p> <pre><code>cd $TOP_FOLDER # Build 4 versions of the hardware design\nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\n# boot from FPGA \nexport BOOTS_FIRST=fpga # enable watchdog \nexport ENABLE_WATCHDOG_RST=1 # treat watchdog timeout as configuration failure to trigger RSU \nexport WATCHDOG_RST_ACTION=remote_update\n# Customize parms in tcl\nsed -i '/STRATIX_JTAG_USER_CODE 4/i set_global_assignment -name RSU_MAX_RETRY_COUNT 3' agilex7f-ed-gsrd/agilex_soc_devkit_ghrd/create_ghrd_quartus.tcl\nfor version in {0..3}\ndo\nrm -rf ghrd.$version\ncp -r agilex7f-ed-gsrd ghrd.$version\ncd ghrd.$version\n# update sysid to make binaries slightly different \nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' agilex_soc_devkit_ghrd/create_ghrd_qsys.tcl\n# Finsish customization and now building the hardware design\nmake agf014eb-si-devkit-oobe-baseline-all\ncd ..\ndone\nrm -rf agilex7f-ed-gsrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created.</p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/install/designs/agf014eb_si_devkit_oobe_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/install/designs/agf014eb_si_devkit_oobe_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/install/designs/agf014eb_si_devkit_oobe_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/install/designs/agf014eb_si_devkit_oobe_baseline.sof </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone https://github.com/altera-fpga/arm-trusted-firmware cd arm-trusted-firmware # checkout the branch used for this document, comment out to use default \ngit checkout -b test -t origin/socfpga_v2.12.1 make bl31 PLAT=agilex cd .. </code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga\n# comment out next line to use the latest default branch \ngit checkout -b test -t origin/socfpga_v2025.04 # enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin .\n# Create configuration custom file.\ncat &lt;&lt; EOF &gt; config-fragment-agilex\n# Use 'Image' for kernel image instead of 'kernel.itb'\nCONFIG_BOOTFILE=\"Image\"\n# - Disable NAND/UBI related settings from defconfig.\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# - Disable distroboot and use specific boot command.\nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable; setenv bootfile Image; run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex_defconfig\n# Use created custom configuration file to merge with the default configuration obtained in .config file.\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex\nmake -j 48\ncd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga\ngit clone https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\n# checkout the branch used for this document, comment out to use default\ngit checkout -b test -t origin/socfpga-6.12.19-lts # configure the RSU driver to be built into the kernel\nmake clean &amp;&amp; make mrproper\nmake defconfig\n./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y\nmake oldconfig\nmake -j 48 Image dtbs\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is provided below so and you can easily create the initial flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER # Create automatically the .pfg file\ncat &lt;&lt; EOF &gt; initial_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.0/install/designs/agf014eb_si_devkit_oobe_baseline.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n        &lt;bitstream id=\"Bitstream_2\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.1/install/designs/agf014eb_si_devkit_oobe_baseline.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0020FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00210000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x02000000\" e_addr=\"0x02FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03000000\" e_addr=\"0x03FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;AGFB014R24B&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/altera_pro/25.1/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg\n</code></pre> <p>Here are the complete instructions on how to manually create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER\nqpfgw &amp;\n</code></pre> </li> <li> <p>Select the Device family as Agilex 7, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bitswap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file ghrd_agfb014r24b2e2v.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/install/designs/agf014eb_si_devkit_oobe_baseline.sof image. This is the initial application image. The tab now looks like below.</p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. This opens the window to browse for the FSBL and select authentication and encryption settings. </p> <p> </p> </li> <li> <p>Click the Bootloader  (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the MT25QU02G in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (agf014eb_si_devkit_oobe_baseline.sof). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0090FFFF in order to reserve 7MB for the factory image. This end address was calculated by adding 8MB to the end of the BOOT_INFO partition. Click OK. </p> <p>Note: There is a requirement that the starting address of the SPT0 partition is aligned to 64KB. In order to warranty this, the End Address of the FACTORY_IMAGE must finish at an address ending with 0xXXXXFFFF.</p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be trieed after all the application images failed. </p> </li> <li> <p>Select the MT25QU02G flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(agf014eb_si_devkit_oobe_baseline.sof). This becomes the initial application image. Select the Page as 1. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x01000000 and End Address = 0x01FFFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.    The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image</p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions) and set the start and end addresses as follows. </p> <p>* P2: Start Address = 0x02000000 and End Address = 0x02FFFFFF.     * P3: Start Address = 0x03000000 and End Address = 0x03FFFFFF. </p> <p>Note: Make sure that all the partitions created for the applications fit in the appropriate QSPI partition or partitions defined in device corresponding device tree in U-Boot and Linux. In the case of Linux, also make sure that the QSPI partition or partitions defined in the device tree to store the applications partitions are also defined in the qspi.rc file in LIBRSU.</p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c initial_image.pfg\n</code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -rf images/application2.rpd\nquartus_pfg -c hw/ghrd.2/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON\n</code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/factory_update.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created. </p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/decision_firmware_update.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decision firmware update image is created. </p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul> <p>Notes:</p> <ul> <li>The first SOF file contains the factory image, from which data is taken to fill out the new decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from this SOF file is not used.</li> <li>The app_image parameter contains the SOF that is used for the application image section of the combined image.</li> <li>The hps_path parameter is unused, and may be removed in the future.</li> <li>The app_image_hps_path parameter contains the HPS FSBL hex file to be used for the application imge section of the combined image.</li> <li>When using HPS first, the additional parameter \"-o hps=1\" needs to be added, and the following files are created combined_application.hps.rpd (combined application image)  and combined_application.core.rbf (corresponding fabric configuration file).</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar   https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf zlib-1.3.1\nwget http://zlib.net/zlib-1.3.1.tar.gz\ntar xf zlib-1.3.1.tar.gz\nrm zlib-1.3.1.tar.gz\ncd zlib-1.3.1/\nexport CROSS_PREFIX=${CROSS_COMPILE}\n./configure\nmake\nexport ZLIB_PATH=`pwd`\ncd ..\n</code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.3.1/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.3.1/libz.so* - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application. </p> <pre><code>cd $TOP_FOLDER rm -rf intel-rsu\ngit clone https://github.com/altera-fpga/intel-rsu\ncd intel-rsu\n# checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/master\ncd lib\n# add -I$(ZLIB_PATH) to CFLAGS\nsed -i 's/\\(CFLAGS := .*\\)$/\\1 -I\\$\\(ZLIB_PATH\\)/g' makefile\nmake\ncd ..\ncd example\n# add -L$(ZLIB_PATH) to LDFLAGS\nsed -i 's/\\(LDFLAGS := .*\\)$/\\1 -L\\$\\(ZLIB_PATH\\)/g' makefile\nmake\ncd ..\ncd ..\n</code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/intel-rsu/lib/librsu.so - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/intel-rsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/intel-rsu/example/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example.</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2021.04/gsrd/tools/make_sdimage_p3.py chmod +x make_sdimage_p3.py\n# prepare the fat contents \nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents \nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\nsudo sed -i 's/agilex7_dk_si_agf014eb/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\nsudo cp $TOP_FOLDER/intel-rsu/example/rsu_client home/root/\nsudo cp $TOP_FOLDER/intel-rsu/lib/librsu.so lib/\nsudo cp $TOP_FOLDER/intel-rsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\ncd ..\n# create sd card image\nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card. </p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Agilex SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to JTAG. </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer.</p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\"\n</code></pre> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to QSPI. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Agilex SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <ol> <li> <p>Power up the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2024.01-33547-g098abd8f13-dirty (Aug 19 2024 - 12:15:42 -0500)\nReset state: Cold\nMPU          1200000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nDDR: 8192 MiB\nSDRAM-ECC: Initialized success with 1722 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nNOTICE:  BL31: v2.10.1  (release):QPDS24.2_REL_GSRD_PR\nNOTICE:  BL31: Built : 12:14:02, Aug 19 2024\nU-Boot 2024.01-33547-g098abd8f13-dirty (Aug 19 2024 - 12:15:42 -0500)socfpga_agilex\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Agilex SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  28 devices, 23 uclasses, devicetree: separate\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:   Warning: ethernet@ff800000 (eth0) using random MAC address - 86:c6:bd:7c:4f:7d\neth0: ethernet@ff800000\nHit any key to stop autoboot:  0 SOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options. </p> <pre><code>SOCFPGA # rsu \nrsu - Agilex SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name &lt;name&gt; - find slot by name and display the slot number slot_count - display the slot count slot_disable &lt;slot&gt; - remove slot from CPB slot_enable &lt;slot&gt; - make slot the highest priority slot_erase &lt;slot&gt; - erase slot slot_get_info &lt;slot&gt; - display slot information slot_load &lt;slot&gt; - load slot immediately slot_load_factory - load factory immediately slot_priority &lt;slot&gt; - display slot priority slot_program_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program buffer into slot, and make it highest priority slot_program_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program raw buffer into slot slot_program_factory_update_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program factory update buffer into slot, and make it highest priority slot_rename &lt;slot&gt; &lt;name&gt; - rename slot slot_delete &lt;slot&gt; - delete slot slot_create &lt;name&gt; &lt;address&gt; &lt;size&gt; - create slot slot_size &lt;slot&gt; - display slot size slot_verify_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against buffer slot_verify_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against raw buffer status_log - display RSU status update &lt;flash_offset&gt; - Initiate firmware to load bitstream as specified by flash_offset notify &lt;value&gt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt &lt;address&gt; - restore SPT from an address save_spt &lt;address&gt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb &lt;address&gt; - restore CPB from an address save_cpb &lt;address&gt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00920000 RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00210000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000210000 Length: 0x00700000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code> SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\nSOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 16777216. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 16777216. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 16777216. </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased. SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n2248704 bytes read in 103 ms (20.8 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Power cycle the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting the specific image to be loaded, in this case using the following command.</p> <pre><code>rsu slot_load 1 </code></pre> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands. </p> <pre><code>SOCFPGA # rsu update 0x01000000 \nRSU: RSU update to 0x0000000001000000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log to confirm it.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202:  both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report.</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code>SOCFPGA # mw.l 0xffd00204 0 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value. </p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf0061234 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it. </p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n2478080 bytes read in 113 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nSlot 2 was programmed with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2. </p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x02000000 0x10000 \nSF: 16384 bytes @ 0x2000000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf004d003 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status. </p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 512 KB). </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x10000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d00f Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot. </p> <p><pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> 6. Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <p><pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK </code></pre> 4. Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image : 0x01000000 Last Fail Image : 0x00100000 State : 0xf004d010 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre>   The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <p><pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> 6. Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted Current Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d011 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected. </p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created. </p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <p><pre><code>SOCFPGA # rsu clear_error_status \n</code></pre>   Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds. </p> <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. </p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x918000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF Bad SPT0 magic number 0xFFFFFFFF no valid SPT0 and SPT1 found Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the highest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails. </p> <pre><code>SOCFPGA # rsu slot_count \ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#using-the-combined-application-image","title":"Using the Combined Application Image","text":"<p>This section shows an example of using a combined application image, from U-Boot. Similar commands can be used from Linux.</p> <p>The combined application images are used the exact same way as regular application images, just that they first update the decision firmware and decision firmware data if necessary, before the device is configured with the functionality from the application SOF.</p> <p>Note: The combined application images do not have absolute pointers inside like the regular application images, the factory update images, or the decision firmware update images. Because of this, they can be written to flash with any of the U-Boot and LibRSU APIs that write to slots.</p> <ol> <li> <p>Program the RSU initial image created with the previous version ($TOP_FOLDER/initial_image_prev.jic).</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_prev.jic\"\n</code></pre> </li> <li> <p>Power cyle the board, stop to U-Boot prompt and query the decision firmware information from U-Boot, this should be a previous version.</p> <pre><code>SOCFPGA # rsu display_dcmf_version\nDCMF0 version = 25.1.0\nDCMF1 version = 25.1.0\nDCMF2 version = 25.1.0\nDCMF3 version = 25.1.0\n</code></pre> </li> <li> <p>Find an unused slot (slot 1, P2), erase it, write the combined application image to it, verify that it was programmed successfully  and check it is now the highest priority.</p> <pre><code>SOCFPGA # rsu slot_erase 1\nSlot 1 erased.\nSOCFPGA # fatload mmc 0:1 ${loadaddr} combined_application.rpd\n151552 bytes read in 9 ms (16.1 MiB/s)\nSOCFPGA # rsu slot_program_buf 1 ${loadaddr} ${filesize}\nSlot 1 was programmed with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_verify_buf 1 ${loadaddr} ${filesize}\nSlot 1 was verified with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_get_info 1\nNAME: P2\nOFFSET: 0x0000000002000000\nSIZE: 0x01000000\nPRIORITY: 1\n</code></pre> </li> <li> <p>Pass control to the combined application update image.</p> <pre><code>SOCFPGA # rsu slot_load 1\n</code></pre> </li> <li> <p>The combined application image checks the currently used decision firmware copy, it sees that it is older, then it updates the decision firmware and decision firmware data, then it loads the actual application image section. Everything takes a few seconds.</p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware is updated, and the application image is running fine.</p> <pre><code>SOCFPGA # rsu status_log\nCurrent Image : 0x02000000\nLast Fail Image : 0x00000000\nState : 0x00000000\nVersion : 0x00000202\nError location : 0x00000000\nError details : 0x00000000\nRetry counter : 0x00000000\nSOCFPGA # rsu display_dcmf_version\nDCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\n</code></pre> </li> <li> <p>Power cycle the board, the same combined application image is loaded, as it is the highest priority. But it takes a couple of seconds less, as the decision firmware does not need to be updated.</p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <ol> <li> <p>Power up the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message. </p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\nOperation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status.  It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting a specific image to be loaded, using the following commands.</p> <pre><code>./rsu_client --request 1 reboot </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202:both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report .</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux.</p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number. </p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux and display the status:  It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB. </p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot.</p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB. </p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is required to have the status available in Linux. </p> <ol> <li> <p>Power up the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions. </p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --    slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is not rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status: </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash.</p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status. </p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> </li> </ol> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.  Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> <ol> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails. </p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created. </p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine. </p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5, Agilex\u2122 3 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p> <p>Note:  Agilex\u2122 3 HPS Remote System Update User Guide will be released soon.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/","title":"HPS Multi-QSPI Remote System Update Tutorial Example Design: Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#intro","title":"Intro","text":"<p>This page is an extension of the  Agilex 7 SoC HPS Remote System Update Example and will show you how to build RSU images with multi QSPI support. This feature allows you to extend the flash space available to store the RSU applications so the size of these could be increased. This feature allows you to support up to 4 QSPI flash devices of the same model (i.e. same size). </p> <p>Note: This feature is first enabled in 24.3 release.</p> <p>When exercising multi-QSPI feature, there are few conditions that need to be satisfied:</p> <ul> <li>The Boot info, including the decision firmware and decision firmware data must be stored in the flash 0.</li> <li>The factory image also must be stored in the flash 0.</li> <li>The SPTs and CPBs also must be stored in in flash 0.</li> <li>The starting location of any component and partition in the QSPI flash devices should be aligned to the erase granularity defined in the devices.</li> <li>An application could be located in the cross boundary of 2 chips (i.e. located in more than one chip), but the previous condition still must be satisfied.</li> </ul> <p> </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#build-instructions","title":"Build Instructions","text":"<p>The binaries build instructions presented here are targeted for the Agilex\u2122 7 Transceiver-SoC Development kit P-Tile E-Tile production Linear power solution (DK-SI-AGF014EB). This provides the full recipes to build the binaries that you will need to exercise RSU functionality. The example provided here used only 2 flash devices (MT25QU02G) so the total memory size available is 512 MB. In the flash device layout, there is 1 partition defined in chip 0 and 2 partitions in chip 1. This QSPI layout can be seen in the following table:</p> Component Start Address Size Chip BOOT_INFO 0x0000_0000 0x0020_FFFF 0 FACTORY IMAGE 0x0021_0000 0x0070_0000 0 SPT0 0x0091_0000 0x0001_0000 0 SPT1 0x0092_0000 0x0001_0000 0 CPB0 0x0093_0000 0x0001_0000 0 CPB1 0x0094_0000 0x0001_0000 0 P1 0x0100_0000 0x0100_0000 0 P2 0x1000_0000 0x0100_0000 1 P3 0x1100_0000 0x0100_0000 1 <p>The end results of the build flow are described next.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex-multiQSPI-rsu\nmkdir agilex-multiQSPI-rsu\ncd agilex-multiQSPI-rsu\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes.</p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below.</p> <pre><code>cd $TOP_FOLDER\n# Build 4 versions of the hardware design\nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\n# boot from FPGA\nexport BOOTS_FIRST=fpga\n# enable watchdog\nexport ENABLE_WATCHDOG_RST=1\n# treat watchdog timeout as configuration failure to trigger RSU\nexport WATCHDOG_RST_ACTION=remote_update\n# Customize parms in tcl\nsed -i '/STRATIX_JTAG_USER_CODE 4/i set_global_assignment -name RSU_MAX_RETRY_COUNT 3' agilex7f-ed-gsrd/agilex_soc_devkit_ghrd/create_ghrd_quartus.tcl\n# Set QSPI clock to 25 Mhz (needed for multi-qspi support)\nsed -i '/STRATIX_JTAG_USER_CODE 4/i set_global_assignment -name ACTIVE_SERIAL_CLOCK AS_FREQ_25MHZ' agilex7f-ed-gsrd/agilex_soc_devkit_ghrd/create_ghrd_quartus.tcl\nfor version in {0..3}\ndo\nrm -rf ghrd.$version\ncp -r agilex7f-ed-gsrd ghrd.$version\ncd ghrd.$version\n# update sysid to make binaries slightly different \nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' agilex_soc_devkit_ghrd/create_ghrd_qsys.tcl\n# Finsish customization and now building the hardware design\nmake agf014eb-si-devkit-oobe-baseline-all\ncd ..\ndone\nrm -rf agilex7f-ed-gsrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created.</p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/install/designs/agf014eb_si_devkit_oobe_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/install/designs/agf014eb_si_devkit_oobe_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/install/designs/agf014eb_si_devkit_oobe_baseline.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/install/designs/agf014eb_si_devkit_oobe_baseline.sof </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\n# checkout the branch used for this document, comment out to use default\ngit checkout -b test -t origin/socfpga_v2.12.1\nmake bl31 PLAT=agilex\ncd ..\n</code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it. To enable multi-qspi support in U-Boot RSU functionality, set CONFIG_SOCFPGA_RSU_MULTIFLASH to y in the build configuration file. Also make sure that CONFIG_SF_DEFAULT_CS is set to 0 to indicate that the SPTs and CPBs are located in chip 0. There are some required changes in the device tree that allow you to enable multi-QSPI in U-Boot. These changes are the following.</p> <ul> <li>Add the number of QSPI flash devices in the system in the qspi node in socfpga_agilex.dtsi. This parameter will allow u-boot to know the number of flash devices. You can manually probe each device from U-Boot shell using sf probe 0:&lt;flash device&gt;. This command also is used to select the QSPI chip for which the sf read, sf write and sf erase will operate over.</li> <li>Create the flash1 node in socfpga_agilex_socdk-u-boot.dtsi, so it exist a node for each one of the flash devices in the system.</li> <li>For each one of the flash nodes is necessary to  reduce the maximum SPI clock frequency to 25 MHz. This is done through the spi-max-frequency field. You also need to assign the corresponding chip select number to each one of the QSPI devices using the reg field. You also need to define any partitions that you want to create in each of the flash devices. In this case a single partition is created in each of the chips. The partition size corresponds to the size of each chip. These updates are done in the socfpga_agilex_socdk.dts file.</li> <li>You can also add QSPI flash0 as the 1st device from which SPL will try to boot from. This is done by updating the u-boot,spl-boot-order field in the socfpga_agilex_socdk-u-boot.dtsi. </li> </ul> <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga\n# comment out next line to use the latest default branch \ngit checkout -b test -t origin/socfpga_v2025.04\n\n# enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n\n# Update device tree to enable multi-qspi\n# Adding the number of QSPI devices\nsed -i '/clocks = &lt;&amp;qspi_clk&gt;;/a \\\\t\\t\\tnum-cs = &lt;2&gt;;'  arch/arm/dts/socfpga_agilex.dtsi\n\n# Starting booting from QSPI to probe QSPI devices. Removing atempt to boot from NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0,\\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n\n# Rename the flash0 to flash1 (later will recreate the node for flash0)\n# This is done to have a QSPI flash reference to add the new node just above the reference one.\nsed -i 's/\\&amp;flash0 {/\\&amp;flash1 {/' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\nsed -i '/\\&amp;flash1 {/i \\&amp;flash0 {\\n\\tcompatible = \\\"jedec,spi-nor\\\";\\n\\tspi-tx-bus-width = &lt;4&gt;;\\n\\tspi-rx-bus-width = &lt;4&gt;;\\n\\tbootph-all;\\n\\t/delete-property/ cdns,read-delay; \\n};\\n' \\\narch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# remove the NAND configuration from device tree\nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n\n# Change max clk frequency of SPI flash0\nsed -i 's/spi-max-frequency = &lt;100000000&gt;;/spi-max-frequency = &lt;25000000&gt;;/g' arch/arm/dts/socfpga_agilex_socdk.dts\n# Change the partition size for flash0\nsed -i 's/reg = &lt;0x0 0x04200000&gt;;/reg = &lt;0x0 0x10000000&gt;;/g' arch/arm/dts/socfpga_agilex_socdk.dts\n# Delete 2nd partition\nsed -i '/root/,/};/d' arch/arm/dts/socfpga_agilex_socdk.dts\n\n# make this one flash1 (later will recreate node for flash0 using flash1 location as reference )\nsed -i 's/flash0: flash@0 {/flash1: flash@1 {/' arch/arm/dts/socfpga_agilex_socdk.dts\nsed -i '/flash1: flash@1 {/!b;n;n;n;n;c\\\\t\\treg = &lt;1&gt;;' arch/arm/dts/socfpga_agilex_socdk.dts\nsed -i 's/qspi_boot:/flash1_boot:/g' arch/arm/dts/socfpga_agilex_socdk.dts\n# Re-create the original node for flash0\nsed -i '/flash1: flash@1 {/i \\\\tflash0: flash@0 {\\n\\t\\t#address-cells = &lt;1&gt;;\\n\\t\\t#size-cells = &lt;1&gt;;\\\n\\t\\tcompatible = \"mt25qu02g\";\\n\\t\\treg = &lt;0&gt;;\\n\\t\\tspi-max-frequency = &lt;25000000&gt;;\\n\\n\\t\\tm25p,fast-read;\\\n\\t\\tcdns,page-size = &lt;256&gt;;\\n\\t\\tcdns,block-size = &lt;16&gt;;\\n\\t\\tcdns,read-delay = &lt;1&gt;;\\n\\t\\tcdns,tshsl-ns = &lt;50&gt;;\\\n\\t\\tcdns,tsd2d-ns = &lt;50&gt;;\\n\\t\\tcdns,tchsh-ns = &lt;4&gt;;\\n\\t\\tcdns,tslch-ns = &lt;4&gt;;\\n\\n\\t\\tpartitions {\\\n\\t\\t\\tcompatible = \"fixed-partitions\";\\n\\t\\t\\t#address-cells = &lt;1&gt;;\\n\\t\\t\\t#size-cells = &lt;1&gt;;\\\n\\t\\t\\tqspi_boot: partition@0 {\\n\\t\\t\\t\\tlabel = \"u-boot\";\\n\\t\\t\\t\\treg = &lt;0x0 0x10000000&gt;;\\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\t};\\n' arch/arm/dts/socfpga_agilex_socdk.dts\n\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin .\n# Create configuration custom file.\ncat &lt;&lt; EOF &gt; config-fragment-agilex\n# Use 'Image' for kernel image instead of 'kernel.itb'\nCONFIG_BOOTFILE=\"Image\"\n# ENABLE MULTIFLASH\nCONFIG_SOCFPGA_RSU_MULTIFLASH=y\nCONFIG_SF_DEFAULT_CS=0\n# - Disable NAND/UBI related settings from defconfig.\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# - Disable distroboot and use specific boot command.\nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable; setenv bootfile Image; setenv fdtimage socfpga_agilex7f_socdk_multiqspi.dtb; run mmcload; run linux_qspi_enable; run rsu_status; run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\n# Enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex_defconfig\n# Use created custom configuration file to merge with the default configuration obtained in .config file.\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex\nmake -j 48\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-linux","title":"Building Linux","text":"<p>In Linux, the socfpga_agilex7f_socdk_multiqspi.dts device tree is used which includes the updates needed to support the multi-QSPI feature. The required changes are shown next.</p> <ul> <li>The definition of the flash nodes (up to 4). In each of these nodes the qspi_bootx partition is created. For each one of the flashes nodes defined Linux will create a MTD device for each partition if it detects that a flash device asociated with this node actually exists.</li> <li>In each one of the flash devices reducing the maximum SPI clock frequency to 25 MHz.</li> <li>In each one of the flash devices assigning to the reg field the corresponding chips select: 0, 1, 2 or 3.</li> <li>Define the rsu_handle field to point to the qspi_boot0 partition. Although this is done for all the flash node, this is needed only for the flash0. The limits of this partition is patched by U-Boot (rsu_dtb() function) to restric this partition in flash 0 to the area  that goes from the starting location of the SPT0 table to the end of the chip. This makes that Linux could only access this region in chip 0 using the mtd0 device.</li> </ul> <p> </p> <p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone https://github.com/altera-fpga/linux-socfpga cd linux-socfpga # checkout the branch used for this document, comment out to use default \ngit checkout -b test -t origin/socfpga-6.12.19-lts # Workaround to the 14024915012 issue in whcih the number of QSPI devices was incorrecltly determined from the device tree.\n# This is a temporal hack to update cqspi_setup_flash(). This Will be fixed in 25.1.1.\nsed -i 's/max_cs = cqspi-&gt;num_chipselect - 1;/max_cs = 0;/g' drivers/spi/spi-cadence-quadspi.c\nsed -i 's/else if (cs &lt; max_cs)/else if (cs &gt; max_cs)/g' drivers/spi/spi-cadence-quadspi.c\n\n# configure the RSU driver to be built into the kernel \nmake clean &amp;&amp; make mrproper make defconfig ./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y\n# enable kernel debugging with RiscFree\n./scripts/config --set-val CONFIG_DEBUG_INFO  y\n./scripts/config --set-val CONFIG_GDB_SCRIPTS y\nmake oldconfig make -j 48 Image dtbs cd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex7f_socdk_multiqspi.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is provided below so and you can easily create the initial flash image by passing it to the Programming File Generator as shown below. The layout described in this .pfg file matches the layout described earlier in this page.</p> <pre><code>cd $TOP_FOLDER # Create automatically the .pfg file\ncat &lt;&lt; EOF &gt; initial_image_multiQSPI.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"initial_image_multiQSPI\" directory=\"./\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"initial_image_multiQSPI_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_multiQSPI_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.0/install/designs/agf014eb_si_devkit_oobe_baseline.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n        &lt;bitstream id=\"Bitstream_2\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.1/install/designs/agf014eb_si_devkit_oobe_baseline.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"QSPI04G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" multiple_flash_cs=\"2\" factory_fallback=\"0\" e_addr=\"0x0020FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00210000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x10000000\" e_addr=\"0x10FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x11000000\" e_addr=\"0x11FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;AGFB014R24B&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# MultiQSPI is supported starting in 24.3\n~/altera_pro/25.1/quartus/bin/quartus_pfg -c initial_image_multiQSPI.pfg\nmv initial_image_multiQSPI.jic initial_image_multiQSPI_prev.jic\nmv initial_image_multiQSPI_jic_2Gb_cs0.rpd initial_image_multiQSPI_jic_2Gb_cs0_prev.rpd\nmv initial_image_multiQSPI_jic_2Gb_cs1.rpd initial_image_multiQSPI_jic_2Gb_cs1_prev.rpd\nmv initial_image_multiQSPI_jic.map initial_image_multiQSPI_jic_prev.map\n\n# Create Initial Image for this release\ncd $TOP_FOLDER\nquartus_pfg -c initial_image_multiQSPI.pfg\n</code></pre> <p>After completion of this stage you should see the following files created. These are the images QSPI images.</p> <ul> <li>$TOP_FOLDER/initial_image_multiQSPI.jic - Initial QSPI image used for regular RSU use cases.</li> <li>$TOP_FOLDER/initial_image_multiQSPI_prev.jic - Initial QSPI image used to exercise combined application use case. - Not available in 24.3 release.</li> </ul> <p>For detailed instructions on how to create the .pfg, please refer to the Creating the initial flash-image in main RSU page. For a multi-QSPI initial image there are some variations that need to be obserrved and these are described next.</p> <ul> <li> <p>When selecting the flash device in Configuration Device tab and clicking Add Device you need to select as device any of the QSPI0xG devices depending on the total size of the multi-QSPI system (in bits). In the figure below are shown the possible options. These options gets available when building an RSU image. In this figure, the QSPI04G is being selected for a 4 Gbit system (512 MB) integrated by 2 flash devices of 2Gbit each one.</p> <p> </p> </li> </ul> <ul> <li>When configuring the memory locations for each one of the components make sure that the BOOT_INFO, FACTORY_IMAGE, STPs and CPBs fall into the memory area corresponding to the chip 0. </li> <li>Also, when configuring the memory locations for the partitions, the memory ranges are defined based on having a single memory space that comprises the total memory available in all the QSPI flash devices. It is supported that a partition covers areas in more than one chip but the starting location of the partition should still be aligned to the erase granularity defined.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -rf images/application2.rpd\nquartus_pfg -c hw/ghrd.2/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON\n</code></pre> <p>The following application image is created: </p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/factory_update.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created.</p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/decision_firmware_update.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decistion firmware update image is created.</p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build echo 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal </code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf zlib-1.3.1 wget http://zlib.net/zlib-1.3.1.tar.gz tar xf zlib-1.3.1.tar.gz rm zlib-1.3.1.tar.gz cd zlib-1.3.1/ export CROSS_PREFIX=${CROSS_COMPILE} ./configure make export ZLIB_PATH=`pwd` cd .. </code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.3.1/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.3.1/libz.so* - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application. Notice that you will need to modify the qspi.rc file (file used by librsu to retreive some of the RSU configuration) to provide  the mtd partitions in QSPI to be used for RSU, in this case it will be mtd0 and mtd1.</p> <pre><code>cd $TOP_FOLDER rm -rf intel-rsu git clone https://github.com/altera-fpga/intel-rsu cd intel-rsu # checkout the branch used for this document, comment out to use default \ngit checkout -b test -t origin/master # Replace single mtd device with the the mtd devices created \n# from each one of the QSPI partitions\nsed  -i 's/root qspi \\/dev\\/mtd0/root qspi \\/dev\\/mtd0,\\/dev\\/mtd1/g'  etc/qspi.rc cd lib # add -I$(ZLIB_PATH) to CFLAGS \nsed -i 's/\\(CFLAGS := .*\\)$/\\1 -I\\$\\(ZLIB_PATH\\)/g' makefile make cd .. cd example # add -L$(ZLIB_PATH) to LDFLAGS \nsed -i 's/\\(LDFLAGS := .*\\)$/\\1 -L\\$\\(ZLIB_PATH\\)/g' makefile make cd .. cd .. </code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/intel-rsu/lib/librsu.so - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/intel-rsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/intel-rsu/example/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example.</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2021.04/gsrd/\\\ntools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n# prepare the fat contents\nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex7f_socdk_multiqspi.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\nsudo sed -i 's/agilex7_dk_si_agf014eb/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\nsudo cp $TOP_FOLDER/intel-rsu/example/rsu_client home/root/\nsudo cp $TOP_FOLDER/intel-rsu/lib/librsu.so lib/\nsudo cp $TOP_FOLDER/intel-rsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\ncd .. # create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as indicated next.</p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card.</p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#writing-initial-multi-qspi-rsu-image-to-qspi","title":"Writing Initial multi-QSPI RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM boot card on the Agilex 7 SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Agilex 7 SoC Development Kit switches to have MSEL set to JTAG. </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer: </p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_multiQSPI.jic\" </code></pre> </li> <li> <p>Configure the Agilex 7 SoC Development Kit switches to have MSEL set to QSPI. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Agilex 7 SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#exercise-rsu-binaries","title":"Exercise RSU Binaries","text":"<p>The same RSU exercises for U-Boot and Linux described at Agilex 7 SoC HPS Remote System Update Example are supported for multi-QSPI. You can exercise all of them, but in the command responses just consider the new layout used in here (i.e. the location of the partitions will be different ). </p> <p>In the scenario in which an application is being corrupted using a U-Boot command, you also will need to use the correct location of the application. Also remember that in multi-QSPI the sf probe U-Boot command is used to select the appropriate flash device before performing any read, write or erase operation. The sf erase, sf write and sd read U-Boot commands use as memory address the relative address in the chip selected.</p> Action Command Select chip 0 sf probe 0:0  or sf probe Select chip 1 sf probe 0:1 Write to chip selected sf write &lt;address in SRAM&gt; &lt;offset in chip&gt; &lt;data size&gt; Read from chip selected sf read &lt;address in SRAM&gt; &lt;offset in chip&gt; &lt;data size&gt; Erase data in chip sf erase &lt;offset in chip&gt; &lt;data size&gt; <p>Note: When the combined application is used to upgrade the decision firmware, it is required to start with an initial image created with an older version than the one used to create this application. When exercising this use case in a multi-QSPI board, the decision firmware in the initial image also requires to support the multi-QSPI feature which is supported by Quartus Prime starting on 24.2 release.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/","title":"FPGA Crypto Services (FCS) Tutorial Example Design User Guide","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#introduction","title":"Introduction","text":"<p>The new FPGA Crypto Services (FCS) solution features a modular design and utilizes the standard Linux cryptographic framework. This offers the FCS clients a simplified API interface for performing cryptographic operations. Furthermore, it integrates the advanced SIP-SVC v3 protocol, which improves communication with the SDM over the previous SIP-SVC v1 version. This enhancement leads to greater efficiency, flexibility, and security in cryptographic operations.</p> <p>This tutorial provides an overview of the new architecture, instructions for building various FCS components, guidance on which configurations to enable or disable, details on new commands, and information on modifications needed to execute other API commands. All FCS commands are the same as Legacy FCS solutions except a few which are detailed in the upcoming sections.</p> Features Actions Session management Open and Close sessions Key Management Create a key, Import a key, Export a Key, Remove a key, Get key info Random number generation Send a request to generate random number AES Encryption and Description ECB Mode, CTR Mode, CBC Mode Provision data Retrieve the device provision data for device management and confirmation needs Counter set and Counter set preauthorization Set one selected counter to its specified value in both provision firmware and the main firmware Get the digest Request the SHA-2 hash digest on a blob MAC verify Check the integrity and authenticity of a blob by comparing the calculated MAC with tagged MAC Get ECDH shared secret Digital signature signing request on a data blob QSPI COMMANDS OPEN, CLOSE, SET_CS, READ, ERASE, WRITE Device Information GET_IDCODE, GET_DEVICE_IDENTITY Attestation Commands MCTP_REQUEST, CREATE_CERTIFICATES_ON_RELOAD, GET_ATTESTATION_CERTIFICATE SDOS Encryption and  Decryption Encrypt an input data and decrypt it Support ECDSA Use case Get ECDSA public key, ECDSA Hash signing, ECDSA Hash verify, ECDSA SHA2 Data Signing, ECDSA SHA2 Data verify HPS image validation Check the integrity and authenticity of an image before configuration"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#architecture-overview","title":"Architecture Overview","text":"<p>The new FCS architecture software stack and its components can be found in the figure below.</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#fcs-repository","title":"FCS Repository","text":"<p>Boards/Device Utilized: Agilex\u2122 7 F-Series SoC Development Kit</p> SW Component Repository Branch/tag/Version LibFCS altera-fpga/libfcs: Altera FPGA Crypto Services Library main Linux altera-fpga/linux-socfpga: Linux development repository for socfpga socfpga-6.12.19-lts U-Boot altera-fpga/u-boot-socfpga socfpga_v2025.04 ATF altera-fpga/arm-trusted-firmware socfpga_v2.12.1 FCS Prepare altera-fpga/fcs_apps: Applications for Vendor Authorized Boot support fcs_prepare"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#environment-setup","title":"Environment Setup","text":"<ol> <li>Create the top folder to store all the build artifacts:</li> </ol> <pre><code>mkdir agilex7_fcs\ncd agilex7_fcs\nexport TOP_FOLDER=`pwd`\n</code></pre> <ol> <li>Download the compiler toolchain, add it to the PATH variable:</li> </ol> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <ol> <li>Enable Quartus tools to be called from command line:</li> </ol> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <ol> <li>Install Yocto Dependencies:</li> </ol> <p>Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions. The commands to install the required packages on Ubuntu 22.04 are:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code>sudo ln -sf /bin/bash /bin/sh\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#system-image-creation","title":"System Image Creation","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#build-arm-trusted-firmware","title":"Build Arm Trusted Firmware","text":"<pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b socfpga_v2.12.1 https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex bl31 cd ..\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#build-u-boot","title":"Build U-Boot","text":"<pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b socfpga_v2025.04 https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex/release/bl31.bin cat &lt;&lt; EOF &gt; config-fragment\n# Use 'Image' for kernel image instead of 'kernel.itb'\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig.\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command.\nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} signed_bitstream_core.rbf; bridge disable;fpga load 0 \\${loadaddr} \\${filesize};bridge enable; setenv bootfile Image; run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</li> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#build-linux","title":"Build Linux","text":"<pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b socfpga-6.12.19-lts https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig </code></pre> <p>After that, the FCS drivers need to be enabled using menuconfig</p> <pre><code>make menuconfig\n</code></pre> <p>Select the following configuration options for FCS.</p> <p>Device Drivers \u2192 Misc devices \u2192 Altera FPGA FCS configuration support(select *)</p> <p></p> <p>Finally, build the Linux Image:</p> <pre><code>make -j 64 Image dtbs\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb</li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#compile-libfcs-and-fcs-client-application","title":"Compile LibFCS and FCS Client application","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#compile-the-fcs-client-and-libfcs","title":"Compile the FCS Client and LibFCS","text":"<pre><code>git clone https://github.com/altera-fpga/libfcs\ncd libfcs/\nexport ARCH=arm64; export CROSS_COMPILE=aarch64-none-linux-gnu-\nrm -rf build/ &amp;&amp; rm -rf third_party/libkcapi/ &amp;&amp; cmake -S . -B build -DARCH=linux_aarch64 -DOS=linux &amp;&amp; cmake --build build\n</code></pre> <p>The output files of the compilation must be copied to the target device, as below:</p> <ul> <li>$TOP_FOLDER/libfcs/build/bin/fcs_client</li> <li>$TOP_FOLDER/libfcs/build/lib/LibFCS.so</li> <li>$TOP_FOLDER/libfcs/build/lib/LibFCS.so.1</li> <li>$TOP_FOLDER/libfcs/include/libfcs.h</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#compile-fcs_prepare-tool","title":"Compile fcs_prepare tool","text":"<pre><code>git clone https://github.com/altera-fpga/fcs_apps fcs_prepare\ncd fcs_prepare\ngi checkout fcs_prepare\nexport ARCH=; export CROSS_COMPILE=\nmake clean &amp;&amp; make all\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#install-yocto-dependencies","title":"Install Yocto Dependencies","text":"<p>Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions. The commands to install the required packages on Ubuntu 22.04 are:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code>sudo ln -sf /bin/bash /bin/sh\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#build-rootfs","title":"Build Rootfs","text":"<pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b styhead https://git.yoctoproject.org/poky\ngit clone -b styhead https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b styhead https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#generate-signature-chains","title":"Generate Signature Chains","text":"<pre><code>cd $TOP_FOLDER\nmkdir keys &amp;&amp; cd keys\nmkdir -p privatekeys; mkdir -p publickeys; mkdir -p qky </code></pre> <p>Start a Nios V command shell to have all Quartus tools in the PATH:</p> <pre><code>~/intelFPGA_pro/25.1.1/niosv/bin/niosv-shell\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#generate-root-key","title":"Generate Root Key","text":"<pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/root0.pem\nquartus_sign --family=agilex --operation=make_public_pem privatekeys/root0.pem publickeys/root0_public.pem\nquartus_sign --family=agilex --operation=make_root publickeys/root0_public.pem qky/root0.qky\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#generate-fpga-signing-keys","title":"Generate FPGA Signing Keys","text":"<pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/sign0.pem\nquartus_sign --family=agilex --operation=make_public_pem privatekeys/sign0.pem publickeys/sign0_public.pe\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#generate-signature-chain","title":"Generate Signature Chain","text":"<p>FPGA Signing - Cancel ID 1 \u2013 Permissions: FPGA/HPS/HPS Debug</p> <pre><code>quartus_sign --family=agilex --operation=append_key --previous_pem=privatekeys/root0.pem --previous_qky=qky/root0.qky --permission=14 --cancel=1 --input_pem=publickeys/sign0_public.pem qky/sign0_cancel1.qky\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#build-hardware-design","title":"Build Hardware Design","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#build-the-ghrd","title":"Build the GHRD","text":"<pre><code>cd $TOP_FOLDER\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#enable-security-features-authentication","title":"Enable Security Features: Authentication","text":"<p>Next, enable the QKY key file in the Quartus project: For the FPGA configuration bitstream to be properly signed, enable the Quartus key File in the Quartus Project.</p> <p>Open the GHRD project in Quartus.</p> <ul> <li>From the Assignments Menu, navigate to Device &gt; Device and Pin Options &gt; Security. Under the Quartus key file, browse and select qky/sign0_cancel1.qky.</li> <li>Alternatively, you can add the following assignment to the .qsf file: \"set_global_assignment -name QKY_FILE \"</li> </ul> <p>Regenerate the sof by running the Assembler.</p> <ul> <li>From the Processing menu, select Compilation Dashboard. In the Compilation Dashboard, select Assembler to regenerate the sof.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#generate-and-sign-fpga-and-hps-rbf-files","title":"Generate and Sign FPGA and HPS RBF Files","text":"<p>Add FSBL bootloader to configuration bitstream, and generate the core and HPS .rbf files:</p> <pre><code>cd $TOP_FOLDER\nmkdir bitstreams &amp;&amp; cd bitstreams\ncp ../agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof design.sof\nquartus_pfg -c design.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1 \\\n-o sign_later=ON\n</code></pre> <p>After that, two .rbf files are created:</p> <ul> <li>$TOP_FOLDER /bitstreams/ghrd.core.rbf</li> <li>$TOP_FOLDER /bitstreams/ghrd.hps.rbf</li> </ul> <p>Finally, sign the .rbf files:</p> <pre><code>quartus_sign --family=agilex --operation=sign --qky=../keys/qky/sign0_cancel1.qky \\\n--pem=../keys/privatekeys/sign0.pem ghrd.core.rbf signed_bitstream_core.rbf\nquartus_sign --family=agilex --operation=sign --qky=../keys/qky/sign0_cancel1.qky \\\n--pem=../keys/privatekeys/sign0.pem ghrd.hps.rbf signed_bitstream_hps.rbf\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#generate-sdos-signed-certificate-if-sdos-is-needed","title":"Generate SDOS Signed Certificate (If SDOS is needed)","text":"<p>Generate the SDOS signed certificate using the command below:</p> <p>First, generate the SDOS Service Root Key compact certificate:</p> <pre><code>quartus_pfg -ccert -o ccert_type=PROV_SERVICE_ROOT_KEY -o entropy=&lt;32-byte hex string&gt; unsigned_prov_srk.ccert\n</code></pre> <p>Next, create a signature chain with the correct permission bit set using the following command:</p> <pre><code>quartus_sign --family=agilex --operation=append_key \\\n--previous_pem=root0_private.pem \\\n--previous_qky=root0.qky \\\n--permission=0x8000 \\\n--cancel=1 \\\n--input_pem=sdosccert1_public.pem \\\nsdosccert1_sign_chain.qky\n</code></pre> <p>Finally, sign the generated compact certificate using the following command:</p> <pre><code>quartus_sign --family=agilex --operation=sign \\\n--pem=sdosccert1_private.pem \\\n--qky=sdosccert1_sign_chain.qky \\\nunsigned_prov_srk.ccert signed_prov_srk.ccert\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#generate-the-key-object-file-for-encryptiondecryption","title":"Generate the Key Object File for Encryption/Decryption","text":"<p>First, create the key data file in .txt format:</p> <pre><code>cd $TOP_FOLDER/fcs_prepare\necho  111111112222222233333333444444445555555566666666777777778888888899999999aaaaAAAAbbbbBBBBccccCCCC &gt;&gt; key.txt\n./fcs_prepare -G aes_key.obj -i 14 -x 256 -k 1 -u 0x3 -t key.txt\n</code></pre> <p>To view the aes_test.obj file, use the command below to observe the output:</p> <pre><code>./fcs_prepare -P aes_key.obj\n\n---- Decode and print crypto service key object file ---- Successfully decode aes_test.obj file with 80 bytes\nPrint crypto service key object\n    key_id              0x0000000e\n    key_type            1 (1:AES, 2:HMAC, 3:ECC NIST P Curve, 4:ECC-BrainPool)\nkey_usage           0x00000003 (B0:Enc, B1:Dec, B2:Sign, B3:Verify, B4:Exchange)\nkey_size            256 bits\n    key_object_version  1 key_fips_mode       0 key_owner_id        0 key_user_id         0 key_protection      0\nkey_wrap_version    0\ndata          11 11 11 11 22 22 22 22 33 33 33 33 44 44 44 44\n55 55 55 55 66 66 66 66 77 77 77 77 88 88 88 88\niv            00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nmac           00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#prepare-the-fcs_client-files","title":"Prepare the fcs_client Files","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#copy-the-fcs_client-binary-and-drivers","title":"Copy the fcs_client binary and drivers","text":"<pre><code>Cd $TOP_FOLDER\nmkdir fcs_client_bins &amp;&amp; cd fcs_client_bins\ncp ../../libfcs/build/bin/fcs_client .\nmkdir fcs_drivers &amp;&amp; fcs_drivers\ncp ../../libfcs/build/lib/libFCS* .\ncp ../../libfcs/include/libfcs.h .\ncd ..\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#copy-the-key-object-file","title":"Copy the key object file","text":"<pre><code>cp ../fcs_prepare/aes_test.obj .\ncp ..\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#create-sd-card-image","title":"Create SD Card Image","text":"<pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\n# Download the sd-card image creator\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n# Prepare the image files\nmkdir fatfs &amp;&amp; cd fatfs\ncp $TOP_FOLDER/bitstreams/signed_bitstream_core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\n# Copy the fcs_client files\ncd home/\nsudo cp -r ../../../fcs_client_bins/ root/\ncd ../..\n# Create the image\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=512M \\\n-s 640M \\\n-n agilex7_fcs.img\ncd ..\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#write-sd-card-image","title":"Write SD Card Image","text":"<p>On Linux, use the dd utility as shown next:</p> <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if= agilex7_fcs.img of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre> <p>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. Write the image as shown in the next figure: </p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#running-the-application-on-board","title":"Running the Application on Board","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#board-configuration","title":"Board Configuration","text":"<ol> <li>Power down the board</li> <li>Set MSEL to JTAG mode (SW27: OFF- OFF- OFF- OFF)</li> <li>Connect the HPS UART to a terminal on the host machine.</li> <li>Configure the root key, SDOS ccert, and signed_bitstream_hps.rbf</li> </ol> <pre><code>cd $TOP_FOLDER/bitstreams\nquartus_pgm -c 1 -m jtag -o \"pi;../keys/qky/root0.qky\"\nquartus_pgm -c 1 -m jtag -o \"p;signed_prov_service_root_key_uds_efuse.ccert\"\nquartus_pgm -c 1 -m jtag -o \"p;signed_bitstream_hps.rbf\"\n</code></pre> <p>On the HPS terminal, observe the FSBL output:</p> <pre><code>U-Boot SPL 2025.04-g08197d3d7344-dirty (Sep 03 2025 - 12:07:38 -0400)\nReset state: Cold\nMPU          1200000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nDDR: 8192 MiB\nSDRAM-ECC: Initialized success with 1716 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\n...\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#linux-environment-setup","title":"Linux Environment Setup","text":"<p>Use \u201croot\u201d as login, and navigate to the fcs_client_bins directory. We need to deploy the fcs client drivers and the Linux modules.</p> <pre><code>cd fcs_client_bins\ncd fcs_drivers\ncp * /usr/lib\nldconfig\n</code></pre> <p>Navigate to the fcs_client binary and check all the dependencies availability using ldd command:</p> <pre><code>cd ../bins/\nldd fcs_client\n        linux-vdso.so.1 (0x0000ffff7f7ec000)\nlibFCS.so.2 =&gt; /usr/lib/libFCS.so.2 (0x0000ffff7f780000)\nlibfdt.so.1 =&gt; /usr/lib/libfdt.so.1 (0x0000ffff7f760000)\nlibc.so.6 =&gt; /lib/libc.so.6 (0x0000ffff7f5b0000)\n/lib/ld-linux-aarch64.so.1 (0x0000ffff7f7b0000)\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#testing-fcs_client-application","title":"Testing fcs_client Application","text":"<p>Inside bins/ directory, run the fcs_client help command</p> <pre><code>./fcs_client -h\n</code></pre> <p>The help argument prints out all the supported actions in fcs_client application.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#encryptiondecryption-through-crypto-services-commands","title":"Encryption/Decryption through Crypto-Services Commands","text":"<p>To run an encryption test, first create a random data file and the IV file.</p> <pre><code>dd if=/dev/urandom of=iv.bin bs=1 count=16\ndd if=/dev/urandom of=usr_data.bin bs=1 count=32672\n</code></pre> <p>Next, open an fcs_client session and retrieve a session ID:</p> <pre><code>./fcs_client -e\nCrypto service sessionID=affea22b-80c3-a14e-a82e-a3a22656f0ce\n</code></pre> <p>After that, import the crypto service key to the device:</p> <pre><code>./fcs_client -B -s affea22b-80c3-a14e-a82e-a3a22656f0ce -i aes_key.obj\n</code></pre> <p>Then use the -Y (AES Crypt) function to encrypt the user_data.bin:</p> <pre><code>./fcs_client -Y -s affea22b-80c3-a14e-a82e-a3a22656f0ce -n 1 -k 14 -b 0 -m 0 -i usr_data.bin -o enc_usr_data.bin -f iv.bin\n</code></pre> <p>The encrypted file enc_usr_data.bin can be seen in the current running directory.</p> <p>To retrieve the original file from the encrypted one, use the following command:</p> <pre><code>./fcs_client -Y -s affea22b-80c3-a14e-a82e-a3a22656f0ce -n 1 -k 14 -b 0 -m 1 -i enc_usr_data.bin -o dec_usr_data.bin -f iv.bin\n</code></pre> <p>To verify the operation, use \u201cdiff\u201d command to check the usr_data.bin with dec_usr_data.bin.</p> <pre><code>diff usr_data.bin dec_usr_data.bin\n</code></pre> <p>No output from this command must be observed on terminal to prove the match case.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/cryptoservices/ug-fpga-cryptoservice-agx7-soc/#sdos-tests","title":"SDOS Tests","text":"<p>To perform encryption operation via SDOS, use:</p> <pre><code>./fcs_client -E -i usr_data.bin -o enc_sdos_usr_data.bin -s affea22b-80c3-a14e-a82e-a3a22656f0ce -d 0x1234 -r 0xabcd -n 0x22334455 -v\n</code></pre> <p>The expected output is:</p> <pre><code>main[2528] filesize=32672\nMagic Number: 0xACBDBDED\nData Length (w/ padding): 32672\nPad: 0\nSRKI: 0\nASOI: 4660\nOwner ID: cd ab 00 00 00 00 00 00\nHeader Padding: 0x1020304\nIV field: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\nSize of struct fcs_aes_crypt_header: 40\nSave encrypted data to enc_sdos_usr_data.bin\nSaving 32760 [0x7FF8] bytes\n</code></pre> <p>The decryption operation via SDOS can be executing running the command below:</p> <pre><code>./fcs_client -D -i enc_sdos_usr_data.bin -o dec_sdos_usr_data.bin -s affea22b-80c3-a14e-a82e-a3a22656f0ce -n 0x22334455 -v </code></pre> <p>The expected output is:</p> <pre><code>main[2655] filesize=32760\nMagic Number: 0xACBDBDED\nData Length (w/ padding): 32672\nPad: 0\nSRKI: 0\nASOI: 4660\nOwner ID: cd ab 00 00 00 00 00 00\nHeader Padding: 0x1020304\nIV field: 00 00 00 00 6d fc 6b 49 6a ca 23 a6 e6 98 61 8e\nSave decrypted data to dec_sdos_usr_data.bin\nSaving 32672 [0x7FA0] bytes\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/sdos/ug-sdos-agx7f-soc/","title":"Secure Data Object Storage (SDOS) Tutorial Example User Guide","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/sdos/ug-sdos-agx7f-soc/#introduction","title":"Introduction","text":"<p>Altera\u00ae Agilex\u2122 7 SoC devices support Secure Data Object Storage (SDOS) services. The Secure Device Manager (SDM) provides security services to HPS or logic runs on fabric. SDOS provides interfaces for secure data encryption and decryption along with signature generation and verification. </p> <p>The purpose of this tutorial is to demonstrate how to access SDOS services from SPL and U-Boot levels. The tests below are based on the Secure Boot Demo Design presented in this Vendor Authorized Boot (HPS-First) Tutorial Example Design User Guide</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/sdos/ug-sdos-agx7f-soc/#running-sdos-services-from-spl","title":"Running SDOS Services from SPL","text":"<p>After completing Step 12 in the Secure Boot Demo here, you need to modify some of the SPL source codes to add the SDOS functions. The current SPL source code provides secure VAB for image authentication only. We can add the modifications below to enable SDOS tests for: </p> <ol> <li>Open / Close SDOS session. </li> <li>Create a dummy data buffer. </li> <li>Send SDOS encryption command via mailbox, and retrieve the encrypted data in another buffer. </li> <li>Send back the encrypted data buffer with a decryption command via mailbox and retrieve the original data in a third buffer. </li> </ol> <p>To achieve the test scenario above, navigate to the top directory, then to u-boot-socfpga. </p> <pre><code>cd $TOP_DIR/u-boot-socfpga/arch/arm/mach-socfpga </code></pre> <p>In this directory, open the mailbox_s10.c in a text editor to modify it. The added code snippet can be pasted after line 108 here . </p> <pre><code>int secure_test() { //Custom.. \nunsigned char* inbuffer __attribute__ ((aligned (8))) = (unsigned char*)0x2000000; unsigned char* enc_buffer __attribute__ ((aligned (8))) = (unsigned char*)0x3000000; unsigned char* dec_buffer __attribute__ ((aligned (8))) = (unsigned char*)0x4000000; unsigned int sdos_hdr[] = { //Magic Word \n0xACBDBDED, //data size in bytes \n0x00007FA0, //AOI,key info - service root,padding length \n0x160b0000, //Owner ID \n0x44332211, 0x88776655, //Header Padding \n0x01020304, //IV \n0x44332211, 0x88776655, 0x44332211, 0x88776655, }; memcpy(inbuffer, sdos_hdr, 40); int i=0; for (i=0; i &lt; 32712; i++){ inbuffer[i+40] = i; } printf(\"Testing input buffer:\\n\"); for (i=40; i &lt; 80; i++){ printf(\"%x \", inbuffer[i]); } unsigned int session_id, context_id =0; int ret_code, command_length; unsigned int argument[9]; unsigned int response_length, cmd, argument_length; unsigned int response_stored[4]; argument[0] = 0; cmd = 0xA0; command_length = 0; argument_length = 0; response_length = 1; printf(\"\\nOpening SDM Session\\n\"); ret_code = mbox_send_cmd(MBOX_ID_UBOOT, cmd, MBOX_CMD_DIRECT, argument_length, argument, 0, &amp;response_length, response_stored); if(ret_code != 0) { printf(\"Open FCS error, return code: 0x%x\\n\", ret_code); } else { session_id = response_stored[0]; printf(\"SDM Session opened, ID= 0x%x -- ret_code= x%x \\n\", session_id,ret_code); } printf(\"SDOS ENC with Session ID = 0x%x\\n\",session_id); cmd = 0x7E; argument[0] = session_id; argument[1] = context_id++; argument[2] = (7 &lt;&lt; 24); argument[3] = (unsigned int)inbuffer; argument[4] = 32712; argument[5] = (unsigned int)enc_buffer; argument[6] = 32760; argument_length = 7; command_length = 7; response_length = 4; unsigned long begin = timer_get_us(); ret_code = mbox_send_cmd(MBOX_ID_UBOOT, cmd, MBOX_CMD_DIRECT, argument_length, argument, 0, &amp;response_length, response_stored); unsigned long end = timer_get_us(); unsigned long time_spent = (unsigned long)(end - begin); if(0 != ret_code) { printf(\"SDOS Encryption error, return code: 0x%x\\n\", ret_code); }else{ printf(\"Time spent for SDOS Encryption (timer_get_us)= %d ms\\n\", time_spent/1000); printf(\"Testing Encryption Buffer:\\n\"); for (i=40; i &lt; 80; i++){ printf(\"%x \", enc_buffer[i]); } } printf(\"\\nSDOS Decryption with Session ID = 0x%x\\n\",session_id); cmd = 0x7F; argument[0] = session_id; argument[1] = context_id++; argument[2] = (7 &lt;&lt; 24); argument[3] = 0x44332211; argument[4] = 0x88776655; argument[5] = (unsigned int)enc_buffer; argument[6] = 32760; argument[7] = (unsigned int)dec_buffer; argument[8] = 32712; argument_length = 9; command_length = 9; response_length = 4; begin = timer_get_us(); ret_code = mbox_send_cmd(MBOX_ID_UBOOT, cmd, MBOX_CMD_DIRECT, argument_length, argument, 0, &amp;response_length, response_stored); end = timer_get_us(); time_spent = (unsigned long)(end - begin); if(0 != ret_code) { printf(\"SDOS Decryption error, return code: 0x%x\\n\", ret_code); }else{ printf(\"Time spent for SDOS Decryption (timer_get_us)= %d ms\\n\", time_spent/1000); printf(\"Testing Decryption Buffer:\\n\"); for (i=40; i &lt; 80; i++){ //16384 32672 \nprintf(\"%x \", dec_buffer[i]); } } argument[0] = 0; cmd = 0xA1; command_length = 1; argument_length = 1; response_length = 0; printf(\"\\nClosing SDM Session\\n\"); ret_code = mbox_send_cmd(MBOX_ID_UBOOT, cmd, MBOX_CMD_DIRECT, argument_length, argument, 1, &amp;response_length, response_stored); if(ret_code != 0) { printf(\"Close FCS error, return code: 0x%x\\n\", ret_code); } else { printf(\"SDM Session closed, resp= 0x%x -- ret_code= x%x \\n\", response_stored[0], ret_code); } return 0; //Custom// \n} </code></pre> <p>In the code above, secure_test() function contains all the necessary steps to add SDOS tests for the mailbox drive. First, we create the data buffers in the DDR region. Second, we create the SDOS header, make sure to add the proper size for the test data. In this demo, we used 0x00007FA0 for the maximum data size for AES encryption (32K-96 bytes). After that, we prepare the mailbox commands for opening an SDOS session, send an encryption command, send a decryption command, and finally, close the SDOS session. </p> <p>After adding this code snippet, we need to call the secure_test() function. This call can be set after initializing DDR and Mailbox, it can be placed in spl_agilex.c found inside mach-socfpga directory. After line 89, we can add the function call: </p> <pre><code>secure_test(); </code></pre> <p>After saving both files, we need to re-generate u-boot: </p> <pre><code>cd $TOP_DIR/u-boot-socfpga/ make -j 24 u-boot u-boot.img u-boot.dtb spl/u-boot-spl-dtb.hex </code></pre> <p>Now, we have creared a newer version of u-boot-spl-dtb.hex, which must be included in the bitstream file. To do so, follow the steps below: </p> <pre><code>cd $TOP_DIR/agilex_soc_devkit_ghrd/output_files/ quartus_pfg -c ghrd_agfb014r24b2e2v.sof ghrd.rbf -o hps_path=../../u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1 -o sign_later=ON cd $TOP_DIR/bitstreams/ quartus_sign --family=agilex --operation=sign --qky=../qky/sign0_cancel1.qky \\\n--pem=../privatekeys/sign0.pem ../agilex_soc_devkit_ghrd/output_files/ghrd.hps.rbf signed_bitstream_hps.rbf </code></pre> <p>To run the test, we need to set MSEL to JTAG, qkey, service key, and signed_bitstream_hps.rbf are downloaded via JTAG: </p> <pre><code>cd $TOP_DIR/ quartus_pgm -c 1 -m jtag -o \"pi;qky/root0.qky\" quartus_pgm -c 1 -m jtag --service_root_key quartus_pgm -c 1 -m jtag -o \"p;bitstreams/signed_bitstream_hps.rbf\" </code></pre> <p>Once the required files are configured on board, the HPS terminal prints out the SPL output, a sample of this output can be seen below: </p> <pre><code>U-Boot SPL 2023.07-rc6-30090-g4b66dd57fd-dirty (Feb 29 2024 - 19:39:29 -0500) \nReset state: Cold \nMPU 1200000 kHz \nL4 Main 400000 kHz \nL4 sys free 100000 kHz \nL4 MP 200000 kHz \nL4 SP 100000 kHz \nSDMMC 50000 kHz \nDDR: 8192 MiB \nSDRAM-ECC: Initialized success with 1730 ms \n\nTesting input buffer: \n0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 \nOpening SDM Session \nSDM Session opened, ID= 0x21000001 -- ret_code= x0 \nSDOS ENC with Session ID = 0x21000001 \nTime spent for SDOS Encryption (timer_get_us)= 13 ms \nTesting Encryption Buffer: \n12 42 42 53 a0 7f 0 0 0 0 b 16 11 22 33 44 55 66 77 88 4 3 2 1 0 0 0 0 64 90 32 66 22 2d ae 94 66 23 57 6c 71 ab 3d 54 f 32 2c 5 3b 35 \nSDOS Decryption with Session ID = 0x21000001 \nTime spent for SDOS Decryption (timer_get_us)= 1 ms \nTesting Decryption Buffer: \n0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 \n\nQSPI: Reference clock at 400000 kHz \nWDT: Started watchdog@ffd00200 with servicing every 1000ms (10s timeout) \nTrying to boot from MMC1 \n\\## Checking hash(es) for config board-0 ... OK \n\\## Checking hash(es) for Image atf ... crc32+ OK \nImage Authentication passed at address 0x0000000000001034 (45084 bytes) \n\\## Checking hash(es) for Image uboot ... crc32+ OK \nImage Authentication passed at address 0x0000000000200000 (703096 bytes) \n\\## Checking hash(es) for Image fdt-0 ... crc32+ OK \nImage Authentication passed at address 0x00000000002aba8c (18744 bytes) NOTICE: BL31: bl31_setup \nNOTICE: BL31: bl31_plat_arch_setup \nNOTICE: BL31: v2.8.1(release):QPDS23.2_REL_GSRD_PR \nNOTICE: BL31: Built : 20:57:39, Nov 27 2023 \n</code></pre> <p>The output colored in blue is coming from the added code to the SPL source code. We can notice a print snapshot of the dummy input buffer, SDOS session open, AES encryption, print of encrypted data, AES decryption, retrieve the original data, and close the SDOS session. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/crypto/sdos/ug-sdos-agx7f-soc/#running-sdos-from-u-boot","title":"Running SDOS from U-Boot","text":"<p>To run SDOS from U-Boot, we need to use smc command in U-Boot command line environment. Before proceeding with the tests, we need to prepare the dummy data file offline using a Linux machine. To prepare the dummy data file, we use the following command: </p> <pre><code>dd if=/dev/urandom of=random.bin bs=1 count=32672 </code></pre> <p>Once the randm.bin file is created, we need to modify this file to include the sdos header at the top of it. Any hex editor can help us on that task, as seen in the image below. </p> <p> </p> <p>Once the bin file is ready, we can store it in the sdcard. Then, boot the system, and interrupt the boot at U-Boot stage to enter U-Boot command line. The following commands can be used to run the test: </p> <ol> <li>Load the random.bin file from the SDCARD: </li> </ol> <pre><code>fatload mmc 0:1 0x2000000 random.bin </code></pre> <ol> <li>Open SDOS Session: </li> </ol> <pre><code>smc c200006e </code></pre> <ol> <li>Send encryption command: </li> </ol> <pre><code>smc c2000090 21000001 55aa 1 02000000 7fc8 03000000 7ff8 </code></pre> <p>where: </p> Parameter Description c2000090 INTEL_SIP_SMC_FCS_CRYPTION_EXT 21000001 session ID 55aa context ID 1 operating mode (1 for encryption and 0 for decryption) 02000000 physical address of the stored input original data 7fc8 size of input data 03000000 physical address of the output encrypted data 7ff8 size of output encrypted data <ol> <li>Send decryption command: </li> </ol> <pre><code>smc c2000090 21000001 55aa 0 03000000 7ff8 04000000 7fc8 </code></pre> <p>where: </p> Parameter Description c2000090 INTEL_SIP_SMC_FCS_CRYPTION_EXT 21000001 session ID 55aa context ID 0 operating mode (1 for encryption and 0 for decryption) 03000000 physical address of the stored encrypted input data 7ff8 size of input data 04000000 physical address of the output original data 7fc8 size of output encrypted data <ol> <li>Close SDOS session: </li> </ol> <pre><code>smc c200006f 21000001 </code></pre> <p>Note: you can use md command to verify the memory locations of the input buffer, encrypted buffer, and decrypted buffer as below: </p> <p>Open an SDOS session </p> <pre><code>SOCFPGA_AGILEX # smc c200006e \nRes: 0x0 0x0 0x21000001 0x0 </code></pre> <p>Load the random.bin file to DDR memory </p> <pre><code>SOCFPGA_AGILEX # fatload mmc 0:1 0x2000000 random.bin \n32672 bytes read in 4 ms (7.8 MiB/s) </code></pre> <p>Read data from the input buffer address, with size of 50 objects <pre><code>SOCFPGA_AGILEX # md.b 0x2000000 50 \n02000000: ed bd bd ac a0 7f 00 00 00 00 0b 16 11 22 33 44 .............\"3D \n02000010: 55 66 77 88 04 03 02 01 11 22 33 44 55 66 77 88 Ufw......\"3DUfw. 02000020: 11 22 33 44 55 66 77 88 00 01 02 03 04 05 06 07 .\"3DUfw......... \n02000030: 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 ................ \n02000040: 18 19 1a 1b 1c 1d 1e 1f 49 b0 dd d4 9c 37 f2 1b ........I....7.. \n</code></pre></p> <p>Send SDOS encrypt command </p> <pre><code>SOCFPGA_AGILEX # smc c2000090 21000001 55aa 1 02000000 7fc8 03000000 7ff8 \nRes: 0x0 0x0 0x3000000 0x7ff8 </code></pre> <p>Read data from the encrypted input buffer address, with size of 50 objects <pre><code>SOCFPGA_AGILEX # md.b 0x3000000 50 \n03000000: 12 42 42 53 a0 7f 00 00 00 00 0b 16 11 22 33 44 .BBS.........\"3D \n03000010: 55 66 77 88 04 03 02 01 00 00 00 00 2d 19 d6 24 Ufw.........-..$ 03000020: 1b 94 5f 96 1c 22 5b d4 4a fd be 60 ba 62 19 41 .._..\"[.J..`.b.A 03000030: e2 8d f2 84 ba 58 3d ca 29 af 42 9c 7b 4e 3c df .....X=.).B.{N&lt;. 03000040: f3 ae 6b b0 66 e6 c5 42 b8 49 96 56 16 70 24 88 ..k.f..B.I.V.p$. </code></pre></p> <p>Send SDOS decrypt command </p> <pre><code>SOCFPGA_AGILEX # smc c2000090 21000001 55aa 0 03000000 7ff8 04000000 7fc8 \nRes: 0x0 0x0 0x4000000 0x7fc8 </code></pre> <p>Read data from the decrypted buffer address, with size of 50 objects </p> <pre><code>SOCFPGA_AGILEX # md.b 0x4000000 50 \n04000000: ed bd bd ac a0 7f 00 00 00 00 0b 16 11 22 33 44 .............\"3D \n04000010: 55 66 77 88 04 03 02 01 00 00 00 00 2d 19 d6 24 Ufw.........-..$ 04000020: 1b 94 5f 96 1c 22 5b d4 00 01 02 03 04 05 06 07 .._..\"[......... 04000030: 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 ................ 04000040: 18 19 1a 1b 1c 1d 1e 1f 49 b0 dd d4 9c 37 f2 1b ........I....7.. </code></pre> <p>Close the SDOS session</p> <pre><code>SOCFPGA_AGILEX # smc c200006f 21000001 \nRes: 0x0 0x0 0x0 0x0\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/","title":"Vendor Authorized Boot (FPGA-First) Tutorial Example Design User Guide","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#introduction","title":"Introduction","text":"<p>The Vendor Authorized Boot (VAB) design demonstrates an end-to-end authenticated boot flow, from device power on until the Linux kernel is loaded. There are two main components of this design - the Secure Device Manager (SDM) which authenticates the configuration bitstream and U-boot with the Vendor Authorized Boot (VAB) feature. This design is demonstrated on Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)  but can also be easily ported to other boards. </p> <p>This demo design requires the following:  - QKY file to program virtual key for SDM authentication  - Signed RBF file (configuration bitstream) that consists of Agilex\u2122 7 GHRD and U-boot FSBL  - U-boot FSBL and SSBL with VAB features  - Linux LTSI </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#overview","title":"Overview","text":"<p>The main purpose of a secure boot system is to ensure that the software running in the Hard Processor System (HPS) is trusted. Upon power up, a trusted first stage of boot will be executed - subsequent stages are only loaded and executed if it is authenticated by the current boot stage.  In the Altera\u00ae Agilex\u2122 7 SoC FPGA devices, the Secure Device Manager (SDM) is the entry point for all configuration and booting scenarios. As such, the SDM is the root of trust and will be authenticating the configuration bitstream before any HPS software is being loaded. The SDM's Configuration Management Firmware (CMF) and HPS's First Stage Bootloader (FSBL) are validated as part of the signed configuration bitstream. If VAB is enabled in U-Boot, the FSBL will validate the Second Stage Bootloader (SSBL) and the SSBL will validate the Linux kernel. </p> <p>Note: In this demo design, only the authentication feature of the SDM is being demonstrated. The SDM supports other security features such as bitstream encryption, Physically Unclonable Function (PUF) and many more. </p> <p> </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#environment-setup","title":"Environment Setup","text":"<ol> <li>Create the main directory of the design: </li> </ol> <pre><code>cd ~ mkdir agx7_vab &amp;&amp; cd agx7_vab &amp;&amp; export TOP_DIR=$(pwd) </code></pre> <ol> <li>Download and extract the Linaro toolchain. Then, configure your environment to access the Linaro cross compiler:</li> </ol> <pre><code>wget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\n</code></pre> <ol> <li>Enable Quartus tools to be called from command line:</li> </ol> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#building-the-system-image","title":"Building the System Image","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#build-arm-trusted-firmware","title":"Build Arm Trusted Firmware","text":"<pre><code>cd $TOP_DIR\ngit clone https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware\ngit checkout -b socfpga_v2.12.0_vab origin/socfpga_v2.12.0\nmake realclean\nmake bl31 CROSS_COMPILE=aarch64-none-linux-gnu- PLAT=agilex DEPRECATED=1 HANDLE_EA_EL3_FIRST=1\ncd ..\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#build-u-boot","title":"Build U-Boot","text":"<p>The VAB deconfig will add the Vendor Authorized Boot firmware to the FSBL and SSBL.  <pre><code>cd $TOP_DIR\ngit clone -b QPDS25.1_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga export CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm make clean &amp;&amp; make mrproper make socfpga_agilex_vab_defconfig make -j 24 u-boot u-boot.img u-boot.dtb spl/u-boot-spl-dtb.hex cd .. </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#build-linux-kernel-with-intel-fgpa-crypto-service-support","title":"Build Linux Kernel with Intel FGPA Crypto Service Support","text":"<pre><code>cd $TOP_DIR\ngit clone -b QPDS25.1_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga cd linux-socfpga export CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm64 make clean make defconfig make menuconfig #(Browse and enable Cryptographic API &gt; Hardware crypto devices &gt; (*)Intel FPGA Crypto Service support) \nmake -j 16 all &amp;&amp; make dtbs &amp;&amp; make -j 16 modules cd .. </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#generate-signature-chains","title":"Generate Signature Chains","text":"<p>Create three signature chains (FPGA, SDM FW Cosigning, and HPS software).  Create directories for the keys and signature chains.  <pre><code>mkdir -p privatekeys mkdir -p publickeys mkdir -p qky </code></pre> Start a Nios V command shell to have all Quartus tools in the PATH:  <pre><code>~/altera_pro/25.1/niosv/bin/niosv-shell\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#generate-root-key","title":"Generate Root Key","text":"<pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/root0.pem quartus_sign --family=agilex --operation=make_public_pem privatekeys/root0.pem publickeys/root0_public.pem quartus_sign --family=agilex --operation=make_root publickeys/root0_public.pem qky/root0.qky </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#generate-signing-keys","title":"Generate Signing Keys","text":"<p>FPGA Signing  <pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/sign0.pem quartus_sign --family=agilex --operation=make_public_pem privatekeys/sign0.pem publickeys/sign0_public.pem </code></pre> SDM Cosigning  <pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/cosign0.pem quartus_sign --family=agilex --operation=make_public_pem privatekeys/cosign0.pem publickeys/cosign0_public.pem </code></pre> HPS Software  <pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/software0.pem\nquartus_sign --family=agilex --operation=make_public_pem privatekeys/software0.pem publickeys/software0_public.pem </code></pre> Generate Signature Chains:  FPGA Signing - Cancel ID 1 \u2013 Permissions: FPGA/HPS/HPS Debug  <pre><code>quartus_sign --family=agilex --operation=append_key --previous_pem=privatekeys/root0.pem --previous_qky=qky/root0.qky --permission=14 --cancel=1 --input_pem=publickeys/sign0_public.pem qky/sign0_cancel1.qky </code></pre> SDM cosigning - cancel ID 2 \u2013 Permissions: SDM Firmware  <pre><code>quartus_sign --family=agilex --operation=append_key --previous_pem=privatekeys/root0.pem --previous_qky=qky/root0.qky --permission=0x1 --cancel=2 --input_pem=publickeys/cosign0_public.pem qky/cosign0_cancel2.qky </code></pre> HPS Software - cancel ID 3 \u2013 Permissions: HPS Firmware  <pre><code>quartus_sign --family=agilex --operation=append_key --previous_pem=privatekeys/root0.pem --previous_qky=qky/root0.qky --permission=0x80 --cancel=3 --input_pem=publickeys/software0_public.pem qky/software0_cancel3.qky </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#build-the-hardware-design","title":"Build the Hardware Design","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#build-the-ghrd","title":"Build the GHRD","text":"<p>Download the GHRD from GitHub, and build it using the commands below:  <pre><code>cd $TOP_FOLDER\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1_REL_GSRD_PR.zip\nunzip QPDS25.1_REL_GSRD_PR.zip\nrm QPDS25.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\ncd ..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#enable-security-features-authentication","title":"Enable Security Features: Authentication","text":"<p>For the FPGA configuration bitstream to be properly signed, enable the Quartus key File in the Quartus Project.  - Open the GHRD project in Quartus.  - From the Assignments Menu, navigate to Device &gt; Device and Pin Options &gt; Security. Under Quartus key file, browse and select qky/sign0_cancel1.qky.  - Alternately, you can add the following assignment to the .qsf file: \"set_global_assignment -name QKY_FILE \" </p> <p>Regenerate the sof by running the Assembler.  - From the Processing menu, select Compilation Dashboard. In the Compilation Dashboard, select Assembler to regenerate the sof. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#generate-and-sign-fpga-and-hps-rbf-files","title":"Generate and Sign FPGA and HPS RBF Files","text":"<p>Add FSBL bootloader to configuration bitstream.  <pre><code>cd $TOP_DIR\nmkdir bitstreams cd bitstreams quartus_pfg -c ../agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof ghrd_agfb014r24b2e2v_hps.sof -o hps_path=../u-boot-socfpga/spl/u-boot-spl-dtb.hex </code></pre> Cosign the SDM firmware.  <pre><code>quartus_sign --family=agilex --operation=sign --qky=../qky/cosign0_cancel2.qky --pem=../privatekeys/cosign0.pem $QUARTUS_ROOTDIR/../devices/programmer/firmware/agilex.zip signed_agilex.zip </code></pre> Create Raw Binary File (rbf) with SDM Firmware included.  <pre><code>quartus_pfg -c -o fw_source=signed_agilex.zip ../agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps.sof \\ \n-o sign_later=ON unsigned_bitstream.rbf </code></pre> Sign the rbf.  <pre><code>quartus_sign --family=agilex --operation=sign --qky=../qky/sign0_cancel1.qky --pem=../privatekeys/sign0.pem unsigned_bitstream.rbf signed_bitstream.rbf </code></pre> Create .jic for flash programmer. (Optional)  <pre><code>quartus_pfg -c signed_bitstream.rbf signed_flash.jic -o device=MT25QU128 -o flash_loader=AGFB014R24B -o mode=ASX4 </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#prepare-the-signed-images","title":"Prepare the Signed Images","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#compile-fcs_prepare","title":"Compile fcs_prepare","text":"<p>The VAB preparation tool is used along with quartus_sign to create a signed firmware image. The signing process perfoms the following:  - The VAB preparation tool calculates the SHA384 hash of the firmware image and creates an unsigned certificate, named unsigned_cert.ccert.  - The signing tool signs the unsigned certification using the appropriate signature chain and creates a signed certificate.  - The VAB preparation tool will append the signed certificate and certificate length to the firmware image, creating a signed firmware image hps_image_signed.vab.  - Create a FIT image of the individually signed firmware images.  <pre><code>cd $TOP_DIR\ngit clone https://github.com/altera-opensource/fcs_apps mv fcs_apps fcs_prepare cd fcs_prepare git checkout -b fcs_prepare_vab origin/fcs_prepare export CROSS_COMPILE=; export ARCH= make clean &amp;&amp; make all </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#create-signed-u-boot-image","title":"Create Signed U-boot Image","text":"<p>A signed U-boot image will consist of three individually signed firmware images (bl31.bin, u-boot.dtb and u-boot-nodtb.bin) in a FIT image:    Create a working directory for signing images  <pre><code> cd $TOP_DIR\nmkdir signed_hps_images &amp;&amp; cd signed_hps_images </code></pre> Create the certificate for bl31.bin  <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../arm-trusted-firmware/build/agilex/release/bl31.bin -v quartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky --pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_bl31.bin.ccert ../fcs_prepare/fcs_prepare --finish ./signed_cert_bl31.bin.ccert --imagefile ../arm-trusted-firmware/build/agilex/release/bl31.bin mv hps_image_signed.vab ../u-boot-socfpga/signed-bl31.bin rm unsigned_cert.ccert </code></pre> Create the certificate for u-boot.dtb  <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../u-boot-socfpga/u-boot.dtb -v quartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky --pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_u-boot_pad.dtb.ccert ../fcs_prepare/fcs_prepare --finish ./signed_cert_u-boot_pad.dtb.ccert --imagefile ../u-boot-socfpga/u-boot.dtb mv hps_image_signed.vab ../u-boot-socfpga/signed-u-boot.dtb rm unsigned_cert.ccert </code></pre> Create the certificate for u-boot-nodtb.bin  <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../u-boot-socfpga/u-boot-nodtb.bin -v quartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky --pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_u-boot-nodtb.bin.ccert ../fcs_prepare/fcs_prepare --finish ./signed_cert_u-boot-nodtb.bin.ccert --imagefile ../u-boot-socfpga/u-boot-nodtb.bin mv hps_image_signed.vab ../u-boot-socfpga/signed-u-boot-nodtb.bin rm unsigned_cert.ccert </code></pre> Move into the U-Boot directory and run the FIT creation script  <pre><code>cd $TOP_DIR/u-boot-socfpga/ export CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm64 ./tools/binman/binman build -u -d u-boot.dtb -O . -i u-boot  </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#create-signed-linux-image","title":"Create Signed Linux Image","text":"<p>A signed Linux image will consist of two individually signed firmware images (Image and linux.dtb) in a FIT image:    Move into the signed images working directory  <pre><code>cd $TOP_DIR/signed_hps_images </code></pre> Create the certificate for the Image.  <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../linux-socfpga/arch/arm64/boot/Image -v quartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky --pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_Image.ccert ../fcs_prepare/fcs_prepare --finish ./signed_cert_Image.ccert --imagefile ../linux-socfpga/arch/arm64/boot/Image mv hps_image_signed.vab ../u-boot-socfpga/signed-Image rm unsigned_cert.ccert </code></pre> Create the certificate for linux.dtb.  <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb -v quartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky --pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_linux.dtb.ccert ../fcs_prepare/fcs_prepare --finish ./signed_cert_linux.dtb.ccert --imagefile ../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb mv hps_image_signed.vab ../u-boot-socfpga/signed-linux.dtb rm unsigned_cert.ccert </code></pre> Move into the U-Boot directory and run the FIT creation script.  <pre><code>cd $TOP_DIR/u-boot-socfpga/ export CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm64 ./tools/binman/binman build -u -d u-boot.dtb -O . -i kernel </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#create-fcs_client-optional","title":"Create fcs_client (optional)","text":"<p>The FCS_Client is an application that will allow validation of firmware images from the linux kernel. This application interfaces the Intel FPGA Crypto Services drivers included with the linux build.  <pre><code>cd $TOP_DIR\ngit clone https://github.com/altera-opensource/fcs_apps mv fcs_apps fcs_client cd fcs_client git checkout -b fcs_client_vab origin/fcs_client export CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm64 make clean &amp;&amp; make all  </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#create-rootfs","title":"Create Rootfs","text":"<p>Refer to Building Yocto Rootfs <pre><code>cd $TOP_DIR\nmkdir rootfs &amp;&amp; cd rootfs git clone -b styhead https://git.yoctoproject.org/poky\ngit clone -b styhead https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b styhead   https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf  echo 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver devmem2\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#create-sd-card-image","title":"Create SD Card Image","text":"<p><pre><code>cd $TOP_DIR\nmkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/2020.11/gsrd/tools/make_sdimage_p3.py chmod +x make_sdimage_p3.py # remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\n</code></pre> Copy over U-boot and Linux  <pre><code>mkdir sdfs &amp;&amp; cd sdfs cp ../../u-boot-socfpga/u-boot.itb . cp ../../u-boot-socfpga/kernel.itb . </code></pre> Copy over rootfs  <pre><code>mkdir rootfs &amp;&amp; cd rootfs sudo tar xf ../../rootfs/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\n</code></pre> Copy fcs_client into rootfs (optional)  <pre><code>sudo mkdir home/root/tools sudo cp ../../fcs_client/fcs_client home/root/tools/fcs_client </code></pre> Copy signed images into rootfs to test fcs_client (optional). In this example, we copied over signed-bl31.bin.  <pre><code>sudo mkdir home/root/images sudo cp ../../u-boot-socfpga/signed-bl31.bin home/root/images/signed-bl31.bin </code></pre> Create the SD Card Image  <pre><code>cd $TOP_DIR/sd_card\nsudo python3 make_sdimage_p3.py -f -P sdfs/*,num=1,format=fat32,size=50M -P rootfs/*,num=2,format=ext3,size=400M -s 512M -n sdcard_agilex_secure_boot.img cd .. </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#program-the-board-and-boot","title":"Program the Board and Boot","text":"<p>Configure board for SDM to boot from JTAG:  - SW1: 1:ON 2:ON 3:ON 4: OFF  - All other switches are in the default position  Insert the updated SD card into the slot on the OOBE HPS Daughtercard  Connect to the board with a serial terminal with 115,200-8-N-1 settings  Power up the board. Program and verify the virtual key using the following command. After this step, the device will no longer accept any unsigned bitstream or bitstream that has been signed with a different key until the device has received a power cycle.  <pre><code>quartus_pgm -c 1 -m jtag -o \"pi;qky/root0.qky\" </code></pre> Program the signed RBF file using the following command:  <pre><code>quartus_pgm -c 1 -m jtag -o \"p;bitstreams/signed_bitstream.rbf\" </code></pre> SDM will authenticate the bitstream and only allow configuration to proceed if the image is authenticated. Once RBF programming is done, you will be able to observe the U-boot boot messages at the serial terminal. The FSBL will verify the SSBL (in blue). The SSBL will then boot and verify the Linux kernel (in red).  <pre><code>U-Boot SPL 2021.04-14501-gbdc9a4409d (Jan 13 2022 - 17:20:53 -0600) Reset state: Cold MPU 1200000 kHz L4 Main 400000 kHz L4 sys free 100000 kHz L4 MP 200000 kHz L4 SP 100000 kHz SDMMC 50000 kHz DDR: 8192 MiB SDRAM-ECC: Initialized success with 1727 ms QSPI: Reference clock at 400000 kHz WDT: Started with servicing (10s timeout) Trying to boot from MMC1 ## Checking hash(es) for config conf \u2026 OK \n## Checking hash(es) for Image atf \u2026 crc32+ OK \nImage Authentication passed at address 0x0000000000001038 (40988 bytes) ## Checking hash(es) for Image uboot \u2026 crc32+ OK \nImage Authentication passed at address 0x0000000000200014 (627496 bytes) ## Checking hash(es) for Image fdt \u2026 crc32+ OK \nImage Authentication passed at address 0x0000000000299350 (18184 bytes) NOTICE: BL31: v2.5.0(release):QPDS21.1STD_REL_GSRD_PR NOTICE: BL31: Built : 17:05:32, Jan 13 2022 U-Boot 2021.04-14501-gbdc9a4409d (Jan 13 2022 - 17:20:53 -0600)socfpga_agilex CPU: Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53) Model: SoCFPGA Agilex SoCDK DRAM: 8 GiB WDT: Started with servicing (10s timeout) MMC: dwmmc0@ff808000: 0 Loading Environment from MMC... *** Warning - bad CRC, using default environment In: serial0@ffc02000 Out: serial0@ffc02000 Err: serial0@ffc02000 Net: Warning: ethernet@ff800000 (eth0) using random MAC address - 52:ec:38:d3:48:8e eth0: ethernet@ff800000 Hit any key to stop autoboot: 0 Failed to load 'u-boot.scr' 31856470 bytes read in 1487 ms (20.4 MiB/s) ## Loading kernel from FIT Image at 02000000 \u2026 \nUsing 'conf' configuration Verifying Hash Integrity \u2026 OK Trying 'kernel' kernel subimage Description: Linux Kernel Type: Kernel Image Compression: uncompressed Data Start: 0x020000bc Data Size: 31837308 Bytes = 30.4 MiB Architecture: AArch64 OS: Linux Load Address: 0x04080000 Entry Point: 0x04080000 Hash algo: crc32 Hash value: 51c0a4d2 Verifying Hash Integrity \u2026 crc32+ OK Image Authentication passed at address 0x00000000020000bc (31836672 bytes) ## Loading fdt from FIT Image at 02000000 \u2026 \nUsing 'conf' configuration Verifying Hash Integrity \u2026 OK Trying 'fdt' fdt subimage Description: Linux DTB Type: Flat Device Tree Compression: uncompressed Data Start: 0x03e5ce10 Data Size: 17304 Bytes = 16.9 KiB Architecture: AArch64 Hash algo: crc32 Hash value: 57811f0f Verifying Hash Integrity \u2026 crc32+ OK Image Authentication passed at address 0x0000000003e5ce10 (16668 bytes) Booting using the fdt blob at 0x3e5ce10 Loading Kernel Image Loading Device Tree to 000000007fa33000, end 000000007fa3a11b \u2026 OK SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Enabling QSPI at Linux DTB... RSU: Firmware or flash content not supporting RSU RSU: Firmware or flash content not supporting RSU RSU: Firmware or flash content not supporting RSU RSU: Firmware or flash content not supporting RSU Starting kernel \u2026 </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/fpga-first/ug-vab-fpga-first-agx7f-soc/#using-fcs_client","title":"Using fcs_client","text":"<p>If included in your rootfs, you can verify signed firmware images using fcs_client.  Enter username as 'root' (no password required) once booting is complete.  In the below example, we are validating the signed_bl31.bin which we added to the rootfs. Return status '0x0' indicates validated firmware.  <pre><code>Poky (Yocto Project Reference Distro) 3.4.1 agilex /dev/ttyS0 agilex login: root root@agilex:~# ./tools/fcs_client -V ./images/signed-bl31.bin -t 0 -v fcs_validate_request[481] filesize=41624 fcs_validate_request[503] sz=41624, filesize=41624 fcs_validate_request[516] Parsing Normal image fcs_validate_hps_image_buf[349] perform Hash Calculation Computed Hash 0000: 0e 20 6f af 08 9c db b9 0008: d6 25 71 1b fe 62 df 0d 0010: 21 d6 c8 15 1f 7d 4c 32 0018: c3 3e 53 c0 2c 5e 83 dc 0020: 41 71 ff f5 2a 45 1c 4e 0028: 24 67 8e 50 00 dd 10 34 Certificate Hash 0000: 0e 20 6f af 08 9c db b9 0008: d6 25 71 1b fe 62 df 0d 0010: 21 d6 c8 15 1f 7d 4c 32 0018: c3 3e 53 c0 2c 5e 83 dc 0020: 41 71 ff f5 2a 45 1c 4e 0028: 24 67 8e 50 00 dd 10 34 Hash matches so sending to SDM... VAB Certificate size is 636. ioctl size=636, address=0x0x1950f4ac ioctl return status=0x0 size=636 root@agilex:~# </code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/","title":"Vendor Authorized Boot (HPS-First) Tutorial Example Design User Guide","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#introduction","title":"Introduction","text":"<p>The Vendor Authorized Boot (VAB) design demonstrates an end-to-end authenticated boot flow, from device power on until the Linux kernel is loaded. There are two main components of this design - the Secure Device Manager (SDM) which authenticates the configuration bitstream and U-boot with the Vendor Authorized Boot (VAB) feature. This design is demonstrated on the  Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) but can also be easily ported to other boards.</p> <p>This demo design requires the following: - QKY file to program virtual key for SDM authentication - Signed RBF file (configuration bitstream) that consists of Agilex\u2122 7  GHRD and U-boot FSBL - U-boot FSBL and SSBL with VAB features - Linux LTSI</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#overview","title":"Overview","text":"<p>The main purpose of a secure boot system is to ensure that the software running in the Hard Processor System (HPS) is trusted. Upon power up, a trusted first stage of boot will be executed - subsequent stages are only loaded and executed if it is authenticated by the current boot stage. In the Altera\u00ae Agilex\u2122 7 SoC FPGA devices, the Secure Device Manager (SDM) is the entry point for all configuration and booting scenarios. As such, the SDM is the root of trust and will be authenticating the configuration bitstream before any HPS software is being loaded. The SDM's Configuration Management Firmware (CMF) and HPS's First Stage Bootloader (FSBL) are validated as part of the signed configuration bitstream. If VAB is enabled in U-Boot, the FSBL will validate the Second Stage Bootloader (SSBL) and the SSBL will validate the linux kernel.</p> <p>Note: In this demo design, only the authentication feature of the SDM is being demonstrated. The SDM supports other security features such as bitstream encryption, Physically Unclonable Function (PUF) and many more.  </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#environment-setup","title":"Environment Setup","text":"<ol> <li>Create the main directory of the design: </li> </ol> <pre><code>cd ~ mkdir agx7_vab &amp;&amp; cd agx7_vab &amp;&amp; export TOP_DIR=$(pwd) </code></pre> <ol> <li>Download and extract the Linaro toolchain. Then, configure your environment to access the Linaro cross compiler:</li> </ol> <p><pre><code>wget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\n</code></pre> 3. Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#building-the-system-image","title":"Building the System Image","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#build-arm-trusted-firmware","title":"Build Arm Trusted Firmware","text":"<pre><code>cd $TOP_DIR\ngit clone https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware\ngit checkout -b socfpga_v2.8.1_vab origin/socfpga_v2.8.1\nmake realclean\nmake bl31 CROSS_COMPILE=aarch64-none-linux-gnu- PLAT=agilex DEPRECATED=1 \\\nHANDLE_EA_EL3_FIRST=1\ncd ..\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#build-u-boot","title":"Build U-Boot","text":"<p>The VAB deconfig will add the Vendor Authorized Boot firmware to the FSBL and SSBL. <pre><code>cd $TOP_DIR\ngit clone https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga\ngit checkout -b socfpga_v2023.01_vab origin/socfpga_v2023.01\nexport CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex_vab_defconfig\nmake -j 24 u-boot u-boot.img u-boot.dtb spl/u-boot-spl-dtb.hex\ncd ..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#build-linux-kernel-with-intel-fgpa-crypto-service-support","title":"Build Linux Kernel with Intel FGPA Crypto Service Support","text":"<pre><code>cd $TOP_DIR\ngit clone https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\ngit checkout -b socfpga-6.1.20 origin/socfpga-6.1.20-lts\nexport CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm64\nmake clean\nmake defconfig\nmake menuconfig\n   (Browse and enable Cryptographic API &gt; Hardware crypto devices &gt; (*)Intel FPGA Crypto Service support)\nmake -j 16 all &amp;&amp; make dtbs &amp;&amp; make -j 16 modules\ncd ..\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#generate-signature-chains","title":"Generate Signature Chains","text":"<p>Create three signature chains (FPGA, SDM FW Cosigning, and HPS software). Create directories for the keys and signature chains. <pre><code>mkdir -p privatekeys\nmkdir -p publickeys\nmkdir -p qky\n</code></pre> Start a Nios command shell to have all Quartus tools in the PATH: <pre><code>~/intelFPGA_pro/&lt;VERSION&gt;/niosv/bin/niosv-shell\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#generate-root-key","title":"Generate Root Key","text":"<pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase \\\nprivatekeys/root0.pem\nquartus_sign --family=agilex --operation=make_public_pem privatekeys/root0.pem \\\npublickeys/root0_public.pem\nquartus_sign --family=agilex --operation=make_root publickeys/root0_public.pem qky/root0.qky\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#generate-signing-keys","title":"Generate Signing Keys","text":"<p>FPGA Signing</p> <p><pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase \\\nprivatekeys/sign0.pem\nquartus_sign --family=agilex --operation=make_public_pem privatekeys/sign0.pem \\\npublickeys/sign0_public.pem\n</code></pre> SDM Cosigning <pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase \\\nprivatekeys/cosign0.pem\nquartus_sign --family=agilex --operation=make_public_pem privatekeys/cosign0.pem \\\npublickeys/cosign0_public.pem\n</code></pre> HPS Software <pre><code>quartus_sign --family=agilex --operation=make_private_pem --curve=secp384r1 --no_passphrase \\\nprivatekeys/software0.pem\nquartus_sign --family=agilex --operation=make_public_pem privatekeys/software0.pem \\\npublickeys/software0_public.pem\n</code></pre> Generate Signature Chains: FPGA Signing - Cancel ID 1 \u2013 Permissions: FPGA/HPS/HPS Debug <pre><code>quartus_sign --family=agilex --operation=append_key --previous_pem=privatekeys/root0.pem \\\n--previous_qky=qky/root0.qky --permission=14 --cancel=1 \\\n--input_pem=publickeys/sign0_public.pem qky/sign0_cancel1.qky\n</code></pre> SDM cosigning - cancel ID 2 \u2013 Permissions: SDM Firmware <pre><code>quartus_sign --family=agilex --operation=append_key --previous_pem=privatekeys/root0.pem \\\n--previous_qky=qky/root0.qky --permission=0x1 --cancel=2 \\\n--input_pem=publickeys/cosign0_public.pem qky/cosign0_cancel2.qky\n</code></pre> HPS Software - cancel ID 3 \u2013 Permissions: HPS Firmware <pre><code>quartus_sign --family=agilex --operation=append_key --previous_pem=privatekeys/root0.pem \\\n--previous_qky=qky/root0.qky --permission=0x80 --cancel=3 \\\n--input_pem=publickeys/software0_public.pem qky/software0_cancel3.qky\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#build-the-hardware-design","title":"Build the Hardware Design","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#build-the-ghrd","title":"Build the GHRD","text":"<p>Download the GHRD from Github, and build it using the commands below:</p> <pre><code>cd $TOP_DIR\nrm -rf ghrd-socfpga agilex_soc_devkit_ghrd\ngit clone -b QPDS23.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex_soc_devkit_ghrd .\ncd agilex_soc_devkit_ghrd\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\ncd ..\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#enable-security-features-authentication","title":"Enable Security Features: Authentication","text":"<p>For the FPGA configuration bitstream to be properly signed, enable the Quartus key File in the Quartus Project.</p> <ul> <li>Open the GHRD project in Quartus.</li> <li>From the Assignments Menu, navigate to Device &gt; Device and Pin Options &gt; Security. Under Quartus key file, browse and select qky/sign0_cancel1.qky.</li> <li>Alternately, you can add the following assignment to the .qsf file: \"set_global_assignment -name QKY_FILE \"</li> </ul> <p>Regenerate the sof by running the Assembler. - From the Processing menu, select Compilation Dashboard. In the Compilation Dashboard, select Assembler to regenerate the sof.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#generate-and-sign-fpga-and-hps-rbf-files","title":"Generate and Sign FPGA and HPS RBF Files","text":"<p>Add FSBL bootloader to configuration bitstream.</p> <p><pre><code>cd $TOP_DIR\nmkdir bitstreams\ncd bitstreams\nquartus_pfg -c \\\n../agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\\n../agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps.sof -o hps_path=../u-boot-socfpga/spl/u-boot-spl-dtb.hex\n</code></pre> Cosign the SDM firmware. <pre><code>quartus_sign --family=agilex --operation=sign --qky=../qky/cosign0_cancel2.qky --pem=../privatekeys/cosign0.pem \\\n$QUARTUS_ROOTDIR/../devices/programmer/firmware/agilex.zip signed_agilex.zip\n</code></pre> Create Raw Binary File (rbf) with SDM Firmware included. <pre><code>quartus_pfg -c -o fw_source=signed_agilex.zip ../agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps.sof \\\n-o sign_later=ON unsigned_bitstream.rbf\n</code></pre> Sign the rbf. <pre><code>quartus_sign --family=agilex --operation=sign --qky=../qky/sign0_cancel1.qky \\\n--pem=../privatekeys/sign0.pem unsigned_bitstream.rbf signed_bitstream.rbf\n</code></pre> Create .jic for flash programmer. (Optional) <pre><code>quartus_pfg -c signed_bitstream.rbf signed_flash.jic -o device=MT25QU128 -o flash_loader=AGFB014R24B -o mode=ASX4\n</code></pre> Move back into the project directory. <pre><code>cd ..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#prepare-the-signed-images","title":"Prepare the Signed Images","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#compile-fcs_prepare","title":"Compile fcs_prepare","text":"<p>The VAB preparation tool is used along with quartus_sign to create a signed firmware image. The signing process perfoms the following: - The VAB preparation tool calculates the SHA384 hash of the firmware image and creates an unsigned certificate, named unsigned_cert.ccert. - The signing tool signs the unsigned certification using the appropriate signature chain and creates a signed certificate. - The VAB preparation tool will append the signed certificate and certificate length to the firmware image, creating a signed firmware image hps_image_signed.vab. - Create a FIT image of the individually signed firmware images. <pre><code>cd $TOP_DIR\ngit clone https://github.com/altera-opensource/fcs_apps\nmv fcs_apps fcs_prepare\ncd fcs_prepare\ngit checkout -b fcs_prepare_vab origin/fcs_prepare\nexport CROSS_COMPILE=; export ARCH=\nmake clean &amp;&amp; make all\ncd ..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#create-signed-u-boot-image","title":"Create Signed U-boot Image","text":"<p>A signed U-boot image will consist of three individually signed firmware images (bl31.bin, u-boot.dtb and u-boot-nodtb.bin) in a FIT image:  Create a working directory for signing images</p> <p><pre><code>cd $TOP_DIR\nmkdir signed_hps_images &amp;&amp; cd signed_hps_images\n</code></pre> Create the certificate for bl31.bin <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../arm-trusted-firmware/build/agilex/release/bl31.bin -v\nquartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky \\\n--pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_bl31.bin.ccert\n../fcs_prepare/fcs_prepare --finish ./signed_cert_bl31.bin.ccert --imagefile \\\n../arm-trusted-firmware/build/agilex/release/bl31.bin\nmv hps_image_signed.vab ../u-boot-socfpga/signed-bl31.bin\nrm unsigned_cert.ccert </code></pre> Create the certificate for u-boot.dtb <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../u-boot-socfpga/u-boot.dtb -v\nquartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky \\\n--pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_u-boot_pad.dtb.ccert\n../fcs_prepare/fcs_prepare --finish ./signed_cert_u-boot_pad.dtb.ccert --imagefile ../u-boot-socfpga/u-boot.dtb\nmv hps_image_signed.vab ../u-boot-socfpga/signed-u-boot.dtb\nrm unsigned_cert.ccert\n</code></pre> Create the certificate for u-boot-nodtb.bin <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../u-boot-socfpga/u-boot-nodtb.bin -v\nquartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky \\\n--pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_u-boot-nodtb.bin.ccert\n../fcs_prepare/fcs_prepare --finish ./signed_cert_u-boot-nodtb.bin.ccert --imagefile \\\n../u-boot-socfpga/u-boot-nodtb.bin\nmv hps_image_signed.vab ../u-boot-socfpga/signed-u-boot-nodtb.bin\nrm unsigned_cert.ccert\n</code></pre> Move into the U-Boot directory and run the FIT creation script <pre><code>cd ../u-boot-socfpga/\nexport CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm64\n./tools/binman/binman build -u -d u-boot.dtb -O . -i u-boot\ncd ..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#create-signed-linux-image","title":"Create Signed Linux Image","text":"<p>A signed Linux image will consist of two individually signed firmware images (Image and linux.dtb) in a FIT image:  Move into the signed images working directory <pre><code>cd $TOP_DIR/signed_hps_images\n</code></pre> Create the certificate for the Image. <pre><code>../fcs_prepare/fcs_prepare --hps_cert ../linux-socfpga/arch/arm64/boot/Image -v\nquartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky \\\n--pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_Image.ccert\n../fcs_prepare/fcs_prepare --finish ./signed_cert_Image.ccert --imagefile ../linux-socfpga/arch/arm64/boot/Image\nmv hps_image_signed.vab ../u-boot-socfpga/signed-Image\nrm unsigned_cert.ccert </code></pre> Create the certificate for linux.dtb. <pre><code>../fcs_prepare/fcs_prepare --hps_cert \\\n../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb -v\nquartus_sign --family=agilex --operation=SIGN --qky=../qky/software0_cancel3.qky \\\n--pem=../privatekeys/software0.pem ./unsigned_cert.ccert ./signed_cert_linux.dtb.ccert\n../fcs_prepare/fcs_prepare --finish ./signed_cert_linux.dtb.ccert --imagefile \\\n../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb\nmv hps_image_signed.vab ../u-boot-socfpga/signed-linux.dtb\nrm unsigned_cert.ccert\n</code></pre> Move into the U-Boot directory and run the FIT creation script. <pre><code>cd ../u-boot-socfpga/\nexport CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm64\n./tools/binman/binman build -u -d u-boot.dtb -O . -i kernel\ncd ..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#create-fcs_client-optional","title":"Create fcs_client (optional)","text":"<p>The FCS_Client is an application that will allow validation of firmware images from the linux kernel. This application interfaces the Intel FPGA Crypto Services drivers included with the linux build. <pre><code>cd $TOP_DIRcd $TOP_DIR\ngit clone https://github.com/altera-opensource/fcs_apps\nmv fcs_apps fcs_client\ncd fcs_client\ngit checkout -b fcs_client_vab origin/fcs_client\nexport CROSS_COMPILE=aarch64-none-linux-gnu-; export ARCH=arm64\nmake clean &amp;&amp; make all\ncd ..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#create-rootfs","title":"Create Rootfs","text":"<p>Refer to Building Yocto Rootfs <pre><code>cd $TOP_DIR\nmkdir rootfs &amp;&amp; cd rootfs\ngit clone -b honister git://git.yoctoproject.org/poky.git\ngit clone -b honister git://git.yoctoproject.org/meta-intel-fpga.git\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\nbitbake core-image-minimal\ncd ../..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#create-sd-card-image","title":"Create SD Card Image","text":"<p><pre><code>cd $TOP_DIR\nmkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/2020.11/gsrd/tools/make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n</code></pre> Copy over U-boot and Linux <pre><code>mkdir sdfs &amp;&amp; cd sdfs\ncp ../../u-boot-socfpga/u-boot.itb .\ncp ../../u-boot-socfpga/kernel.itb .\ncd ..\n</code></pre> Copy over rootfs <pre><code>mkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf ../../rootfs/build/tmp/deploy/images/agilex/core-image-minimal-agilex.tar.gz\ncd ..\n</code></pre> Copy fcs_client into rootfs (optional) <pre><code>cd rootfs\nsudo mkdir home/root/tools\nsudo cp ../../fcs_client/fcs_client home/root/tools/fcs_client\ncd ..\n</code></pre> Copy signed images into rootfs to test fcs_client (optional). In this example, we copied over signed-bl31.bin. <pre><code>cd rootfs\nsudo mkdir home/root/images\nsudo cp ../../u-boot-socfpga/signed-bl31.bin home/root/images/signed-bl31.bin\ncd ..\n</code></pre> Create the SD Card Image <pre><code>sudo python3 make_sdimage_p3.py -f \\\n-P sdfs/*,num=1,format=fat32,size=50M \\\n-P rootfs/*,num=2,format=ext3,size=400M \\\n-s 512M \\\n-n sdcard_agilex_secure_boot.img\ncd ..\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#program-the-board-and-boot","title":"Program the Board and Boot","text":"<p>Configure board for SDM to boot from JTAG:</p> <ul> <li>SW1: 1:ON 2:ON 3:ON 4: OFF</li> <li>All other switches are in the default position Insert the updated SD card into the slot on the OOBE HPS Daughtercard Connect to the board with a serial terminal with 115,200-8-N-1 settings Power up the board. Program and verify the virtual key using the following command. After this step, the device will no longer accept any unsigned bitstream or bitstream that has been signed with a different key until the device has received a power cycle. <pre><code>quartus_pgm -c 1 -m jtag -o \"pi;qky/root0.qky\"\n</code></pre> Program the signed RBF file using the following command: <pre><code>quartus_pgm -c 1 -m jtag -o \"p;bitstreams/signed_bitstream.rbf\"\n</code></pre> SDM will authenticate the bitstream and only allow configuration to proceed if the image is authenticated. Once RBF programming is done, you will be able to observe the U-boot boot messages at the serial terminal. The FSBL will verify the SSBL (in blue). The SSBL will then boot and verify the Linux kernel (in red). <pre><code>U-Boot SPL 2021.04-14501-gbdc9a4409d (Jan 13 2022 - 17:20:53 -0600)\nReset state: Cold\nMPU          1200000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nDDR: 8192 MiB\nSDRAM-ECC: Initialized success with 1727 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started with servicing (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config conf \u2026 OK\n## Checking hash(es) for Image atf \u2026 crc32+ OK\nImage Authentication passed at address 0x0000000000001038 (40988 bytes)\n## Checking hash(es) for Image uboot \u2026 crc32+ OK\nImage Authentication passed at address 0x0000000000200014 (627496 bytes)\n## Checking hash(es) for Image fdt \u2026 crc32+ OK\nImage Authentication passed at address 0x0000000000299350 (18184 bytes)\nNOTICE:  BL31: v2.5.0(release):QPDS21.1STD_REL_GSRD_PR\nNOTICE:  BL31: Built : 17:05:32, Jan 13 2022\nU-Boot 2021.04-14501-gbdc9a4409d (Jan 13 2022 - 17:20:53 -0600)socfpga_agilex\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Agilex SoCDK\nDRAM:  8 GiB\nWDT:   Started with servicing (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from MMC... *** Warning - bad CRC, using default environment\n\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:\nWarning: ethernet@ff800000 (eth0) using random MAC address - 52:ec:38:d3:48:8e\neth0: ethernet@ff800000\nHit any key to stop autoboot:  0\nFailed to load 'u-boot.scr'\n31856470 bytes read in 1487 ms (20.4 MiB/s)\n## Loading kernel from FIT Image at 02000000 \u2026\nUsing 'conf' configuration\n   Verifying Hash Integrity \u2026 OK\n   Trying 'kernel' kernel subimage\n     Description:  Linux Kernel\n     Type:         Kernel Image\n     Compression:  uncompressed\n     Data Start:   0x020000bc\n     Data Size:    31837308 Bytes = 30.4 MiB\n     Architecture: AArch64\n     OS:           Linux\n     Load Address: 0x04080000\n     Entry Point:  0x04080000\n     Hash algo:    crc32\n     Hash value:   51c0a4d2\n   Verifying Hash Integrity \u2026 crc32+ OK\nImage Authentication passed at address 0x00000000020000bc (31836672 bytes)\n## Loading fdt from FIT Image at 02000000 \u2026\nUsing 'conf' configuration\n   Verifying Hash Integrity \u2026 OK\n   Trying 'fdt' fdt subimage\n     Description:  Linux DTB\n     Type:         Flat Device Tree\n     Compression:  uncompressed\n     Data Start:   0x03e5ce10\n     Data Size:    17304 Bytes = 16.9 KiB\n     Architecture: AArch64\n     Hash algo:    crc32\n     Hash value:   57811f0f\n   Verifying Hash Integrity \u2026 crc32+ OK\nImage Authentication passed at address 0x0000000003e5ce10 (16668 bytes)\nBooting using the fdt blob at 0x3e5ce10\n   Loading Kernel Image\n   Loading Device Tree to 000000007fa33000, end 000000007fa3a11b \u2026 OK\nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB\nEnabling QSPI at Linux DTB...\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\n\nStarting kernel \u2026\n</code></pre></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/security/vab/hps-first/ug-vab-hps-first-agx7f-soc/#using-fcs_client","title":"Using fcs_client","text":"<p>If included in your rootfs, you can verify signed firmware images using fcs_client. Enter username as 'root' (no password required) once booting is complete. In the below example, we are validating the signed_bl31.bin which we added to the rootfs. Return status '0x0' indicates validated firmware. <pre><code>Poky (Yocto Project Reference Distro) 3.4.1 agilex /dev/ttyS0\n\nagilex login: root\nroot@agilex:~# ./tools/fcs_client -V ./images/signed-bl31.bin -t 0 -v\nfcs_validate_request[481] filesize=41624\nfcs_validate_request[503] sz=41624, filesize=41624\nfcs_validate_request[516] Parsing Normal image\nfcs_validate_hps_image_buf[349] perform Hash Calculation\nComputed Hash\n0000: 0e 20 6f af 08 9c db b9\n0008: d6 25 71 1b fe 62 df 0d\n0010: 21 d6 c8 15 1f 7d 4c 32\n0018: c3 3e 53 c0 2c 5e 83 dc\n0020: 41 71 ff f5 2a 45 1c 4e\n0028: 24 67 8e 50 00 dd 10 34\nCertificate Hash\n0000: 0e 20 6f af 08 9c db b9\n0008: d6 25 71 1b fe 62 df 0d\n0010: 21 d6 c8 15 1f 7d 4c 32\n0018: c3 3e 53 c0 2c 5e 83 dc\n0020: 41 71 ff f5 2a 45 1c 4e\n0028: 24 67 8e 50 00 dd 10 34\nHash matches so sending to SDM...\nVAB Certificate size is 636.\nioctl size=636, address=0x0x1950f4ac\nioctl return status=0x0 size=636\nroot@agilex:~#\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/","title":"Setting up and Using Bridges HPS Linux Example for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#overview","title":"Overview","text":"<p>This project demonstrates how to access HPS Memory via the FPGA to HPS bridges when the HPS is running Linux, but is also applicable to other OS\u2019s or BareMetal inclusive.  This project is created for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile, DK-SI-AGF014EB). It includes the effect of:</p> <ul> <li>The memory allocation method used in Linux which sets the memory attributes including security and privilege.</li> <li>The interaction with Arm\u00ae AMBA\u00ae AXI\u2122 Side Band Signal settings required for secure, privileged, and cached transfers from the FPGA using the Cache Coherency Translator IP. This also includes the exercise of the data path that goes from fabric to SDRAM which could go directly to SDRAM or pass through CCU.</li> <li>The Firewall settings for the HPS bridges, which can override AXI transaction attributes.</li> <li>Perform data movement from one SDRAM memory location to another using the Scatter-Gather DMA IP.</li> </ul> <p>This example allocates memory using two methods:</p> <ol> <li> <p>Manually reserved memory at Kernel boot time.</p> <ul> <li>Allocation at Kernel boot time using the Kernel boot argument mem=1G. This limits the Linux kernel to use the lower 1GB (of 2 GB*) SDRAM.</li> <li>This creates a static area of 1 GB (upper region of the 2 GB*) reserved for the application.</li> <li>This area will typically be marked as Privileged and non-secure, but this is implementation dependent.</li> </ul> </li> <li> <p>Runtime allocation from the Contiguous Memory Allocator Area (CMA) of 256 MB.</p> <ul> <li>Kernel allocated memory from device tree supported by Kernel drivers,  dynamic allocation of DMA Memory and the Linux Kernel\u2019s DMA API. </li> <li>An open source 3rd party driver is used to allocate this memory.</li> <li>This memory will typically be marked as privileged as it has been kernel allocated, and may be marked as non-secure.</li> </ul> </li> </ol> <p>Note: The dev kit have 8 GB of memory which is mapped in 2 regions:  one region of 2 GB (going from 0x0 - 0x80000000) and second region of 6 GB (going from 0x280000000 - 0x400000000). The 2 GB region mentioned in the manually reserved memory above is referring  to this 1st region.</p> <p>For further reading:</p> <ul> <li>Linux Kernel DMA API, and CMA documentation can be found in the Linux Kernel Documentation.</li> <li>Information on Memory Attributes in Arm\u00ae architectures can be found in the Arm Architecture documentation available on arm.com.</li> </ul> <p>This example requires a correct configuration for the FPGA Firewall settings to allow only secure access through F2S bridge( through the fpga2soc bit on the soc_noc_fw_mpfe_csr_inst_0_mpfe_scr register with offset 0xF8020018).  For more detail see Intel\u00ae Agilex\u2122 Hard Processor System Address Map and Register Definitions. </p> <p>The HPS is also configured to send the memory transactions directly to the MPFE NOC  or to through the CCU based on the settings defined in the Intel Cache Coherency Translator in the fabric.</p> <p>High Level Diagram:</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#amba-ace-lite-signaling","title":"AMBA ACE-LITE Signaling","text":"<p>The attributes of the AXI transaction from the FPGA are controlled by the Intel Cache Coherency Translator IP. The AXUSER signal is used to steer transactions either directly to the SDRAM or via the HPS Cache Coherency Unit (CCU).</p> <p><pre><code>ACE-LITE Signaling: \n   #[1:0]     - ardomain    \n   #[3:2]     - arbar        \n   #[7:4]     - arsnoop     \n   #[11:8]    - arcache      \n   #[13:12]   - awdomain      \n   #[15:14]   - awbar        \n   #[18:16]   - awsnoop       \n   #[22:19]   - awcache       \n   #[28:23]   - axuser[7:2]   Memory data path (direct or through CCU)\n   #[31:29]   - axprot    Bit0: Privelege mode, Bit1: Secure mode      \n</code></pre> For further reading:</p> <ul> <li>The AMBA\u00ae AXI\u2122 and ACE\u2122 Protocol Specification available form arm.com contains more information on the AXI Side band signals.</li> <li>The Bridges chapter of the Intel\u00ae Agilex\u2122 Hard Processor System Technical Reference Manual contains information and examples bridge settings for AXI Side Band Signals.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#testing-of-the-project","title":"Testing of the Project","text":"<p>The demonstration script runs 4 tests on via a simple bash script. All the tests are run using a DMA controller in the FPGA fabric, controlled from the HPS.</p> <ul> <li>2 sets of Read and Write Buffers are created for the DMA to use. Read and Write buffers are named from the DMA controller perspective).</li> <li>One set of Buffers is created in the manually reserved memory region.</li> <li>One set of Buffers is created in the Contiguous Memory Allocator (CMA) Area.</li> <li>The Read Buffers are populated with test data from user space prior to the test running.</li> <li>The Intel Cache Coherency Translator is set prior to each test, to set the transaction routing (SDRAM Direct or via CCU) and the AXI Transaction attributes. See Test Script for full detail on AXI Attribute settings for each test.</li> </ul> <p></p> <p>The description of the 4 tests that the bash scripts executes are shown next. The test makes use of the devmem2 application from the user space to perform all the operations (configuration and read/write from/to buffers).</p> <ol> <li> <p>Direct to SDRAM. AXI attributes: Privileged, Non-Cached and Non-Secure access.</p> <ul> <li>Write 128 words in the read buffer at the manually reserved area of SDRAM from the user space. Read back the buffer from user space to confirm the content. </li> <li>Configure the DMA controller to move the chunk of the 128 words to the write buffer also in the manually reserved area of SDRAM.</li> <li>Read from the write buffer to verify the content. This content is should not match to the content written in the read buffer due to Non-secure transactions are being blocked by the FPGA firewall.</li> </ul> <p></p> </li> <li> <p>Direct to SDRAM. AXI attributes: Privileged, Non-Cached and Secure access.</p> <ul> <li>Write 128 words in the read buffer at the manually reserved area of SDRAM from the user space. Read back the buffer from user space to confirm the content. </li> <li>Configure the DMA controller to move the chunk of the 128 words to the write buffer also in the manually reserved area of SDRAM.</li> <li>Read from the write buffer to verify the content. The content in the write buffer should match with the data written in the read buffer.</li> </ul> <p></p> </li> <li> <p>Through CCU. AXI attributes: Privileged, Non-Cached and Secure access.</p> <ul> <li>Write 128 words in the read buffer at the manually reserved area of SDRAM from the user space. Read back the buffer from user space to confirm the content. </li> <li>Configure the DMA controller to move the chunk of the 128 words to the write buffer in the CMA reserved area of SDRAM in non-cached mode.</li> <li>Read from the write buffer to verify the content. The content in the write buffer should match with the data written in the read buffer. This test can be edited to use the manually reserved area of SDRAM as the write buffer.</li> </ul> <p></p> </li> <li> <p>Through CCU. AXI attributes: Privileged, Cached and Secure access.</p> <ul> <li>Write 128 words in the read buffer at the manually reserved area of SDRAM from the user space. Read back the buffer from user space to confirm the content. </li> </ul> <ul> <li>Configure the DMA controller to move the chunk of the 128 words to the write buffer in the CMA reserved area of SDRAM in cached mode.</li> </ul> <ul> <li>Read from the write buffer to verify the content. The content in the write buffer should match with the data written in the read buffer. This test can be edited to use the manually reserved area of SDRAM as the write buffer.</li> </ul> <p></p> </li> </ol> <p>The following table describes the configuration that is being performed in the Cache Coherency Translator in each one of the tests and the values in each one of the fields. This configuration determines the memory transaction attributes in each test. </p> Field Test 1DirectNon-SecuredNon-CachedPrivileged Test 2DirectSecuredNon-CachedPrivileged Test 3Through CCUSecuredNon_cachedPrivileged Test 4Through CCUSecuredCachedPrivileged CSR Register 0x7C108208 0x3C108208 0x20982302 0x20F82F02 ARDOMAIN[1:0] 0x0 0x0 0x2 0x2 ARBAR[3:2] 0x2 0x2 0x0 0x0 ARSNOOP[7:4] 0x0 0x0 0x0 0x0 ARCACHE[11:8] 0x2 0x2 0x3 0xF AWDOMAIN[13:12] 0x0 0x0 0x2 0x2 AWBAR[15:14] 0x2 0x2 0x0 0x0 AWSNOOP[18:16] 0x0 0x0 0x0 0x0 AWCACHE[22:19] 0x2 0x2 0x3 0xF AxUSER7_1[28:23] 0x38AxUSER[7:0]=0xE0 0x38AxUSER[7:0]=0xE0 0x1AxUSER[7:0]=0x4 0x1AxUSER[7:0]=0x4 AxPROT[31:29] 0x3 0x1 0x1 0x1 <p>Note: This page was migrated from Rocketboards in 24.3.1 release. In case you need to see the content from earlier versions, please go to https://www.rocketboards.org/foswiki/Projects/SettingUpAndUsingBridgesOnAgilex and see the Revision History of that page.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile, DK-SI-AGF014EB)</p> <ul> <li>Mini USB cable for serial output.</li> </ul> <ul> <li>USB cable for on-board Intel FPGA Download Cable II.</li> </ul> <ul> <li>SD/MMC HPS Daughtercard.</li> </ul> <ul> <li>Micro SD card.</li> </ul> </li> </ul> <ul> <li> <p>Host PC with</p> <ul> <li>Linux distribution with kernel-headers/ kernel-devel and Binutils packages properly installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too.</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1.</li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows).</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#building-the-example","title":"Building the Example","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd_bridge_example\nmkdir agilex7f_gsrd_bridge_example\ncd agilex7f_gsrd_bridge_example\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>This project starts using the GHRD for the DK-SI-AGF014EB OOBE (booting from SD Card) with some modifications that include:</p> <ul> <li>Change HPS parameters related to the FPGA to HPS interface</li> <li>Changing the control interface of the  Intel Cache Coherency Translator</li> </ul> <ul> <li>Include the Modular Scatter-Gather DMA mSGDMA's Overview</li> </ul> <p>This can be performed automatically using the update_ghrd_bridge_example.tcl script as indicated next:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-generate-design\ncd agilex_soc_devkit_ghrd\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/f-series/soc/setup-use-bridges/collateral/update_ghrd_bridge_example.tcl\nqsys-script --qpf=ghrd_agfb014r24b2e2v.qpf --script=update_ghrd_bridge_example.tcl --system-file=qsys_top.qsys\ncd ..\nmake agf014eb-si-devkit-oobe-baseline-package-design\nmake agf014eb-si-devkit-oobe-baseline-prep\nmake agf014eb-si-devkit-oobe-baseline-build\n</code></pre> <p>The output of this stage will be:</p> <ul> <li>$TOP_FOLDER/agilex7f-ed-gsrd/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof</li> </ul> <p>You can also modify and build the hardware project manually as indicated next. This should be done just after executing the make agf014eb-si-devkit-oobe-baseline-generate-design command in the previous instructions.</p> <ol> <li> <p>Open the Quartus project with the following command and then open qsys_top.qsys from Platform Designer:</p> <pre><code>quartus ./agilex_soc_devkit_ghrd/ghrd_agfb014r24b2e2v.qpf &amp;\n</code></pre> <p></p> </li> <li> <p>Right-click on agilex_hps name and select Edit Parameters then configure it as follows and click on finish:</p> <p>FPGA to HPS slave interface</p> <p>- Interface specification \u2192 ACE-lite   - Enable/Data width \u2192 128-bit   - Interface destination \u2192 custom</p> <p>Note: The interface destination is set as custom because we want to control the data path to SDRAM (either direct or through CCU) from the signals in the memory transaction defined by the Cache Coherency Translator.</p> <p></p> </li> <li> <p>Right click to the intel_cache_coherency_translator_0 to configure the parameters as indicated next:</p> <p>General</p> <ul> <li>CONTROL_INTERFACE \u2192 CSR</li> <li>Address Width \u2192 32</li> <li>Data Width \u2192 128</li> <li>AXM ID Width \u2192 5</li> <li>AXM ID Width \u2192 5</li> </ul> <p>ACE-Lite Transaction Control for read Channel</p> <ul> <li>ARDOMAIN_OVERRIDE \u2192 0x2</li> <li>ARCACHE_OVERRIDE_EN \u2192 Enable</li> <li>ARCACHE_OVERRIDE \u2192 0xf</li> </ul> <p>ACE-Lite Transaction Control for Write Channel</p> <ul> <li>AWDOMAIN_OVERRIDE \u2192 0x2</li> <li>AWCACHE_OVERRIDE_EN \u2192 Enable</li> <li>AWCACHE_OVERRIDE \u2192 0xf</li> </ul> <p>User Selection</p> <ul> <li>AxPROT_OVERRIDE_EN \u2192 Enable</li> <li>AxPROT_OVERRIDE \u2192 0x3</li> </ul> <p> </p> </li> <li> <p>Add Modular Scatter-Gather DMA IP to the design with the following configurations:</p> <p>DMA Settings</p> <ul> <li>Data Width \u2192 128</li> <li>Data Path FIFO Depth \u2192 512</li> <li>Descriptor FIFO Depth \u2192 64</li> <li>Response Port \u2192 Memory-Mapped</li> <li>Maximum Transfer Length \u2192 4KB</li> <li>Burst Enable</li> <li>Maximum Burst Count \u2192 64</li> </ul> <p>Extended Feature Options</p> <ul> <li>Enable Extended Feature Support</li> <li>Programmable Burst Enable</li> </ul> <p>Pre-Fetching Options</p> <ul> <li> <p>Data Width of Descriptor read/write master data path \u2192 128</p> <p> </p> </li> </ul> </li> <li> <p>Move the msgdma_0 component (Modular Scatter-Gather DMA) below the agilex_hps component selecting the component and using the UP button.</p> <p> </p> </li> <li> <p>Connect the intel_cache_coherency_translator_0 component as shown next:</p> <p>- csr_clock \u2192 clk_100.out_clk   - csr_reset \u2192 rst_in.out_reset   - csr \u2192 agilex_hps.h2f_lw_axi_master</p> <p></p> </li> <li> <p>Connect the msgdma_0 component (Modular Scatter-Gather DMA) as shown next:</p> <p>- Clock \u2192 clk_100.out_clk   - reset \u2192 rst_in.out_reset   - csr \u2192 agilex_hps.h2f_lw_axi_master   - descriptor_slave \u2192 agilex_hps.h2f_lw_axi_master   - response \u2192 agilex_hps.h2f_lw_axi_master   - mm_read \u2192 intel_cache_coherency_translator_0.s0   - mm_write \u2192 intel_cache_coherency_translator_0.s0</p> <p></p> </li> <li> <p>Use the padlock   on the \"Base\" column to lock all the base addresses except the ones in Intel Cache Coherency translator and Modular Scatter-Gather DMA components. After that go to System \u2192 Assign Base Addresses menu and click it. Once the process is finished, the Address Map tab should look similar to this:</p> <p></p> </li> <li> <p>If everything is ok, there shouldn't be any error on the system Messages tray and you can save the design and click on Generate HDL button now.</p> </li> <li> <p>Finally close Platform Designer and start building the updated hardware design on Quartus Pro by either clicking  or pressing CTL-L.</p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#rebuild-the-hps_debugsof-from-updated-sof","title":"Rebuild the hps_debug.sof from Updated .sof","text":"<pre><code>cd $TOP_FOLDER/agilex7f-ed-gsrd\n# Generate hps_debug.ihex\nmake agf014eb-si-devkit-oobe-baseline-sw-build\nquartus_pfg -c ./agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof ghrd_agfb014r24b2e2v_hps_debug.sof -o hps_path=./agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex\nmv ghrd_agfb014r24b2e2v_hps_debug.sof agilex_soc_devkit_ghrd/output_files/\ncd $TOP_FOLDER\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/agilex7f-ed-gsrd/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex - HPS Debug FSBL</li> <li>$TOP_FOLDER/agilex7f-ed-gsrd/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex7f-ed-gsrd/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#customize-yocto","title":"Customize Yocto","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#adding-our-custom-corerbf","title":"Adding our custom core.rbf","text":"<ol> <li> <p>Copy the rebuilt core.rbf file to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf</li> </ul> <p>In our case we just copy the core.rbf file in the Yocto recipe location:</p> <pre><code>## Custom yocto to use our own core.rbf\nCORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\n</code></pre> </li> <li> <p>In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb modify the agilex_gsrd_code</code> file location:   <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n\"\n</code></pre>   to look like this:</p> <p><pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\nfile://agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=xxxxxxxxx \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n\"\n</code></pre> using the following commands:</p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> </li> <li> <p>In the same Yocto recipe delete the old SHA256 checksum for the file:</p> <pre><code>SRC_URI[agilex7_dk_si_agf014eb_gsrd_core.sha256sum] = \"5d633ee561d5cc8c22b51211a144654fdc0be47ee14b07ac134074cbff84eb8b\"\n</code></pre> <p>by using the following command:</p> <pre><code>sed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#updating-linux-kernel-configuration","title":"Updating Linux Kernel Configuration","text":"<p>In this example you need the following Linux kernel configuration options. Among these configurations it's included the capability  of devmem2 command to access the memory regions where the read/write buffers are located. Yocto allows to add fragments and make the process easier. You can do this by executing the following commands:</p> <pre><code># Add Configs to Linux needed to excercise this example\ncd $TOP_FOLDER/gsrd-socfpga/\ncat &lt;&lt; EOF &gt; $WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts/bridgesfragment.cfg\nCONFIG_ALTERA_SYSID=y\nCONFIG_ALTERA_MSGDMA=y\nCONFIG_FPGA_BRIDGE=y\nCONFIG_ALTERA_FREEZE_BRIDGE=y\nCONFIG_FPGA_REGION=y\nCONFIG_OF_FPGA_REGION=y\nCONFIG_STACKDEPOT=y\nCONFIG_STACK_HASH_ORDER=20\nCONFIG_GDB_SCRIPTS=y\nCONFIG_PAGE_EXTENSION=y\nCONFIG_DEBUG_PAGEALLOC=y\nCONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT=y\nCONFIG_PAGE_OWNER=y\nCONFIG_PTDUMP_CORE=y\nCONFIG_PTDUMP_DEBUGFS=y\nCONFIG_DEBUG_MEMORY_INIT=y\nCONFIG_DEBUG_PER_CPU_MAPS=y\nCONFIG_STACKTRACE=y\nCONFIG_DEBUG_KOBJECT=y\nCONFIG_DEVMEM=y\nCONFIG_STRICT_DEVMEM=n\nCONFIG_EXCLUSIVE_SYSTEM_RAM=n\nEOF\necho \"kconf hardware bridgesfragment.cfg\" &gt;&gt; $WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts/sgmii.scc\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#add-u-dma-buf-driver-to-create-cma-regions","title":"Add u-dma-buf driver to create CMA regions","text":"<p>It is also necessary to modify the device tree to include a 3rd party driver (u-dma-buf) to reseve the CMA memory regionlocation add the following changes to <code>arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dts</code> to define how the memory will be allocated by u-dma-buf. This is done through a patch that will be created  as shown next.</p> <pre><code>## Create the fragment of the device tree to add u-dma-buf and reserve 256 MB of memory. Creating this as patch.\ncd $TOP_FOLDER\nrm -f dmaBufNodes.txt\ncat &lt;&lt; EOF &gt; dmaBufNodes.txt\n    reserved-memory {\n        #address-cells = &lt;2&gt;;\n        #size-cells = &lt;2&gt;;\n        dma0_mem:dma0@0x10000000 {\n        compatible= \"shared-dma-pool\";\n        reusable;\n        reg=&lt;0x0  0x10000000 0x0 0x10000000&gt;;\n        label=\"dma0_mem\";\n        };\n    };\n    soc {\n        clocks {\n            osc1 {\n            clock-frequency = &lt;25000000&gt;;\n            };\n        };\n        udmabuf0: udmabuf@0x10000000 {\n            compatible = \"ikwzm,u-dma-buf\";\n            device-name = \"udmabuf0\";\n            minor-number = &lt;0&gt;;\n            size = &lt;0x10000000&gt;;\n            memory-region = &lt;&amp;dma0_mem&gt;;\n            dma-coherent = &lt;1&gt;;\n        };\n    };\nEOF\n# Create a Linux repository in the $TOP_FOLDER\nrm -rf linux-socfpga-for-patch\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga linux-socfpga-for-patch\n# Add the content of dmaBufNodes.txt  after 4 lines of finding memory@\nawk '\n    /memory@/ {found=NR}  # Store the line number where \"memory@\" is found\n    {print}  # Print each line as it is\n    found &amp;&amp; NR == found + 4 {while ((getline line &lt; \"dmaBufNodes.txt\") &gt; 0) print line; found=0}  # Insert after 4 lines\n' linux-socfpga-for-patch/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dts &gt; temp.dts &amp;&amp; mv temp.dts linux-socfpga-for-patch/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dts\n\n## Create now the patch using the differences\ncd $TOP_FOLDER/linux-socfpga-for-patch\ngit add  arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dts\n# Create the patch and add the Uptream status header to prevent QA errors\ngit diff --patch --staged &gt; $WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts/socfpga_agilex_socdk.dts.patch\n# Add the Upstream-status label to prevent issues\nsed -i '1i Upstream-Status: Pending\\n' $WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts/socfpga_agilex_socdk.dts.patch\n\n# Include the Patch created in to the recipe\ncd $TOP_FOLDER/gsrd-socfpga/\nFILENAME=$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts_%.bbappend\nawk '/file:\\/\\/fit_kernel_agilex7_dk_si_agf014eb.its/ {sub(/\"$/, \" file://socfpga_agilex_socdk.dts.patch\\\"\")} 1' $FILENAME &gt; temp &amp;&amp; mv temp $FILENAME\n#Installing u-dma-buf driver\ncd $TOP_FOLDER/gsrd-socfpga/\ndevtool create-workspace buff\ndevtool add https://github.com/ikwzm/udmabuf\nbitbake-layers create-layer $WORKSPACE/meta-bridges\nbitbake-layers add-layer $WORKSPACE/meta-bridges\ndevtool finish udmabuf  $WORKSPACE/meta-bridges\necho 'CORE_IMAGE_EXTRA_INSTALL+=\"udmabuf\"' &gt;&gt; $WORKSPACE/agilex7_dk_si_agf014eb-gsrd-rootfs/conf/local.conf\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#setting-propper-fpga2soc-permissions-in-u-boot","title":"Setting propper fpga2soc permissions in U-Boot","text":"<p>For this exercise it is required to allow only secure transactions through the fpga-to-hps bridge. This is done by default because U-Boot doesn't modifies the soc_noc_fw_mpfe_csr_inst_0_mpfe_scr register (0xF8020018) in the SDRAML3Interconnect firewall. U-Boot performs some firewall configuration using the settings defined in the soc_noc_fw_mpfe_csr_inst_0_mpfe_scr node in the arch/arm/dts/socfpga_agilex-u-boot.dtsi device tree. Please note that there is not any configuration defined for the offset 0x18, so it means that this register keeps the default configuration having the fpga2soc bit with a value of 0 indicating that only secure transactions are allowed).</p> <p>Note: In previous releases, there was a patch at <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/0001-HSD-14015655818-arm-dts-soc64-agilex-Enable-F2SDRAM-.patch</code> that actually modifies the defualt configuration of this register, but in this release this patch is not longer used.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#configuring-u-boot-script","title":"Configuring U-Boot script","text":"<p>To reserve the 1 GB memory for the buffers in the static region it is necessary to moify the Linux command line to add the mem=1G. The Linux command line is defined through the U-Boot boot script located at <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/uboot.txt</code>. In this file we require to modify the bootargs environment variable. This is done through the following command:</p> <pre><code># Update u-boot script to reserve 1GB for the application\ncd $TOP_FOLDER/gsrd-socfpga/\nOLD_BOOTARGS=\"rootwait\"\nNEW_BOOTARGS=\"rootwait mem=1G\"\nsed  -i \"s/$OLD_BOOTARGS/$NEW_BOOTARGS/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/uboot.txt\nsed -i \"s/$(echo -ne '\\u200b')//g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/uboot.txt  </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#copy-test-application-to-linux-file-system","title":"Copy Test Application to Linux File System","text":"<p>To exercise this application, you need to have the dmaTest_cache_v2.0.run  test script provided in this example in the Linux file system. For this, you need to perform the following:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga/\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/f-series/soc/setup-use-bridges/collateral/dmaTest_cache_v2.0.run\nmv dmaTest_cache_v2.0.run meta-intel-fpga-refdes/recipes-gsrd/socfpga-gsrd-apps/files/\n# Adding this to the list of files to be copied to the file system\nsed -i '/file:\\/\\/README_agilex5/a\\\\t\\tfile:\\/\\/dmaTest_cache_v2.0.run\\\\'  meta-intel-fpga-refdes/recipes-gsrd/socfpga-gsrd-apps/socfpga-gsrd-apps_1.0.bb\nsed -i '/intelFPGA\\/syschk/a\\\\tinstall -m 0755 \\${WORKDIR}\\/sources-unpack\\/dmaTest_cache_v2.0.run \\${D}\\/home\\/root\\/'  meta-intel-fpga-refdes/recipes-gsrd/socfpga-gsrd-apps/socfpga-gsrd-apps_1.0.bb\nsed -i '/FILES:\\${PN} =/a\\\\t\\t   \\/home\\/root\\/dmaTest_cache_v2.0.run \\\\' meta-intel-fpga-refdes/recipes-gsrd/socfpga-gsrd-apps/socfpga-gsrd-apps_1.0.bb\n# Remove QA check for the new file INSANE_SKIP\nsed -i '/INSANE_SKIP:\\${PN} =/aINSANE_SKIP:\\${PN} \\+= \" file-rdeps\"'  meta-intel-fpga-refdes/recipes-gsrd/socfpga-gsrd-apps/socfpga-gsrd-apps_1.0.bb\nsed -i '/INSANE_SKIP:\\${PN}-dev =/aINSANE_SKIP:\\${PN} \\+= \" file-rdeps\"'  meta-intel-fpga-refdes/recipes-gsrd/socfpga-gsrd-apps/socfpga-gsrd-apps_1.0.bb\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#build-yocto","title":"Build Yocto","text":"<p>Now that we are setup we have to execute the following command to start building:</p> <pre><code># Build Yocto\ncd $WORKSPACE\nbitbake_image\npackage\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li>agilex7_dk_si_agf014eb-gsrd-rootfs: area used by OpenEmbedded build system for builds. Description of build directory structure https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li>agilex7_dk_si_agf014eb-gsrd-images: the build script copies here relevant files built by Yocto from the agilex7_dk_si_agf014ea-gsrd-rootfs/tmp/deploy/images/agilex7_dk_si_agf014ea folder, but also other relevant files.</li> </ul> <p>For this example, the two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014ea-gsrd-images</code> folder are:</p> <ul> <li>u-boot-agilex-socdk-gsrd-atf/u-boot-spl-dtb.hex: U-Boot SPL Hex file</li> <li>gsrd-console-image-agilex7.wic: SD Card image</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#building-qspi-flash-image","title":"Building QSPI Flash Image","text":"<p>The QSPI image will contain the SDM firmware, the 1st phase of FPGA configuration data and the HPS FSBL. This is built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex7f-ed-gsrd/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#running-the-example","title":"Running the Example","text":"<p>In order to excercise this example you will need to program the binaries that you built in the previous seccion:</p> <ul> <li>SD Card: <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014ea-gsrd-images/gsrd-console-image-agilex7.wic</code></li> <li>QSPI: <code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic</code></li> </ul> <p>When using the above SD Card image, this already includes the dmaTest_cache_v2.0.run  application that is used to exercise this example. This is a bash script is located at the /home/root/ directoy in Linux which is running in the development kit. </p> <p>Note: Make sure that the variables in the script used to define the addresses for the configuration registers for the Cache Coherency Translator and Modular Scatter-Gather DMA components match the ones set in the GHRD.</p> <p>The addresses set in the GHRD are defined at the lwsoc2fpga bridge with a base address of 0xF9000000:</p> <p></p> <p>These variables are defined in the script as:</p> <pre><code>#Bridges pointers\nicct_csr=0xf9000010\nmsgdma_csr=0xf9000040\nmsgdma_descriptorslave=0xf9000020\nmsgda_response=0xf9000008\n</code></pre> <p>To execute the sample test script:</p> <ol> <li>Power cycle the board to boot to Linux.</li> <li>Identify the dmaTest_cache_v2.0.run test script in your <code>/home/root</code> directory. </li> <li> <p>You can see how to exercise the script by using the -h switch:   <pre><code>root@agilex:~# bash dmaTest_cache_v2.0.run -h\nUsage: dmaTest_cache_v2.0.run options\n              Options:\n                      --help, -h\n                      --privilaged-only, -p\n                      --privilaged-secure, -s\n                      --ccu-uncached, -u\n                      --ccu-cached, -c\n</code></pre>   From this menu, each one of the options executes each one of the 4 tests described earlier in the Testing of the Project section.</p> Option Test Description -p Test 1 Direct to SDRAM. AXI attributes: Privileged, Non-Cached and Non-Secure access. -s Test 2 Direct to SDRAM. AXI attributes: Privileged, Non-Cached and Secure access. -u Test 3 Through CCU. AXI attributes: Privileged, Non-Cached and Secure access. -c Test 4 Through CCU. AXI attributes: Privileged, Cached and Secure access. </li> </ol> <p>The following capture is an example of executing the Test 3.</p> <p>In this test you can see that the read buffer is being written with a 0xAAAAxxxx pattern of 128 words (512 bytes). Then the Cache Coherency Translator is configured to send Privileged Secure Non-cached transactions (with a value of 0x20982302 in the CSR register) and the Modular Scatter-Gather DMA is being configured transfer a block of 512 bytes from the read buffer in the manual region (at address 0x41000000) to the CMA region (at address 0x10000000). You can confirm from the log that the data read from the write buffer also contains the 0xAAAAxxxx pattern indicating that the data was correctly transferred.</p> <pre><code>root@agilex7dksiagf014eb:~# ./dmaTest_cache_v2.0.run -u\nread sysID perif,  should read back 0xACD5CAFE\n/dev/mem opened.\nMemory mapped at address 0xffff8e5c5000.\nRead at address  0xF9000000 (0xffff8e5c5000): 0xACD5CAFE\nSetup AXI Security Bridge via CSR H2F_LW + 0x8\nRead ACE-LITE Bridge Mode\n/dev/mem opened.\nMemory mapped at address 0xffff88d1c000.\nRead at address  0xF9000010 (0xffff88d1c010): 0x60F82F02\n########################################\n============================================\n Test 3: CCU Non-cached Privileged Secure   \n============================================\nSetup AXI Security Bridge via CSR H2F_LW + 0x8\nSet ACE-LITE Bridge to via CCU Non-Cached Mode : 0x60F82F02\n/dev/mem opened.\nMemory mapped at address 0xffff8bdb8000.\nRead at address  0xF9000010 (0xffff8bdb8010): 0x60F82F02\nWrite at address 0xF9000010 (0xffff8bdb8010): 0x20982302, readback 0x20982302\n###################################################\nInitial setup done. Now running the test...\nRead ACE-LITE Bridge Mode\n/dev/mem opened.\nMemory mapped at address 0xffff922b8000.\nRead at address  0xF9000010 (0xffff922b8010): 0x20982302\n###################################################\nCreating populated data buffer at 0x40001000 in unused memory (above 1GB) \nCheck data by reading 1st address\n/dev/mem opened.\nMemory mapped at address 0xffff89529000.\nRead at address  0x40001000 (0xffff89529000): 0xAAAA0000\n###################################################\nCreating populated data buffer at in CMA reserved cached memory at 0x10002000 from userspace\nCheck data by reading 1st address\n/dev/mem opened.\nMemory mapped at address 0xffffbe775000.\nRead at address  0x10002000 (0xffffbe775000): 0x05050505\n###################################################\n##################################################\nFinished filling buffers with with initial data\n##################################################\nSetup DMA controller to start transfering data\nread buffer(0x40001000) -&gt; Write buffer(0x10000000)\nmsgdma : Stop dispatcher\n/dev/mem opened.\nMemory mapped at address 0xffffbcd0b000.\nRead at address  0xF9000044 (0xffffbcd0b044): 0x00000000\nWrite at address 0xF9000044 (0xffffbcd0b044): 0x00000001, readback 0x00000001\nmsgdma : Stop descriptors\n/dev/mem opened.\nMemory mapped at address 0xffff9fd64000.\nRead at address  0xF9000044 (0xffff9fd64044): 0x00000001\nWrite at address 0xF9000044 (0xffff9fd64044): 0x00000020, readback 0x00000020\nmsgdma : Reset Dispatcher\n/dev/mem opened.\nMemory mapped at address 0xffffb7832000.\nRead at address  0xF9000044 (0xffffb7832044): 0x00000020\nWrite at address 0xF9000044 (0xffffb7832044): 0x00000002, readback 0x00000002\nmsgdma : Read address,  lower 32bits, upper 32bits : 0x0000000040001000\n/dev/mem opened.\nMemory mapped at address 0xffff927d3000.\nRead at address  0xF9000020 (0xffff927d3020): 0x00000000\nWrite at address 0xF9000020 (0xffff927d3020): 0x40001000, readback 0x40001000\n/dev/mem opened.\nMemory mapped at address 0xffffbe12b000.\nRead at address  0xF9000034 (0xffffbe12b034): 0x00000000\nWrite at address 0xF9000034 (0xffffbe12b034): 0x00000000, readback 0x00000000\nmsgdma : Write address, lower 32bits, upper 32bits : 0x0000000010000000\n/dev/mem opened.\nMemory mapped at address 0xffff9ebe8000.\nRead at address  0xF9000024 (0xffff9ebe8024): 0x00000000\nWrite at address 0xF9000024 (0xffff9ebe8024): 0x10000000, readback 0x10000000\n/dev/mem opened.\nMemory mapped at address 0xffff8342c000.\nRead at address  0xF9000038 (0xffff8342c038): 0x00000000\nWrite at address 0xF9000038 (0xffff8342c038): 0x00000000, readback 0x00000000\nmsgdma : length in bytes 4068,  128bit x 32\n/dev/mem opened.\nMemory mapped at address 0xffff840ef000.\nRead at address  0xF9000028 (0xffff840ef028): 0x00000000\nWrite at address 0xF9000028 (0xffff840ef028): 0x00000200, readback 0x00000200\nmsgdma : Burst counts 32, sequence number = 1\n/dev/mem opened.\nMemory mapped at address 0xffff99381000.\nRead at address  0xF900002C (0xffff9938102c): 0x00000000\nWrite at address 0xF900002C (0xffff9938102c): 0x20200001, readback 0x20200001\nmsgdma : Check Status\n/dev/mem opened.\nMemory mapped at address 0xffffa2ada000.\nRead at address  0xF9000040 (0xffffa2ada040): 0x0000000A\nmsgdma : Control,  wait for resp\n/dev/mem opened.\nMemory mapped at address 0xffffbeb74000.\nRead at address  0xF900003C (0xffffbeb7403c): 0x00000000\nWrite at address 0xF900003C (0xffffbeb7403c): 0x02000000, readback 0x02000000\n###################################################\n###################################################\n###################################################\n###################################################\nmsgdma : Control,  wait for resp and go\n/dev/mem opened.\nMemory mapped at address 0xffffb94d4000.\nRead at address  0xF900003C (0xffffb94d403c): 0x00000000\nWrite at address 0xF900003C (0xffffb94d403c): 0x82000000, readback 0x82000000\nmsgdma : Check Status\n/dev/mem opened.\nMemory mapped at address 0xffffbea2d000.\nRead at address  0xF9000040 (0xffffbea2d040): 0x00000002\n###################################################\nReading back data from write buffer.    \nReadBack from 0x0000000010000000\n/dev/mem opened.\nMemory mapped at address 0xffff98323000.\nRead at address  0x10000000 (0xffff98323000): 0xAAAA0000\n/dev/mem opened.\nMemory mapped at address 0xffff95cb4000.\nRead at address  0x10000004 (0xffff95cb4004): 0xAAAA0004\n/dev/mem opened.\nMemory mapped at address 0xffffae5f8000.\nRead at address  0x10000008 (0xffffae5f8008): 0xAAAA0008\n/dev/mem opened.\nMemory mapped at address 0xffffab644000.\nRead at address  0x1000000C (0xffffab64400c): 0xAAAA000C\n/dev/mem opened.\nMemory mapped at address 0xffff8b494000.\nRead at address  0x10000010 (0xffff8b494010): 0xAAAA0010\n=================\n    TEST DONE    \n=================\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/setup-use-bridges/ug-setup-use-bridges-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/","title":"HPS Xen Hypervisor GSRD for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#overview","title":"Overview","text":"<p>This page presents the Xen GSRD, which is based on the Linux GSRD for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile).</p> <p>The Xen GSRD uses the SD card for storing the root filesystem.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the Xen GSRD:</p> <ul> <li>Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) ordering code DK-SI-AGF014EB</li> <li>SD/MMC HPS Daughtercard<ul> <li>SDM QSPI Bootcard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel FPGA Download Cable II</li> <li>Micro SD card (4GB or greater)</li> </ul> </li> <li>Host PC with<ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Micro SD card slot or Micro SD card writer/reader</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board)</li> </ul> </li> </ul> <p>You can determine your board version by referring to the following table from https://www.intel.com/content/www/us/en/docs/programmable/683752/current/overview.html</p> Development Kit Version Ordering Code Device Part Number Starting Serial Number Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 2 P-Tiles &amp; E-Tiles) DK-SI-AGF014EB AGFB014R24B2E2V (Power Solution 2) 00205001 Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 1 P-Tiles &amp; E-Tiles) DK-SI-AGF014EA AGFB014R24B2E2V (Power Solution 1) 0001101 Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (ES P-Tiles &amp; E-Tiles) DK-SI-AGF014E3ES AGFB014E3ES (Power Solution 1) 0001001 <p>The DK-SI-AGF014E3ES and DK-SI-AGF014EA are deprecated, and not supported anymore.</p> <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The release files are accessible at https://releases.rocketboards.org/2025.08/xen/agilex7_dk_si_agf014eb_xen/</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>:</p> File Description linux-socfpga-v6.12.19-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2025.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.12.1-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#exercise-xen-gsrd-prebuilt-binaries","title":"Exercise Xen GSRD Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the Xen GSRD, on the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit.</p> <p>Refer to the following links for additional help on getting started:</p> Link Description Board Documentation Board user guide, schematics, etc GSRD Board Setup Section Setting up the development kit GSRD Serial Console Section Setting up serial console GSRD Write SD Card Section Writing SD card image"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#write-binaries","title":"Write Binaries","text":"<p>This section shows presents downloading and flashing the SD card image and JIC files, and downloading the xen rootfs cpio archive to be used by DomUs VMs.</p> <p>1. Download and write to SD card the image https://releases.rocketboards.org/2025.08/xen/agilex7_dk_si_agf014eb_xen/sdimage.tar.gz</p> <p>2. Download and write to QSPI flash the JIC file https://releases.rocketboards.org/2025.08/xen/agilex7_dk_si_agf014eb_xen/ghrd_agfb014r24b2e2v.hps.jic.tar.gz</p> <p>3. Set MSEL to QSPI, and power cycle the board to boot to Linux.</p> <p>4. On the host computer, download the xen rootf cpio archive:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/xen/agilex7_dk_si_agf014eb_xen/xen-image-minimal-agilex7.cpio.gz\n</code></pre> <p>5. On the Linux on target board, copy over the above downloaded file in 'xen' folder:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/xen-image-minimal-agilex7.cpio.gz .\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#boot-xen-gsrd","title":"Boot Xen GSRD","text":"<p>This section shows how to boot the Xen GSRD. By default, if no other operation is done, the board boots into normal, non-Xen enabled GSRD on a power cycle. In order to boot with the Xen Hypervisor, you need to stop the U-Boot countdown, and boot Linux manually using the commands shown in the below sections. This is provided for convenience, and when used in a real production system, U-Boot can be configured to boot the required Xen configuration automatically.</p> <p></p> Boot Without Passthrough <p>1. Set MSEL to QSPI, and power cycle the board</p> <p>2. Press any key during U-Boot countdown to stop it</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nbooti 0x0a000000 - 0x08000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> Boot With Passthrough <p>The instructions are the same as without passthrough, just that the following command needs to be added befote the 'booti' command:</p> Device Passthrough Command QSPI fdt set /soc/spi@ff8d2000 xen,passthrough Ethernet fdt set /soc/ ethernet@ff800000 xen,passthrough USB fdt set /soc/usb@ffb00000 xen,passthrough SD/eMMC fdt set /soc/ ethernet@ff808000 xen,passthrough"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#manage-vms","title":"Manage VMs","text":"<p>This section shows how to use the 'xl' Xen utility to manage VMs running on DomUs. Only a few options are used, refer to 'xl' command help for more options.</p> <p>1. Boot Xen GSRD as shown above. It can be either with or without passthrough</p> <p>2. Create VM1 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_1.cfg\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex7.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>3. Start VM1:</p> <pre><code>xl create test_vm_1.cfg\n</code></pre> <p>4. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>5. Connect to VM1 console:</p> <pre><code>xl console DomU1\n</code></pre> <p>6. Run some commands in VM1:</p> <pre><code>pwd\nls -la\n</code></pre> <p>7. Exit from VM1 console by pressing CTRL + ]. Note this works only from serial console, and not over SSH connection.</p> <p>8. Create VM2 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_2.cfg\n# Guest name\nname = \"DomU2\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex7.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>9. Start VM2:</p> <pre><code>xl create test_vm_2.cfg\n</code></pre> <p>10. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>11. Shutdown VM1:</p> <pre><code>xl shutdown DomU1\n</code></pre> <p>The above command politely asks DomU1 to shut down by using the ACPI shutdown signal and letting the OS shut down.</p> <p>Alternatively, when needed, you can also use 'destroy' commands which acts as a hard power cycle:</p> <pre><code>xl destroy DomU1\n</code></pre> <p>12. List VMs again, it will not show VM1 anymore</p> <pre><code>xl list\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#qspi-passthrough","title":"QSPI Passthrough","text":"<p>This section shows an example of how to assign the QSPI IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p></p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc/spi@ff8d2000 xen,passthrough\nbooti 0x0a000000 - 0x08000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Go to xen folder and look at the provided QSPI passthrough files (dtb file and VM configuration file):</p> <pre><code>root@agilex7dksiagf014eb:~/# cd xen\nroot@agilex7dksiagf014eb:~/xen# ls *spi*\nspi@ff8d2000.cfg  spi@ff8d2000.dtb\nroot@agilex7dksiagf014eb:~/xen# cat spi@ff8d2000.cfg\n# SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"/home/root/xen/xen-image-minimal-agilex7.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\n# Optional incase any passthrough or share mem\ndevice_tree = \"spi@ff8d2000.dtb\"\niomem = [ \"0xff8d2,1\", \"0xff900,100\" ]\nirqs = [ 35 ]\n</code></pre> <p>7. Start the VM, and connect to its console</p> <pre><code>xl create spi@ff8d2000.cfg\nxl console DomU1\n</code></pre> <p>8. In the VM console, login with 'root' account, then run a couple of commands to see QSPI is enabled:</p> <pre><code>root@agilex7dksiagf014eb:~# cat /proc/mtd dev:    size   erasesize  name\nmtd0: 04200000 00010000 \"u-boot\"\nmtd1: 0be00000 00010000 \"root\"\nroot@agilex7dksiagf014eb:~# mtdinfo       Count of MTD devices:           2\nPresent MTD devices:            mtd0, mtd1\nSysfs interface supported:      yes\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#rebuild-xen-gsrd","title":"Rebuild Xen GSRD","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p>The instructions are the same as for the GSRD, except that the environment variable BUILD_HYP=1 needs to be set for building the Xen enabled GSRD version. This environment variable is only used by the Yocto GSRD script.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd.xen\nmkdir agilex7f_gsrd.xen\ncd agilex7f_gsrd.xen\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b walnascar https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\nexport HYP_BUILD=1\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf</li> <li>agilex7_dk_si_agf014eb_nand_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona0.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona1.rbf: not applicable</li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n file://agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=xxxxxxxxx \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the file:</p> <pre><code>SRC_URI[agilex7_dk_si_agf014eb_gsrd_core.sha256sum] = \"5d633ee561d5cc8c22b51211a144654fdc0be47ee14b07ac134074cbff84eb8b\"\n</code></pre> <p>by using the following commands:</p> <pre><code>sed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014eb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014eb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-agilex-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#create-qspi-image","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/xen/ug-xen-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/","title":"Agilex 7 R-Tile AVST PCIe Configuration Intercept Interface (CII) example design","text":""},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#10-about-this-document","title":"1.0 About This Document","text":"<p>This document provides information about the R-Tile AVST PCIe CII interface using an example RTL module that adds the VPD capability in the user logic, running the example design on Agilex 7 I-Series FPGA Development Kit board, and view the result. </p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#20-intended-audience","title":"2.0 Intended Audience","text":"<p>This document is intended for FPGA and system developers to use as a guide for evaluating the R-Tile AVST PCIe IP and CII interface on Agilex 7 I-Series FPGA Development Kit board (Ordering Code: DK-DEV-AGI027-RA, Production Kit)</p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#table-1-terms-and-acronyms","title":"Table 1: Terms and Acronyms","text":"Terms Description AVST Avalon Streaming CfgWr Configuration Write request. A type of PCIe Transaction Layer Packet (TLP) that the host system generates to write data into the configuration space registers of a PCIe device. CfgRd Configuration Read request. A type of PCIe TLP that the host system generates to read data from the configuration space registers of a PCIe device. CfgRd Completion Configuration Read Completion. A type of PCIe TLP that the PCIe device generates in response to a Configuration Read (CfgRd) request from the host. It contains the requested data from the device's configuration space registers. Configuration Space Header The first 64 bytes of a Function's Configuration Space (Offset 00h - 3Fh). Capabilities Pointer register (Offset 34h) gives location of first register block in the linked list of Capability Structures in PCI-Compatible Configuration Space. Linked list of Capabilities PCIe Configuration Space Capabilities are linked together as a linked list. This is referred to as a capability chain in this document PCI-Compatible Configuration Space The first 256 bytes of a Function's Configuration Space (Offset 00h ~ FFh). PCI-Compatible Capability registers are located in this space. E.g., Power Management (ID: 01h), Vital Product Data (ID: 03h), PCI Express (ID: 10h) PCI Express Extended Configuration Space Configuration Space at offset 256 or greater (Offset 100h ~ FFFh). PCI Express Extended Capability registers are located in this space. E.g., Advance Error Reporting (AER) Capability (ID: 001h). VPD Vital Product Data Capability register. Includes information that uniquely identifies hardware and , potentially, software elements of a system."},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#21-related-information","title":"2.1 Related Information","text":"<ul> <li>FPGA R-Tile Avalon \u00ae Streaming (Avalon-ST) IP for PCI Express User Guide</li> <li>FPGA R-Tile Avalon \u00ae Streaming (Avalon-ST) IP for PCI Express Design Example User Guide</li> <li>Agilex \u00ae 7 FPGA I-Series Development Kit (2x R-Tiles + 1x F-Tile)</li> <li>Quartus Prime Pro Signal Tap Logic Analyzer Tool</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#30-overview","title":"3.0 Overview","text":"<p>Agilex 7 R-Tile AVST PCIe CII interface allows the application logic to detect the occurrence of a Configuration (CFG) request from the host and modify its behavior. The application logic can use the CII to :</p> <ul> <li>Delay the processing of a CFG request by the controller. This allows the application to perform any housekeeping task first.</li> <li>Overwrite the data payload of a CfgWr request</li> <li>Overwrite the data payload of a CfgRd Completion</li> </ul> <p>This example design demonstrates a CII use case where a PCIe capability structure is added to the PCIe IP example design capability chain. It shows how you can modify the PCIe capability chain through the CII. </p> <p>Below is the block diagram.</p> <p></p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#40-dut-interface-signal-description","title":"4.0 DUT Interface / Signal Description","text":"<p>The following tables describe the dut interface/signals. </p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#table-2-clocks","title":"Table 2: Clocks","text":"Interface / Signal Description refclk0, refclk1 100MHz reference clocks for the PCIe IP core. coreclkout_hip This clock drives the IP core data link / transaction layers and application layer. slow_clk Clock for sideband interface (e.g., CII). Divide-by-2 or divide-by-4 clock derived from coreclkout_hip. <p>For more info, refer to the IP User Guide. *  [Clocks] (https://www.intel.com/content/www/us/en/docs/programmable/683501/24-3/clocks.html)</p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#table-3-resets","title":"Table 3: Resets","text":"Interface / Signal Description pin_perst_n Active low PCIe reset from the board (PERST#). p0_reset_status_n Active low reset status synchronized to coreclkout_hip. p0_slow_reset_status_n Active low reset status synchronized to slow_clk. ninit_done Active low signal indicating the FPGA device has been configured and is in normal operating mode."},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#table-4-cii-interface","title":"Table 4: CII Interface","text":"Interface / Signal Description p0_cii Configuration Intercept Interface. <p>For more info, refer to the IP User Guide.</p> <ul> <li>[CII Interface] (https://www.intel.com/content/www/us/en/docs/programmable/683501/24-3/configuration-intercept-interface.html)</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#table-5-avalon-streaming-tx-interface","title":"Table 5: Avalon Streaming TX Interface","text":"Interface / Signal Description p0_tx_st* Avalon Streaming TX Interface and TX Flow Control Interface. <p>For more info, refer to the IP User Guide.</p> <ul> <li>[Streaming TX Interface] (https://www.intel.com/content/www/us/en/docs/programmable/683501/24-3/streaming-tx-interface.html)</li> <li>[Streaming TX Flow Control Interface] (https://www.intel.com/content/www/us/en/docs/programmable/683501/24-3/tx-flow-control-interface.html)</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#table-6-avalon-streaming-rx-interface","title":"Table 6: Avalon Streaming RX Interface","text":"Interface / Signal Description p0_rx_st* Avalon Streaming RX Interface and RX Flow Control Interface. <p>For more info, refer to the IP User Guide.</p> <ul> <li>[Streaming RX Interface] (https://www.intel.com/content/www/us/en/docs/programmable/683501/24-3/streaming-rx-interface.html)</li> <li>[Streaming RX Flow Control Interface] (https://www.intel.com/content/www/us/en/docs/programmable/683501/24-3/rx-flow-control-interface.html)</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#table-7-serial-data-interface","title":"Table 7: Serial Data Interface","text":"Interface / Signal Description hip_serial Hard IP transmit and receive serial data interface. <p>For more info, refer to the IP User Guide. * [Serial Data Interafce] (https://www.intel.com/content/www/us/en/docs/programmable/683501/24-3/serial-data-interface.html)</p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#50-description","title":"5.0 Description","text":"<p>Below is the PCIe IP example design Capability chain before adding the VPD. </p> Config Offset Description Capability ID Nex Cap. Pointer Notes 0x34 Capabilities Pointer n/a 0x40 PCIe IP \\n Points to start of the Capability chain (Offset 0x40) - Power Management Capability 0x40 Power Management 0x01 0x70 PCIe IP 0x70 PCI Express 0x10 0x00 PCIe IP \\n End of Capability chain <p>In order to add the VPD Capability register shown below:</p> <p></p> <ol> <li>After reset, the CII module asserts cii_halt to 1.</li> <li>The PCIe IP intercepts the CFG requests and asserts cii_req along with other CII output signals</li> <li>On every CFG request (cii_req = 1), the CII module deasserts cii_halt for 1 clock cycle, allowing the request to completed.     With the cii_halt deasserted:<ul> <li>If the CFG write (cii_wr = 1) data needs to be overwritten, assert cii_override_en and provide write data via cii_override_din[31:0]</li> <li>If the CFG read (cii_wr = 0) data needs to be overwritten, assert cii_override_en and provide read data via cii_override_din[31:0] </li> </ul> </li> <li>The CII module monitors the cii_addr[9:0] and overwrites the read data as follows:<ul> <li>cii_addr == 0x00d (Offset 0x34); cii_override_din = 0x0060</li> <li>cii_addr == 0x018 (Offset 0x60); cii_override_din = 0x4003</li> </ul> </li> </ol> <p>For more details, refer to the rtl/cii.v. </p> <p>Below is the PCIe IP example design Capability register chain with the VPD.</p> Config Offset Description Capability ID Nex Cap. Pointer Notes 0x34 Capabilities Pointer n/a 0x60 PCIe IP \\n Points to start of Capability chain (0x60) - Vital Product Data Capability implemented in user application 0x60 Vital Product Data 0x03 0x40 User Application \\n Added through the CII 0x40 Power Management 0x01 0x70 PCIe IP 0x70 PCI Express 0x10 0x00 PCIe IP \\n End of Capability chain"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#60-pcie-ip-cii-parameter-setting","title":"6.0 PCIe IP CII Parameter Setting","text":"<ol> <li> <p>Check Enable Configuration Interface Intercept option     </p> </li> <li> <p>Set CII Range 0 Parameters</p> <ul> <li>Enable Range 0 CII: 1</li> <li>Range 0 Start Address: 0x00000000</li> <li>Range 0 Address Size: 0x00000ff</li> </ul> </li> </ol>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#70-project-details","title":"7.0 Project Details","text":"<ul> <li>Family: Agilex 7</li> <li>Quartus Version: Quartus Prime Pro Software v. 24.3.0</li> <li>Development Kit: Agilex 7 FPGA I-Series Development Kit, Ordering Code: DK-DEV-AGI027-RA (Production Kit)</li> <li>Device Part: AGIB027R29A1E1VB</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#80-getting-started","title":"8.0 Getting Started","text":""},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#81-required-components-for-hardware-testing","title":"8.1 Required Components for Hardware Testing","text":"<ul> <li>FPGA Board.<ul> <li>Agilex\u2122 7 FPGA I-Series Development Kit, DK-DEV-AGI027-RA (Production Kit)</li> </ul> </li> <li>Tools and software<ul> <li>Quartus \u00aePrime Pro Software</li> </ul> </li> </ul> <p>Below are the steps to compile the example design, test on hardware and view the result. </p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#82-compilation-steps","title":"8.2 Compilation Steps","text":"<ol> <li>Open the Quartus project file (.qpf) in Quartus \u00aePrime Pro Software    Click File &gt; Open Project, and select pcie_ed.qpf. </li> <li>Click Processing &gt; Start Compilation </li> </ol>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#83-hardware-testing-steps","title":"8.3 Hardware Testing Steps","text":"<p>The following instruction shows the steps to run the example design on Agilex 7 FPGA I-Seris Development Kit. </p> <ol> <li> <p>Install Agilex 7 FPGA I-Series Development Kit on a host machine PCIe x16 slot</p> </li> <li> <p>Connect the micro-USB programming cable to J8. See below for J8 location. </p> <p>Board Overview</p> </li> <li> <p>Apply power to the Development Kit. See below for details. </p> <p>Applying Power to the Development Board</p> </li> <li> <p>Download the bitstream (pcie_ed.sof). See below for details.</p> <p>FPGA Configuration</p> </li> <li> <p>Reboot the host machine</p> </li> <li> <p>On the host machine, run lspci command: sudo lspci -d 1172: -v</p> </li> </ol>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#84-viewing-results","title":"8.4 Viewing Results","text":"<p>Verify that the VPD is shown in the lspci command output. </p>"},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#841-pcie-ip-example-design-capability-list-before-adding-the-vpd","title":"8.4.1 PCIe IP Example Design Capability List: before adding the VPD","text":""},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#842-pcie-ip-example-design-capability-list-after-adding-the-vpd","title":"8.4.2 PCIe IP Example Design Capability List: after adding the VPD","text":""},{"location":"embedded-designs/agilex-7/i-series/avst_cii/agilex7-ed-pcie-cii/#signal-tap-logic-analyzer-capture","title":"Signal Tap Logic Analyzer Capture","text":"<p>If you want to observe the CII interface signals in Signal Tap, use the Signal Tap Logic Analyzer file (stp1.stp) provided in the project. Below is the screenshot of the Signal Tap capture. </p> <p>For info on Quartus Prime Pro Signal Tap Logic Analyzer, refer to the link provided in Related Information section.  </p>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/","title":"HPS PCIe Root Port System Example Design for the Agilex\u2122 7 I-Series Transceiver-SoC Development Kit","text":""},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#introduction","title":"Introduction","text":"<p>This page demonstrate PCIe root port design example running on Agilex\u2122 7 I-Series Transceiver-SoC Development Kit with an end point.</p>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#release-content","title":"Release Content","text":"<p>Release note and pre-build binaries can be found in the GitHub repository</p> <p>The pre-build binaries Agilex-7_I-series_artifacts.zip contain the files below.</p> <ul> <li>ghrd.core.rbf</li> <li>ghrd.hps.rbf</li> <li>Image.lzma</li> <li>kernal.itb</li> <li>sdimage.tar.gz</li> <li>socfpga_agilex7_socdk.dtb</li> <li>u-boot.itb</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#system-example-design-overview","title":"System Example Design Overview","text":"<p>This design is based on the Agilex 7 SoC Development Golden Hardware Reference Design (GHRD) which is part of the Golden System Reference Design (GSRD). This design demonstrate the Root port capability, configures the PCIe Subsystem to work in Root port mode and use MCDMA Bridge logic that converts the incoming TLPs from PCIe Subsystem into Memory mapped interface.</p> <p></p> <p>The block diagram show 3 paths between HPS and PCIe subsystem(PCIe HIP + AVMM bridge).</p> <ul> <li>F2H AXI4 (burst enabled)/ACELite interface for data transfers from PCIe EP.</li> <li>H2F AXI4 (burst enabled) interface is used for PCIe EP downstream application configuration space as well as any higher data rate transfers initiated by HPS depending on the application. And also, for PCIe EP configuration address space access.</li> <li>H2F Light weight AXI-4 interface is used for CSR to different block in the design.</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#helpful-reference-documentation","title":"Helpful Reference Documentation","text":"<ul> <li>Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit User Guide</li> <li>Multi Channel DMA for PCI Express IP User Guide</li> <li>Altera SoC FPGA Golden Software Reference Design (GSRD)</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#hardware-description","title":"Hardware Description","text":""},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#memory-map","title":"Memory Map","text":""},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#hps-h2f-memory-map","title":"HPS H2F Memory Map","text":"Address Offset Size (Bytes) Peripheral Remarks 0x8000_0000 256K On Chip Memory Block memory implemented in the FPGA fabric 0x9000_0000 256M BAS Avalon MM Slave of AVMM Bridge\u2019s BAS port 0xA000_0000 2M PCIe SS AXI-Lite interface AXI-Lite of PCIe SS"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#hps-lwh2f-memory-map","title":"HPS LWH2F Memory Map","text":"Address Offset Size (Bytes) Peripheral Remarks 0xF900_0000 8 System ID Hardware configuration system ID 0xF900_0200 16 CCT Cache Coherent Translator 0xF901_0000 16k PCIe CS Avalon MM Slave of PCIe Configuration Slave port (14b address space) 0xF901_8000 128 MSI-to-GIC Vector 0xF901_8080 16 MSI-to-GIC CSR Avalon MM Slave of MSI-to-GIC CSR port 0xF901_80A0 32 Performance Counter Hardware timer for benchmarking purposes 0xF901_80C0 1K AVMM CS Cpl TimeOut &amp; System level Reg. map\u202f Error registers along with Timeout values"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#pcie-bam-interface","title":"PCIe BAM interface","text":"Address Offset Size (Bytes) Peripheral Remarks 0xF901_8000 128 MSI-to-GIC Vector MSI/MSI-X Transactions from PCIe Endpoint. These should be aligned addresses to avoid any re-alignment on BAM AVMM interface. 0x0000_0000 to 0x7FFF_FFFF 2G HPS F2H \u202fHPS FPGA to HPS interface (SDRAM access) 0x10_8000_0000 to 0x11_FFFF_FFFF 6G HPS F2H \u202fHPS FPGA to HPS interface (SDRAM access) -Expanded memory range. Actual allocation is 8G (0x10_0000_0000 to 0x11_FFFF_FFFF) to match the 2 power of &lt;Num of bits)."},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#memory-range-support-expansion","title":"Memory Range Support Expansion","text":"<p>HPS support additional memory for F2H interface. For this example design, memory range support start from initial 2GB at the address offset of 0x8000_0000 and additional 6G memory at address offset of 0x08_8000_0000 to 0x09_FFFF_FFFF. BAM to HPS F2H have multiple path with different Address Expander range as shown in the block diagram.</p> Memory Range Address Base 2GB 0x8000_0000 to 0xFFFF_FFFF Additional 30GB 0x08_8000_0000 to 0x0F_FFFF_FFFF"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#setup-configuration","title":"Setup Configuration","text":"<p>This design tested with the following setup:</p> <ul> <li>Agilex 7 I-Series Premium Development Kit (DK-SI-AGI027FB)</li> <li>PCIe FMC+ Hitech Daughter Card</li> <li>MCIO to U.2/NVME cable</li> </ul> <ul> <li>Tested End Point:<ul> <li>PCI Express NVMe Gen4 SSD (Samsung 980 PRO PCIe 4.0 NVMe)</li> <li>PCI Express Network Interface Card (Intel I350/I210)</li> </ul> </li> </ul> <ul> <li>Tools and software:<ul> <li>System with supported Linux distribution with Ubuntu 22.04 (LTS)</li> <li>Altera\u00ae Quartus \u00aePrime Design Suite software 25.1.1 version</li> <li>Serial terminal application such as Putty</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#board-setup","title":"Board Setup","text":""},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#configuring-board","title":"Configuring board","text":"<p>Configuration switches on the board are as below:</p> Switch Position S19 [1:4] OFF/OFF/ON/ON S20 [1:4] ON/ON/ON/ON S9 [1:4] ON/ON/ON/X S10 [1:4] ON/ON/ON/ON S15 [1:4] ON/ON/ON/OFF S1 [1:4] OFF/OFF/OFF/OFF S6 [1:4] OFF/OFF/OFF/OFF S22 [1:4] ON/ON/ON/ON S23 [1:4] ON/ON/ON/ON S4 [1:4] ON/ON/ON/ON"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#building-the-pcie-root-port-design","title":"Building the PCIe Root Port Design","text":"<p>Here are the steps to build either HW and SW files:</p> <ul> <li>HW_Readme</li> <li>SW_Readme</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#setting-up-the-environment","title":"Setting up the environment","text":"<pre><code>git clone https://github.com/altera-fpga/agilex7-ed-pcie-rp.git\ncd agilex7-ed-pcie-rp/src/\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#building-the-hardware-files","title":"Building the Hardware Files","text":"<p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>Building the Hardware files:</p> <pre><code>cd hw/ag7i027_devkit/syn/\nmake all\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#building-the-software-files","title":"Building the Software Files","text":"<p>Building the Software files:</p> <pre><code>cd $TOP_FOLDER/sw\n. agilex7_dk_si_agi027fc-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Perform Yocto bitbake to generate binaries:</p> <pre><code>bitbake_image\n</code></pre> <p>Package binaries into build folder:</p> <pre><code>package\n</code></pre> <p>Generate the Programming file</p> <pre><code>cd $TOP_FOLDER\ncd hw/ag7i027_devkit/syn/\nquartus_pfg -c -o hps=on -o hps_path=u-boot-spl-dtb.hex output_files/ghrd_agib027r31b1e1vaa.sof output_files/ghrd_agib027r31b1e1vaa.rbf\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#adding-pcie-root-port-in-dts","title":"Adding PCIe root port in dts","text":"<p>Refer to socfpga_agilex_pcie_root_port.dtsi for adding PCIe Root Port bindings to your custom DTS.</p>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#running-the-system-example-design","title":"Running the System Example Design","text":"<p>1. Download SD card image from the prebuilt binaries Agilex-7_I-series_artifacts.zip and extract the archive, obtaining the file <code>gsrd-console-image-agilex7.wic</code>.</p> <p>2. Write the gsrd-console-image-agilex7.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next:</li> </ul> <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex7.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre> <ul> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. For this, first rename the gsrd-console-image-agilex7.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p></p> <p>Program the development kit with hps.rbf file.</p> <pre><code>quartus_pgm -c 1 -m jtag -o p;ghrd.hps.rbf@1\n</code></pre> <p>Open the Putty serial terminal, it will show the board boot-up process.</p> <p>Execute the <code>lspci</code> command to display information about all PCI devices on the system</p> <pre><code>        root@agilex7dksiagi027fc:~# lspci\n</code></pre> <p>There you will see both PCIe devices Rootport(00:00.0) &amp; End Point(01:00.0)</p> <p>Run the following command to retrieve detailed information about the PCIe Root Port: <pre><code>        lspci -vvv\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#fio-transactions","title":"fio transactions","text":"<p>Recommended command to perform write transactions on an NVMe SSD:</p> <pre><code>        fio --filename=/dev/nvme0n1 --rw=write --gtod_reduce=1 --blocksize=64k --size=2G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs=num_of_job\n</code></pre> <p>Recommended command to perform read transactions on an NVMe SSD:</p> <pre><code>        fio --filename=/dev/nvme0n1 --rw=read --gtod_reduce=1 --blocksize=64k --size=2G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs=num_of_job\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#note","title":"Note","text":"<pre><code>    You could change the parameters ==--size=**xG**== with 2G or 8G, ==--rw=**x**== with write or read, ==--numjobs=**x**== with values 4, 8, 16 or 20, i.e.:\n\n* fio --filename=/dev/nvme0n1 --rw= ==**write**== --gtod_reduce=1 --blocksize=64k --size= ==**2G**== --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs= ==**4**==\n* fio --filename=/dev/nvme0n1 --rw= ==**read**== --gtod_reduce=1 --blocksize=64k --size= ==**2G**== --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs= ==**8**==\n* fio --filename=/dev/nvme0n1 --rw= ==**write**== --gtod_reduce=1 --blocksize=64k --size= ==**8G**== --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs= ==**16**==\n* fio --filename=/dev/nvme0n1 --rw= ==**read**== --gtod_reduce=1 --blocksize=64k --size= ==**8G**== --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs= ==**20**==\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/pcie-rp/ug-pcie_rp-agx7-i-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \u00a9 Altera Corporation. Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation. Other names and brands may be claimed as the property of others.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/","title":"Multi-Channel 25GbE Precision Time Protocol System Example Design","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#introduction","title":"Introduction","text":"<p>The Precision Time Protocol (PTP) synchronizes clocks across networked devices to maintain a unified and precise time reference. In systems where components must coordinate actions \u2014such as logging, data exchange, or event triggering\u2014 PTP ensures consistent timing, enabling deterministic operations and improving overall system integrity.</p> <p>Agilex\u2122 7 I-Series is designed to operate as a PTP network node configured as an Ordinary Clock, Boundary Clock or Transparent Clock, as defined by IEEE 1588-2008 - Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems.</p> <p>The details of Precision Time Protocol are beyond the scope of this document.  For comprehensive information, refer to the 1588-2008 - IEEE Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#system-example-design-overview","title":"System Example Design Overview","text":"<p>The Multi-Channel 25GbE Precision Time Protocol System Example Design includes two Ethernet ports with built-in 2-step hardware PTP timestamping capabilities. The integrated Agilex\u2122 7 Hard Processor System (HPS) operates a PTP software stack that complements the hardware-based timestamping functionality.</p> <p>The System Example Design (SED) provides the necessary drivers and user applications to support the Linux Network stack, the Linux PTP stack, and network Quality of Service (QoS) through the Linux kernel Traffic Control (TC) system. T-BC and T-TSC conformance test reports are available with the SED binaries.</p> <p>The system's primary components include:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>User Space Applications</li> </ul> </li> </ul> <p>The high-level hardware setup for the system example design is shown below:</p> <p></p> <p>Figure 1. Multi-channel 25GbE Precision Time Protocol system example design hardware setup</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#glossary","title":"Glossary","text":"Acronym Full Form PTP Precision Time Protocol SED System Example Design ToD Time of Day mSGDMA Modular Scatter-Gather DMA QoS Quality of Service AVST Avalon Streaming AXI Advanced eXtensible Interface CDC Clock Domain Crossing ETS Egress Timestamp ITS Ingress Timestamp TS Timestamp FP Fingerprint NVM Non Volatile Memory GHRD Golden Hardware Reference Design GSRD Golden Software Reference Design"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#prerequisites","title":"Prerequisites","text":"<p>This system example design builds upon the Golden System Reference Design (GSRD) for the Agilex\u2122 7 I-Series Transceiver-SoC Development Kit (4x F-Tile). It is recommended to familiarize yourself with the GSRD development flow before proceeding with this document.</p> <p>The following items are required to fully exercise the SED:</p> <ul> <li>Agilex\u2122 I-Series Transceiver-SoC Development Kit (4x F-Tile) (DK-SI-AGI027FC) x 2.<ul> <li>HPS IO48 OOBE daughter card x 2.</li> <li>Micro USB cable for serial output x 2.</li> <li>USB Type B cable for on-board FPGA Download Cable II x 2.</li> <li>Micro SD card (4GB or greater) x 2.</li> <li>Mini USB cable for OOBE daughter card serial port x 2.</li> <li>100G QSFP Cable. Design tested with:<ul> <li>FS (Q28-AO05) - 5m (16ft) 100G QSFP28 Active Optical Cable.</li> <li>FS (Q28-PC01) - 1m (3ft) 100G QSFP28 Passive Direct Attach Copper Twinax Cable</li> </ul> </li> </ul> </li> <li>Host PC with:<ul> <li>OS Ubuntu 22.04 LTS. System example design source files were compiled using Ubuntu 22.04 LTS. Other versions and distributions may also be compatible.</li> <li>Serial terminal software (e.g., Minicom on Linux, Tera Term or PuTTY on Windows) is required.</li> <li>Micro SD card slot or Micro SD card writer/reader</li> <li>Altera Quartus Prime Pro 25.1.1</li> </ul> </li> </ul> <p>U-Boot and Linux compilation, Yocto build, and SD card image creation require a Linux host PC. All other operations can be performed on either Windows or Linux.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#binaries","title":"Binaries","text":"<p>Release notes and pre-built binaries are available under the GitHub repository release.</p> File Description calnex_conformance_test_report_f-tile_25g.zip T-BC and T-TSC conformance test reports images.zip Pre-compiled bitstream files for system example design devices. sdimage.tar.gz SD binary image containing Linux boot files. Source code (zip) System example design source files provided as a ZIP archive Source code (tar.gz) System example design source files provided as a TAR GZ archive"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#sources","title":"Sources","text":"Component Location Branch Commit ID/Tag GHRD https://github.com/altera-fpga/agilex7-ed-ptp-mcqos-25g/tree/main/agi027fc-si-devkit/src/hw SED-2x25GE-1588PTP-MCQOS-agi027fc-si-devkit-Q25.1.1-Rel-1.1 Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts-ethernet-sed SED-2x25GE-1588PTP-MCQOS-agi027fc-si-devkit-Q25.1.1-Rel-1.1 Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.11.0 9aee18305b73651b74301483510c29fef9ce23ce U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2024.04 135e53726d3dfbe55b4d61c2bf3fdf32cdc372e5 Yocto Project: poky https://git.yoctoproject.org/poky/ scarthgap d1c25a3ce446a23e453e40ac2ba8f22b0e7ccefd Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga/ scarthgap 9714ae1ef8f22302bac60b7d2081bbdf3199ca70 Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes/ scarthgap bffc5bc012f1653beb58878b54b44e74b0f27404 Yocto Project: meta-agilex7-sed https://github.com/altera-fpga/agilex7-ed-ptp-mcqos-25g/tree/main/agi027fc-si-devkit/src/sw/yocto/meta-agilex7-sed scarthgap SED-2x25GE-1588PTP-MCQOS-agi027fc-si-devkit-Q25.1.1-Rel-1.1 GSRD Build Script: gsrd-socfpga https://github.com/altera-fpga/agilex7-ed-ptp-mcqos-25g/tree/main/agi027fc-si-devkit/src/sw/yocto/build.sh SED-2x25GE-1588PTP-MCQOS-agi027fc-si-devkit-Q25.1.1-Rel-1.1"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#release-notes","title":"Release Notes","text":"<p>Multi-Channel 25GbE Precision Time Protocol System Example Design Release Notes.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#multi-channel-25gbe-precision-time-protocol-system-example-design-architecture","title":"Multi-Channel 25GbE Precision Time Protocol System Example Design Architecture","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#hardware-architecture","title":"Hardware Architecture","text":"<p>Figure 2 illustrates the high-level architecture of the system example design. The main components include:</p> <ul> <li>HPS Subsystem</li> <li>DMA Subsystem</li> <li>Packet Switch Subsystem (Also referred to as the PTP Bridge Subsystem)</li> <li>Ethernet Subsystem</li> <li>Main Time Of the Day Subsystem</li> <li>Subordinate Time Of the Day Subsystem</li> <li>Ethernet Packet Generators</li> </ul> <p></p> <p>Figure 2. Multi-Channel 25GbE Precision Time Protocol SED High Level Hardware Architecture</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#hps-subsystem","title":"HPS Subsystem","text":"<p>The HPS Subsystem, built around the Agilex\u2122 7 Hard Processor System (HPS) and supporting logic, manages PTP synchronization and handles Time of Day (ToD) adjustments. It also provides access to status and control registers for other system components.</p> <p>The subsystem communicates with onboard components via its peripherals, using an I2C bus to monitor and configure the QSFP28 module. It also controls the Microchip Microchip ZL30733 PTP &amp; SyncE Network Synchronizer over the same bus, performing phase and frequency adjustments to maintain system-wide timing accuracy.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ethernet-subsystem","title":"Ethernet Subsystem","text":"<p>This module instantiates the Ethernet Subsystem FPGA IP. Refer to its user guide for details.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#dma-subsystem","title":"DMA Subsystem","text":"<p>The DMA Subsystem uses mSGDMA engines to transfer data between the HPS and the Ethernet Subsystem. It includes six DMA Ports, each with two Channels for transmit (TX) and receive (RX) traffic. These channels natively handle PTP timestamps and fingerprints.</p> <p>The subsystem groups DMA Ports into sets of three, assigning each group to one Ethernet port in the Ethernet Subsystem. It also translates protocols between Avalon\u00ae Streaming (AVST) and AXI-Stream (AXI-ST) interfaces, and performs clock domain crossing between the HPS Subsystem and Ethernet Subsystem clock domains. Figure 3 shows a high level architecture diagram of one of the DMA Subsystem ports.</p> <p></p> <p>Figure 3. DMA Subsystem Port High Level Architecture</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-switch-subsystem","title":"Packet Switch Subsystem","text":"<p>The Packet Switch Subsystem implements an L2\u2013L4 Ethernet packet switch that arbitrates among four client interfaces per port, connecting three DMA engines and a traffic generator to the transmit path. On the receive path, packet routing between ports and clients is handled by a Ternary Content-Addressable Memory (TCAM), with rules dynamically configurable via software. By default, packets without a TCAM match are dropped for security reasons. For matched entries, the Packet Switch subsystem routes packets to either a DMA Port or a User Port (Traffic Generator).</p> <p>The TX datapath arbitration ignores Ethernet packet type and uses a weighted priority round-robin scheme to manage requests from DMA and User Port. Figure 4 illustrates the high-level architecture of the Packet Switch transmitter path. On the transmit path, the Ethernet Subsystem returns the egress timestamp (ETS) for each packet along with its corresponding fingerprint for tracking.</p> <p>The RX datapath does not implement priority-based arbitration. Instead, traffic priority to the HPS is software-defined, with each DMA Port represented as a queue and assigned a configurable priority level. Figure 5 illustrates the high-level architecture of the Packet Switch receiver path.</p> <p></p> <p>Figure 4. Packet Switch Subsystem TX Datapath High Level Architecture</p> <p></p> <p>Figure 5. Packet Switch Subsystem RX Datapath High Level Architecture</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#tcam-data-structure","title":"TCAM Data Structure","text":"<p>The TCAM supports lookups using Ethernet frame headers, protocol headers, and IEEE 1588-specific fields.</p> <p>The table below lists the 492-bit TCAM key fields. If a packet lacks a corresponding header field, the key field is set to 0. Otherwise, the Packet Switch parser populates the field with extracted data. Unused bits from shorter headers are also zeroed.</p> Field Width (bits) Description rsvd 32 Reserved. flagField 16 flagField field in PTP header. messageType 4 messageType field in PTP header. ip_protocol 8 IP header protocol field, defined as Protocol in IPv4 or next_header in IPv6. ethtype 16 Ethernet header ethtype dot2q: (eth.{da,sa}) / (vlana.{tpid,tci}) / (vlanb.{tpid,tci}) / ethtype  dot1q: (eth.{da,sa}) / (vlana.{tpid,tci}) / ethtype  eth:   (eth.{da,sa,ethtype})   - ethtype = ethtype tci_vlana 16 TCI field for VLAN A in IEEE 802.1Q frames dot2q: (eth.{da,sa}) / (vlana.{tpid,tci}) / (vlanb.{tpid,tci}) / ethtype  - tci_vlana = vlana.tci  dot1q: (eth.{da,sa}) / (vlana.{tpid,tci}) / ethtype  - tci_vlana = vlana.tci  eth:   (eth.{da,sa,ethtype})  - tci_vlana = '0 tci_vlanb 16 TCI field for VLAN B in IEEE 802.1Q frames dot2q: (eth.{da,sa}) / (vlana.{tpid,tci}) / (vlanb.{tpid,tci}) / ethtype  - tci_vlanb = vlanb.tci  dot1q: (eth.{da,sa}) / (vlana.{tpid,tci}) / ethtype  - tci_vlanb = '0  eth:   (eth.{da,sa,ethtype})  - tci_vlanb = '0 l4_src_port 16 L4 header source port. - l4_src_port = udp.sport  - l4_src_port = tcp.sport l4_dst_port 16 L4 header destination port. - l4_dst_port = udp.dport  - l4_dst_port = tcp.dport src_ip 128 L3 source address field. IPv4:  - src_ip[31:0] = ipv4.src_ip, src_ip[127:32] = '0  IPv6:  - src_ip[127:0] = ipv6.src_ip dst_ip 128 L3 destination address field. IPv4:  - dst_ip[31:0] = ipv4.dst_ip, dst_ip[127:32] = '0  IPv6:  - dst_ip[127:0] = ipv6.dst_ip src_mac 48 Ethernet header source MAC address.  - src_mac = eth.sa dst_mac 48 Ethernet header destination MAC address. - dst_mac = eth.da <p>Table 1. TCAM Key Fields</p> <p>The Linux <code>ptpbridge</code> user application provides access to the TCAM key registers from the OS, removing the complexity of doing low level access to the Packet Switch IP.</p> <p>The table below defines the structure of a TCAM query result. This data is used to route in-transit packets to the destination port specified by the matching TCAM rule.</p> Field Width (bits) Description rsvd 27 Reserved. drop 1 Drop packet. egr_port 4 Selects which egress port to send traffic.  4\u2019d0: MSGDMA Channel 0  4\u2019d1: MSGDMA Channel 1  4\u2019d2: MSGDMA Channel 2  4\u2019d3 \u2013 4\u2019d7: reserved  4\u2019d8: User  4\u2019d8 \u2013 4\u2019d15: reserved <p>Table 2. TCAM Query Result Fields</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#main-time-of-the-day-subsystem-subordinate-time-of-the-day-subsystem","title":"Main Time Of the Day Subsystem &amp; Subordinate Time Of the Day Subsystem","text":"<p>The Main ToD Subsystem wraps the IEEE 1588 Time of Day Clock FPGA IP and its support logic, serving as the system\u2019s local ToD reference. The IP is configured for Accuracy Advanced mode and uses the IOPLL Reconfig FPGA IP, as described in the IOPLL and TOD Setup using IOPLL Reconfig IP chapter of the Ethernet Design Example Components User Guide.</p> <p>The Subordinate ToD Subsystem instantiates a dedicated IEEE 1588 Time of Day Clock FPGA IP per Ethernet interface and integrates an IEEE 1588 TOD Synchronizer FPGA IP to present timestamps in the Ethernet clock domain, as described in the PTP Timestamp Accuracy in Advanced Mode chapter of the F-Tile Ethernet Hard IP User Guide.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ethernet-packet-generators","title":"Ethernet Packet Generators","text":"<p>Two system blocks can generate Ethernet packets. The HPS produces PTP packets when the ptp4l service is enabled and can optionally generate synthetic traffic via ping or iperf3. Additionally, two hardware traffic generators can saturate Ethernet bandwidth with synthetic traffic when enabled by HPS software.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#sed-custom-ip","title":"SED Custom IP","text":"Block Entity Name Description AVST to AXI Bridge avst_axist_bridge AVST to AXI bridge facilitating data transfer between the DMA channels and the Ethernet Subsystem. The bridge operates bidirectionally, providing AXI to AVST translation for data flowing from the Ethernet Subsystem to the DMA channels. It is a single block servicing both TX and RX DMA channels. TX DMA Fifo tx_dma_fifo Top-level wrapper for custom blocks in the TX DMA Datapath. TX ETS Adapter hssi_ets_ts_adapter Adapts the egress timestamp and fingerprint from the Ethernet Subsystem to a format manageable by the TX DMA channel. TX DMA PKT FIFO cdc_packet_fifo Dual clock FIFO for clock domain crossing of packet information from the DMA channel to the Ethernet Subsystem. TX FP Generator tx_dma_fifo Sequential fingerprint generator. A fingerprint will be generated for all packet going out of the system. This is combinational logic inside the 'tx_dma_fifo' module. TX TS Valid tx_dma_fifo Logic that inserts egress timestamps into the MSGDMA prefetcher. This is combinational logic inside the 'tx_dma_fifo' module. TX TS/FP FIFO fp_resp_fifo/ts_fifo Two independent FIFOs to store the returned egress timestamp and its corresponding fingerprint. TX Completion ts_chs_compl Timestamp completion follow-up module. Captures FP and TS from the HSSI subsystem and forwards them to the TX DMA FIFO module if they are valid. FP Compare ts_chs_compl Combinational logic that tracks fingerprints returned by the HSSI Subsystem to validate and return the associated egress timestamp. TX TS FIFO ts_fifo FIFO to store the returned egress timestamp. RX DMA Fifo rx_dma_fifo Top-level wrapper for custom blocks in the RX DMA Datapath. RX TS Valid rx_dma_fifo Logic that inserts ingress timestamps into the MSGDMA prefetcher. This is combinational logic inside the 'rx_dma_fifo' module. RX DMA PKT FIFO cdc_packet_fifo Dual clock FIFO for clock domain crossing of packet information from the Ethernet Subsystem to the DMA channel. RX TS FIFO ts_fifo Single clock FIFO to store ingress timestamps from the Ethernet Subsystem. Main ToD eth_f_mtod_top Wrapper for the Ethernet IEEE 1588 Time of Day Clock FPGA IP. Includes a state machine that flags when the Main ToD Subsystem output is valid for the ToD Subordinate Subsystem to consume. Packet Generator eth_f_packet_client_top Generic Ethernet packet generator/checker. Packet generation parameters are configurable at runtime via software. Packet Generator Adaptor eth_f_packet_client_top_axi_adaptor Provides translation services between AVST and AXI-ST for the system Packet Generators. Packet Switch ptp_bridge_subsys Top level wrapper for TCAM, arbitration and routing logic to handle the system TX/RX data path"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#board-level-clocking-architecture","title":"Board Level Clocking Architecture","text":"<p>At the board level, the system clocking architecture includes the following components:</p> <ul> <li>Microchip ZL30733 PTP &amp; SyncE Network Synchronizer (U123)</li> <li>Oven Controlled Crystal Oscillator (OCXO) (X2)</li> <li>Agilex\u2122 7 AGIB027R31B (U1)</li> <li>Si5332 Low-Jitter Clock Generator (U19)</li> </ul> <p></p> <p>Figure 6. Board High Level Clocking Architecture</p> <p>On power-up, the Microchip ZL30733 PTP &amp; SyncE Network Synchronizer load its configuration profile from internal non-volatile memory (NVM). The default profile doesn't contain the correct configuration needed for the system example design components. At boot time, the HPS establishes access to the ZL30733 via I2C and proceeds to load the correct profile for the system.</p> <p>To enable HPS access to the onboard Microchip ZL30733, a custom bitstream must be loaded into the MAX10 device on the development kit. The required bitstream file, <code>max10_system_0002aa4F.pof</code>, is available as part of <code>images.zip</code> in the Binaries section.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#fpga-design-clocking-architecture","title":"FPGA Design Clocking Architecture","text":"<p>The clock frequencies for the Ethernet Subsystem IP ports <code>i_p8_clk_tx_tod</code>, <code>i_p8_clk_rx_tod</code>, <code>i_p9_clk_tx_tod</code>, <code>i_p9_clk_rx_tod</code>, <code>i_p8_clk_ptp_sample</code>, and  <code>i_p9_clk_ptp_sample</code> follow the guidelines in the Ethernet Subsystem FPGA IP User Guide.</p> <p>Figure 7 shows the high-level system clock distribution tree. For clarity, only one Ethernet port (P8) and one DMA Subsystem port are shown. All DMA ports share the same clock connections. Ports connected to Ethernet port 9 use its output clocks.</p> <p></p> <p>Figure 7. FPGA High Level Clocking Architecture Reduced Diagram</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#software-architecture","title":"Software Architecture","text":"<p>The system example design uses a HPS-first boot flow, where the HPS initializes before configuring the FPGA fabric. U-Boot is loaded from SPI flash or via a partial RBF. The second-stage boot loader loads the Linux kernel and full FPGA bitstream from the SD card. U-Boot enables the HPS bridges and programs the FPGA via the SDM. Once configured, the HPS boots Linux.</p> <p>The design includes drivers and user-space tools for the Linux network stack, PTP stack, and QoS via Traffic Control (TC). Ethernet Subsystem IP drivers support standard tools like <code>ethtool</code>. Drivers for the IEEE 1588 TOD Clock IP, Microchip ZL30733 synchronizer, and DMA ports interface are also provided.</p> <p>Egress QoS is managed by the Linux kernel\u2019s Traffic Control (TC) system. The Ethernet driver uses device tree data to enumerate DMA channels for each physical port. For each channel, it registers a TX buffer ring and exposes it as a separate hardware queue. TC applies queue disciplines (<code>qdiscs</code>) to control packet enqueue/dequeue behavior per queue. The driver integrates with TC to enable per-queue priority and flow control.</p> <p>For each DMA ingress channel, the Ethernet driver registers an RX buffer. Ingress QoS is controlled by the Packet Switch IP and the <code>ptpbridge</code> application, which defines filtering and routing rules. Packets matching a rule are directed to a specific DMA RX channel, queue, or User Port; unmatched packets are dropped by default.</p> <p>The HPS polls RX queues based on interrupt priority, with higher-priority channels mapped to higher-priority interrupts.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#intel-agilex-7-soc-fpga-f-tile-drivers","title":"Intel Agilex\u2122 7 SoC FPGA F-Tile Drivers","text":"Driver Description File Ethernet Driver The Ethernet driver exposes a standard <code>netdev</code> API to the kernel, enabling DMA channel discovery, hardware Time-of-Day (ToD) access, and <code>ethtool</code> enabling <code>drivers/net/ethernet/altera/intel_fpga_eth_main.c</code> ToD Driver Provides access to the Ethernet Subsystem IP configuration and status registers of the Ethernet IEEE 1588 Time of Day Clock FPGA IP. <code>drivers/net/ethernet/altera/intel_fpga_tod.c</code> HSSI Subsystem Driver Provides access to the Ethernet Subsystem IP configuration and status registers, as well as the Subsystem Abstraction Layer (SAL). <code>drivers/net/ethernet/altera/intel_fpga_hssiss.c</code> QSFP Driver The QSFP driver interfaces with the onboard QSFP module, handling configuration registers reads and controlling power and interrupt pins. <code>drivers/net/phy/qsfp.c</code> ZL30733 Driver The ZL30733 driver enables frequency steering for Time-of-Day (ToD) adjustment via the onboard ZL30733 SyncE &amp; IEEE 1588 Network Synchronizer. <code>drivers/net/ethernet/altera/intel_freq_control_zl30793.c</code>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#user-space-applications","title":"User Space Applications","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ptp4l","title":"ptp4l","text":"<p><code>ptp4l</code> is the IEEE 1588 PTP software implementation from the The Linux PTP Project, included in the HPS image. It offers extensive configuration options for system setup. Refer to the <code>ptp4l</code> man page for details</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#phc2sys","title":"phc2sys","text":"<p><code>phc2sys</code> is an open-source utility that synchronizes system clocks, typically aligning the system clock with a PTP Hardware Clock (PHC) managed by <code>ptp4l</code>. For configuration details, refer to the <code>phc2sys</code> man page.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ethtool","title":"ethtool","text":"<p><code>ethtool</code> is an open-source utility for querying and configuring network driver and hardware settings. For usage details, refer to the <code>ethtool</code> man page.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packetgenerator","title":"packetgenerator","text":"<p>This application configures the Packet Generator IP core in the FPGA to generate synthetic Ethernet traffic for validating data path integrity and line rates. It can also modulate bandwidth to test system QoS policies.</p> <p>Packet generation is customizable via parameters such as:</p> <ul> <li>Source and destination MAC addresses</li> <li>Frame sizes</li> <li>Idle packet gaps</li> </ul> <p>Syntax</p> <pre><code>packetgenerator [--device] [/dev/uioX] [options]\n</code></pre> <p>Parameters</p> <ul> <li><code>--help</code>: Print this help contents</li> <li><code>--device</code>: <code>UIO</code> device name</li> <li><code>--dump</code>: Dump all register contents</li> <li><code>--register-offset offset</code>: 32-bit aligned register offset to do direct register read/write</li> <li><code>--register-value value</code>: 32-bit value to be written to the register</li> <li><code>--dest-mac</code>: Destination MAC address in the packet</li> <li><code>--src-mac</code>: Source MAC address in the packet</li> <li><code>--traffic bool</code>: Enable or disable traffic</li> <li><code>--one-shot bool</code>: Enable or disable one-shot mode</li> <li><code>--soft-reset</code>: Trigger a soft reset</li> <li><code>--dyn-pkt-mode bool</code>: Enable or disable dynamic packet mode</li> <li><code>--packet-checker bool</code>: Enable or disable packet checker</li> <li><code>--cntr-snapshot bool</code>: Take a counter snapshot</li> <li><code>--cntr-clear bool</code>: Clear all counter CSRs</li> <li><code>--cntr-internal-clear bool</code>: Clear all internal counters</li> <li><code>--fixed-gap bool</code>: Enable or disable fixed gap between packets</li> <li><code>--pkt-len-mode value</code>: Set packet generation length mode (Fixed/Incremental) [1,2]</li> <li><code>--num-idle-cycles value</code>: Number of idle cycles to insert [0...255]</li> <li><code>--tx-pkt-size value</code>: TX packet size [64...9216]</li> <li><code>--tx-max-pkt-size value</code>: Maximum TX packet size [64...9216]</li> <li><code>--num-packets value</code>: Number of packets to generate [0...0xFFFFFFFF]</li> </ul> <p>System example design packet generators are mapped to <code>/dev/uio0</code> and <code>/dev/uio1</code>.</p> <p>Basic Usage</p> <p>Synthetic Traffic Configuration \u2013 The command below sets up the packet generator with parameters including dynamic packet mode, fixed gap, packet length mode, idle cycles, packet checker, one-shot mode, and packet sizes before initiating traffic generation.</p> <pre><code>packetgenerator --device /dev/uio0 --traffic false --dyn-pkt-mode true --fixed-gap true --pkt-len-mode 0x01 --num-idle-cycles 22 --packet-checker true --one-shot false --tx-pkt-size 1024 --tx-max-pkt-size 1024\n</code></pre> <p>Start Packet Generator \u2013 The command below initiates traffic generation based on the current configuration parameters.</p> <pre><code>packetgenerator --device /dev/uio0 --traffic 1\n</code></pre> <p>Configuration and Status Report \u2013 The command below captures a snapshot of all internal configuration and status registers in the packet generator hardware.</p> <pre><code>packetgenerator --device /dev/uio0 --dump\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ptpbridge","title":"ptpbridge","text":"<p>The <code>ptpbridge</code> application configures the hardware Packet Switch IP, which routes incoming packets to one of three DMA channels per Ethernet interface based on user-defined QoS rules. Packets that do not match any rule are dropped by default.</p> <p>Rule priority is determined by index number, higher index means higher priority. If multiple rules match, the rule with the highest index is applied. To ensure correct behavior, generic rules should be programmed first, followed by more specific rules at higher indices.</p> <p>A maximum of 32 keys can be programmed (0-31).</p> <p>Syntax</p> <pre><code>ptpbridge [--device] [/dev/uioX] [Options]\n</code></pre> <p>Parameters</p> <ul> <li><code>--help</code>: Print this help contents</li> <li><code>--device</code>: *UIO device name</li> <li><code>--dump</code>: Dump all register contents</li> <li><code>--set-key</code>: Set Key. Requires Key fields to be provided</li> <li><code>--remove-key</code>: Remove Key using key-index</li> <li><code>--flush-all-keys</code>: Flush all Key entries from the system</li> <li><code>--flush-all-counters</code>: Flush all debug counters value to 0</li> <li><code>--show-key</code>: Search for Keys fulfilling a search criteria for a port</li> <li><code>--register-rw</code>: Do a direct register read write</li> <li><code>--key-index</code>: Key index to work on</li> <li><code>--dest-mac</code>: Key - Destination MAC. <code>ptpbridge</code> can resolve MAC addresses from Ethernet interface names, e.g. eth1.</li> <li><code>--src-mac</code>: Key - Source MAC. <code>ptpbridge</code> can resolve MAC addresses from Ethernet interface names, e.g. eth1.</li> <li><code>--dest-ip</code>: Key - Destination IP Address</li> <li><code>--src-ip</code>: Key - Source IP address</li> <li><code>--dest-port</code>: Key - Destination L4 port</li> <li><code>--src-port</code>: Key - Source L4 port</li> <li><code>--vlanb</code>: Key - VALNB</li> <li><code>--vlana</code>: Key - VLANA</li> <li><code>--ethtype</code>: Key - Ethernet type</li> <li><code>--protocol</code>: Key - IP Protocol type</li> <li><code>--message</code>: Key - IP Message type</li> <li><code>--flag</code>: Key - Flag field</li> <li><code>--result</code>: Defines the DMA or user port to which the Ethernet packet will be routed if the rule evaluation is true. The mapping for this parameter is as follows:<ul> <li>0x0: route packet to DMA-0</li> <li>0x1: route packet to DMA-1</li> <li>0x2: route packet to DMA-2</li> <li>0x8: route packet to User Port (Packet Generator)</li> </ul> </li> <li><code>port</code>: Ethernet interface to which the rule will apply.<ul> <li>0: Apply rule to <code>eth1</code> Ethernet interface</li> <li>1: Apply rule to <code>eth2</code> Ethernet interface</li> </ul> </li> <li><code>register-offset</code>: Register offset to read/write to. Refer to the PTP Bridge Register Map for direct registers base address and offsets.</li> <li><code>register-value</code>: Register value to write. Can be comma separated to write multiple values.</li> <li><code>length</code>: Number of registers to read</li> <li><code>mask</code>: Set Mask properties for fields manually</li> </ul> <p>System example design Packet Switch is mapped to <code>/dev/uio2</code>.</p> <p>Basic Usage</p> <p>Route all incoming traffic to DMA 0</p> <pre><code>ptpbridge --port 0 --set-key --key-index 0 --result 0x0\n</code></pre> <ul> <li><code>--port 0</code>: This rule applies to Ethernet interface <code>eth1</code>.</li> <li><code>--key-index 0</code>: This rule is stored in key index 0, setting the lowest priority for the rule.</li> <li><code>--result 0x0</code>: Packets fulfilling the rule will be routed to DMA-0.</li> </ul> <p>The above command defines the following rule:</p> <p>Route traffic based on destination MAC address</p> <pre><code>ptpbridge --port 0 --set-key --key-index 0 --dest-mac \"eth1\" --result 0x2\n</code></pre> <p>The above command defines the following rule:</p> <ul> <li><code>--port 0</code>: This rule applies to Ethernet interface <code>eth1</code>.</li> <li><code>--key-index 0</code>: This rule is stored in key index 0, setting the lowest priority for the rule.</li> <li><code>--dest-mac \"eth1\"</code>: This is the filter established by the rule. The rule will return a hit if the evaluated Ethernet frame has the <code>eth1</code> interface MAC address in the MAC address destination field.</li> <li><code>--result 0x2</code>: Packets fulfilling the rule will be routed to DMA-2.</li> </ul> <p>Route traffic based on VLAN and DF flag</p> <pre><code>ptpbridge --port 0 --set-key --key-index 2 --ethtype 0x0800 --protocol 0x01 --vlana 100 --vlanb 200 --flag 0x2 --result 0x2\n</code></pre> <p>The above command defines the following rule:</p> <ul> <li><code>--port 0</code>: This rule applies to Ethernet interface eth1.</li> <li><code>--key-index 2</code>: This rule is stored in key index 2.</li> <li><code>--ethtype 0x0800</code>: Ethernet Type is set to IPv4.</li> <li><code>--protocol 0x01</code>: The IP protocol is set to ICMP.</li> <li><code>--vlana 100</code>: The primary VLAN ID is 100.</li> <li><code>--vlanb 200</code>: The secondary VLAN ID is 200.</li> <li><code>--flag 0x2</code>: The fragment flag is set to 0x2.</li> <li><code>--result 0x2</code>: Packets fulfilling the rule will be routed to DMA-2.</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#address-map","title":"Address Map","text":"Subordinate Name Component Agilex\u2122 HPS H2F AXI Manager Register Description axi4lite_hssi.s0 Ethernet Subsystem CSR 0x0000_0000 - 0x03ff_ffff Link axi4lite_pktcli_0.s0 Generic Packet Client 0x0406_0000 - 0x0406_ffff Link axi4lite_pktcli_1.s0 Generic Packet Client 0x0407_0000 - 0x0407_ffff Link axi4lite_ptpb.s0 Packet Switch 0x0405_0000 - 0x0405_ffff Link ftile_debug_status_pio_0.s1 F-Tile Status Register 0x0404_0060 - 0x0404_006f qsfpdd_status_pio.s1 QSFP-DD Status PIO 0x0404_0050 - 0x0404_005f sys_ctrl_pio_0.s1 QSDP-DD Control PIO 0x0404_0040 - 0x0404_004f dma_subsys.dma_subsys_port0_csr DMA Subsystem Port 0 0x0448_0000 - 0x0448_00ff Link dma_subsys.dma_subsys_port1_csr DMA Subsystem Port 1 0x044c_0000 - 0x044c_00ff Link dma_subsys.dma_subsys_port2_csr DMA Subsystem Port 2 0x0450_0000 - 0x0450_00ff Link dma_subsys.dma_subsys_port3_csr DMA Subsystem Port 3 0x0454_0000 - 0x0454_00ff Link dma_subsys.dma_subsys_port4_csr DMA Subsystem Port 4 0x0458_0000 - 0x0458_00ff Link dma_subsys.dma_subsys_port5_csr DMA Subsystem Port 5 0x045c_0000 - 0x045c_00ff Link mtod_subsys.master_tod_top_0_csr Main ToD Subsystem 0x0404_0000 - 0x0404_003f Link mtod_subsys.mtod_subsys_pps_load_tod_0_csr Main ToD PPS Loader 0x0404_0100 - 0x0404_01ff <p>Table 3. Qsys_top Platform Designer system address map.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-generator-register-description","title":"Packet Generator Register Description","text":"<p>Refer to section Packet Client Register Map from the MACsec FPGA System Design User Guide for the register description.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#qsfpdd-spi-control-pio-register-description","title":"QSFPDD SPI Control PIO Register description","text":"Address Name Bit Offset Reset Value Attribute Description 0x0 qsfpdd_ctrl_pio [0] 1'b1 RW QSFPDD resetn ^ qsfpdd_ctrl_pio [1] 1'b1 RW QSFPDD initmode/lpmode ^ qsfpdd_ctrl_pio [2] 1'b0 RW QSFPDD modseln 0x1 - 0xF Reserved <p>Table 4. QSFPDD SPI control PIO register description.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#qsfpdd-status-pio-register-description","title":"QSFPDD Status PIO Register description","text":"Address Name Bit Offset Attribute Description 0x0 qsfpdd_status_pio [0] RO QSFPDD modprsn ^ qsfpdd_status_pio [1] RO QSFPDD intn 0x1 - 0xF Reserved <p>Table 5. QSFPDD status PIO register description.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#f-tile-status-register-description","title":"F-Tile Status Register Description","text":"Bit Ethernet Subsystem Port Description 0 Port 8 Ethernet Subsystem 'o_p8_tx_lanes_stable' signal. For more information consult the following Link 1 ^ Ethernet Subsystem 'o_p8_tx_pll_locked' signal. For more information consult the following Link 2 ^ Ethernet Subsystem 'o_p8_rx_pcs_ready' signal. For more information consult the following Link 3 ^ Ethernet Subsystem 'o_p8_tx_ptp_ready' signal. For more information consult the following Link 4 ^ Ethernet Subsystem 'o_p8_rx_ptp_ready' signal. For more information consult the following Link 5 ^ Ethernet Subsystem 'o_p8_rx_ptp_offset_data_valid' signal. For more information consult the following Link 6 ^ Ethernet Subsystem 'o_p8_tx_ptp_offset_data_valid' signal. For more information consult the following Link 10 Port 9 Ethernet Subsystem 'o_p9_tx_lanes_stable' signal. For more information consult the following Link 11 ^ Ethernet Subsystem 'o_p9_tx_pll_locked' signal. For more information consult the following Link 12 ^ Ethernet Subsystem 'o_p9_rx_pcs_ready' signal. For more information consult the following Link 13 ^ Ethernet Subsystem 'o_p9_tx_ptp_ready' signal. For more information consult the following Link 14 ^ Ethernet Subsystem 'o_p9_rx_ptp_ready' signal. For more information consult the following Link 15 ^ Ethernet Subsystem 'o_p9_rx_ptp_offset_data_valid' signal. For more information consult the following Link 16 ^ Ethernet Subsystem 'o_p9_tx_ptp_offset_data_valid' signal. For more information consult the following Link <p>Table 6. F-Tile status register description.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#dma-subsystem-port-memory-map","title":"DMA SubSystem Port Memory Map","text":"Subordinate Name Component subsys_ftile_25gbe_1588_csr Register Description ftile_25gbe_rx_dma_ch1 RX DMA channel 0x0080 - 0x00bf Link ftile_25gbe_tx_dma_ch1 TX DMA channel 0x0000 - 0x003f Link <p>Table 7. DMA Subsystem port memory map.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#dma-subsystem-channel-memory-map","title":"DMA SubSystem Channel Memory Map","text":"Subordinate Name Component [rx/tx]_dma_csr Register Description [tx/rx]_dma_dispatcher DMA dispatcher 0x0020 - 0x003f Link [tx/rx]_dma_prefetcher DMA prefetcher 0x0000 - 0x001f Link <p>Table 8. DMA Subsystem channel memory map.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-switch-register-map","title":"Packet Switch Register Map","text":"Module Start Address End Address Ingress Arbiter 0 0x0 0x8 Ingress Arbiter 1 0xC 0x14 Egress RX Demux 0 0x60 0x70 Egress RX Demux 1 0x88 0x98 Ingress RX Width Adapter 0 0x1A0 0x1A8 Ingress RX Width Adapter 1 0x1AC 0x1B4 TCAM_0 (16KB) 0x200 0x41FC TCAM_1 (16KB) 0x4200 0x81FC Egress RX Width Adapter 0 (User port) 0x8200 0x8208 Egress RX Width Adapter 1 (User port) 0x820C 0x8214 <p>Table 9. Packet Switch Register Description</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-switch-ingress-arbiter-register-description","title":"Packet Switch Ingress Arbiter Register Description","text":"Register Name Offset Field Width (bits) Type HW Reset Value Description scratch_reg 0x00 scratch 32 RW 32'h0 Scratch Register. cfg_priority_dma 0x04 reserved [31:12] RO 16'h0 Reserved. ch_2 [11:8] RW 4'h3 Configured priority level for DMA channel 2. 0: highest priority, 3: lowest priority, other values are reserved. This register along with cfg_priority_user register (0x8) configures the ingress arbiter priority levels. Values across both registers must have unique priority values. ch_1 [7:4] RW 4'h2 Configured priority level for DMA channel 1. 0: highest priority, 3: lowest priority, other values are reserved. This register along with cfg_priority_user register (0x8) configures the ingress arbiter priority levels. Values across both registers must have unique priority values. ch_0 [3:0] RW 4'h0 Configured priority level for DMA channel 0. 0: highest priority, 3: lowest priority, other values are reserved. This register along with cfg_priority_user register (0x8) configures the ingress arbiter priority levels. Values across both registers must have unique priority values. cfg_priority_user 0x08 reserved [31:4] RO 28'h0 Reserved. port_0 [3:0] RW 4'h1 Configured priority level for User_0 port. 0: highest priority, 3: lowest priority, \u2018d4-\u2018d15: reserved. This register along with cfg_priority_dma register (0x4) configures the ingress arbiter priority levels. Values across both registers must have unique priority values. <p>Table 10. Packet Switch Ingress Arbiter Register Description.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-switch-egress-rx-demux-register-description","title":"Packet Switch Egress RX Demux Register Description","text":"Register Name Offset Field Width (bits) Type HW Reset Value Description scratch_reg 0x00 scratch [31:0] RW 32'h0 Scratch Register. control_reg 0x04 reserved [31:3] RO 29'h0 Reserved. dma_2_drop_en [2] RW 1'h0 Enable drop threshold to be used for DMA CH_2. dma_1_drop_en [1] RW 1'h0 Enable drop threshold to be used for DMA CH_1. dma_0_drop_en [0] RW 1'h0 Enable drop threshold to be used for DMA CH_0. dma_0_drop_threshold_reg 0x08 reserved [31:16] RO 16'h0 Reserved. drop_threshold [15:0] RW 16'd496 Drop threshold for DMA CH_0. dma_1_drop_threshold_reg 0x0C reserved [31:16] RO 16'h0 Reserved. drop_threshold [15:0] RW 16'd496 Drop threshold for DMA CH_1. dma_2_drop_threshold_reg 0x10 reserved [31:16] RO 16'h0 Reserved. drop_threshold [15:0] RW 16'd496 Drop threshold for DMA CH_2. <p>Table 11. Packet Switch Egress RX Demux Register Description.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-switch-ingress-rx-width-adjuster-register-description","title":"Packet Switch Ingress RX Width Adjuster Register Description","text":"Register Name Offset Field Width (bits) Type HW Reset Value Description scratch_reg 0x00 scratch [31:0] RW 32'h0 Scratch Register. control_reg 0x04 Reserved [31:1] RO 31'h0 cfg_rx_pause_en [0] RW 1'h0 Enable RX pause. cfg_threshold_reg 0x08 drop_threshold [31:16] RW 16'd1948 Configured threshold when packets are dropped. rx_pause_threshold [15:0] RW 16'd1024 Configured threshold when RX pause is asserted. <p>Table 12. Packet Switch Ingress RX Width Adjuster Register Description.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-switch-egress-rx-width-adjuster-register-description","title":"Packet Switch Egress RX Width Adjuster Register Description","text":"Register Name Offset Field Width (bits) Type HW Reset Value Description scratch_reg 0x00 scratch [31:0] RW 32'h0 Scratch Register. control_reg 0x04 reserved [31:1] RO 31'h0 Reserved. drop_en [0:0] RW 1'h0 Enable drop threshold to be used for egress width adapter. cfg_drop_threshold_reg 0x08 reserved [31:16] RO 16'h0 Reserved. drop_threshold [15:0] RW 16'd496 Drop threshold for egress width adapter. <p>Table 13. Packet Switch Egress RX Width Adjuster Register Description.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#tcam-key-register-map","title":"TCAM Key Register Map","text":"Register Field Register Offset Register Bit Key Field Key_15 0x103C [31:12] reserved Key_15 0x103C [11:0] rsvd[31:20] Key_14 0x1038 [31:12] rsvd[19:0] Key_14 0x1038 [11:0] flagField[15:4] Key_13 0x1034 [31:28] flagField[3:0] Key_13 0x1034 [27:24] messageType[3:0] Key_13 0x1034 [23:16] ip_protocol[7:0] Key_13 0x1034 [15:0] ethtype[15:0] Key_12 0x1030 [31:16] tci_vlana[15:0] Key_12 0x1030 [15:0] tci_vlanb[15:0] Key_11 0x102C [31:16] l4_src_port[15:0] Key_11 0x102C [15:0] l4_dst_port[15:0] Key_10 0x1028 [31:0] src_ip[127:96] Key_9 0x1024 [31:0] src_ip[95:64] Key_8 0x1020 [31:0] src_ip[63:32] Key_7 0x101C [31:0] src_ip[31:0] Key_6 0x1018 [31:0] dst_ip[127:96] Key_5 0x1014 [31:0] dst_ip[95:64] Key_4 0x1010 [31:0] dst_ip[63:32] Key_3 0x100C [31:0] dst_ip[31:0] Key_2 0x1008 [31:0] src_mac[47:16] Key_1 0x1004 [31:16] src_mac[15:0] Key_1 0x1004 [15:0] dst_mac[47:32] Key_0 0x1000 [31:0] dst_mac[31:0] <p>Table 14. TCAM key register map.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#interrupt-map","title":"Interrupt Map","text":"Interrupt F2H IRQ Linux Interrupt dipsw_pio_irq 0 button_pio_irq 1 mtod_subsys_pps_load_tod_0_pps_irq 2 qsfpdd_status_pio 5 ftile_debug_status_pio 6 dma_subsys_port5_tx_dma_ch1_irq 13 36 dma_subsys_port5_rx_dma_ch1_irq 14 35 dma_subsys_port4_tx_dma_ch1_irq 15 34 dma_subsys_port4_rx_dma_ch1_irq 16 33 dma_subsys_port3_tx_dma_ch1_irq 17 32 dma_subsys_port3_rx_dma_ch1_irq 18 31 dma_subsys_port2_tx_dma_ch1_irq 19 30 dma_subsys_port2_rx_dma_ch1_irq 20 29 dma_subsys_port1_tx_dma_ch1_irq 21 28 dma_subsys_port1_rx_dma_ch1_irq 22 27 dma_subsys_port0_tx_dma_ch1_irq 23 26 dma_subsys_port0_rx_dma_ch1_irq 24 25 <p>Table 15. Interrupt map.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#hardware-setup","title":"Hardware Setup","text":"<p>Figure 8. Agilex\u2122 I-Series Transceiver-SoC Development Kit (4 x F-Tile)</p> <p>Set up the board default settings, as listed by the the Agilex\u2122 I-Series Transceiver-SoC Development Kit User Guide, \"Default Settings\" section:</p> Switch Default Position S19 [1:4] OFF/OFF/ON/ON S20 [1:4] ON/ON/ON/ON S9 [1:4] ON/OFF/OFF/X S10 [1:4] ON/ON/ON/ON S15 [1:4] ON/ON/ON/OFF S1 [1:4] OFF/OFF/OFF/OFF S6 [1:4] OFF/OFF/OFF/OFF S22 [1:4] ON/ON/ON/ON S23 [1:4] ON/ON/ON/ON S4 [1:4] ON/ON/ON/ON <p>Table 16. Factory Default Switch Settings</p> <p>Connect the Type B USB cable from each development kit to the host for JTAG access.</p> <p>Connect the two Agilex\u2122 I-series Transceiver-SoC Development Kits with a QSFP-DD/28 cable via the QSFP-DD cage J27 (Highlighted in red figure 8).</p> <p></p> <p>Figure 9. IO48 OOBE daughter card</p> <p>Connect the IO48 OOBE Daughter Card to J4 on each development kit.</p> <p>Connect the mini-USB ports (J7) from each of the IO48 OOBE Daughter Card to your host machine. Both development kits OOBE Daughter Cards are connected to the same host.</p> <p>Figure 10 shows a high level connectivity diagram for both development kits.</p> <p></p> <p>Figure 10. High level hardware connectivity diagram</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#configure-the-serial-connection","title":"Configure the Serial Connection","text":"<p>The Embedded Linux OS on the Agilex\u2122 7 Transceiver-SoC Development Kit can be accessed via a serial terminal such as Minicom or PuTTY. First, identify the serial connection IDs between your host and each development kit. On an Ubuntu host, list the most recently connected USB-to-Serial devices using:</p> <pre><code>admin@10.1.23.255:~$ dmesg | grep \"ttyUSB*\"\n[    6.251435] usb 1-1.2: FTDI USB Serial Device converter now attached to ttyUSB1\n[    6.255400] usb 1-1.3: FTDI USB Serial Device converter now attached to ttyUSB2\n</code></pre> <p>In this example, the two detected devices correspond to the serial connections for the Agilex\u2122 7 Transceiver-SoC Development Kits, as no other USB-to-Serial cables are connected to the host.</p> <p>Start a serial session for each development kit using Minicom. Open separate terminal windows and launch a Minicom instance in each to monitor both kits concurrently.</p> <p>Development Kit 1 terminal:</p> <pre><code># Note: Device names may vary depending on your system. Adjust accordingly.\nadmin@10.1.23.255:~$ minicom -D /dev/ttyUSB1\n</code></pre> <p>Development Kit 2 terminal:</p> <pre><code># Note: Device names may vary depending on your system. Adjust accordingly.\nadmin@10.1.23.255:~$ minicom -D /dev/ttyUSB2\n</code></pre> <p>Access the Minicom configuration screen using the following key combination:</p> <ul> <li><code>Ctrl + A</code>, then press <code>Z</code> for the Command Summary menu</li> <li><code>SHIFT + O</code> for the configuration menu</li> </ul> <p>Configure each serial session with the following parameters:</p> <ul> <li>Bps/Par/Bits: 115200 8N1</li> <li>Hardware Flow Control: No</li> <li>Software Flow Control: No</li> </ul> <p>Your 'Serial port setup' screen should resemble the following after adjusting the configuration parameters:</p> <pre><code>Welcome to minicom 2.7.1                                                                  OPTI+--------------------------------------------------------------------#             Comp| A -    Serial Device      : /dev/ttyUSB1                              |             Port| B - Lockfile Location     : /var/lock                                 |             | C -   Callin Program      :                                           |             Pres| D -  Callout Program      :                                           |             | E -    Bps/Par/Bits       : 115200 8N1                                |             | F - Hardware Flow Control : No                                        |             | G - Software Flow Control : No                                        |             |                                                                       |             |    Change which setting?                                              |             +--------------------------------------------------------------------#             | Screen and keyboard      |                                                  | Save setup as dfl        |                                                  | Save setup as..          |                                                  | Exit                     |                                                  +-----------------------#\n</code></pre> <p>Both terminal will remain inactive until the Agilex\u2122 7 device is configured.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on use case.</p> <ul> <li>User Flow 1: Testing with Pre-build Binaries.</li> </ul> <ul> <li>User Flow 2: Testing Complete Flow.</li> </ul> User Flow Description Required for User Flow 1 Required for User Flow 2 Environment Setup Tools Download and Installation Yes Yes Install dependency packages for SW compilation No Yes Package Download Yes Yes Compilation HW compilation No Yes SW compilation No Yes Programming Programming the SW binary Yes Yes Programming the HW binary Yes Yes Linux boot Yes Yes Testing Initial System Configuration Yes Yes Run Ping test Yes Yes Run iPerf3 test Yes Yes Run Packet Generator test Yes Yes Run ptp4l test Yes Yes <p>Table 17. User Test Flows.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#tools-download-and-installation","title":"Tools Download and Installation","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#altera-quartus-prime-pro","title":"Altera Quartus Prime Pro","text":"<p>Download the Quartus\u00ae Prime Pro Edition software version 25.1.1 from the FPGA Software Download Center. Follow the on-screen instructions to complete the installation process.</p> <p>Refer to Altera\u00ae FPGA Software Installation and Licensing for more information on the installation and licensing process.</p> <p>Set up the Altera\u00ae Quartus\u00ae tools in the PATH enviormental variable.</p> <pre><code># Adjust QUARTUS_ROOTDIR target to reflect your Quartus installation path  \nexport QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#install-dependency-packages-for-sw-compilation","title":"Install dependency packages for SW compilation","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#arm-gnu-toolchain-113rel1","title":"Arm GNU Toolchain 11.3.Rel1","text":"<p>Download the GCC ARM cross-compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>wget https://developer.arm.com/-/media/Files/downloads/gnu/11.3.rel1/binrel/\\\narm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.3.rel1-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#yocto-build-prerequisites","title":"Yocto Build Prerequisites","text":"<p>Before building the Yocto-based Linux image, ensure the host system meets the Yocto system requirements.</p> <p>The command to install the required packages and set the environment on Ubuntu 22.04-LTS is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\nexport LC_ALL=\"en_US.UTF-8\"\nexport LC_CTYPE=\"en_US.UTF-8\"\nexport LC_NUMERIC=\"en_US.UTF-8\"\nexport LANG=en_US.UTF-8\nexport LANGUAGE=en_US.UTF-8\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#bash-as-default-command-interpreter","title":"Bash as Default Command Interpreter","text":"<p>On Ubuntu 22.04, set Bash as the system default command interpreter:</p> <pre><code>sudo ln -sf /bin/bash /bin/sh\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#package-download","title":"Package Download","text":"<p>Clone the GitHub repository to obtain the System Example Design source package.</p> <pre><code>git clone https://github.com/altera-fpga/agilex7-ed-ptp-mcqos-25g.git\ncd agilex7-ed-ptp-mcqos-25g\ngit checkout SED-2x25GE-1588PTP-MCQOS-agi027fc-si-devkit-Q25.1.1-Rel-1.1\ncd agi027fc-si-devkit\nexport TOP_FOLDER=`pwd`\nmkdir bin\n</code></pre> <p>Directory Structure Used in This Example Design:</p> <pre><code>|--- agi027fc-si-devkit\n  |   |--- src\n  |   |   |--- hw\n  |   |   |--- sw\n</code></pre> <p>Pre-built binaries are available under the GitHub repository releases. File descriptions are provided in the Binaries section.</p> <p>Extract all files and copy them to $TOP_FOLDER/bin to run hardware tests on the development kit.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#compilation","title":"Compilation","text":"<p>The following steps outline the build process for both hardware (HW) and software (SW) components.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#hw-compilation","title":"HW compilation","text":"<p>The <code>src/hw/synth</code> directory contains the Quartus project and a Makefile with the following build targets:</p> <ul> <li><code>make synth</code>   - Runs synthesis stage of Altera\u00ae Quartus\u00ae</li> <li><code>make compile</code> - Runs the compile stage of Altera\u00ae Quartus\u00ae</li> <li><code>make all</code>     - Runs a full Altera\u00ae Quartus\u00ae compilation flow</li> </ul> <p>Run the following command to compile the project:</p> <pre><code>cd $TOP_FOLDER/src/hw/synth/\nmake all\n</code></pre> <p>Alternatively, launch Altera\u00ae Quartus\u00ae in GUI mode, open <code>top.qpf</code>, and run the compile operation. This generates <code>top.sof</code> at <code>$TOP_FOLDER/src/hw/output_files/</code>.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#build-hps-and-core-rbf-file","title":"Build HPS and CORE RBF file","text":"<p>The configuration bitstream generated by Altera\u00ae Quartus\u00ae Prime includes the FPGA core, I/O, and the HPS First-Stage Bootloader (FSBL). After compiling the project, you must integrate your current U-Boot FSBL (<code>u-boot-spl-dtb.hex</code>) into the bitstream.</p> <p>To embed the .hex file into the bitstream, run the following command:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c -o hps=on -o hps_path=src/sw/artifacts/u-boot-spl-dtb.hex src/hw/synth/output_files/top.sof bin/top.rbf\n</code></pre> <p>The following files are generated:</p> <ul> <li><code>$TOP_FOLDER/bin/top.hps.rbf</code>  - HPS First configuration bitstream, phase 1 (HPS and DDR)</li> <li><code>$TOP_FOLDER/bin/top.core.rbf</code> - HPS First configuration bitstream, phase 2 (FPGA fabric)</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#build-qspi-image","title":"Build QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER quartus_pfg -c src/hw/synth/output_files/top.sof \\\nbin/top.jic \\\n-o hps_path=src/sw/artifacts/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1VB \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/bin/top.hps.jic</code>   - Flash image for HPS First configuration bitstream, phase 1 (HPS and DDR)</li> <li><code>$TOP_FOLDER//bin/top.core.rbf</code> - HPS First configuration bitstream, phase 2 (FPGA fabric, discarded, as we already have it on the SD card)</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#sw-compilation","title":"SW Compilation","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#build-yocto","title":"Build Yocto","text":"<p>Start the Yocto build process by executing the following command:</p> <pre><code>cd $TOP_FOLDER/src/sw/yocto\n. agilex7_dk_si_agi027fc-PTP_2P25G_MCQ-build.sh\nbuild_default\n</code></pre> <p>After a successful build, all required images are stored in the <code>$TOP_FOLDER/src/sw/yocto/agilex7_dk_si_agi027fc-gsrd-images</code> directory. Build time varies depending on the host system's resource specifications. Upon successful compilation of the 25GbE system example design, the following files are generated:</p> <ul> <li><code>$TOP_FOLDER/src/sw/yocto/agilex7_dk_si_agi027fc-gsrd-images/u-boot-agilex7_dk_si_agi027fc-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/src/sw/yocto/agilex7_dk_si_agi027fc-gsrd-images/u-boot-agilex7_dk_si_agi027fc-socdk-gsrd-atf/u-boot.itb</code></li> <li><code>$TOP_FOLDER/src/sw/yocto/agilex7_dk_si_agi027fc-gsrd-images/kernel_sed.itb</code></li> <li><code>$TOP_FOLDER/src/sw/yocto/agilex7_dk_si_agi027fc-gsrd-images/sdimage.tar.gz</code></li> </ul> <p>Copy <code>sdimage.tar.gz</code> and <code>kernel_sed.itb</code> to the bin folder.</p> <pre><code>cp -rf $TOP_FOLDER/src/sw/yocto/agilex7_dk_si_agi027fc-gsrd-images/sdimage.tar.gz $TOP_FOLDER/bin/sdimage.tar.gz\ncp -rf $TOP_FOLDER/src/sw/yocto/agilex7_dk_si_agi027fc-gsrd-images/kernel_sed.itb $TOP_FOLDER/bin/kernel_sed.itb\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#yocto-update","title":"Yocto Update","text":"<p>If the hardware project is modified, the software must be updated to match the new bitstream. The HPS second-stage bootloader embeds a SHA signature of the FPGA bitstream during compilation. Any change to the bitstream alters the SHA, requiring a bootloader update.</p> <p>To update the FPGA bitstream SHA signature in the HPS second-stage bootloader, follow these steps:</p> <ol> <li>Replace <code>$TOP_FOLDER/src/sw/yocto/meta-agilex7-sed/recipes-bsp/ghrd/files/agilex7_dk_si_agi027fc_gsrd_ghrd_PTP_2P25G_MCQ.core.rbf</code> with the updated <code>top.core.rbf</code></li> <li>Update the recipe at <code>$TOP_FOLDER/src/sw/yocto/meta-agilex7-sed/recipes-bsp/ghrd/hw-ref-design.bb</code> using the following commands</li> </ol> <pre><code>cd $TOP_FOLDER\nCORE_RBF=src/sw/yocto/meta-agilex7-sed/recipes-bsp/ghrd/files/agilex7_dk_si_agi027fc_gsrd_ghrd_PTP_2P25G_MCQ.core.rbf\nrm -rf $CORE_RBF\ncp -f bin/top.core.rbf $CORE_RBF\nFILE=src/sw/yocto/meta-agilex7-sed/recipes-bsp/ghrd/hw-ref-design.bbappend\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_SHA=\".*sha256sum_PTP_2P25G_MCQ.*\"\nNEW_SHA=\"sha256sum_PTP_2P25G_MCQ = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_SHA/$NEW_SHA/\" \"$FILE\"\n</code></pre> <p>After completing the previous step, rebuild the design as described in Build Yocto.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#programming","title":"Programming","text":"<p>If following User Flow 1, download the Prebuild Binaries. Ensure all steps under Hardware Setup are completed before proceeding.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#programming-the-sw-binary","title":"Programming the SW binary","text":"<p>The SD card image file <code>sdimage.tar.gz</code> is provided in the as part of the Prebuild Binaries, you may refer to Release Content for more information.</p> <p>Follow the instructions under \"Write SD Card\" in the HPS GSRD User Guide for the Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (4x F-Tile) to create two bootable SD cards using the provided image file.</p> <p>Insert the SD cards into each development kit.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#programming-the-hw-binary","title":"Programming the HW binary","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#program-the-onboard-max10-device","title":"Program the onboard MAX10 device","text":"<p>Using Quartus\u00ae Programmer Tool version 25.1.1 GUI, configure the onboard MAX10 device with <code>max10_system_0002aa4F.pof</code> from the pre-build binaries files.</p> <p>Alternatively, you can perform this operation via the command line. First, verify that all devices on the development kit are recognized and identify the JTAG cable number using the following command:</p> <pre><code>/home/user$ jtagconfig\n1) Agilex I-Series SOC Dev Kit on 10.244.179.132 [USB-1]\n6BA00477   S10HPS/AGILEX_HPS/N5X_HPS\n  0343B0DD   AGFB027R24C(.|B|C|R2|R0)/..\n  031830DD   10M16S(A|C|L)\n2) Agilex I-Series SOC Dev Kit on 10.244.179.132 [USB-2]\n6BA00477   S10HPS/AGILEX_HPS/N5X_HPS\n  0343B0DD   AGFB027R24C(.|B|C|R2|R0)/..\n  031830DD   10M16S(A|C|L)\n</code></pre> <p>From the <code>jtagconfig</code> output, two Agilex\u2122 7 Transceiver-SoC Development Kits are detected, with devices identified and assigned to cable 1 and cable 2.</p> <p>Configure the development kits from your host using the following command:</p> <pre><code>cd $TOP_FOLDER/bin\n# Update the -c parameter to match the JTAG cable numbers assigned to your development kits\nquartus_pgm -c 1 -m jtag -o \"p;./max10_system_0002aa4F.pof@3\" &amp;&amp; quartus_pgm -c 2 -m jtag -o \"p;./max10_system_0002aa4F.pof@3\"\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#program-the-onboard-agilex-7-device","title":"Program the onboard Agilex\u2122 7 device","text":"<p>Using Quartus\u00ae Programmer Tool version 25.1.1 GUI, configure the onboard <code>AGFB027R24C</code> device with <code>top.hps.rbf</code>. </p> <p>Alternatively, you can perform this operation via the command line. First, verify that all devices on the development kit are recognized and identify the JTAG cable number using the following command:</p> <pre><code>/home/user$ jtagconfig\n1) Agilex I-Series SOC Dev Kit on 10.244.179.132 [USB-1]\n6BA00477   S10HPS/AGILEX_HPS/N5X_HPS\n  0343B0DD   AGFB027R24C(.|B|C|R2|R0)/..\n  031830DD   10M16S(A|C|L)\n2) Agilex I-Series SOC Dev Kit on 10.244.179.132 [USB-2]\n6BA00477   S10HPS/AGILEX_HPS/N5X_HPS\n  0343B0DD   AGFB027R24C(.|B|C|R2|R0)/..\n  031830DD   10M16S(A|C|L)\n</code></pre> <p>From the <code>jtagconfig</code> output, two Agilex\u2122 7 Transceiver-SoC Development Kits are detected, with devices identified and assigned to cable 1 and cable 2.</p> <p>Configure the development kits from your host using the following command:</p> <pre><code>cd $TOP_FOLDER/bin\n# Update the -c parameter to match the JTAG cable numbers assigned to your development kits\n# If the Agilex 7 FPGA is in position 1, update the parameter after @ to reflect the correct device index.\nquartus_pgm -c 1 -m jtag -o \"p;./bin/top.hps.rbf@2\" &amp;&amp; quartus_pgm -c 2 -m jtag -o \"p;./bin/top.hps.rbf@2\"\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#linux-boot","title":"Linux Boot","text":"<p>On the HPS UART (Minicom connection), you\u2019ll observe the HPS booting Linux from the SD card. Once booted, log in with username <code>root</code> and no password. The system is now ready for configuration.</p> <p>If everything is functioning correctly, each Minicom terminal will display boot messages from the HPS running Linux.</p> <pre><code>agilex7dksiagi027fc login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should r\ntesting and development purposes only. It is recommended that you crr\nown distribution for production use.\n\nroot@agilex7dksiagi027fc:~# uname -a\nLinux agilex7dksiagi027fc 6.12.19-altera-ptp-sed-release-R1.1\nroot@agilex7dksiagi027fc:~/scripts# cat /etc/os-release\nID=poky\nNAME=\"Poky (Yocto Project Reference Distro)\"\nVERSION=\"5.0.5 (scarthgap)\"\nVERSION_ID=5.0.5\nVERSION_CODENAME=\"scarthgap\"\nPRETTY_NAME=\"Poky (Yocto Project Reference Distro) 5.0.5 (scarthgap)\"\nCPE_NAME=\"cpe:/o:openembedded:poky:5.0.5\"\nroot@agilex7dksiagi027fc:~/scripts#\n</code></pre> <p>Repeat the same steps for the second Agilex\u2122 7 I-Series Transceiver-SoC Development Kit.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ethernet-link-status","title":"Ethernet Link Status","text":"<p>Check the network status on each Agilex\u2122 7 I-Series Transceiver-SoC Development Kit using the following command:</p> <pre><code>root@agilex7dksiagi027fc:~# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN 0\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever\n2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state0\n    link/ether 66:68:45:23:2d:d3 brd ff:ff:ff:ff:ff:ff\n3: teql0: &lt;NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 0\nlink/void 4: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state U0\n    link/ether 4a:e9:22:7c:86:00 brd ff:ff:ff:ff:ff:ff\n    inet 169.254.167.23/16 brd 169.254.255.255 scope global eth1\n       valid_lft forever preferred_lft forever\n    inet6 fe80::48e9:22ff:fe7c:8600/64 scope link proto kernel_ll valid_lft forever preferred_lft forever\n5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state U0\n    link/ether ae:1b:b7:7c:16:d0 brd ff:ff:ff:ff:ff:ff\n    inet 169.254.86.21/16 brd 169.254.255.255 scope global eth2\n       valid_lft forever preferred_lft forever\n    inet6 fe80::ac1b:b7ff:fe7c:16d0/64 scope link proto kernel_ll valid_lft forever preferred_lft forever\nroot@agilex7dksiagi027fc:~# </code></pre> <p>Three Ethernet interfaces will be listed in the output of <code>ip addr</code>:</p> <ol> <li><code>eth0</code> : HPS dedicated Ethernet interface (1Gbps)</li> <li><code>eth1</code> : 25G Ethernet Port (25Gbps)</li> <li><code>eth2</code> : 25G Ethernet Port (25Gbps)</li> </ol>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#initial-system-configuration","title":"Initial System Configuration","text":"<p>After booting on both development kits, the System Example design requires initialization of key components: DMA subsystem, User Logic (Packet Generator), Packet Switch, Egress QoS-TC, and Iperf. Two configuration methods are supported.</p> <ol> <li>One-step configuration via script</li> <li>Step-by-Step configuration of each interface.</li> </ol>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#configuration-via-script","title":"Configuration Via Script","text":"<p>For manual configuration, skip this section.</p> <p>The <code>2PortMCQ.sh</code> script is included in the Yocto rootfs image at <code>/home/root/scripts/</code>. It accepts a single numeric argument specifying the target development kit. Usage:</p> <pre><code>source ./2PortMCQ.sh &lt;development kit number&gt;\n</code></pre> <p>Valid argument values are <code>1</code> or <code>2</code>.</p> <p>Run the following command on Development Kit 1:</p> <pre><code>source ./2PortMCQ.sh 1\n</code></pre> <p>Expected output:</p> <pre><code>root@agilex7dksiagi027fc:~/scripts# source ./2PortMCQ.sh 1\nProgramming the Basic IP address...\nClearing old PTPBridge rules Port - 0...\nUIO device file found. Using /dev/uio2\nKey Flush successful...\nClearing old TC rules Port - 0...\nClearing old PTPBridge rules Port - 1...\nUIO device file found. Using /dev/uio2\nKey Flush successful...\nClearing old TC rules Port - 1...\nFlushing old IPv4 and IPv6 addresses and routes\nSetting DEVKIT to 1.\nRunning script for Devkit 1.\n    link/ether 66:68:45:23:2d:d3 brd ff:ff:ff:ff:ff:ff\n    link/ether 4a:e9:22:7c:86:00 brd ff:ff:ff:ff:ff:ff\n    link/ether ae:1b:b7:7c:16:d0 brd ff:ff:ff:ff:ff:ff\nProgramming the PTP Bridge Port - 0...\nProgramming the PTP Bridge Generic rule...\neth1 - 4a:e9:22:7c:86:00\nUIO device file found. Using /dev/uio2\nSetting Entry: Success\nCopying Keyfields: Port: 0 Key index: 0 Success\nSetting Result Register: 2. Success\nSetting Mask Register: Success\nSetting Mgmt Cntrl Register: Success\nWait till operation is done: Key Insertion successful...\nProgramming the PTP Bridge - Low priority rules...\nUIO device file found. Using /dev/uio2\nSetting Entry: Success\nCopying Keyfields: Port: 0 Key index: 1 Success\nSetting Result Register: 2. Success\nSetting Mask Register: Success\nSetting Mgmt Cntrl Register: Success\nWait till operation is done: Key Insertion successful...\nUIO device file found. Using /dev/uio2\nSetting Entry: Success\n\n&lt;-- output truncated --&gt;\n\nProgramming the IPV6 rules - Port 1\nSetting IPv6 local addresses\nUIO device file found. Using /dev/uio2\nSetting Entry: Success\nCopying Keyfields: Port: 1 Key index: 20 Success\nSetting Result Register: 2. Success\nSetting Mask Register: Success\nSetting Mgmt Cntrl Register: Success\nWait till operation is done: Key Insertion successful...\nUIO device file found. Using /dev/uio2\nSetting Entry: Success\nCopying Keyfields: Port: 1 Key index: 21 Success\nSetting Result Register: 2. Success\nSetting Mask Register: Success\nSetting Mgmt Cntrl Register: Success\nWait till operation is done: Key Insertion successful...\nTraffic Class Egress QOS programming - Port - eth1\nCreate QDisc...\nCreate Filters - PTP packets to DMA0...\nCreate Filters - IPERF 540X packets to DMA0...\nCreate Filters - IPERF 530X packets to DMA1...\nCreate Filters - IPERF 520X packets to DMA2...\nCreate Filters - ICMP packets to DMA2...\nTraffic Class Egress QOS programming - Port - eth2\nCreate QDisc...\nCreate Filters - PTP packets to DMA0...\nCreate Filters - IPERF 540X packets to DMA0...\nCreate Filters - IPERF 530X packets to DMA1...\nCreate Filters - IPERF 520X packets to DMA2...\nCreate Filters - ICMP packets to DMA2...\nConfiguration for Devkit 1 set\nroot@agilex7dksiagi027fc:~/scripts#\n</code></pre> <p>Configure Development Kit 2:</p> <pre><code>source ./2PortMCQ.sh 2\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#manual-configuration","title":"Manual Configuration","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#define-interrupt-core-handling","title":"Define Interrupt Core Handling","text":"<p>Set up SMP affinity for Ethernet interrupts to distribute handling across different CPUs.</p> <p>Execute the following commands on both development kits:</p> <pre><code>echo -e \"Programming the Basic IP address...\"\necho \"2\" &gt; /proc/irq/25/smp_affinity &amp;&amp; echo \"2\" &gt; /proc/irq/26/smp_affinity &amp;&amp; echo \"4\" &gt; /proc/irq/27/smp_affinity &amp;&amp; echo \"4\" &gt; /proc/irq/28/smp_affinity &amp;&amp; echo \"8\" &gt; /proc/irq/29/smp_affinity &amp;&amp; echo \"8\" &gt; /proc/irq/30/smp_affinity\necho \"1\" &gt; /proc/irq/31/smp_affinity &amp;&amp; echo \"1\" &gt; /proc/irq/32/smp_affinity &amp;&amp; echo \"2\" &gt; /proc/irq/33/smp_affinity &amp;&amp; echo \"2\" &gt; /proc/irq/34/smp_affinity &amp;&amp; echo \"4\" &gt; /proc/irq/35/smp_affinity &amp;&amp; echo \"4\" &gt; /proc/irq/36/smp_affinity\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#clear-old-configurations","title":"Clear Old Configurations","text":"<p>Clear existing Packet Switch TCAM keys, traffic class (TC) configurations, and any pre-existing IPv6 settings.</p> <p>Execute the following commands on both development kits:</p> <pre><code>echo -e \"Clearing old PTPBridge rules Port - 0...\"\nptpbridge --port 0 --flush-all-keys\necho -e \"Clearing old TC rules Port - 0...\"\ntc filter del dev eth1 egress\ntc qdisc del dev eth1 clsact\necho -e \"Clearing old PTPBridge rules Port - 1...\"\nptpbridge --port 1 --flush-all-keys\necho -e \"Clearing old TC rules Port - 1...\"\ntc filter del dev eth2 egress\ntc qdisc del dev eth2 clsact\n\necho -e \"Flushing old IPv4 and IPv6 addresses and routes\"\nip addres flush eth1 &amp;&amp; ip route flush dev eth1\nip -6 addres flush eth1 &amp;&amp; ip -6 route flush dev eth1\nip addres flush eth2 &amp;&amp; ip route flush dev eth2\nip -6 addres flush eth2 &amp;&amp; ip -6 route flush dev eth2\n</code></pre> <p>If no configuration is stored, the commands may return error messages. These errors are safe to ignore.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#set-ipv4-addresses","title":"Set IPv4 Addresses","text":"<p><code>eth1</code> and <code>eth2</code> are the Linux interface names assigned to Ethernet Subsystem IP ports 8 and 9, respectively. Both interfaces must be in the UP state and have IP addresses assigned. Use the following commands to overwrite the IP addresses and bring the interfaces up.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>ip link set eth1 up &amp;&amp; ip addr add 192.168.121.1 dev eth1 &amp;&amp; ip route add 192.168.121.0/24 dev eth1 src 192.168.121.1\nip link set eth2 up &amp;&amp; ip addr add 192.168.122.1 dev eth2 &amp;&amp; ip route add 192.168.122.0/24 dev eth2 src 192.168.122.1\n\nip addr | grep ether\n</code></pre> <p>Execute the following commands on development kit 2:</p> <pre><code>ip link set eth1 up &amp;&amp; ip addr add 192.168.121.2 dev eth1 &amp;&amp; ip route add 192.168.121.0/24 dev eth1 src 192.168.121.2\nip link set eth2 up &amp;&amp; ip addr add 192.168.122.2 dev eth2 &amp;&amp; ip route add 192.168.122.0/24 dev eth2 src 192.168.122.2\n\nip addr | grep ether\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-switch-rules","title":"Packet Switch Rules","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#generic-traffic-rules","title":"Generic Traffic Rules","text":"<p>The following rules configure the Packet Switch to route ping requests to the lowest priority DMA (DMA-2) on both Ethernet interfaces.</p> <pre><code>echo -e \"Programming the PTP Bridge Port - 0...\"\necho -e \"Programming the PTP Bridge Generic rule...\"\nptpbridge --port 0 --set-key --key-index 0 --dest-mac \"eth1\"  --result 0x2\necho -e \"Programming the PTP Bridge - Low priority rules...\"\nptpbridge --port 0 --set-key --key-index 1 --ethtype 0x0806 --result 0x2\nptpbridge --port 0 --set-key --key-index 2 --ethtype 0x0800 --protocol 0x01 --result 0x2\n\necho -e \"Programming the PTP Bridge Port - 1...\"\necho -e \"Programming the PTP Bridge Generic rule...\"\nptpbridge --port 1 --set-key --key-index 0 --dest-mac \"eth2\"  --result 0x2\necho -e \"Programming the PTP Bridge - Low priority rules...\"\nptpbridge --port 1 --set-key --key-index 1 --ethtype 0x0806 --result 0x2\nptpbridge --port 1 --set-key --key-index 2 --ethtype 0x0800 --protocol 0x01 --result 0x2\n</code></pre> <p>The first rule matches packets with a destination MAC address equal to that of the Ethernet interface. The second rule filters Ethernet frames with Ethertype set to IPv4 and the IPv4 protocol field set to ICMP. The final rule filters frames with Ethertype set to ARP.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#iperf3-synthetic-traffic-rules","title":"iPerf3 Synthetic Traffic Rules","text":"<p>iPerf3 is a tool for active measurement of maximum achievable bandwidth on IP networks. It can generate traffic between a client and server, with configurable parameters such as the network port used. The following rules assign a target DMA based on the network port of incoming Ethernet packets.</p> <pre><code>echo -e \"Programming the PTP Bridge Port - 0...\"\necho -e \"Programming the PTP Bridge - IPERF 540X to DMA0...\"\nptpbridge --port 0 --set-key --key-index 3 --ethtype 0x0800 --dest-port 5401 --result 0x0\nptpbridge --port 0 --set-key --key-index 4 --ethtype 0x0800 --dest-port 5402 --result 0x0\nptpbridge --port 0 --set-key --key-index 5 --ethtype 0x0800 --src-port 5401 --result 0x0\nptpbridge --port 0 --set-key --key-index 6 --ethtype 0x0800 --src-port 5402 --result 0x0\necho -e \"Programming the PTP Bridge - IPERF 530X to DMA1...\"\nptpbridge --port 0 --set-key --key-index 7 --ethtype 0x0800 --dest-port 5301 --result 0x1\nptpbridge --port 0 --set-key --key-index 8 --ethtype 0x0800 --dest-port 5302 --result 0x1\nptpbridge --port 0 --set-key --key-index 9 --ethtype 0x0800 --src-port 5301 --result 0x1\nptpbridge --port 0 --set-key --key-index 10 --ethtype 0x0800 --src-port 5302 --result 0x1\necho -e \"Programming the PTP Bridge - IPERF 520X to DMA2...\"\nptpbridge --port 0 --set-key --key-index 11 --ethtype 0x0800 --dest-port 5201 --result 0x2\nptpbridge --port 0 --set-key --key-index 12 --ethtype 0x0800 --dest-port 5202 --result 0x2\nptpbridge --port 0 --set-key --key-index 13 --ethtype 0x0800 --src-port 5201 --result 0x2\nptpbridge --port 0 --set-key --key-index 14 --ethtype 0x0800 --src-port 5202 --result 0x2\n\necho -e \"Programming the PTP Bridge Port - 1...\"\necho -e \"Programming the PTP Bridge - IPERF 540X to DMA0...\"\nptpbridge --port 1 --set-key --key-index 3 --ethtype 0x0800 --dest-port 5401 --result 0x0\nptpbridge --port 1 --set-key --key-index 4 --ethtype 0x0800 --dest-port 5402 --result 0x0\nptpbridge --port 1 --set-key --key-index 5 --ethtype 0x0800 --src-port 5401 --result 0x0\nptpbridge --port 1 --set-key --key-index 6 --ethtype 0x0800 --src-port 5402 --result 0x0\necho -e \"Programming the PTP Bridge - IPERF 530X to DMA1...\"\nptpbridge --port 1 --set-key --key-index 7 --ethtype 0x0800 --dest-port 5301 --result 0x1\nptpbridge --port 1 --set-key --key-index 8 --ethtype 0x0800 --dest-port 5302 --result 0x1\nptpbridge --port 1 --set-key --key-index 9 --ethtype 0x0800 --src-port 5301 --result 0x1\nptpbridge --port 1 --set-key --key-index 10 --ethtype 0x0800 --src-port 5302 --result 0x1\necho -e \"Programming the PTP Bridge - IPERF 520X to DMA2...\"\nptpbridge --port 1 --set-key --key-index 11 --ethtype 0x0800 --dest-port 5201 --result 0x2\nptpbridge --port 1 --set-key --key-index 12 --ethtype 0x0800 --dest-port 5202 --result 0x2\nptpbridge --port 1 --set-key --key-index 13 --ethtype 0x0800 --src-port 5201 --result 0x2\nptpbridge --port 1 --set-key --key-index 14 --ethtype 0x0800 --src-port 5202 --result 0x2\n</code></pre> <p>The commands above configure the Packet Switch to route all traffic using port 540X to DMA-0, 530X to DMA-1, and 520X to DMA-2.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ptp-traffic-rules","title":"PTP Traffic Rules","text":"<p>PTP Ethernet packets will be routed to the highest priority DMA (DMA-0) to keep the system time synchronized with the network time. Execute the following commands on both development kits to make both Ethernet interfaces prioritize the PTP traffic: </p> <pre><code>echo -e \"Programming the PTP Bridge Port - 0...\"\necho -e \"Programming the PTP Bridge - PTP Packets to DMA0...\"\nptpbridge --port 0 --set-key --key-index 15 --dest-mac \"01:80:C2:00:00:0E\" --result 0x0\nptpbridge --port 0 --set-key --key-index 16 --dest-mac \"01:1B:19:00:00:00\" --result 0x0\nptpbridge --port 0 --set-key --key-index 17 --ethtype 0x88F7 --result 0x0\nptpbridge --port 0 --set-key --key-index 18 --ethtype 0x88F8 --result 0x0\n\necho -e \"Programming the PTP Bridge Port - 1...\"\necho -e \"Programming the PTP Bridge - PTP Packets to DMA0...\"\nptpbridge --port 1 --set-key --key-index 15 --dest-mac \"01:80:C2:00:00:0E\" --result 0x0\nptpbridge --port 1 --set-key --key-index 16 --dest-mac \"01:1B:19:00:00:00\" --result 0x0\nptpbridge --port 1 --set-key --key-index 17 --ethtype 0x88F7 --result 0x0\nptpbridge --port 1 --set-key --key-index 18 --ethtype 0x88F8 --result 0x0\n</code></pre> <p>The commands above set rules to filter packets based on the destination address used for PTP broadcast messages and the protocol identifier encapsulated in the EtherType field of the Ethernet frame. The rules are applied to both Ethernet interfaces in this example, but there is an independent scheduler for each Ethernet interface, making it possible to have different rules for each one of them.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#packet-generator-traffic-rules","title":"Packet Generator Traffic Rules","text":"<p>The following set of rules defines the routing to the client ports where the system example design packet generators are connected.</p> <p>The <code>packetgenerator</code> commands set the source and destination MAC addresses to be used by each packet generator. Then, the <code>ptpbridge</code> is used to filter incoming Ethernet frames coming from the opposite development kit and route them to one of the user ports (user ports are represented by '0x8'). There are two additional commands to program the packet generator module with traffic configuration parameters.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>echo -e \"Programming the PTP Bridge - Port 0 User packets to User port...\"\npacketgenerator --device /dev/uio0 --dest-mac \"12:34:56:78:0A:2\" --src-mac \"12:34:56:78:0A:1\"\nptpbridge --set-key --port 0 --key-index 19 --dest-mac \"12:34:56:78:0A:1\" --result 0x8\necho -e \"Programming the PTP Bridge - Port 1 User packets to User port...\"\npacketgenerator --device /dev/uio1 --dest-mac \"12:34:56:78:0A:4\" --src-mac \"12:34:56:78:0A:3\"\nptpbridge --set-key --port 1 --key-index 19 --dest-mac \"12:34:56:78:0A:3\" --result 0x8\n\necho -e \"Programming the Packet Generator - Port 0\"\npacketgenerator --device /dev/uio0 --traffic false --dyn-pkt-mode true --fixed-gap true --pkt-len-mode 0x01 --num-idle-cycles 22 --packet-checker true --num-packets 0xFFFFFFFF --one-shot false --tx-pkt-size 1024 --tx-max-pkt-size 1024\necho -e \"Programming the Packet Generator - Port 1\"\npacketgenerator --device /dev/uio1 --traffic false --dyn-pkt-mode true --fixed-gap true --pkt-len-mode 0x01 --num-idle-cycles 22 --packet-checker true --num-packets 0xFFFFFFFF --one-shot false --tx-pkt-size 1024 --tx-max-pkt-size 1024\n</code></pre> <p>Execute the following commands on development kit 2:</p> <pre><code>echo -e \"Programming the PTP Bridge - Port 0 User packets to User port...\"\npacketgenerator --device /dev/uio0 --dest-mac \"12:34:56:78:0A:1\" --src-mac \"12:34:56:78:0A:2\"\nptpbridge --set-key --port 0 --key-index 19 --dest-mac \"12:34:56:78:0A:2\" --result 0x8\necho -e \"Programming the PTP Bridge - Port 1 User packets to User port...\"\npacketgenerator --device /dev/uio1 --dest-mac \"12:34:56:78:0A:3\" --src-mac \"12:34:56:78:0A:4\"\nptpbridge --set-key --port 1 --key-index 19 --dest-mac \"12:34:56:78:0A:4\" --result 0x8\n\necho -e \"Programming the Packet Generator - Port 0\"\npacketgenerator --device /dev/uio0 --traffic false --dyn-pkt-mode true --fixed-gap true --pkt-len-mode 0x01 --num-idle-cycles 22 --packet-checker true --num-packets 0xFFFFFFFF --one-shot false --tx-pkt-size 1024 --tx-max-pkt-size 1024\necho -e \"Programming the Packet Generator - Port 1\"\npacketgenerator --device /dev/uio1 --traffic false --dyn-pkt-mode true --fixed-gap true --pkt-len-mode 0x01 --num-idle-cycles 22 --packet-checker true --num-packets 0xFFFFFFFF --one-shot false --tx-pkt-size 1024 --tx-max-pkt-size 1024\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ipv6-traffic-rules","title":"IPv6 Traffic Rules","text":"<p>The next commands set set IPv6 addresses and update the routing table  for both ethernet interfaces. Then, the <code>ptpbridge</code> rules define that that IPv6 ping requests needs to be channeled to the lowest-priority DMA (DMA-2) on both Ethernet interfaces.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>echo -e \"Programming the IPV6 rules - Port 0\"\necho -e \"Setting IPv6 local addresses\"\nip -6 addr add 2001:db8:abcd:0012::1/64 dev eth1 &amp;&amp; ip link set dev eth1 up\nsleep 2\nip -6 route add 2001:db8:abcd:0012::1/64 dev eth1 src 2001:db8:abcd:0012::1\n\nptpbridge --port 0 --set-key --key-index 20 --ethtype 0x86DD --result 0x2\nptpbridge --port 0 --set-key --key-index 21 --ethtype 0x86DD --protocol 0x3A  --result 0x2\n\necho -e \"Programming the IPV6 rules - Port 1\"\necho -e \"Setting IPv6 local addresses\"\nip -6 addr add 2001:db8:abcd:0013::1/64 dev eth2 &amp;&amp; ip link set dev eth2 up\nsleep 2\nip -6 route add 2001:db8:abcd:0013::1/64 dev eth2 src 2001:db8:abcd:0013::1\n\nptpbridge --port 1 --set-key --key-index 20 --ethtype 0x86DD --result 0x2\nptpbridge --port 1 --set-key --key-index 21 --ethtype 0x86DD --protocol 0x3A  --result 0x2\n</code></pre> <p>Execute the following commands on development kit 2:</p> <pre><code>echo -e \"Programming the IPV6 rules - Port 0\"\necho -e \"Setting IPv6 local addresses\"\nip -6 addr add 2001:db8:abcd:0012::2/64 dev eth1 &amp;&amp; ip link set dev eth1 up\nsleep 2\nip -6 route add 2001:db8:abcd:0012::2/64 dev eth1 src 2001:db8:abcd:0012::2\n\nptpbridge --port 0 --set-key --key-index 20 --ethtype 0x86DD --result 0x2\nptpbridge --port 0 --set-key --key-index 21 --ethtype 0x86DD --protocol 0x3A  --result 0x2\n\necho -e \"Programming the IPV6 rules - Port 1\"\necho -e \"Setting IPv6 local addresses\"\nip -6 addr add 2001:db8:abcd:0013::2/64 dev eth2 &amp;&amp; ip link set dev eth2 up\nsleep 2\nip -6 route add 2001:db8:abcd:0013::2/64 dev eth2 src 2001:db8:abcd:0013::2\n\nptpbridge --port 1 --set-key --key-index 20 --ethtype 0x86DD --result 0x2\nptpbridge --port 1 --set-key --key-index 21 --ethtype 0x86DD --protocol 0x3A  --result 0x2\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#traffic-classes","title":"Traffic Classes","text":"<p>Egress QoS is implemented using the Linux TC (Traffic Control) subsystem alongside the network stack.</p> <p>The next steps define a qdisc-based TC configuration, which can be paired with filters to route egress packets to specific DMA paths. Packet routing is determined by the <code>skb</code>-&gt;priority field, which must be set according to test requirements. Execute the following commands on both development kits.</p> <p>The <code>tc</code> filters define:</p> <p>tc filters route traffic as follows:</p> <ul> <li>PTP and iPerf3 on port 540X \u2192 DMA 0</li> <li>iPerf3 on port 530X \u2192 DMA 1</li> <li>iPerf3 on port 520X and ICMP (ping) \u2192 DMA 2</li> </ul> <pre><code>echo -e \"Traffic Class Egress QOS programming - Port - eth1\"\necho -e \"Create QDisc...\"\ntc qdisc add dev eth1 clsact\necho -e \"Create Filters - PTP packets to DMA0...\"\nMAC1_ADDR=\"01:80:C2:00:00:0E\"\nMAC1_HEX=$(echo $MAC1_ADDR | sed 's/://g' | tr 'a-f' 'A-F')\nMAC2_ADDR=\"01:1B:19:00:00:00\"\nMAC2_HEX=$(echo $MAC2_ADDR | sed 's/://g' | tr 'a-f' 'A-F')\ntc filter add dev eth1 egress prio 0 u32 match ip dport 319 0xffff match ip protocol 17 0xff action skbedit priority 0\ntc filter add dev eth1 egress prio 0 u32 match ip dport 320 0xffff match ip protocol 17 0xff action skbedit priority 0\ntc filter add dev eth1 egress prio 0 u32 match u16 0x${MAC1_HEX:0:4} 0xFFFF at -14 match u32 0x${MAC1_HEX:4:8} 0xFFFFFFFF at -12 action skbedit priority 0\ntc filter add dev eth1 egress prio 0 u32 match u16 0x${MAC2_HEX:0:4} 0xFFFF at -14 match u32 0x${MAC2_HEX:4:8} 0xFFFFFFFF at -12 action skbedit priority 0\necho -e \"Create Filters - IPERF 540X packets to DMA0...\"\ntc filter add dev eth1 egress prio 0 u32 match ip dport 5401 0xffff match ip protocol 6 0xff action skbedit priority 0\ntc filter add dev eth1 egress prio 0 u32 match ip sport 5401 0xffff match ip protocol 6 0xff action skbedit priority 0\necho -e \"Create Filters - IPERF 530X packets to DMA1...\"\ntc filter add dev eth1 egress prio 0 u32 match ip dport 5301 0xffff match ip protocol 6 0xff action skbedit priority 1\ntc filter add dev eth1 egress prio 0 u32 match ip sport 5301 0xffff match ip protocol 6 0xff action skbedit priority 1\necho -e \"Create Filters - IPERF 520X packets to DMA2...\"\ntc filter add dev eth1 egress prio 0 u32 match ip dport 5201 0xffff match ip protocol 6 0xff action skbedit priority 2\ntc filter add dev eth1 egress prio 0 u32 match ip sport 5201 0xffff match ip protocol 6 0xff action skbedit priority 2\necho -e \"Create Filters - ICMP packets to DMA2...\"\ntc filter add dev eth1 egress prio 0 u32 match ip protocol 1 0xff action skbedit priority 2\necho -e \"Traffic Class Egress QOS programming - Port - eth2\"\necho -e \"Create QDisc...\"\ntc qdisc add dev eth2 clsact\necho -e \"Create Filters - PTP packets to DMA0...\"\ntc filter add dev eth2 egress prio 0 u32 match ip dport 319 0xffff match ip protocol 17 0xff action skbedit priority 0\ntc filter add dev eth2 egress prio 0 u32 match ip dport 320 0xffff match ip protocol 17 0xff action skbedit priority 0\ntc filter add dev eth2 egress prio 0 u32 match u16 0x${MAC1_HEX:0:4} 0xFFFF at -14 match u32 0x${MAC1_HEX:4:8} 0xFFFFFFFF at -12 action skbedit priority 0\ntc filter add dev eth2 egress prio 0 u32 match u16 0x${MAC2_HEX:0:4} 0xFFFF at -14 match u32 0x${MAC2_HEX:4:8} 0xFFFFFFFF at -12 action skbedit priority 0\necho -e \"Create Filters - IPERF 540X packets to DMA0...\"\ntc filter add dev eth2 egress prio 0 u32 match ip dport 5401 0xffff match ip protocol 6 0xff action skbedit priority 0\ntc filter add dev eth2 egress prio 0 u32 match ip sport 5401 0xffff match ip protocol 6 0xff action skbedit priority 0\necho -e \"Create Filters - IPERF 530X packets to DMA1...\"\ntc filter add dev eth2 egress prio 0 u32 match ip dport 5301 0xffff match ip protocol 6 0xff action skbedit priority 1\ntc filter add dev eth2 egress prio 0 u32 match ip sport 5301 0xffff match ip protocol 6 0xff action skbedit priority 1\necho -e \"Create Filters - IPERF 520X packets to DMA2...\"\ntc filter add dev eth2 egress prio 0 u32 match ip dport 5201 0xffff match ip protocol 6 0xff action skbedit priority 2\ntc filter add dev eth2 egress prio 0 u32 match ip sport 5201 0xffff match ip protocol 6 0xff action skbedit priority 2\necho -e \"Create Filters - ICMP packets to DMA2...\"\ntc filter add dev eth2 egress prio 0 u32 match ip protocol 1 0xff action skbedit priority 2\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ethernet-connectivity-test","title":"Ethernet Connectivity Test","text":"<p>After finishing the Initial System Configuration, verify the network connectivity between both development kits with the next steps.</p> <p>Confirm both Ethernet interfaces are up in both development kits:</p> <p>Execute the following commands on development kit 1:</p> <pre><code>root@agilex7dksiagi027fc:~# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever\n2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen0\n    link/ether c2:15:53:59:8b:9f brd ff:ff:ff:ff:ff:ff\n3: teql0: &lt;NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 100\nlink/void 4: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\nlink/ether a2:0a:92:62:93:4c brd ff:ff:ff:ff:ff:ff\n    inet 192.168.121.1/32 scope global eth1\n       valid_lft forever preferred_lft forever\n    inet6 2001:db8:abcd:12::1/64 scope global valid_lft forever preferred_lft forever\n5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\nlink/ether 86:28:4b:90:11:dd brd ff:ff:ff:ff:ff:ff\n    inet 192.168.122.1/32 scope global eth2\n       valid_lft forever preferred_lft forever\n    inet6 2001:db8:abcd:13::1/64 scope global valid_lft forever preferred_lft forever\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>Execute the following commands on development kit 2:</p> <pre><code>root@agilex7dksiagi027fc:~# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever\n2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen0\n    link/ether fa:06:aa:f6:2b:48 brd ff:ff:ff:ff:ff:ff\n3: teql0: &lt;NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 100\nlink/void 4: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\nlink/ether be:3b:79:e1:0d:ac brd ff:ff:ff:ff:ff:ff\n    inet 192.168.121.2/32 scope global eth1\n       valid_lft forever preferred_lft forever\n    inet6 2001:db8:abcd:12::2/64 scope global valid_lft forever preferred_lft forever\n5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\nlink/ether e2:4c:47:71:75:4c brd ff:ff:ff:ff:ff:ff\n    inet 192.168.122.2/32 scope global eth2\n       valid_lft forever preferred_lft forever\n    inet6 2001:db8:abcd:13::2/64 scope global valid_lft forever preferred_lft forever\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>Verify connectivity between development kits using <code>ping</code>:</p> <p>Execute the following commands on development kit 1:</p> <pre><code>root@agilex7dksiagi027fc:~# ping -c 3 192.168.121.2                             PING 192.168.121.2 (192.168.121.2): 56 data bytes\n64 bytes from 192.168.121.2: seq=0 ttl=64 time=0.298 ms\n64 bytes from 192.168.121.2: seq=1 ttl=64 time=0.196 ms\n64 bytes from 192.168.121.2: seq=2 ttl=64 time=0.102 ms\n\n--- 192.168.121.2 ping statistics ---\n3 packets transmitted, 3 packets received, 0% packet loss\nround-trip min/avg/max = 0.102/0.198/0.298 ms\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>Execute the following commands on development kit 2:</p> <pre><code>root@agilex7dksiagi027fc:~# ping -c 3 192.168.121.1                             PING 192.168.121.1 (192.168.121.1): 56 data bytes\n64 bytes from 192.168.121.1: seq=0 ttl=64 time=0.421 ms\n64 bytes from 192.168.121.1: seq=1 ttl=64 time=0.124 ms\n64 bytes from 192.168.121.1: seq=2 ttl=64 time=0.117 ms\n\n--- 192.168.121.1 ping statistics ---\n3 packets transmitted, 3 packets received, 0% packet loss\nround-trip min/avg/max = 0.117/0.220/0.421 ms\nroot@agilex7dksiagi027fc:~#\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#testing","title":"Testing","text":"<p>Before running a test, ensure the hardware setup matches the Hardware Setup section, and you have executed the steps listed in Initial System Configuration.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#run-ping-test","title":"Run Ping Test","text":"<p>The transcript below shows a ping test from development kit 1 serial session. 100,000 pings are sent to development kit 2. DMA-2 handles egress traffic, verified by polling its interrupt count. As shown, all ping requests were correctly filtered to DMA-2.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>root@agilex7dksiagi027fc:~# ping -i 0.0001 -q -c 100000 -I eth1 192.168.121.2\nPING 192.168.121.2 (192.168.121.2): 56 data bytes\n\n--- 192.168.121.2 ping statistics ---\n100000 packets transmitted, 99997 packets received, 3 duplicates, 0% packet loss\nround-trip min/avg/max = 0.065/0.091/3.259 ms\nroot@agilex7dksiagi027fc:~# cat /proc/interrupts | grep eth1\n25:         57          0          0          0     GICv2  72 Level     eth1\n26:          0          0          0          0     GICv2  73 Level     eth1\n27:          0          0          0          0     GICv2  70 Level     eth1\n28:          0          0          0          0     GICv2  71 Level     eth1\n29:         11          0     100005          0     GICv2  68 Level     eth1\n30:          0          0     100008          0     GICv2  69 Level     eth1\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>Execute the following commands on development kit 2:</p> <pre><code>root@agilex7dksiagi027fc:~# ping -i 0.0001 -q -c 100000 -I eth1 192.168.121.1\nPING 192.168.121.1 (192.168.121.1): 56 data bytes\n\n--- 192.168.121.1 ping statistics ---\n100000 packets transmitted, 99990 packets received, 10 duplicates, 0% packet loss\nround-trip min/avg/max = 0.064/0.090/2.565 ms\nroot@agilex7dksiagi027fc:~# cat /proc/interrupts | grep eth1\n 31:         36          0          0         44     GICv2  66 Level     eth1\n 32:          0          0          0          0     GICv2  67 Level     eth1\n 33:          0          0          0          0     GICv2  64 Level     eth1\n 34:          0          0          0          0     GICv2  65 Level     eth1\n 35:         11     100015          0          0     GICv2  62 Level     eth1\n 36:          0     100007          0          0     GICv2  63 Level     eth1\nroot@agilex7dksiagi027fc:~#\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#run-iperf3-test","title":"Run iPerf3 Test","text":"<p>The iPerf3 test uses development kit 2 as the server and development kit 1 as the client. Start the iPerf3 server on kit 2 with parallel instances listening on ports 5201, 5301, and 5401.</p> <p>Execute the following commands on development kit 2:</p> <pre><code>iperf3 -D -s -B 192.168.121.2 -p 5201 &gt; /var/log/iperf.eth1.1 2&gt;&amp;1 &amp;\niperf3 -D -s -B 192.168.121.2 -p 5301 &gt; /var/log/iperf.eth1.2 2&gt;&amp;1 &amp;\niperf3 -D -s -B 192.168.121.2 -p 5401 &gt; /var/log/iperf.eth1.3 2&gt;&amp;1 &amp;\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#iperf-traffic-to-dma-0","title":"iPerf traffic to DMA 0","text":"<p>The transcript below shows an iPerf3 test from development kit 1, targeting port 5401 on the server and using port 5402 locally. DMA-0 usage (highest priority) is confirmed by the interrupt count on its associated queue.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>root@agilex7dksiagi027fc:~# iperf3 -M 1460 -c 192.168.121.2 -t 80000 -p 5401 --cport 5402\nConnecting to host 192.168.121.2, port 5401\n[  5] local 192.168.121.1 port 5402 connected to 192.168.121.2 port 5401\n[ ID] Interval           Transfer     Bitrate         Retr  Cwnd\n[  5]   0.00-1.00   sec  64.8 MBytes   543 Mbits/sec   32    158 KBytes       [  5]   1.00-2.00   sec  63.9 MBytes   536 Mbits/sec   38    119 KBytes       [  5]   2.00-3.00   sec  64.1 MBytes   537 Mbits/sec   29    153 KBytes       [  5]   3.00-4.00   sec  64.5 MBytes   541 Mbits/sec   35    144 KBytes       [  5]   4.00-5.00   sec  63.9 MBytes   536 Mbits/sec   25    146 KBytes       [  5]   5.00-6.00   sec  64.1 MBytes   538 Mbits/sec   26    120 KBytes       [  5]   6.00-7.00   sec  64.2 MBytes   539 Mbits/sec   36    150 KBytes       [  5]   7.00-8.00   sec  64.4 MBytes   540 Mbits/sec   23    148 KBytes       [  5]   8.00-9.00   sec  64.6 MBytes   542 Mbits/sec   39    120 KBytes       [  5]   9.00-10.00  sec  64.0 MBytes   537 Mbits/sec   37    148 KBytes       [  5]  10.00-11.00  sec  64.4 MBytes   540 Mbits/sec   56    154 KBytes       [  5]  11.00-11.38  sec  24.2 MBytes   534 Mbits/sec    8    141 KBytes       - - - - - - - - - - - - - - - - - - - - - - - - -\n[ ID] Interval           Transfer     Bitrate         Retr\n[  5]   0.00-11.38  sec   732 MBytes   539 Mbits/sec  384            sender\n[  5]   0.00-11.38  sec  0.00 Bytes  0.00 bits/sec                  receiver\niperf3: interrupt - the client has terminated\nroot@agilex7dksiagi027fc:~#\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#iperf-traffic-to-dma-1","title":"iPerf traffic to DMA 1","text":"<p>The transcript below shows an iPerf3 test from development kit 1, targeting port 5301 on the server and using port 5302 locally. DMA-1 usage is confirmed by the interrupt count on its associated queue.</p> <pre><code>root@agilex7dksiagi027fc:~# iperf3 -M 1460 -c 192.168.121.2 -t 80000 -p 5301 --cport 5302\nConnecting to host 192.168.121.2, port 5301\nConnecting to host 192.168.121.2, port 5301\n[  5] local 192.168.121.1 port 5302 connected to 192.168.121.2 port 5301\n[ ID] Interval           Transfer     Bitrate         Retr  Cwnd\n[  5]   0.00-1.00   sec  65.0 MBytes   544 Mbits/sec   35    115 KBytes       [  5]   1.00-2.00   sec  65.2 MBytes   547 Mbits/sec   28    158 KBytes       [  5]   2.00-3.00   sec  64.2 MBytes   539 Mbits/sec   42    158 KBytes       [  5]   3.00-4.00   sec  64.5 MBytes   541 Mbits/sec   36    141 KBytes       [  5]   4.00-5.00   sec  64.4 MBytes   540 Mbits/sec   22    137 KBytes       [  5]   5.00-6.00   sec  63.6 MBytes   533 Mbits/sec   39    147 KBytes       [  5]   6.00-7.00   sec  63.9 MBytes   536 Mbits/sec   42    157 KBytes       [  5]   7.00-8.00   sec  63.8 MBytes   535 Mbits/sec   23    150 KBytes       [  5]   8.00-9.00   sec  64.1 MBytes   538 Mbits/sec   42    143 KBytes       [  5]   9.00-10.00  sec  64.8 MBytes   543 Mbits/sec   39    151 KBytes       [  5]  10.00-10.81  sec  51.0 MBytes   531 Mbits/sec   18    116 KBytes       - - - - - - - - - - - - - - - - - - - - - - - - -\n[ ID] Interval           Transfer     Bitrate         Retr\n[  5]   0.00-10.81  sec   695 MBytes   539 Mbits/sec  366            sender\n[  5]   0.00-10.81  sec  0.00 Bytes  0.00 bits/sec                  receiver\niperf3: interrupt - the client has terminated\n\nroot@agilex7dksiagi027fc:~# cat /proc/interrupts | grep eth1\n 25:     415767          0          0          0     GICv2  72 Level     eth1\n 26:     365267          0          0          0     GICv2  73 Level     eth1\n 27:          0     186195          0          0     GICv2  70 Level     eth1\n 28:          0      38260          0          0     GICv2  71 Level     eth1\n 29:         11          0     100011          0     GICv2  68 Level     eth1\n 30:          0          0     100018          0     GICv2  69 Level     eth1\nroot@agilex7dksiagi027fc:~#\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#iperf-traffic-to-dma-2","title":"iPerf traffic to DMA 2","text":"<p>The transcript below shows an iPerf3 test from development kit 1 using port 5201 on the server and 5202 on the client. DMA-2 usage (lowest priority) is confirmed by the interrupt count on its associated queue.</p> <pre><code>root@agilex7dksiagi027fc:~# iperf3 -M 1460 -c 192.168.121.2 -t 80000 -p 5201 --cport 5202    Connecting to host 192.168.121.2, port 5201\n[  5] local 192.168.121.1 port 5202 connected to 192.168.121.2 port 5201\n[ ID] Interval           Transfer     Bitrate         Retr  Cwnd\n[  5]   0.00-1.00   sec  66.1 MBytes   554 Mbits/sec   39    116 KBytes       [  5]   1.00-2.00   sec  64.4 MBytes   540 Mbits/sec   51    123 KBytes       [  5]   2.00-3.00   sec  64.6 MBytes   542 Mbits/sec   23    146 KBytes       [  5]   3.00-4.00   sec  64.0 MBytes   537 Mbits/sec   40    146 KBytes       [  5]   4.00-5.00   sec  63.9 MBytes   536 Mbits/sec   34    154 KBytes       [  5]   5.00-6.00   sec  64.8 MBytes   543 Mbits/sec   46    144 KBytes       [  5]   6.00-7.00   sec  64.4 MBytes   540 Mbits/sec   34    156 KBytes       [  5]   7.00-8.00   sec  63.4 MBytes   532 Mbits/sec   28    168 KBytes       [  5]   8.00-9.00   sec  63.9 MBytes   536 Mbits/sec   34    130 KBytes       [  5]   9.00-10.00  sec  64.2 MBytes   539 Mbits/sec   25    158 KBytes       [  5]  10.00-11.00  sec  64.2 MBytes   539 Mbits/sec   35    160 KBytes       [  5]  11.00-11.34  sec  22.0 MBytes   546 Mbits/sec   22    119 KBytes       - - - - - - - - - - - - - - - - - - - - - - - - -\n[ ID] Interval           Transfer     Bitrate         Retr\n[  5]   0.00-11.34  sec   730 MBytes   540 Mbits/sec  411            sender\n[  5]   0.00-11.34  sec  0.00 Bytes  0.00 bits/sec                  receiver\niperf3: interrupt - the client has terminated\n\nroot@agilex7dksiagi027fc:~# cat /proc/interrupts | grep eth1\n 25:     415790          0          0          0     GICv2  72 Level     eth1\n 26:     365267          0          0          0     GICv2  73 Level     eth1\n 27:          0     186195          0          0     GICv2  70 Level     eth1\n 28:          0      38260          0          0     GICv2  71 Level     eth1\n 29:         11          0     315979          0     GICv2  68 Level     eth1\n 30:          0          0     133629          0     GICv2  69 Level     eth1\nroot@agilex7dksiagi027fc:~#\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#run-packet-generator-test","title":"Run Packet Generator Test","text":"<p>System packet generators operate independently of the HPS and DMA engines. Their datapath traverses the Packet Switch and can saturate the 25GbE ports. No <code>tc</code> filters apply, as they are not HPS-connected and not software-controlled. Bandwidth allocation is managed solely by the Packet Switch arbiter.</p> <p>Test execution involves configuring traffic parameters for the generators. The transcript below shows initial setup and traffic start. The <code>--dump</code> flag captures packet generator status registers, indicating TX bandwidth utilization of ~25.35 Gbps.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>root@agilex7dksiagi027fc:~# packetgenerator --device /dev/uio0 --traffic false --dyn-pkt-mode true --fixed-gap true --pkt-len-mode 0x01 --num-idle-cycles 8 --packet-checker true  --one-shot false --tx-pkt-size 1024 --tx-max-pkt-size 1024\nTx traffic state set: Disabled\nDynamic Packet Mode set: Enabled\nFixed Gap set: Enabled\nPacket length mode set: 1\nNumber of Idle Cycles set: 8\nPkt Checker set: Enabled\nOne Shot mode set: Disabled\nTx Packet Size set: 1024\nMax Tx Packet Size set: 1024\nroot@agilex7dksiagi027fc:~# packetgenerator --device /dev/uio0 --traffic 1\nTx traffic state set: Enabled\nroot@agilex7dksiagi027fc:~# packetgenerator --device /dev/uio0 --dump\nConfig Control: 0x8635\n        Tx traffic: Enabled\n        Packet Generation Mode: Continuous Soft Reset: Disabled\n        Dynamic Mode: Enabled\n        Pkt Checker: Enabled\n        Counter Snapshot Status: Disabled\n        Counter Clear Status: Disabled\n        Internal Counter Clear Status: Disabled\n        Fixed Gap: Enabled\n        Packet Length Mode: Fixed\n        Number of Idle Cycles: 8\nDestination Mac Address: 12:34:56:78:0A:02\nSource Mac Address: 12:34:56:78:0A:01\nNumber of Packets: 4294967295\nPacket Size Config Control: 0x4000400\n        Tx Packet Size: 1024 Tx Max Packet Size: 1024\nPacket Generator Status: 0x1e\n        SADB configuration status: Incomplete\n        System Reset Sequence status: Complete\n        HSSI SS tx_lanes_stable status: Asserted\n        HSSI SS tx_pll_locked status: Asserted\n        HSSI SS rx_pcs status: Asserted\nPacket Checker Status: 0x0\n        Data Mismatch status: Not seen\nTX Start of Packet Count: 37451629\nTX End of Packet Count: 37451846\nTX Error Packet Count: 0\nRX Start of Packet Count: 0\nRX End of Packet Count: 0\nRX Error Packet Count: 0\nPkt Checker Live Counter: 0\nPKT TX Byte Count: 39656528320\nPKT RX Byte Count: 0\nPKT TX Num Ticks Count: 4957121724\nPKT RX Num Ticks Count: 0\nTX Bandwidth: 25358344768 bps\nRX Bandwidth: 0 bps\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>TX bandwidth utilization can be tuned by adjusting packet length and idle cycles. The transcript below modifies the number of idle cycles between packets in flight. The change is verified via a read of the packet generator status registers, which shows a maximum bandwidth of ~23.61 Gbps.</p> <pre><code>root@agilex7dksiagi027fc:~# packetgenerator --device /dev/uio0 --num-idle-cycles 16 --tx-pkt-size 1024 --tx-max-pkt-size 1024\nNumber of Idle Cycles set: 16\nTx Packet Size set: 1024\nMax Tx Packet Size set: 1024\nroot@agilex7dksiagi027fc:~# packetgenerator --device /dev/uio0 --dump Config Control: 0x10635\n        Tx traffic: Enabled\n        Packet Generation Mode: Continuous Soft Reset: Disabled\n        Dynamic Mode: Enabled\n        Pkt Checker: Enabled\n        Counter Snapshot Status: Disabled\n        Counter Clear Status: Disabled\n        Internal Counter Clear Status: Disabled\n        Fixed Gap: Enabled\n        Packet Length Mode: Fixed\n        Number of Idle Cycles: 16\nDestination Mac Address: 12:34:56:78:0A:02\nSource Mac Address: 12:34:56:78:0A:01\nNumber of Packets: 4294967295\nPacket Size Config Control: 0x4000400\n        Tx Packet Size: 1024 Tx Max Packet Size: 1024\nPacket Generator Status: 0x1e\n        SADB configuration status: Incomplete\n        System Reset Sequence status: Complete\n        HSSI SS tx_lanes_stable status: Asserted\n        HSSI SS tx_pll_locked status: Asserted\n        HSSI SS rx_pcs status: Asserted\nPacket Checker Status: 0x0\n        Data Mismatch status: Not seen\nTX Start of Packet Count: 559732907\nTX End of Packet Count: 559733116\nTX Error Packet Count: 0\nRX Start of Packet Count: 0\nRX End of Packet Count: 0\nRX Error Packet Count: 0\nPkt Checker Live Counter: 0\nPKT TX Byte Count: 591628496376\nPKT RX Byte Count: 0\nPKT TX Num Ticks Count: 73953613933\nPKT RX Num Ticks Count: 0\nTX Bandwidth: 23615146240 bps\nRX Bandwidth: 0 bps\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>Enabling the packet generator on the second development kit starts the integrated packet checker and reports RX bandwidth. The transcript below shows the status change after activation.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>root@agilex7dksiagi027fc:~# packetgenerator --device /dev/uio0 --dump\nConfig Control: 0x16634\n        Tx traffic: Disabled\n        Packet Generation Mode: Continuous Soft Reset: Disabled\n        Dynamic Mode: Enabled\n        Pkt Checker: Enabled\n        Counter Snapshot Status: Disabled\n        Counter Clear Status: Disabled\n        Internal Counter Clear Status: Disabled\n        Fixed Gap: Enabled\n        Packet Length Mode: Fixed\n        Number of Idle Cycles: 22\nDestination Mac Address: 12:34:56:78:0A:01\nSource Mac Address: 12:34:56:78:0A:02\nNumber of Packets: 4294967295\nPacket Size Config Control: 0x4000400\n        Tx Packet Size: 1024 Tx Max Packet Size: 1024\nPacket Generator Status: 0x1e\n        SADB configuration status: Incomplete\n        System Reset Sequence status: Complete\n        HSSI SS tx_lanes_stable status: Asserted\n        HSSI SS tx_pll_locked status: Asserted\n        HSSI SS rx_pcs status: Asserted\nPacket Checker Status: 0x0\n        Data Mismatch status: Not seen\nTX Start of Packet Count: 0\nTX End of Packet Count: 0\nTX Error Packet Count: 0\nRX Start of Packet Count: 1136848921\nRX End of Packet Count: 1136849121\nRX Error Packet Count: 0\nPkt Checker Live Counter: 1136849343\nPKT TX Byte Count: 0\nPKT RX Byte Count: 0\nPKT TX Num Ticks Count: 0\nPKT RX Num Ticks Count: 0\nTX Bandwidth: 0 bps\nRX Bandwidth: 23615150848 bps\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>RX bandwidth is reported to be ~23.61 Gbps.</p> <p>To fully saturate an Ethernet port, run the following commands on both development kits to enable their respective packet generators:</p> <pre><code>packetgenerator --device /dev/uio0 --num-idle-cycles 16 --tx-pkt-size 1024 --tx-max-pkt-size 1024\npacketgenerator --device /dev/uio0 --traffic 1\n</code></pre> <p>Both development kits are now transmitting and receiving Ethernet traffic on port 1. Run a status dump on either kit to report bandwidth utilization:</p> <pre><code>root@agilex7dksiagi027fc:~/scripts# packetgenerator --device /dev/uio0 --dump\nConfig Control: 0x8635\n        Tx traffic: Enabled\n        Packet Generation Mode: Continuous Soft Reset: Disabled\n        Dynamic Mode: Enabled\n        Pkt Checker: Enabled\n        Counter Snapshot Status: Disabled\n        Counter Clear Status: Disabled\n        Internal Counter Clear Status: Disabled\n        Fixed Gap: Enabled\n        Packet Length Mode: Fixed\n        Number of Idle Cycles: 8\nDestination Mac Address: 12:34:56:78:0A:02\nSource Mac Address: 12:34:56:78:0A:01\nNumber of Packets: 4294967295\nPacket Size Config Control: 0x4000400\n        Tx Packet Size: 1024 Tx Max Packet Size: 1024\nPacket Generator Status: 0x1e\n        SADB configuration status: Incomplete\n        System Reset Sequence status: Complete\n        HSSI SS tx_lanes_stable status: Asserted\n        HSSI SS tx_pll_locked status: Asserted\n        HSSI SS rx_pcs status: Asserted\nPacket Checker Status: 0x0\n        Data Mismatch status: Not seen\nTX Start of Packet Count: 249401806\nTX End of Packet Count: 249402022\nTX Error Packet Count: 0\nRX Start of Packet Count: 43882945\nRX End of Packet Count: 43883143\nRX Error Packet Count: 0\nPkt Checker Live Counter: 43883467\nPKT TX Byte Count: 264077193064\nPKT RX Byte Count: 44937076872\nPKT TX Num Ticks Count: 33009703937\nPKT RX Num Ticks Count: 6319335403\nTX Bandwidth: 25358377536 bps\nRX Bandwidth: 23615140544 bps\nroot@agilex7dksiagi027fc:~/scripts#\n</code></pre> <p>Both TX and RX channels are now active.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#run-ptp4l-test","title":"Run ptp4l Test","text":"<p>Development kit 1 acts as the network master; development kit 2 is the subordinate. Both are configured as ordinary clocks using ptp4l. Configuration files provided by the system example design are located at <code>/root/cfg/</code>.</p> <pre><code>root@agilex7dksiagi027fc:~# ls /root/cfg/\nboundary.cfg\nmaster.cfg\nslave.cfg\n</code></pre> <p>The transcript below configures development kit 1 as the network master.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>root@agilex7dksiagi027fc:~# ptp4l -i eth1 -m -f /root/cfg/master.cfg                        option slaveOnly is deprecated, please use clientOnly instead\noption masterOnly is deprecated, please use serverOnly instead\nptp4l[162.444]: selected /dev/ptp0 as PTP clock\nptp4l[162.504]: port 1 (eth1): INITIALIZING to LISTENING on INIT_COMPLETE\nptp4l[162.504]: port 0 (/var/run/ptp4l): INITIALIZING to LISTENING on INIT_COMPLETE\nptp4l[162.504]: port 0 (/var/run/ptp4lro): INITIALIZING to LISTENING on INIT_COMPLETE\nptp4l[162.904]: port 1 (eth1): LISTENING to MASTER on ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES\nptp4l[162.904]: selected local clock 52c803.fffe.45f11c as best master\nptp4l[162.904]: port 1 (eth1): assuming the grand master role\n</code></pre> <p>Development kit 2 loads <code>slave.cfg</code> to operate as the network slave.</p> <p>Execute the following commands on development kit 2:</p> <pre><code>root@agilex7dksiagi027fc:~# ptp4l -i eth1 -m -s -f /root/cfg/slave.cfg\noption slaveOnly is deprecated, please use clientOnly instead\noption masterOnly is deprecated, please use serverOnly instead\nptp4l[193.064]: selected /dev/ptp0 as PTP clock\nptp4l[193.124]: port 1 (eth1): INITIALIZING to LISTENING on INIT_COMPLETE\nptp4l[193.124]: port 0 (/var/run/ptp4l): INITIALIZING to LISTENING on INIT_COMPLETE\nptp4l[193.124]: port 0 (/var/run/ptp4lro): INITIALIZING to LISTENING on INIT_COMPLETE\nptp4l[193.246]: port 1 (eth1): new foreign master 52c803.fffe.45f11c-1\nptp4l[193.496]: selected best master clock 52c803.fffe.45f11c\nptp4l[193.496]: port 1 (eth1): LISTENING to UNCALIBRATED on RS_SLAVE\nptp4l[193.621]: master offset 2709964362 s0 freq      -0 path delay        10\nptp4l[193.684]: master offset 2709964348 s0 freq      -0 path delay        13\nptp4l[193.746]: master offset 2709964337 s0 freq      -0 path delay        12\nptp4l[193.809]: master offset 2709964326 s0 freq      -0 path delay        12\nptp4l[193.871]: master offset 2709964314 s0 freq      -0 path delay        13\nptp4l[193.934]: master offset 2709964306 s0 freq      -0 path delay         9\nptp4l[193.996]: master offset 2709964291 s0 freq      -0 path delay        12\nptp4l[194.059]: master offset 2709964281 s0 freq      -0 path delay        11\nptp4l[194.121]: master offset 2709964270 s0 freq      -0 path delay        10\nptp4l[194.184]: master offset 2709964257 s0 freq      -0 path delay        11\n&lt;-- output truncated --&gt;\n\nptp4l[253.727]: master offset          1 s0 freq      -0 path delay         8\nptp4l[253.775]: master offset          0 s0 freq      -0 path delay         8\nptp4l[253.792]: master offset          1 s0 freq      -0 path delay         7\nptp4l[253.838]: master offset          1 s0 freq      -0 path delay         7\nptp4l[253.854]: master offset          0 s0 freq      -0 path delay         8\nptp4l[253.900]: master offset          0 s0 freq      -0 path delay         8\nptp4l[253.918]: master offset          0 s0 freq      -0 path delay         8\nptp4l[253.964]: master offset          0 s0 freq      -0 path delay         8\nptp4l[253.984]: master offset          0 s0 freq      -0 path delay         8\nptp4l[254.028]: master offset          1 s2 freq      +0 path delay         7\nptp4l[254.028]: port 1 (eth1): UNCALIBRATED to SLAVE on MASTER_CLOCK_SELECTED\nptp4l[254.044]: master offset          1 s2 freq      +1 path delay         7\nptp4l[254.110]: master offset          1 s2 freq      +1 path delay         7\nptp4l[254.155]: master offset          1 s2 freq      +1 path delay         7\nptp4l[254.171]: master offset          1 s2 freq      +1 path delay         7\nptp4l[254.248]: master offset          1 s2 freq      +1 path delay         7\nptp4l[254.249]: master offset          0 s2 freq      +0 path delay         7\nptp4l[254.280]: master offset          1 s2 freq      +1 path delay         7\nptp4l[254.295]: master offset          1 s2 freq      +1 path delay         7\n</code></pre> <p>To verify that both systems use DMA-0 for PTP traffic, inspect <code>/proc/interrupts</code> and confirm that the highest-priority interrupts are triggered for PTP TX/RX handling.</p> <p>Execute the following commands on development kit 1:</p> <pre><code>root@agilex7dksiagi027fc:~# cat /proc/interrupts | grep eth1\n 25:       1283          0          0          0     GICv2  72 Level     eth1\n 26:        175          0          0          0     GICv2  73 Level     eth1\n 27:          0          0          0          0     GICv2  70 Level     eth1\n 28:          0          0          0          0     GICv2  71 Level     eth1\n 29:          9          0         17          0     GICv2  68 Level     eth1\n 30:          0          0         10          0     GICv2  69 Level     eth1\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>Execute the following commands on development kit 2:</p> <pre><code>root@agilex7dksiagi027fc:~# cat /proc/interrupts | grep eth1\n 25:       1456          0          0          0     GICv2  72 Level     eth1\n 26:       5841          0          0          0     GICv2  73 Level     eth1\n 27:          0          0          0          0     GICv2  70 Level     eth1\n 28:          0          0          0          0     GICv2  71 Level     eth1\n 29:         10          0         10          0     GICv2  68 Level     eth1\n 30:          0          0         11          0     GICv2  69 Level     eth1\nroot@agilex7dksiagi027fc:~#\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#debug","title":"Debug","text":"<p>This section outlines common issues and solutions encountered during system bring-up.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ethernet-interfaces-are-missing","title":"Ethernet Interfaces are Missing","text":"<p>After login into the HPS, the Ethernet ports are not listed by Linux as shown below.</p> <pre><code>root@agilex7dksiagi027fc:~# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever\n2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen0\n    link/ether fa:06:aa:f6:2b:48 brd ff:ff:ff:ff:ff:ff\n3: teql0: &lt;NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 100\nlink/void root@agilex7dksiagi027fc:~#\n</code></pre> <p>A common cause of this error are listed below.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#incorrect-onboard-max10-bitstream","title":"Incorrect onboard MAX10 bitstream","text":"<p>The custom MAX10 bitstream is not loaded, causing ZL30733 configuration to fail. Check the Linux boot log for the following message:</p> <pre><code>Loading fpga from 0x02840620 to 0x0a000000\n.......FPGA reconfiguration OK!\n Initializing Clock Cleaner (ZL30733) via I2C zl30733_i2c_init: Could not identify ZL30733 chip on I2C bus 0, address 0x70\n.......FPGA reconfiguration OK!\nEnable FPGA bridges\n</code></pre> <p>To solve this issue, load the <code>max10_system_0002aa4F.pof</code> as described in the Program the onboard MAX10 device section. Once the correct MAX10 bitstream is loaded, the boot log will show:</p> <pre><code>Loading fpga from 0x02840620 to 0x0a000000\n.......FPGA reconfiguration OK!\n Initializing Clock Cleaner (ZL30733) via I2C ...Configuring PLL Done!\n.......FPGA reconfiguration OK!\nEnable FPGA bridges\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#ethernet-interfaces-are-down","title":"Ethernet Interfaces are DOWN","text":"<p>After login into the HPS, the Ethernet ports are not listed by Linux as shown below.</p> <pre><code>root@agilex7dksiagi027fc:~# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever\n2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000\nlink/ether e2:06:d6:88:ef:23 brd ff:ff:ff:ff:ff:ff\n3: teql0: &lt;NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 100\nlink/void 4: eth1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000\nlink/ether fa:74:c3:a3:30:c1 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.121.1/32 scope global eth1\n       valid_lft forever preferred_lft forever\n5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000\nlink/ether 86:03:88:45:9a:f9 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.122.1/32 scope global eth2\n       valid_lft forever preferred_lft forever\n</code></pre> <p>A common cause of this error are listed below.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#suboptimal-link-quality","title":"Suboptimal Link Quality","text":"<p>The System Example Design does not support auto-negotiation or link training, it uses fixed analog settings optimized for active optical cables (AOC). Validated with FS Q28-AO05 (5\u202fm / 16\u202fft) 100G QSFP28 AOC and FS Q28-PC01 (1\u202fm / 3\u202fft) 100G QSFP28 passive DAC. Longer DAC cables or different cable types (length, vendor, optical) may require manual tuning of the Ethernet interface analog settings.</p> <p>Before debugging, ensure cables are properly connected to both development kits. Begin by assessing link health using the procedure in Reading the Ethernet Subsystem IP Configuration and Status Registers with the HPS. If a port shows degraded status and a DAC cable is used, adjust analog settings as described in Enabling Transceiver Tool Kit for the Ethernet Subsystem. Run BER and Eye Viewer tests; if results are suboptimal, follow the guidance in section 7.2.7 of the F-Tile Architecture and PMA and FEC Direct PHY IP User Guide.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#system-debug-tools","title":"System Debug Tools","text":""},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#reading-the-ethernet-subsystem-ip-configuration-and-status-registers-with-the-hps","title":"Reading the Ethernet Subsystem IP Configuration and Status Registers with the HPS","text":"<p>The HPS exposes the Ethernet Subsystem IP Configuration and Status Registers (CSR) via the Linux file system, providing real-time visibility into Ethernet interface status. This data is useful for debugging link-related issues.</p> <p>To capture a CSR snapshot, log into the HPS through a serial session and run the following command:</p> <pre><code>root@agilex7dksiagi027fc:~# cat /sys/kernel/debug/hssiss_dbg/dumpcsr </code></pre> <p>The output will resemble the following transcript:</p> <pre><code>Dumping device feature registers\n        0: 10003015\n4: 30000000\n8: 18418b9d\n        c: 99a078ad\n        10: d9db4a9b\n        14: 4118a7cb\n        18: c0\n        1c: 0\n20: 0\n24: 31c\nDumping other CSR registers\nHSSISS_CSR_VER: 20000\nHSSISS_CSR_COMMON_FEATURE_LIST: c005\nDumping port attributes\n        0: 0\n1: 0\n2: 0\n3: 0\n4: 0\n5: 0\n6: 0\n7: 0\n8: a40415\n        9: a40415\n        a: 0\nb: 0\nc: 0\nd: 0\ne: 0\n10: 0\n11: 0\n12: 0\n13: 0\nHSSISS_CSR_CMDSTS: 5\nHSSISS_CSR_CTRLADDR: 50020c06\nHSSISS_CSR_RD_DATA: f\nHSSISS_CSR_WR_DATA: 9ee00d\nHSSISS_CSR_GMII_TX_LATENCY: 0\nHSSISS_CSR_GMII_RX_LATENCY: 0\nDumping port status\n        0: 0\n1: 0\n2: 0\n3: 0\n4: 0\n5: 0\n6: 0\n7: 0\n8: e00094\n        9: e00094\n        a: 0\nb: 0\nc: 0\nd: 0\ne: 0\n10: 0\n11: 0\n12: 0\n13: 0\nHSSISS_CSR_TSE_CTRL: 0\nHSSISS_CSR_DBG_CTRL: 62000\nHSSISS_CSR_HOTPLUG_DBG_CTRL: 9c400000\nHSSISS_CSR_HOTPLUG_DBG_STS: 0\n0\nroot@agilex7dksiagi027fc:~#\n</code></pre> <p>To interpret the output from dumpcsr, refer to section 7. Register Descriptions in the Ethernet Subsystem FPGA IP User Guide. Offsets listed under <code>Dumping device feature</code> registers correspond to section 7.1 Subsystem Registers.</p> <p>For debugging, the most relevant data appears under <code>Dumping port status</code>. Registers with a read value of 0 indicate Ethernet Subsystem ports not used by the System Example Design.</p> <pre><code>Dumping port status\n.\n. 7: 0\n8: a00180\n9: e00194\na: 0\n.\n.     </code></pre> <p>To decode status for ports 8 and 9, refer to section 7.1.14 HSSI Ethernet Port X Status in the Ethernet Subsystem FPGA IP User Guide.</p> <p>Example</p> <p>Port 8 status at offset <code>0xA00180</code>:</p> Bit Value Description 31:27 0 Reserved 26 0 No parity errors detected 25:24 0 Not applicable for F-Tile 23 1 tx_pll_locked status bit 22 0 rx_pcs_ready status bit 21 1 tx_lanes_stable status bit 20 0 Not applicable for F-Tile 19 0 Not applicable for F-Tile 18 0 Reserved 17 0 Reserved 16 0 Reserved 15 0 Reserved 14:13 0 Reserved 12:11 0 Reserved 10 0 tx_unidir_control register bit 1 status - unidirectional remote fault disable 9 0 tx_unidir_control register bit 2 status - unidirectional force remote fault 8 1 Remote Fault status bit 7 1 Local Fault status bit 6 0 Unidiectional enable status bit (Clause 66) 5 0 Link Fault Generation Enable status bit (Clause 66) 4 0 rx_block_lock status bit 3 0 rx_am_lock status bit 2 0 o_cdr_lock status bit 1 0 o_rx_hi_ber status bit 0 0 Reserved <p>Table 18. Port 8 Offset <code>0xA00180</code> Decoding.</p> <p>Port 9 status at offset <code>E00194</code>:</p> Bit Value Description 31:27 0 Reserved 26 0 No parity errors detected 25:24 0 Not applicable for F-Tile 23 1 tx_pll_locked status bit 22 1 rx_pcs_ready status bit 21 1 tx_lanes_stable status bit 20 0 Not applicable for F-Tile 19 0 Not applicable for F-Tile 18 0 Reserved 17 0 Reserved 16 0 Reserved 15 0 Reserved 14:13 0 Reserved 12:11 0 Reserved 10 0 tx_unidir_control register bit 1 status - unidirectional remote fault disable 9 0 tx_unidir_control register bit 2 status - unidirectional force remote fault 8 1 Remote Fault status bit (Only functional if feature is enabled) 7 1 Local Fault status bit (Only functional if feature is enabled) 6 0 Unidiectional enable status bit (Clause 66) 5 0 Link Fault Generation Enable status bit (Clause 66) 4 1 rx_block_lock status bit 3 0 rx_am_lock status bit 2 1 o_cdr_lock status bit 1 0 o_rx_hi_ber status bit 0 0 Reserved <p>Table 19. Port 9 Offset <code>0xA00180</code> Decoding.</p> <p>From the decoded register values, Port 8 shows TX is operational (<code>tx_pll_locked</code> and <code>tx_lanes_stable</code> asserted), but RX is not ready \u2014 its CDR failed to recover a clock signal from the link partner. Port 9 shows no TX/RX issues; however, bits 8 (Remote Fault) and 9 (Local Fault) are asserted. These are latched fault indicators and must be cleared manually. In this case, the remote fault likely occurred during initialization and is not a concern if the link is stable.</p> <p>Bits 23, 22, 21, 4, 5, 3, 2, and 1 reflect TX/RX status for each port and help isolate whether the issue is hardware or software-related, and whether it affects TX, RX, or both.</p> <p>For detailed signal descriptions, refer to section 7.1 Status Interface in the F-Tile Ethernet FPGA Hard IP User Guide.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#access-to-the-ethernet-subsystem-ip-configuration-and-status-registers-with-the-hps","title":"Access to the Ethernet Subsystem IP Configuration and Status Registers with the HPS","text":"<p>Access to the Ethernet Subsystem CSR is available through the HPS via the Linux file system. Use the following syntax to read or write CSR registers. These commands must be executed from the following path:</p> <pre><code>/sys/kernel/debug/hssiss_dbg\n</code></pre> <p>Write Operation Syntax \u2013 Use the following syntax to write to Ethernet Subsystem CSR registers.</p> <pre><code>echo \"&lt;base&gt; &lt;offset&gt; &lt;direct&gt; &lt;wr_value&gt;\" &gt; direct_reg\n</code></pre> <p>Read Operation Syntax \u2013 Use the following syntax to read to Ethernet Subsystem CSR registers.</p> <pre><code>echo \"&lt;base&gt; &lt;offset&gt; &lt;direct&gt; &lt;wr_value&gt;\" &gt; direct_reg\ncat direct_reg\n</code></pre> <p>Where:</p> Parameter Description base Base address from the Ethernet Subsystem IP. The Address map can be found in section 7.3. F-Tile Address Maps from the Ethernet Subsystem FPGA IP User Guide offset Register offset for access. See the F-Tile Ethernet FPGA Hard IP Register documentation for address and description of Ethernet Port registers within the Ethernet Subsystem IP. direct Set to '1' to access Ethernet port registers; set to '0' to access Ethernet Subsystem CSRs wr_value Data used for write operations <p>Table 20. <code>direct_reg</code> Fields.</p> <p>Example</p> <p>To trigger a soft global reset on Port 8 (<code>eth1</code>), set bit [0] of the <code>eth_reset</code> register at offset <code>0x108</code>. See transcript below for expected output.</p> <pre><code>root@agilex7dksiagi027fc:~# cd /sys/kernel/debug/hssiss_dbg/\nroot@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# echo \"0x1200000 0x108 1 1\" &gt; direct_reg\n[14012.863321] intel_fpga_eth soc:hssi_0_eth eth1: Link is Down\n</code></pre> <p>After the write, interface <code>eth1</code> transitions to down state.</p> <pre><code>root@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# ip addr\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever\n2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000\nlink/ether e2:06:d6:88:ef:23 brd ff:ff:ff:ff:ff:ff\n3: teql0: &lt;NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 100\nlink/void 4: eth1: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000\nlink/ether fa:74:c3:a3:30:c1 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.121.1/32 scope global eth1\n       valid_lft forever preferred_lft forever\n5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\nlink/ether 86:03:88:45:9a:f9 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.122.1/32 scope global eth2\n       valid_lft forever preferred_lft forever\n    inet6 2001:db8:abcd:13::1/64 scope global valid_lft forever preferred_lft forever\nroot@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg#\n</code></pre> <p>Read <code>eth_reset_status</code> (offset <code>0x10C</code>) to confirm reset acknowledgment from the controller.</p> <pre><code>root@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# echo \"0x1200000 0x10C 1\" &gt; direct_reg\nroot@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# cat direct_reg 5500\n</code></pre> <p><code>eth_reset_status</code> (<code>0x10C</code>) returns a decimal value indicating the Ethernet interface is in a reset cycle. To exit global reset on Port 8, clear bit [0] of eth_reset (<code>0x108</code>).</p> <pre><code>root@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# echo \"0x1200000 0x108 1 0\" &gt; direct_reg\n[14455.979357] intel_fpga_eth soc:hssi_0_eth: DBG: eth_ftile_tx_rx_user_flow speed=25000 num_vl=1 num_fl=1 num_pl=1\n[14455.990799] intel_fpga_eth soc:hssi_0_eth: DBG: eth_ftile_tx_rx_user_flow ETH_TX_PTP_READY - tx_ref_pl:0 tx_extra_latency:0x00031072 tx_tam_adjust:-1711153\n[14456.007504] intel_fpga_eth soc:hssi_0_eth: DBG: eth_ftile_tx_rx_user_flow ETH_RX_PTP_READY - rx_ref_pl:0 rx_extra_latency:0x800369d0 rx_tam_adjust:-1716888\n[14456.021427] intel_fpga_eth soc:hssi_0_eth eth1: Link is Up - 25Gbps/Full - flow control rx/tx\nroot@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# </code></pre> <p>Read <code>eth_reset_status</code> (<code>0x10C</code>) to verify reset cycle completion.</p> <pre><code>root@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# echo \"0x1200000 0x10C 1\" &gt; direct_reg\nroot@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# cat direct_reg                                                                                               6607\n</code></pre> <p>Verify that interface <code>eth1</code> is in the UP state.</p> <pre><code>root@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg# ip addr                                                                                              1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever\n2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000\nlink/ether e2:06:d6:88:ef:23 brd ff:ff:ff:ff:ff:ff\n3: teql0: &lt;NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 100\nlink/void 4: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\nlink/ether fa:74:c3:a3:30:c1 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.121.1/32 scope global eth1\n       valid_lft forever preferred_lft forever\n    inet 169.254.221.176/16 brd 169.254.255.255 scope global eth1\n       valid_lft forever preferred_lft forever\n    inet6 fe80::f874:c3ff:fea3:30c1/64 scope link proto kernel_ll valid_lft forever preferred_lft forever\n5: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\nlink/ether 86:03:88:45:9a:f9 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.122.1/32 scope global eth2\n       valid_lft forever preferred_lft forever\n    inet6 2001:db8:abcd:13::1/64 scope global valid_lft forever preferred_lft forever\nroot@agilex7dksiagi027fc:/sys/kernel/debug/hssiss_dbg#\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#enabling-transceiver-tool-kit-for-the-ethernet-subsystem","title":"Enabling Transceiver Tool Kit for the Ethernet Subsystem","text":"<p>The system example design supports the F-Tile Transceiver Toolkit for debugging potential link quality issues. Follow the next steps to enable the Transceiver Toolkit:</p> <ol> <li>With Quartus\u00ae Prime Pro version 25.1.1, open the system example design project.</li> <li>In 'Project Navigator' click on 'IP Components' Tab.</li> <li>Double click on the entity 'inst_hssi_25G', the IP Parameter Editor will open the Ethernet Subsystem IP instance.</li> <li>In the 'HSSI Subsystem' &gt;&gt; 'Device 0 Configuration' &gt;&gt; 'Main Configuration' tab, set to 'Enable' the 'Enable JTAG to Avalon Master Bridge' parameter. Refer to the screen shot below.</li> <li>In the 'HSSI Subsystem' &gt;&gt; 'Device 0 Configuration' &gt;&gt; 'F-Tile IP Configuration' &gt;&gt; 'Port 8 Configuration' &gt;&gt; 'P8 IP' tab, click on the 'Enable debug endpoint for transceiver toolkit' parameter.</li> <li>repeat step 5 for 'Port 9 Configuration' &gt;&gt; 'P9 IP' tab. Refer to the screen shot below.</li> <li>Save and regenerate the IP.</li> <li>Recompile the Altera Quartus Prime project.</li> <li>Regenerate the software with the new generated 'core.rbf' file.</li> </ol> <p>Refer to section '7.2. F-Tile Transceiver Debugging Flow Walkthrough' from the 'F-Tile Architecture and PMA and FEC Direct PHY IP User Guide' for more information on link quality related issues and their resolution. Sections '7.2.5. Running BER Tests' and '7.2.6. Running Eye Viewer Tests' are essential to qualify the Ethernet link health.</p> <p></p> <p>Figure 11. Set 'Enable JTAG to Avalon Master Bridge' for the Ethernet Subystem IP.</p> <p></p> <p>Figure 12. Set 'Enable debug endpoint for transceiver toolkit' for both Ethernet Subystem IP ports.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#simulation","title":"Simulation","text":"<p>The Multi-Channel 25GbE Precision Time Protocol System Example Design includes a suite of standalone UVM simulation tests for hardware verification. These tests validate the Quartus\u00ae project within a Universal Verification Methodology (UVM) environment, ensuring functional correctness.</p> <p>The UVM suite provides a structured framework for simulating various operating conditions and use cases, enabling thorough validation of system behavior.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#simulation-environment-setup","title":"Simulation Environment Setup","text":"<p>The following third-party tools and associated verification IPs, along with valid licenses, are required to execute the UVM simulation test cases for the design:</p> Design Tool Version Synopsys VCS* Tool V-2023.12-SP2-1 Altera\u00ae Quartus\u00ae Prime Pro Tool 25.1.1 Synopsys DesignWare VIP W-2025.03C Python 3.7.7 Perl 5.8.8 CMAKE 3.11.4 GCC 7.2.0 <p>The system testbench instantiates two AXI Synopsys Verification IP (VIP) modules, requiring a separate license in addition to the Synopsys VCS simulation tool license.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#simulation-directory","title":"Simulation Directory","text":"<p>Simulation source files and scripts are located at: <code>$TOP_FOLDER/src/hw/verification/2P25G_DV</code></p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#uvm-test-use-cases","title":"UVM Test Use Cases","text":"<p>The design includes three UVM test cases to validate the following functionality:</p> <ul> <li>Configuration and status register access</li> <li>DMA Subsystem &lt;-&gt; Ethernet Subsystem data path</li> <li>Packet Generator &lt;-&gt; Ethernet Subsystem data path</li> </ul> <p>The test cases are:</p> <p>1. CSR access test</p> <p>The test exercises full configuration and status register access across the DMA Subsystem, Packet Switch Subsystem, and Ethernet Subsystem. After initial system configuration and Ethernet link bring-up, all registers are read and compared against expected default values. The test then performs write-read operations at target offsets to validate register accessibility.</p> <p>Test Case: <code>fptp_csr_test</code> Test Case Sequence: <code>fptp_csr_seq</code></p> <p>2. Data path test - DMA base test -</p> <p>This test exercises all DMA ports in the subsystem. The sequence starts with Ethernet link bring-up, followed by DMA Subsystem and Packet Switch configuration. Once initialized, packets are submitted to all DMA queues and looped back through the Ethernet Subsystem to validate end-to-end data path integrity.</p> <p>Test Case: <code>fptp_dma_base_test</code> Test Case Sequence: <code>fptp_dma_base_seq</code></p> <p>3. Data path test - QoS user test -</p> <p>This test exercises the Packet Switch user client port. The sequence begins with Ethernet link bring-up, followed by Packet Switch, Packet generator and DMA Subsystem configuration. Once initialized, the packet generator connected to the user client port starts transmitting traffic. Packets are looped back through the Ethernet Subsystem and routed back to the generator, validating the end-to-end path.</p> <p>Test Case: <code>fptp_qos_usr_test</code> Test Case Sequence: <code>fptp_qos_usr_seq</code></p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#configuring-uvm-environment","title":"Configuring UVM Environment","text":"<p>Export the simulation folder path to the environment with the following command:</p> <pre><code>export PTP_ROOTDIR=$TOP_FOLDER/src/hw/verification/2P25G_DV\n</code></pre> <p>Update <code>setup.sh</code> with values from your local environment to configure simulation variables. The script is located at: <code>$TOP_FOLDER/src/hw/verification/2P25G_DV/env/setup.sh</code></p> <p>The following parameter variables are required for simulation:</p> <pre><code>export WORKDIR=$PTP_ROOTDIR\nexport DESIGN_DIR=$PTP_ROOTDIR/../../src\nexport QUARTUS_HOME=$QUARTUS_ROOTDIR\nexport QUARTUS_INSTALL_DIR=$QUARTUS_ROOTDIR\nexport QUARTUS_ROOTDIR_OVERRIDE=$QUARTUS_ROOTDIR\nexport DESIGNWARE_HOME= &lt;synopsys vip location&gt;\nexport VCS_HOME=&lt;Synopsys VCS simulation installation dir&gt;\nexport UVM_HOME=$VCS_HOME/etc/uvm-1.2\nexport SYNTH_DIR=$PTP_ROOTDIR/../../synth\n</code></pre> <p><code>QUARTUS_ROOTDIR</code> and <code>TOP_FOLDER</code> must be defined as described in Environment Setup.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#test-flow","title":"Test Flow","text":"<p>Users must define these parameter variables and their installation path as described in Configuring UVM Environment before running simulation.</p> <ol> <li>Navigate to the verification script folder</li> </ol> <pre><code>cd $TOP_FOLDER/src/hw/verification/scripts\n</code></pre> <ol> <li>Generate IP RTL and compile simulation libraries. </li> </ol> <pre><code>gmake -f Makefile.mk cmplib HSSI_25G=1 | tee cmp.log\n</code></pre> <p>This step generates the system IP RTL and simulation libraries.</p> <p>Execute this command when compiling the DUT for the first time or after any changes to project IPs. If errors occur, refer to cmp.log for details.</p> <ol> <li>Build IP and testbench RTL. Compile and elaborate the Design Under Test (DUT) and testbench by executing the following command:</li> </ol> <pre><code>gmake -f Makefile.mk build HSSI_25G=1 DUMP=1\n</code></pre> <p>Set the DUMP variable to 1 to enable waveform database (VPD file) generation during simulation. This switch is optional.</p> <p>Execute this command when compiling the DUT for the first time or after any changes to tesbench or RTL source files. </p> <ol> <li>Run the test case using the following simulation syntax:</li> </ol> <pre><code>gmake -f Makefile.mk run TESTNAME=&lt;test_case_name&gt; SEQNAME=&lt;test_sequence_name&gt; SEED=&lt;seed_number&gt;\n</code></pre> <p>Where <code>&lt;test_case_name&gt;</code> can be:</p> <ul> <li>fptp_csr_test</li> <li>fptp_dma_base_test</li> <li>fptp_qos_usr_test</li> </ul> <p>Each <code>&lt;test_case_name&gt;</code> corresponds to a <code>&lt;test_sequence_name&gt;</code> by replacing the <code>_test</code> suffix with <code>_seq</code>.</p> <ul> <li>fptp_csr_test -&gt; fptp_csr_seq</li> <li>fptp_dma_base_test -&gt; fptp_dma_base_seq</li> <li>fptp_qos_usr_test -&gt; fptp_qos_usr_seq</li> </ul> <p>The SEED parameter defines the value used to initialize the design state. Using the same SEED ensures identical test conditions across runs. This parameter is optional\u2014if omitted, a random value is used.</p> <p>For example, run the following command to execute the fptp_csr_test simulation:</p> <pre><code>gmake -f Makefile.mk run TESTNAME=fptp_csr_test SEQNAME=fptp_csr_seq DUMP=1\n</code></pre> <p>You can run multiple test cases without repeating steps 2 and 3. RTL generation and compilation results remain valid as long as the source files are unchanged.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#simulation-results","title":"Simulation Results","text":"<p>Simulation results are available under the <code>$PTP_ROOTDIR/sim/&lt;test_case_name&gt;</code> directory. If a test case is re-run, the previous results folder is renamed with a numeric sequence suffix, and a new folder is created to store the latest simulation results.</p>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#simulation-command-summary","title":"Simulation Command Summary","text":"Simulation Step Command IP RTL generation and simulation libraries compilation <code>gmake -f Makefile.mk cmplib HSSI_25G=1 \\| tee cmp.log</code> Build DUT and testbench RTL <code>gmake -f Makefile.mk build HSSI_25G=1</code> Run Simulation gmake -f Makefile.mk run TESTNAME= SEQNAME= DUMP=1"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#reference","title":"Reference","text":"<ul> <li>Ethernet Subsystem FPGA IP User Guide</li> <li>F-Tile Ethernet Hard IP User Guide</li> <li>Ethernet Design Example Components User Guide</li> <li>Embedded Peripherals IP User Guide</li> <li>F-Tile Architecture and PMA and FEC Direct PHY IP User Guide</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/ptp/agx7i-ptp-mcqos-25g/agx7i-ptp-mcqos-25g/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \u00a9 Altera Corporation. Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation. Other names and brands may be claimed as the property of others.</p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.</p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/","title":"HPS GSRD User Guide for the Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (4x F-Tile)","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#overview","title":"Overview","text":"<p>This page presents the Golden System Reference Design for the Intel\u00ae Agilex\u2122 I-Series Transceiver-SoC Development Kit (4x F-Tile) ordering code DK-SI-AGI027FC. The GSRD demonstrates the following: </p> <ul> <li>FPGA side <ul> <li>LEDs connected to GPIO soft IP modules </li> <li>DIP switches and push buttons connected to GPIO soft IP modules </li> </ul> </li> <li>HPS side <ul> <li>Linux, booted by U-Boot and ATF </li> <li>Board web server </li> <li>Sample driver </li> <li>Reacting to FPGA DIP switches and push buttons </li> <li>Sample applications </li> <li>Hello world </li> <li>Controlling FPGA LEDs: blink, scroll, toggle </li> <li>System check application </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the GSRD:</p> <ul> <li>Intel\u00ae Agilex\u2122 I-Series Transceiver-SoC Development Kit (4x F-Tile).<ul> <li>SD/MMC HPS Daughtercard </li> <li>Mini USB cable for serial output </li> <li>USB Type B cable for on-board Intel FPGA Download Cable II </li> <li>Micro SD card (4GB or greater)  </li> </ul> </li> <li>Host PC with:<ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too </li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows) </li> <li>Micro SD card slot or Micro SD card writer/reader </li> <li>Intel Quartus Prime Pro Edition </li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> </ul> </li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board) </li> </ul> <p>This page applies to the latest version of the Development Kit, with ordering code DK-SI-AGI027FC. You can identify your board by reviewing the the table in Intel Agilex\u2122 I-Series Transceiver-SoC Development Kit User Guide: </p> Development Kit Version Ordering Code Device Part Number Serial Number Identifier Suppported by GSRD Intel Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (Production 1 4x F-Tile) DK-SI-AGI027FA (Power Solution 2) AGIB027R31B1E1V 2000001 Yes Intel Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (Production 2) DK-SI-AGI027FC (Power Solution 2) AGIB027R31B1E1VB 3000001 Yes Intel Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (ES1 4x F-Tile) DK-SI-AGI027FB (Power Solution 1) AGIB027R31B1E1VAA 0001001 Yes Intel Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (ES) DK-SI-AGI027FES (Power Solution 1) AGIB027R31B1E2VR0 0000001 No <p>For ordering codes DK-SI-AGI027FA, and DK-SI-AGI027FB, refer to a previous version of this page: https://altera-fpga.github.io/rel-24.3.1/embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/</p> <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#binaries","title":"Binaries","text":"Board Binaries AGI027FB https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agi027fb_gsrd/ AGI027FA https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agi027fa_gsrd/ AGI027FC https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agi027fc_gsrd/ <p>The source code is included on the SD card in the Linux rootfs path <code>/home/root</code>: </p> File Description linux-socfpga-v6.12.19-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2025.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.12.1-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html .</p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#running-the-gsrd","title":"Running the GSRD","text":"<p>Note: The instructions provided here are using the prebuilt binaries, but the same procedure applies for the rebuilt binaries. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#boot-linux","title":"Boot Linux","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#configure-board","title":"Configure Board","text":"<p>Set up the board default settings, as listed by the the Intel Agilex\u2122 I-Series Transceiver-SoC Development Kit User Guide, \"Default Settings\" section: </p> Switch Default Position S19 [1:4] OFF/OFF/ON/ON S20 [1:4] ON/ON/ON/ON S9 [1:4] ON/OFF/OFF/X S10 [1:4] ON/ON/ON/ON S15 [1:4] ON/ON/ON/OFF S1 [1:4] OFF/OFF/OFF/OFF S6 [1:4] OFF/OFF/OFF/OFF S22 [1:4] ON/ON/ON/ON S23 [1:4] ON/ ON / ON / ON S4 [1:4] ON/ ON / ON / ON"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#write-sd-card","title":"Write SD Card","text":"<p>This section explains how to create the SD card necessary to boot Linux, using the SD card image available with the pre-built Linux binaries package. Once the SD card has been created, insert the card into the SD slot of the Micro SD daughter card. </p>  Write SD Card on Linux  <p>1. Download the SD card image and extract it: </p> <p>For DK-SI-AGI027FC board: </p> <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agi027fc_gsrd/sdimage.tar.gz tar xf sdimage.tar.gz </code></pre> <p>The extracted file is named <code>gsrd-console-image-agilex.wic</code>. </p> <p>2. Determine the device associated with the SD card on the host by running the following command before and after inserting the card. </p> <pre><code>$ cat /proc/partitions </code></pre> <p>Let's assume it is /dev/sdx. </p> <p>3. Use dd utility to write the SD image to the SD card. </p> <pre><code>$ sudo dd if=gsrd-console-image-agilex.wic of=/dev/sdx bs=1M </code></pre> <p>Note we are using sudo to be able to write to the card. </p> <p>4. Use sync utility to flush the changes to the SD card. </p> <pre><code>$ sudo sync </code></pre>  Write SD Card on Windows  <p>1. Download the SD card and extract it: </p> <ul> <li>For DK-SI-AGI027FC board: https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agi027fc_gsrd/sdimage.tar.gz</li> </ul> <p>The extracted file is named <code>gsrd-console-image-agilex.wic</code>. </p> <p>2. Rename the wic file as <code>sdcard.img</code> </p> <p>3. Use Win32DiskImager to write the image to the SD card. The tool can be downloaded from https://sourceforge.net/projects/win32diskimager/files/latest/download</p> <p></p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#configure-serial-connection","title":"Configure Serial Connection","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, you need to install thhe FTDI drivers from  https://ftdichip.com/drivers/ </p> <p>The serial communication parameters are: </p> <ul> <li>Baud-rate: 115,200 </li> <li>Parity: none </li> <li>Flow control: none </li> <li>Stop bits: 1 </li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus. </p> <p>On Linux, the minicom utility can be used. Here is how to configure it: </p> <p>1. The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following: </p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB* </li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet. </li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared. </li> <li>Install minicom application on host PC, if not installed. </li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom </li> <li>Configure minicom. </li> </ul> <pre><code>$ sudo minicom -s </code></pre> <p>Under Serial Port Setup choose the following: </p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary) </li> <li>Bps/Par/Bits: 115200 8N1 </li> <li>Hardware Flow Control: No </li> <li>Software Flow Control: No </li> <li>Hit [ESC] to return to the main configuration menu </li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#write-jic-image-to-qspi","title":"Write JIC Image to QSPI","text":"<p>The QSPI JIC image contains the FPGA configuration bitstream, and the U-Boot SPL. </p> <p>1. Download and extract the image file: </p> <p>For DK-SI-AGI027FC board: </p> <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_si_agi027fc_gsrd/ghrd_agib027r31b1e1vb.jic.tar.gz tar xf ghrd_agib027r31b1e1vb.jic.tar.gz </code></pre> <p>2. Configure MSEL to JTAG: </p> Switch Setting S9 [1:4] ON/ON/ON/X <p>3. Power cycle the board </p> <p>4. Connect the Type B USB cable from the development kit to the host for JTAG access. Write the image using the following commands: </p> <p>For DK-SI-AGI027FC board: </p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agib027r31b1e1vb.jic\" </code></pre> <p>5. Configure MSEL back to QSPI: </p> Switch Setting S9 [1:4] ON/OFF/OFF/X"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#boot-linux_1","title":"Boot Linux","text":"<p>1. Make sure to have the SD card inserted in the board slot. </p> <p>2. Start serial terminal (when using Minicom it will connect using the selected settings, for others connect manually). </p> <p>3. Power up the board </p> <p>4. The device will be configured from QSPI, HPS will be loaded with the U-Boot SPL, which will then load ATF and U-Boot proper, then Linux will be booted. Login using 'root' and no password. </p> <p>5. Run 'ifconfig' command to determine the IP of the board: </p> <pre><code>root@agilexfm87:~# ifconfig eth0: flags=4163 mtu 1500 inet 192.168.1.172 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::54c0:6cff:fe8e:fbac prefixlen 64 scopeid 0x20 ether 56:c0:6c:8e:fb:ac txqueuelen 1000 (Ethernet) RX packets 100 bytes 7640 (7.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 52 bytes 7830 (7.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 21 base 0x2000 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 100 bytes 8468 (8.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 100 bytes 8468 (8.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#running-sample-applications","title":"Running Sample Applications","text":"<p>The GSRD includes a number of sample Linux applications that help demonstrate some of the features of the platform: </p> <ul> <li>Display Hello World message </li> <li>Control LEDs </li> <li>Detect interrupts from push buttons and DIP switches </li> </ul> <p>The sample applications can be used as a starting point for users to write their own applications that interact with software IP through Linux drivers. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#prerequisites_1","title":"Prerequisites","text":"<p>1. Boot Linux on the target board as described in Boot Linux. You will not need to use the serial terminal if you plan on using ssh connection. </p> <p>2. Connect to the board using one of the following options: </p> <ul> <li>Connect using serial console, as described in Boot Linux </li> <li>Connect using SSH</li> </ul> <p>3. In serial console, or ssh client console, change current folder to be /home/root/intelFPGA. This is where the application binaries are stored. </p> <pre><code>root@agilexfm87:~# cd /home/root/intelFPGA/ </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#display-hello-world-message","title":"Display Hello World Message","text":"<p>Run the following command to display the Hello World message on the console: </p> <pre><code>root@agilexfm87:~/intelFPGA# ./hello Hello SoC FPGA!%ENDCOLOR </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#exercise-soft-pio-driver-for-led-control","title":"Exercise Soft PIO Driver for LED Control","text":"<p>The following green LEDs are exercised: </p> <ul> <li>USER LED0 </li> <li>USER LED1 </li> <li>USER LED2 </li> <li>USER LED4 </li> </ul> <p>Note: USER LED3 is always on, red colored, and cannot be controlled from software. </p> <p>1. In order to blink an LED in a loop, with a specific delay in ms, run the following command: </p> <pre><code>./blink &lt;led_number&gt; &lt;delay_ms&gt; </code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3. </li> <li>The delay_ms is a number that specifies the desired delay in ms between turning the LED on and off. </li> </ul> <p>2. In order to turn an individual LED on or off, run the following command: </p> <pre><code>./toggle &lt;led_number&gt; &lt;state&gt; </code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3. </li> <li>The state needs to be 0 to turn the LED off, and 1 to turn the LED on. </li> </ul> <p>3. In order to scroll the FPGA LEDs with a specific delay, please run the following command: </p> <pre><code>./scroll_client &lt;delay&gt; </code></pre> <p>The delay specifies the desired scrolling behavior: </p> <ul> <li>delay &gt; 0 - specify new scrolling delay in ms, and start scrolling </li> <li>delay &lt; 0 - stop scrolling </li> <li>delay = 0 - display current scroll delay </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#register-interrupts-and-call-interrupt-service-routine","title":"Register Interrupts and Call Interrupt Service Routine","text":"<p>The following are exercised: </p> <ul> <li>User FPGA DIP switches </li> <li>USER_SW0 </li> <li>USER_SW1 </li> <li>USER_SW2 </li> <li>USER_SW3 </li> <li>User FPGA push buttons </li> <li>USER_PB0 </li> <li>USER_PB1 </li> </ul> <p>In order to register an interrupt handler to a specific GPIO, you will first need to determine the GPIO number used. </p> <p>1. Open the Linux Device Tree socfpga_agilex7_ghrd.dtsi file and look up the labels for the DIP switches and Push button GPIOs: </p> <pre><code> button_pio: gpio@f9001060 { compatible = \"altr,pio-1.0\"; reg = &lt;0xf9001060 0x10&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 18 4&gt;; altr,gpio-bank-width = &lt;4&gt;; altr,interrupt-type = &lt;2&gt;; #gpio-cells = &lt;2&gt;; \ngpio-controller; }; dipsw_pio: gpio@f9001070 { compatible = \"altr,pio-1.0\"; reg = &lt;0xf9001070 0x10&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 17 4&gt;; altr,gpio-bank-width = &lt;4&gt;; altr,interrupt-type = &lt;3&gt;; #gpio-cells = &lt;2&gt;; \ngpio-controller; }; </code></pre> <p>2. Run the following to determine the GPIO numbers for the DIP switches </p> <pre><code>root@agilexfm87:~/intelFPGA# grep -r \"gpio@f9001070\" /sys/class/gpio/gpiochip*/label /sys/class/gpio/gpiochip1928/label:/soc/gpio@f9001070 </code></pre> <p>This means that the GPIOs 1928 .. 1931 are allocated to the DIP switches (there are 4 of them). </p> <p>3. Run the followinig to determine the GPIO numbers for the pushbuttons </p> <pre><code>root@agilexfm87:~/intelFPGA# grep -r \"gpio@f9001060\" /sys/class/gpio/gpiochip*/label /sys/class/gpio/gpiochip1960/label:/soc/gpio@f9001060 </code></pre> <p>This means that the GPIOs 1960, 1961 are allocated to the push buttons (there are 2 of them). </p> <p>4. Register interrupt for one of the dipswiches, using the appropriate GPIO number, as determined in a previous step: </p> <pre><code>root@agilexfm87:~/intelFPGA# modprobe gpio_interrupt gpio_number=1928 intr_type=3 [ 893.594901] gpio_interrupt: loading out-of-tree module taints kernel. [ 893.602212] Interrupt for GPIO:1928 [ 893.602212] registered </code></pre> <p>5. Toggle the USER_SW0/SW1.1 dipswitch a few times, you will see messages from the interrupt handler </p> <pre><code>[ 933.872016] Interrupt happened at gpio:1928 [ 936.630233] Interrupt happened at gpio:1928 [ 938.737038] Interrupt happened at gpio:1928 [ 939.951513] Interrupt happened at gpio:1928 </code></pre> <p>6. Remove the driver </p> <pre><code>root@agilexfm87:~/intelFPGA# rmmod gpio_interrupt </code></pre> <p>7. Register the pushbutton interrupt, using the appropriate GPIO number as determine on a previous step </p> <pre><code>root@agilexfm87:~/intelFPGA# modprobe gpio_interrupt gpio_number=1960 intr_type=2 [ 1138.025297] Interrupt for GPIO:1960 [ 1138.025297] registered </code></pre> <p>8. Push the pusbutton USER_PB0/S2 a few times, you will see interrupt handler messages </p> <pre><code>[ 1141.672192] Interrupt happened at gpio:1960 [ 1142.110673] Interrupt happened at gpio:1960 [ 1142.499468] Interrupt happened at gpio:1960 [ 1142.884199] Interrupt happened at gpio:1960 </code></pre> <p>9. Once done, remove the handler </p> <pre><code>root@agilexfm87:~/intelFPGA# rmmod gpio_interrupt </code></pre> <p>Note: If you are on the ssh console, you will need to run the program dmesg after pressing the button in order to see the messages: </p> <pre><code>root@stratix10:~/intelFPGA# dmesg </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#system-check-application","title":"System Check Application","text":"<p>System check application provides a glance of system status of basic peripherals such as: </p> <ul> <li>USB: USB device driver </li> <li>Network IP (IPv4): Network IP address </li> <li>HPS LEDs: HPS LED state </li> <li>FPGA LEDs: FPGA LED state </li> </ul> <p>Run the application by issuing the following command: </p> <pre><code>root@agilexfm87:~/intelFPGA# ./syschk </code></pre> <p>The window will look as shown below - press 'q' to exit: </p> <pre><code> ALTERA SYSTEM CHECK lo : 127.0.0.1 usb1 : DWC OTG Controller eth0 : 192.168.1.172 serial@ffc02100 : disabled fpga_led2 : ON serial@ffc02000 : okay hps_led2 : OFF fpga_led0 : OFF hps_led0 : OFF fpga_led3 : OFF fpga_led1 : OFF hps_led1 : OFF </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#connect-to-board-web-server-and-ssh-client","title":"Connect to Board Web Server and SSH Client","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#connect-to-web-server","title":"Connect to Web Server","text":"<p>1. Boot Linux as described in Boot Linux. </p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be network interfaces of them, either can be used. </p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter. </p> <p> </p> <p>4. In the section named Interacting with Agilex\u2122 SoC Development Kit you can perform the following actions: </p> <ul> <li>See which LEDs are ON and which are off in the LED Status. Note that if the LEDs are setup to be scrolling, the displayed scrolling speed will not match the actual scrolling speed on the board. </li> <li>Stop LEDs from scrolling, by clicking START and STOP buttons. The delay between LEDs turning ON and OFF is set in the LED Lightshow box. </li> <li>Turn individual LEDs ON and OFF with the ON and OFF buttons. Note that this action is only available when the LED scrolling/lightshow is stopped. </li> <li>Blink individual LEDs by typing a delay value in ms then clicking the corresponding BLINK button. Note that this action is only available when the LED scrolling/lightshow is stopped. </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#connect-using-ssh","title":"Connect Using SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection. </p> <p> </p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS: </p> <pre><code>$ sudo yum install openssh-clients </code></pre> <p>or the following command on Ubuntu: </p> <pre><code>$ sudo apt-get install openssh-client </code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action: </p> <p> </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-gsrd-for-dk-si-agi027fc","title":"Build GSRD for DK-SI-AGI027FC","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub. </p> <p> </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf gsrd.dk_si_agi027fc mkdir gsrd.dk_si_agi027fc cd gsrd.dk_si_agi027fc export TOP_FOLDER=$(pwd) </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design: </p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agi027fc-si-devkit-oobe-baseline-all\ncd .. </code></pre> <p>The following files are created: </p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agi027fc_si_devkit_oobe_baseline.sof</code> - FPGA configuration file, without HPS FSBL </li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agi027fc_si_devkit_oobe_baseline_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex7f-ed-gsrd/install/designs/agi027fc_si_devkit_oobe_baseline_hps_debug.sof \\\nghrd_agib027r31b1e1vb.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1VB \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agib027r31b1e1vb.hps.jic\n</code></pre> <p>The following files will be created: </p> <ul> <li>$TOP_FOLDER/ghrd_agib027r31b1e1vb.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric </li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. agilex7_dk_si_agi027fc-gsrd-build.sh build_setup </code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps: </p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex7_dk_si_agi027fc-gsrd-rootfs/ </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes: </p> <ul> <li><code>agilex7_dk_si_agi027fc_gsrd_ghrd.core.rbf</code> - core rbf file for configuring the fabric </li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location: </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agi027fc_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd_agib027r31b1e1vb.core.rbf $CORE_RBF </code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location: </p> <pre><code>SRC_URI:agilex7_dk_si_agi027fc ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agi027fc_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agi027fc_gsrd_core \\\n \" </code></pre> <p>to look like this: </p> <pre><code>SRC_URI:agilex7_dk_si_agi027fc ?= \"\\\n file://agilex7_dk_si_agi027fc_gsrd_ghrd.core.rbf \\\n \" </code></pre> <p>using the following commands: </p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agi027fc_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agi027fc_gsrd_core\" NEW_URI=\"file:\\/\\/agilex7_dk_si_agi027fc_gsrd_ghrd.core.rbf\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>3. In the same Yocto recipe update the SHA256 checksum for the file: </p> <pre><code>SRC_URI[agilex7_dk_si_agi027fc_gsrd_core.sha256sum] = \"225869090fe181cb3968eeaee8422fc409c11115a9f3b366a31e3219b9615267\" </code></pre> <p>by using the following commands: </p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_SHA=\"SRC_URI\\[agilex7_dk_si_agi027fc_gsrd_core\\.sha256sum\\] = .*\" NEW_SHA=\"SRC_URI[agilex7_dk_si_agi027fc_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_SHA/$NEW_SHA/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>: </p> <ul> <li>uboot.txt - distroboot script </li> <li>uboot_script.its - its file for creating FIT image from the above script </li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>: </p> <ul> <li>fit_kernel_agilex7_dk_si_agi027fc.its - its file for creating the kernel.itb image </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto: </p> <pre><code>bitbake_image </code></pre> <p>Gather files: </p> <pre><code>package </code></pre> <p>Once the build is completed successfully, you will see the following two folders are created: </p> <ul> <li><code>agilex7_dk_si_agi027fc-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build </li> <li><code>agilex7_dk_si_agi027fc-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agi027fc-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files. </li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex-gsrd-images</code> folder are: </p> File Description sdimage.tar.gz SD Card Image, to be written on SD card u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file, to be used for generating the bootable SOF file"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-qspi-image","title":"Build QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex7f-ed-gsrd/install/designs/agi027fc_si_devkit_oobe_baseline.sof \\\nghrd_agib027r31b1e1vb.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_si_agi027fc-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1VB \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/ghrd_agib027r31b1e1vb.hps.jic</code> - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR </li> <li><code>$TOP_FOLDER/ghrd_agib027r31b1e1vb.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/","title":"HPS GSRD User Guide for the Agilex\u2122 7 FPGA M-Series Development Kit - HBM2e Edition (3x F-Tile &amp; 1x R-Tile)","text":""},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#overview","title":"Overview","text":"<p>This page presents the Golden System Reference Design for the Intel Agilex\u2122 7 FPGA M-Series Development Kit - HBM2e Edition (3x F-Tile &amp; 1x R-Tile). The GSRD demonstrates the following: </p> <ul> <li>HPS side <ul> <li>Linux, booted by U-Boot and ATF </li> <li>Board web server </li> <li>Sample applications </li> <li>Hello world </li> <li>System check application </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the GSRD: </p> <ul> <li>Intel Agilex\u2122 7 FPGA M-Series Development Kit - HBM2e Edition (3x F-Tile &amp; 1x R-Tile), ordering code DK-DEV-AGM039FES <ul> <li>SD/MMC HPS Daughtercard </li> <li>Mini USB cable for serial output </li> <li>Micro USB cable for on-board Intel FPGA Download Cable II </li> <li>Micro SD card (4GB or greater) </li> </ul> </li> <li>Host PC with <ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too </li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows) </li> <li>Micro SD card slot or Micro SD card writer/reader </li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board) </li> </ul> <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#binary-release-contents","title":"Binary Release Contents","text":"<p>The binary release files are accessible at https://releases.rocketboards.org/2024.04/gsrd/agilex7_dk_dev_agm039fes_gsrd/.</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>: </p> File Description linux-socfpga-v6.12.19-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2025.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.12.1-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#development-kit","title":"Development Kit","text":"<p>The Agilex\u2122 7 M-Series HBM Development Kit is shown below: </p> <p> </p> <p>Refer to the following for more information about the Development Kit: </p> <ul> <li>Installer Package </li> <li>Board User Guide </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#running-gsrd-with-pre-built-binaries","title":"Running GSRD with Pre-Built Binaries","text":""},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#booting-linux","title":"Booting Linux","text":"<p>1. Connect the following cables to the board: </p> <ul> <li>Power: from board to power supply </li> <li>HPS UART Console: from vertical mini USB connector on the HPS daughtercard to host PC </li> <li>JTAG: from micro USB cable on edge of the board to host PC </li> </ul> <p>2. Download, extract and write to SD card the following SD card image: https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_dev_agm039fes_gsrd/sdimage.tar.gz. Then insert SD card into the HPS OOBE Daughtercard socket. </p> <p>3. Configure board to the default settings, making sure set S24 dipswitch to OFF-OFF-OFF-ON, to select MSEL=JTAG, so that board does not configure on power up. </p> <p>4. Power up the board </p> <p>5. Download the HPS RBF file and configure the HPS RBF file over JTAG: </p> <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/agilex7_dk_dev_agm039fes_gsrd/ghrd.hps.rbf quartus_pgm -c 1 -m jtag -o \"p;ghrd_agmf039r47a1e2vr0.hps.rbf\" </code></pre> <p>6. Linux will boot, use 'root' as username to log in, no password will be required. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#run-hello-world-application","title":"Run Hello World Application","text":"<p>Change to IntelFPGA folder, and run the hello application, which will display a meesage as shown below: </p> <pre><code>root@agilex7dkdevagm039fes:~# cd intelFPGA/ root@agilex7dkdevagm039fes:~/intelFPGA# ./hello Hello SoC FPGA! </code></pre>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#run-syscheck-application","title":"Run SysCheck Application","text":"<p>Run the SysCheck application: </p> <pre><code>root@agilex7dkdevagm039fes:~/intelFPGA# ./syschk </code></pre> <p>It will display some system information: </p> <pre><code> ALTERA SYSTEM CHECK lo : 127.0.0.1 usb1 : DWC OTG Controller eth0 : 192.168.1.52 serial@ffc02100 : disabled hps_led2 : OFF serial@ffc02000 : okay hps_led0 : OFF hps_led1 : OFF </code></pre> <p>Press Q to exit the appplication. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#connect-to-web-server","title":"Connect to Web Server","text":"<p>1. Boot Linux as described in previous section. </p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be network interfaces of them, either can be used. </p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter. </p> <p> </p> <p>Caution: The web server is intended to allow users to control FPGA connected LEDs on the board. Due to an issue in this release, this functionality is not yet enabled. It will be enabled in the next release. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#connect-over-ssh","title":"Connect over SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection. </p> <p> </p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS: </p> <pre><code>$ sudo yum install openssh-clients </code></pre> <p>or the following command on Ubuntu: </p> <pre><code>$ sudo apt-get install openssh-client </code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action: </p> <pre><code>ssh root@192.168.1.106 </code></pre> <p> </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#build-the-gsrd","title":"Build the GSRD","text":""},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf agilex7m.gsrd mkdir agilex7m.gsrd cd agilex7m.gsrd export TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design: </p> <pre><code>cd $TOP_FOLDER rm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agm039fes-soc-devkit-oobe-baseline-all\n</code></pre> <p>The following files are created: </p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agm039fes_soc_devkit_oobe_baseline.sof</code> - FPGA configuration file, without HPS FSBL </li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agm039fes_soc_devkit_oobe_baseline_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-core-rbf","title":"Create Core RBF","text":"<pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agm039fes_soc_devkit_oobe_baseline_hps_debug.sof \\ \nghrd_agmf039r47a1e2vr0.rbf \\ \n-o hps=1 rm ghrd_agmf039r47a1e2vr0.hps.rbf </code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/ghrd_agmf039r47a1e2vr0.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric </li> </ul> <p>Note we are also creating an HPS RBF file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>Then clone the Yocto script and prepare the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR  https://github.com/altera-fpga/gsrd-socfpga cd gsrd-socfpga . agilex7_dk_dev_agm039fes-gsrd-build.sh build_setup </code></pre>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> the name <code>agilex7_dk_dev_agm039fes_gsrd_ghrd.core.rbf</code> as expected by the recipes using the following command: </p> <pre><code>RECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_dev_agm039fes_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd_agmf039r47a1e2vr0.core.rbf $CORE_RBF </code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location to point to the local file: </p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_dev_agm039fes_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_dev_agm039fes_gsrd_core\" NEW_URI=\"file:\\/\\/agilex7_dk_dev_agm039fes_gsrd_ghrd.core.rbf\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $RECIPE </code></pre> <p>3. In the same Yocto recipe update the SHA256 checksum for the file: </p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_SHA=\"SRC_URI\\[agilex7_dk_dev_agm039fes_gsrd_core\\.sha256sum\\] = .*\" NEW_SHA=\"SRC_URI[agilex7_dk_dev_agm039fes_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_SHA/$NEW_SHA/g\" $RECIPE </code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>: </p> <ul> <li>uboot.txt - distroboot script </li> <li>uboot_script.its - its file for creating FIT image from the above script </li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>: </p> <ul> <li>fit_kernel_agilex7_dk_dev_agm039fes.its - its file for creating the kernel.itb image </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto: </p> <pre><code>bitbake_image </code></pre> <p>Gather files: </p> <pre><code>package </code></pre> <p>Once the build is completed successfully, you will see the following two folders are created: </p> <ul> <li><code>agilex7_dk_dev_agm039fes-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build </li> <li><code>agilex7_dk_dev_agm039fes-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_dev_agf027f1es-gsrd-rootfs/tmp/deploy/images/agilex7_dk_dev_agm039fes/</code> folder, but also other relevant files. </li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_dev_agm039fes-gsrd-images</code> folder are: </p> File Description sdimage.tar.gz SD Card Image, to be written on SD card u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file, to be used for generating the bootable SOF file"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-bootable-hps-rbf-file","title":"Create Bootable HPS RBF File","text":"<pre><code>cd $TOP_FOLDER rm -f *rbf* quartus_pfg -c $TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agm039fes_soc_devkit_oobe_baseline.sof \\\nghrd_agmf039r47a1e2vr0.rbf \\ \n-o hps_path=gsrd-socfpga/agilex7_dk_dev_agm039fes-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\ \n-o hps=1 </code></pre> <p>The following files will be created: </p> <ul> <li>$TOP_FOLDER/ghrd_agmf039r47a1e2vr0.hps.rbf - RBF file to configure the device for HPS first, phase 1 </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#configure-through-avstx8","title":"Configure Through AVSTx8","text":"<p>This section presents the details on how the GSRD can be configured automatically at power up through AVSTx8, instead of using JTAG. </p> <p>The required steps are: </p> <p>1. Create the PFG file (optional, PFG file already provided here: ghrd_agmf039r47a1e2vr0.pfg)  2. Create the POF file, using the above PFG file  3. Create the CDF file, used by Quartus Programmer to know how to write the POF file  4. Write the the POF file to MAX10 board controller flash, using the Quartus Programmer  5. Configure board through AVSTx8 </p> <p>Warning: When using the AVSTx8 configuration method on the DevKit, the 'reboot' command from U-Boot and Linux will not work. This is because the 'reboot' command issues a Cold Reset to HPS, resulting in SDM wiping HPS and waiting for the configuration bitstream to be re-sent through AVSTx8 which is not implemented on this board. In order to make this work you need to inform the external configuration agent to re-send the configuration bitstream once the Cold Reset happens. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-programmer-generator-configuration-for-avstx8","title":"Create Programmer Generator Configuration for AVSTx8","text":"<p>The PFG file contains information needed by the Quartus Programming File Generator to create the POF file to be stored on the QSPI flash attached to the MAX 10 board controller. The MAX 10 board controller reads the information from that QSPI file and configures the FPGA device over AVST. </p> <p>This section provides the details on how the PFG file is created. A copy of the file is also attached to this page: ghrd_agmf039r47a1e2vr0.pfg. </p> <p>The steps required to create the file are: </p> <p>1. Start Programmer File Generator GUI: </p> <pre><code>qpfgw &amp; </code></pre> <p>2. In the Output Files tab: </p> <ul> <li>Select Device family: Agilex\u2122 7 </li> <li>Select Configuration mode: AVSTx8 </li> <li>Edit Name: ghrd_agmf039r47a1e2vr0 </li> <li>Check Programmer Object File (.pof) </li> <li>Check Memory Map File (.map) </li> </ul> <p>The window will look similar to this: </p> <p> </p> <p>3. Click on the Input Files tab, then click on Add Bitstream... , then select Files of type to be \"Raw Binary File (.rbf)\" then browse to the <code>ghrd_agmf039r47a1e2vr0.hps.rbf</code> file and click **Open*. </p> <p> </p> <p>The window will look similar to this: </p> <p> </p> <p>4. Go to Configuration Device tab, click Add Device, select the CFI_2Gb option and click OK. </p> <p>5. Click on the OPTIONS partition to select it, then click the Edit button: </p> <p> </p> <p>6. In the Edit Partition window, select the following: </p> <ul> <li>Address Mode: Start </li> <li>Start Address: 0x00002000 </li> </ul> <p> </p> <p>Press OK. </p> <p>7. Click on CFI_2Gb then click Add Partition and select the following: </p> <ul> <li>Name: P1 </li> <li>Input file: Bitstream_1 </li> <li>Address mode: Start </li> <li>Start address: 0x00004000 </li> </ul> <p> </p> <p>Press OK. </p> <p>8. Go to File &gt; Save menu and save the configuration file as \"ghrd_agmf039r47a1e2vr0.pfg\" </p> <p> </p> <p> </p> <p>Note: The created PFG file contains absolute paths. The attached PFG file was manually edited to use relative paths instead, so it can be used even when moving files in other folders on the host PC. </p> <p>9. At this point you can generate the POF directly by clicking the Generate button. </p> <p> </p> <p>Caution: Please use the addresses 0x00002000 for OPTIONS and 0x00004000 for P1, as they are required by the MAX10 board controller. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-pof-avstx8-configuration-file","title":"Create POF AVSTx8 Configuration File","text":"<p>The POF file is created by using the PFG file and running the following command: </p> <pre><code>cd $TOP_FOLDER wget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/m-series/hbm2e/collateral/ghrd_agmf039r47a1e2vr0.pfg\nquartus_pfg -c ghrd_agmf039r47a1e2vr0.pfg </code></pre> <p>The following file is created: </p> <ul> <li>$TOP_FOLDER/ghrd_agmf039r47a1e2vr0.pof - contains the MAX 10 flash image required to configure the Agilex\u2122 7 device over AVST </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-cdf-programmer-configuration-file","title":"Create CDF Programmer Configuration File","text":"<p>The provided ghrd_agmf039r47a1e2vr0.cdf) file contains the configuration required for the Quartus Programmer to be able to write the POF file to the QSPI attached to the MAX 10 Board Controller. </p> <p>This section provides instructions on how this CDF file was created, for reference purposes. </p> <p>1. Set dipswitch S24 to OFF-OFF-OFF-ON so that board configures through JTAG. </p> <p>2. Power up the board </p> <p>3. Start Programmer GUI: </p> <pre><code>cd $TOP_FOLDER quartus_pgmw &amp; </code></pre> <p> </p> <p>4. In the Programmer window, click on Hardware Setup and select the following: </p> <ul> <li>Currently selected hardware: Intel Agilex\u2122 M-Series Development Kit - HBM2e Edition </li> <li>Hardware Frequency: 16000000 </li> </ul> <p> </p> <p>Then click Close. </p> <p>5. In the Programmer window click Autodetect, then select either option from the Select Device window as shown below: </p> <p> </p> <p>6. In the Programmer window, select the VTAP10 device, then right-click it, and select Edit &gt; Change Device </p> <p> </p> <p>Select the MAX 10 &gt; 10M50DAF256 device then click OK. </p> <p> </p> <p>7. Right click the MAX10 device, and select Edit &gt; Attach Flash Device </p> <p> </p> <p>Select Quad SPI Flash Memory &gt; QSPI_2Gb option and click OK </p> <p> </p> <p>8. Right click the QSPI_2Gb entry on the top panel, then click Change File </p> <p> </p> <p>Browse to \"ghrd_agmf039r47a1e2vr0.pof\" and click Open. </p> <p>9. In the Programmer window, select the Program/Configure and Verify checkboxes for both \"P1\" and \"OPTION_BITS\" partitions </p> <p> </p> <p>10. Go to File &gt; Save and save the configuration file as \"board.cdf\" </p> <p>Note: The output file \"ghrd_agmf039r47a1e2vr0.cdf\" has an absolute path to the \"ghrd_agmf039r47a1e2vr0.pof\" file. The provided file was hand edited to use a relative path instead, so files could be located anywhere on the host PC file system. </p> <p>11. At this stage you can also click the Start button, for the Programmer to write the file to flash. A progress bar will be shown: </p> <p> </p> <p>12. On successfull completion, the Programmer will show 100% completed: </p> <p> </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#write-pof-file-using-the-cdf-file","title":"Write POF File Using the CDF File","text":"<p>1. Connect the following cables to the board: </p> <ul> <li>Power: from board to power supply </li> <li>JTAG: from micro USB cable on edge of the board to host PC </li> </ul> <p>2. Configure board to the default settings, except set S24 dipswitch to OFF-OFF-OFF-ON, to select MSEL=JTAG, so that board does not configure on power up. </p> <p>3. Power up the board </p> <p>4. Make sure you have the following files in the current folder: </p> <ul> <li>ghrd_agmf039r47a1e2vr0.cdf </li> <li>ghrd_agmf039r47a1e2vr0.pof </li> </ul> <p>5. Run the following command to flash the POF file: </p> <pre><code>cd $TOP_FOLDER wget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/agilex-7/m-series/hbm2e/collateral/ghrd_agmf039r47a1e2vr0.cdf\nquartus_pgm ghrd_agmf039r47a1e2vr0.cdf </code></pre>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#boot-linux","title":"Boot Linux","text":"<p>1. Power down the board </p> <p>2. Set S24 to ON-OFF-OFF-ON to set MSEL=AVSTx8, so that the FPGA device gets configured with the POF on the next power cycle. </p> <p>3. Power up the board </p> <p>4. FPGA device will get configured, the U-Boot SPL will be ran, then U-Boot and then Linux. Log in with 'root' when prompted, no passowrd will be required, just like when configuring board with the RBF file.</p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/","title":"PCIe Root Port User Guide","text":""},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#summary","title":"Summary","text":"<p>PCIe root port is the downstream port of Root Complex which establish the PCIe link with any PCIe Endpoint or PCIe Bridge.</p> <p>This reference design demonstrates a PCIe root port running on Intel Agilex\u2122 7 FPGA M-Series FPGA Transceiver-SoC Development Kit connected to end point. A Gen5x4 link is shown.</p> <p>Refer to the GitHub repository for the Quartus Project and Yocto Project files.</p>"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#required-components","title":"Required Components","text":"<ul> <li>Root Port Host Board.<ul> <li>Agilex\u2122 7 FPGA M-Series Development Kit \u2013 HBM2e.</li> </ul> </li> </ul> <ul> <li>Hardware needed for End Point.<ul> <li>PCI Express NVMe Gen 5.0 x4 M.2 SSD1</li> <li>PCIe Gen5 capable x4 U.2 to M.2 Adapter</li> <li>PCIe Gen5 MCIO x4 for U.2 2x2 Dual Port2</li> </ul> </li> <li>Pre-compiled Software/Firmware.</li> </ul> <ul> <li>Tools and software.<ul> <li>System with supported Linux distribution with Ubuntu 22.04 (LTS)</li> <li>Intel \u00ae Quartus \u00aePrime Design Suite software 24.3 version </li> <li>Serial terminal application such as Putty</li> </ul> </li> </ul> <p>*Full setup with the Agilex\u2122 7 FPGA M-Series Development Kit \u2013 HBM2e, MCIO cables, adapter &amp; NVMe.</p> <p></p> <p>*NVMe connected to the U.2 to M.2 adapter.</p>"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#helpful-reference-documentation","title":"Helpful Reference Documentation","text":"<ul> <li>Intel Agilex \u00ae 7 FPGA M-Series Development Kit \u2013 HBM2e</li> </ul> <ul> <li>Multi Channel DMA Intel \u00ae FPGA IP for PCI Express User Guide</li> </ul> <ul> <li>R-Tile Avalon \u00ae Intel \u00ae FPGA IP for PCI Express</li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#build-agilex-pcie-root-port","title":"Build Agilex PCIe Root Port","text":"<p>Here are the steps to build either SW and HW files:</p> <ul> <li>SW_Readme</li> <li>HW_Readme</li> </ul> <p>Both links show how to build the files needed for the project, acording with the Intel\u00ae SoC FPGA Golden Software Reference Design (GSRD)</p>"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#hardware-description","title":"Hardware Description","text":""},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#memory-map","title":"Memory Map","text":""},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#hps-h2f-memory-map","title":"HPS H2F Memory Map","text":"Address Offset Size (Bytes) Peripheral Remarks 0x80000000 256K On Chip Memory Block memory implemented in the FPGA fabric 0x90000000 256M BAS Avalon MM Slave of PCIe BAS port 0xA0000000 2M PCIe HIP Reconfig Avalon MM Slave of PCIe HIP Reconfiguration port"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#hps-lwh2f-memory-map","title":"HPS LWH2F Memory Map","text":"Address Offset Size (Bytes) Peripheral Remarks 0xF9000000 8 System ID Hardware configuration system ID 0xF9001080 16 LED PIO 0xF9001060 16 Button PIO Push Button 0xF9001070 16 DIPSW PIO DIP Switch 0xF9001100 256 ILC Interrupt Latency Counter 0xF9010000 32k PCIe CRA Avalon MM Slave of PCIe HIP CRA port 0xF9018000 128 MSI-to-GIC Vector 0xF9018080 16 MSI-to-GIC CSR Avalon MM Slave of MSI-to-GIC CSR port 0xF90180A0 32 Performance Counter Hardware timer for benchmarking purposes 0xF9000210 8 CCT Cache Coherent Translator CSR for changing AxCACHE/PROT/DOMAIN signals of ACE-Lite\u202f 0xF9000300 32 F2H interface tester HPS can indirectly initiate F2H request through LW H2F interface.\u202f 0xF9001070 16 DIPSW PIO DIP Switch 0xF90180C0 256 AVMM CS Cpl TimeOut &amp; System level Reg. map\u202f Error registers along with Timeout values"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#pcie-bam-interface","title":"PCIe BAM interface","text":"Address Offset Size (Bytes) Peripheral Remarks 0x80000000 256k On Chip Memory Block memory implemented in the FPGA fabric 0xF9018000 128 MSI-to-GIC Vector 0x00000000 8G HPS F2H \u202fHPS FPGA to HPS interface (SDRAM access)"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#run-example","title":"Run Example","text":"<p>The instructions from this section present how to get the boot up process of the PCIe Root Port:</p> <ul> <li>Load the hps.rbf file<p>Using command line: </p> <p><pre><code>quartus_pgm -c 1 -m jtag -o p;MY_DESIGN.hps.rbf@1\n</code></pre>   Using the Intel \u00ae Quartus \u00aePrime Programer 24.3 version GUI:</p> <p></p> </li> </ul> <ul> <li>Open the Putty serial terminal, it will show a partial bootup process</li> </ul> <p>Console Output:</p> <pre><code>U-Boot SPL 2024.04 (Oct 16 2024 - 02:54:45 +0000)\nReset state: Cold\nMPU     1200000 kHz\nL4 Main    400000 kHz\nL4 sys free  100000 kHz\nL4 MP     200000 kHz\nL4 SP     100000 kHz\nSDMMC     50000 kHz\nDDR: Populating DDR handoff\npopulate_ddr_handoff: MPFE-EMIF is in multichannel mode\npopulate_ddr_handoff: Memory type is DDR\npopulate_ddr_handoff: IO96B 0xf8400000 CSR enabled\npopulate_ddr_handoff: returned num_instance 0x1\nDDR: Address MPFE 0xf8020000\nis_ddr_init_hang: 0x0\nDDR: SDRAM init in progress ...\nDDR: MPFE configuration in progress ...\nconfig_mpfe_sideband_mgr: F2SDRAM_SIDEBAND_FLAGOUTSTATUS0: 0x110\nconfig_mpfe_sideband_mgr: Multichannel bit is set\nDDR: MPFE configuration completed\nDDR: Waiting for NOCPLL locked ...\nDDR: NOCPLL locked\nDDR: Checking calibration...\nio96b_cal_status: Calibration for IO96B instance 0xf8400400 done at 7641 msec!\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\nio96b_mb_init: num_instance 1\nio96b_mb_init: get memory interface IO96B 0\nio96b_mb_req: Write 0x10001 to IOSSM_CMD_REQ_OFFSET 0xf840043c\nio96b_mb_req: CMD_RESPONSE_STATUS 0xf840045c: 0x10001\nio96b_mb_req: IOSSM_CMD_RESPONSE_DATA_0_OFFSET 0xf8400458: 0x20000000\nio96b_mb_req: IOSSM_CMD_RESPONSE_DATA_1_OFFSET 0xf8400454: 0x0\nio96b_mb_req: CMD_RESPONSE_STATUS 0xf840045c: 0x10001\nio96b_mb_req: CMD_RESPONSE_READY 0xf840045c: 0x10000\nio96b_mb_init: get response from memory interface IO96B 0\nio96b_mb_init: IO96B 0: num_mem_interface: 0x1\nio96b_mb_init: IO96B 0 mem_interface 0: ip_type_ret: 0x1\nio96b_mb_init: IO96B 0 mem_interface 0: instance_id_ret: 0x0\nDDR: Calibration success\nio96b_mb_req: Write 0x20020002 to IOSSM_CMD_REQ_OFFSET 0xf840043c\nio96b_mb_req: CMD_RESPONSE_STATUS 0xf840045c: 0x10001\nio96b_mb_req: CMD_RESPONSE_STATUS 0xf840045c: 0x10001\nio96b_mb_req: CMD_RESPONSE_READY 0xf840045c: 0x10000\nio96b_mb_req: Write 0x20020004 to IOSSM_CMD_REQ_OFFSET 0xf840043c\nio96b_mb_req: CMD_RESPONSE_STATUS 0xf840045c: 0x1\nio96b_mb_req: IOSSM_CMD_RESPONSE_DATA_0_OFFSET 0xf8400458: 0x120\nio96b_mb_req: IOSSM_CMD_RESPONSE_DATA_1_OFFSET 0xf8400454: 0x20\nio96b_mb_req: CMD_RESPONSE_STATUS 0xf840045c: 0x1\nio96b_mb_req: CMD_RESPONSE_READY 0xf840045c: 0x0\nDDR: Warning: DRAM size from device tree (2048 MiB)\nmismatch with hardware (4096 MiB).\nDDR5: 2048 MiB\nio96b_mb_req: Write 0x20040102 to IOSSM_CMD_REQ_OFFSET 0xf840043c\nio96b_mb_req: CMD_RESPONSE_STATUS 0xf840045c: 0x1\nio96b_mb_req: CMD_RESPONSE_STATUS 0xf840045c: 0x1\nio96b_mb_req: CMD_RESPONSE_READY 0xf840045c: 0x0\necc_enable_status: ECC enable status: 0\nDDR5: size check success\nDDR5: firewall init success\nDDR5 init success\nWDT:  Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\ndenali-nand-dt nand@ffb90000: timeout while waiting for irq 0x2000\ndenali-nand-dt nand@ffb90000: reset not completed.\nTrying to boot from MMC1\n\n\\## Checking hash(es) for config board-0 ... OK\n\\## Checking hash(es) for Image atf ... crc32+ OK\n\\## Checking hash(es) for Image uboot ... crc32+ OK\n\\## Checking hash(es) for Image fdt-0 ... crc32+ OK\nNOTICE: BL31: v2.10.0 (release):v2.3-6541-gdc434c310\nNOTICE: BL31: Built : 01:18:01, Jan 26 2024\nU-Boot 2023.10 (Feb 02 2024 - 07:15:25 +0000)socfpga_agilex7\nCPU:  Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Agilex7-M SoCDK\nDRAM: 2 GiB\nCore: 27 devices, 22 uclasses, devicetree: separate\nWDT:  Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nNAND: denali-nand-dt nand@ffb90000: timeout while waiting for irq 0x2000\ndenali-nand-dt nand@ffb90000: reset not completed.\nFailed to initialize Denali NAND controller. (error -5)\n0 MiB\nMMC:  dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nLoading Environment from UBI... denali-nand-dt nand@ffb90000: timeout while waiting for irq 0x2000\ndenali-nand-dt nand@ffb90000: reset not completed.\nCould not find a valid device for ffb90000.nand.0\nPartition root not found!\n\n** Cannot find mtd partition \"root\"\nIn:  serial0@ffc02000\nOut:  serial0@ffc02000\nErr:  serial0@ffc02000\nNet:\nWarning: ethernet@ff800000 (eth0) using random MAC address - e6:80:0a:7c:d8:14\neth0: ethernet@ff800000\nHit any key to stop autoboot: 0\n</code></pre> <ul> <li>Load the core.rbf file.</li> </ul> <pre><code>dhcp $loadaddr XX.XXX.XXX.XX:your_reposiroty_path/image_256mps.core.rbf;\n</code></pre> <p>Console Output:</p> <pre><code>Speed: 1000, full duplex\nBOOTP broadcast 1\nBOOTP broadcast 2\nBOOTP broadcast 3\nDHCP client bound to address 10.244.177.41 (984 ms)\nUsing ethernet@ff800000 device\nTFTP from server XX.XXX.XXX.XX; our IP address is XX.XXX.XXX.XX\nFilename 'your_reposiroty_path/image_256mps.core.rbf'.\nLoad address: 0x2000000\nLoading: #################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n###\n8.7 MiB/s\ndone\nBytes transferred = 8617984 (838000 hex)\n</code></pre> <ul> <li>Enable the bridge with the following command: </li> </ul> <pre><code>dcache flush; fpga load 0 $loadaddr $filesize; bridge enable;\n</code></pre> <p>Console Output:</p> <pre><code>.........FPGA reconfiguration OK!\n</code></pre> <ul> <li>Execute the following commands to load the kernel.itb:<pre><code>* SOCFPGA_AGILEX7 # setenv bootargs earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait;\n* SOCFPGA_AGILEX7 # dhcp $loadaddr XX.XXX.XXX.XX:your_reposiroty_path/image_256mps/kernel.itb-775d75991e1d;\n</code></pre> </li> </ul> <p>Console Output:</p> <pre><code>Speed: 1000, full duplex\nBOOTP broadcast 1\nDHCP client bound to address XX.XXX.XXX.XX (108 ms)\nUsing ethernet@ff800000 device\nTFTP from server XX.XXX.XXX.XX; our IP address is XX.XXX.XXX.XX\nFilename 'your_reposiroty_path/image_256mps/kernel.itb-775d75991e1d'.\nLoad address: 0x2000000\nLoading: #################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n#################################################################\n##########################################\n8.7 MiB/s\ndone\nBytes transferred = 10148942 (9adc4e hex)\n</code></pre> <ul> <li>Execute this <code>bootm ${loadaddr}#board-2;</code> to start the bootup process   At the end type <code>root</code></li> </ul> <pre><code>    SOCFPGA_AGILEX7 # bootm ${loadaddr}#board-2;\n</code></pre> <p>At the end type <code>root</code></p> <pre><code>    agilex7dkdevagm039fes login: root\n</code></pre> <p>Console Output:</p> <pre><code>Loading kernel from FIT Image at 02000000 ...\n\nUsing 'board-2' configuration\n   Verifying Hash Integrity ... OK\n   Trying 'kernel' kernel subimage\n     Description:  Linux Kernel\n     Type:         Kernel Image\n     Compression:  lzma compressed\n     Data Start:   0x020000dc\n     Data Size:    10127394 Bytes = 9.7 MiB\n     Architecture: AArch64\n     OS:           Linux\n     Load Address: 0x06000000\n     Entry Point:  0x06000000\n     Hash algo:    crc32\n     Hash value:   ce31562a\n   Verifying Hash Integrity ... crc32+ OK\n\nLoading fdt from FIT Image at 02000000 ...\n\nUsing 'board-2' configuration\n   Verifying Hash Integrity ... OK\n  Trying 'fdt-4' fdt subimage\n     Description:  socfpga_socdk_combined\n     Type:         Flat Device Tree\n     Compression:  uncompressed\n     Data Start:   0x029a89e4\n     Data Size:    19670 Bytes = 19.2 KiB\n     Architecture: AArch64\n     Hash algo:    crc32\n     Hash value:   53ebb81a\n   Verifying Hash Integrity ... crc32+ OK\n   Booting using the fdt blob at 0x29a89e4\n Working FDT set to 29a89e4\n   Uncompressing Kernel Image\n   Loading Device Tree to 000000007eada000, end 000000007eae1cd5 ... OK\nWorking FDT set to 7eada000\n\nStarting kernel ...\n\nDeasserting all peripheral resets\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]\n[    0.000000] Linux version 6.6.51-altera-g775d75991e1d (pcolberg@ttolabhlds034u.tor.altera.com) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240716) #15 SMP PREEMPT Fri Nov 22 23:34:36 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex7-M SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000000000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000000000000..0x0000000001ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] earlycon: uart0 at MMIO32 0x00000000ffc02000 (options '115200n8')\n[    0.000000] printk: bootconsole [uart0] enabled\n[    0.000000] NUMA: No NUMA configuration found\n[    0.000000] NUMA: Faking a node at [mem 0x0000000000000000-0x000000007fffffff]\n[    0.000000] NUMA: NODE_DATA [mem 0x7fbf19c0-0x7fbf3fff]\n[    0.000000] Zone ranges:\n[    0.000000]   DMA      [mem 0x0000000000000000-0x000000007fffffff]\n[    0.000000]   DMA32    empty\n[    0.000000]   Normal   empty\n[    0.000000] Movable zone start for each node\n[    0.000000] Early memory node ranges\n[    0.000000]   node   0: [mem 0x0000000000000000-0x0000000001ffffff]\n[    0.000000]   node   0: [mem 0x0000000002000000-0x000000007fffffff]\n[    0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x000000007fffffff]\n[    0.000000] cma: Reserved 32 MiB at 0x000000007aa00000 on node -1\n[    0.000000] psci: probing for conduit method from DT.\n[    0.000000] psci: PSCIv1.1 detected in firmware.\n[    0.000000] psci: Using standard PSCI v0.2 function IDs\n[    0.000000] psci: MIGRATE_INFO_TYPE not supported.\n[    0.000000] psci: SMC Calling Convention v1.4\n[    0.000000] percpu: Embedded 22 pages/cpu s50792 r8192 d31128 u90112\n[    0.000000] Detected VIPT I-cache on CPU0\n[    0.000000] CPU features: detected: ARM erratum 845719\n[    0.000000] alternatives: applying boot alternatives\n[    0.000000] Kernel command line: earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait\n[    0.000000] Dentry cache hash table entries: 262144 (order: 9, 2097152 bytes, linear)\n[    0.000000] Inode-cache hash table entries: 131072 (order: 8, 1048576 bytes, linear)\n[    0.000000] Fallback order for Node 0: 0\n[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 516096\n[    0.000000] Policy zone: DMA\n[    0.000000] mem auto-init: stack:all(zero), heap alloc:off, heap free:off\n[    0.000000] software IO TLB: area num 4.\n[    0.000000] software IO TLB: mapped [mem 0x0000000076a00000-0x000000007aa00000] (64MB)\n[    0.000000] Memory: 1882196K/2097152K available (17600K kernel code, 4282K rwdata, 10816K rodata, 9280K init, 608K bss, 182188K reserved, 32768K cma-reserved)\n[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1\n[    0.000000] rcu: Preemptible hierarchical RCU implementation.\n[    0.000000] rcu:     RCU event tracing is enabled.\n[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=256 to nr_cpu_ids=4.\n[    0.000000]  Trampoline variant of Tasks RCU enabled.\n[    0.000000]  Tracing variant of Tasks RCU enabled.\n[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.\n[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4\n[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0\n[    0.000000] Root IRQ handler: gic_handle_irq\n[    0.000000] GIC: Using split EOI/Deactivate mode\n[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on contention.\n[    0.000000] arch_timer: cp15 timer(s) running at 400.00MHz (phys).\n[    0.000000] clocksource: arch_sys_counter: mask: 0x7ffffffffffffff max_cycles: 0x5c4093a7d1, max_idle_ns: 440795210635 ns\n[    0.000001] sched_clock: 59 bits at 400MHz, resolution 2ns, wraps every 4398046511103ns\n[    0.008926] Console: colour dummy device 80x25\n[    0.013367] printk: console [tty0] enabled\n[    0.017459] printk: bootconsole [uart0] disabled\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]\n[    0.000000] Linux version 6.6.51-altera-g775d75991e1d (pcolberg@ttolabhlds034u.tor.altera.com) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240716) #15 SMP PREEMPT Fri Nov 22 23:34:36 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex7-M SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000000000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000000000000..0x0000000001ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] earlycon: uart0 at MMIO32 0x00000000ffc02000 (options '115200n8')\n[    0.000000] printk: bootconsole [uart0] enabled\n[    0.000000] NUMA: No NUMA configuration found\n[    0.000000] NUMA: Faking a node at [mem 0x0000000000000000-0x000000007fffffff]\n[    0.000000] NUMA: NODE_DATA [mem 0x7fbf19c0-0x7fbf3fff]\n[    0.000000] Zone ranges:\n[    0.000000]   DMA      [mem 0x0000000000000000-0x000000007fffffff]\n[    0.000000]   DMA32    empty\n[    0.000000]   Normal   empty\n[    0.000000] Movable zone start for each node\n[    0.000000] Early memory node ranges\n[    0.000000]   node   0: [mem 0x0000000000000000-0x0000000001ffffff]\n[    0.000000]   node   0: [mem 0x0000000002000000-0x000000007fffffff]\n[    0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x000000007fffffff]\n[    0.000000] cma: Reserved 32 MiB at 0x000000007aa00000 on node -1\n[    0.000000] psci: probing for conduit method from DT.\n[    0.000000] psci: PSCIv1.1 detected in firmware.\n[    0.000000] psci: Using standard PSCI v0.2 function IDs\n[    0.000000] psci: MIGRATE_INFO_TYPE not supported.\n[    0.000000] psci: SMC Calling Convention v1.4\n[    0.000000] percpu: Embedded 22 pages/cpu s50792 r8192 d31128 u90112\n[    0.000000] Detected VIPT I-cache on CPU0\n[    0.000000] CPU features: detected: ARM erratum 845719\n[    0.000000] alternatives: applying boot alternatives\n[    0.000000] Kernel command line: earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait\n[    0.000000] Dentry cache hash table entries: 262144 (order: 9, 2097152 bytes, linear)\n[    0.000000] Inode-cache hash table entries: 131072 (order: 8, 1048576 bytes, linear)\n[    0.000000] Fallback order for Node 0: 0\n[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 516096\n[    0.000000] Policy zone: DMA\n[    0.000000] mem auto-init: stack:all(zero), heap alloc:off, heap free:off\n[    0.000000] software IO TLB: area num 4.\n[    0.000000] software IO TLB: mapped [mem 0x0000000076a00000-0x000000007aa00000] (64MB)\n[    0.000000] Memory: 1882196K/2097152K available (17600K kernel code, 4282K rwdata, 10816K rodata, 9280K init, 608K bss, 182188K reserved, 32768K cma-reserved)\n[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1\n[    0.000000] rcu: Preemptible hierarchical RCU implementation.\n[    0.000000] rcu:     RCU event tracing is enabled.\n[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=256 to nr_cpu_ids=4.\n[    0.000000]  Trampoline variant of Tasks RCU enabled.\n[    0.000000]  Tracing variant of Tasks RCU enabled.\n[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.\n[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4\n[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0\n[    0.000000] Root IRQ handler: gic_handle_irq\n[    0.000000] GIC: Using split EOI/Deactivate mode\n[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on contention.\n[    0.000000] arch_timer: cp15 timer(s) running at 400.00MHz (phys).\n[    0.000000] clocksource: arch_sys_counter: mask: 0x7ffffffffffffff max_cycles: 0x5c4093a7d1, max_idle_ns: 440795210635 ns\n[    0.000001] sched_clock: 59 bits at 400MHz, resolution 2ns, wraps every 4398046511103ns\n[    0.008926] Console: colour dummy device 80x25\n[    0.013367] printk: console [tty0] enabled\n[    0.017459] printk: bootconsole [uart0] disabled\n[    0.022166] Calibrating delay loop (skipped), value calculated using timer frequency.. 800.00 BogoMIPS (lpj=1600000)\n[    0.022190] pid_max: default: 32768 minimum: 301\n[    0.022274] LSM: initializing lsm=capability,integrity\n[    0.022381] Mount-cache hash table entries: 4096 (order: 3, 32768 bytes, linear)\n[    0.022405] Mountpoint-cache hash table entries: 4096 (order: 3, 32768 bytes, linear)\n[    0.023515] cacheinfo: Unable to detect cache hierarchy for CPU 0\n[    0.024210] RCU Tasks: Setting shift to 2 and lim to 1 rcu_task_cb_adjust=1.\n[    0.024299] RCU Tasks Trace: Setting shift to 2 and lim to 1 rcu_task_cb_adjust=1.\n[    0.024499] rcu: Hierarchical SRCU implementation.\n[    0.024511] rcu:     Max phase no-delay instances is 1000.\n[    0.025712] EFI services will not be available.\n[    0.025931] smp: Bringing up secondary CPUs ...\n[    0.026524] Detected VIPT I-cache on CPU1\n[    0.026622] CPU1: Booted secondary processor 0x0000000001 [0x410fd034]\n[    0.027181] Detected VIPT I-cache on CPU2\n[    0.027224] CPU2: Booted secondary processor 0x0000000002 [0x410fd034]\n[    0.027713] Detected VIPT I-cache on CPU3\n[    0.027752] CPU3: Booted secondary processor 0x0000000003 [0x410fd034]\n[    0.027816] smp: Brought up 1 node, 4 CPUs\n[    0.027866] SMP: Total of 4 processors activated.\n[    0.027878] CPU features: detected: 32-bit EL0 Support\n[    0.027888] CPU features: detected: 32-bit EL1 Support\n[    0.027901] CPU features: detected: CRC32 instructions\n[    0.027983] CPU: All CPU(s) started at EL2\n[    0.028018] alternatives: applying system-wide alternatives\n[    0.031080] devtmpfs: initialized\n[    0.035508] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns\n[    0.035545] futex hash table entries: 1024 (order: 4, 65536 bytes, linear)\n[    0.036766] pinctrl core: initialized pinctrl subsystem\n[    0.038462] DMI not present or invalid.\n[    0.039280] NET: Registered PF_NETLINK/PF_ROUTE protocol family\n[    0.040479] DMA: preallocated 256 KiB GFP_KERNEL pool for atomic allocations\n[    0.040654] DMA: preallocated 256 KiB GFP_KERNEL|GFP_DMA pool for atomic allocations\n[    0.040851] DMA: preallocated 256 KiB GFP_KERNEL|GFP_DMA32 pool for atomic allocations\n[    0.040918] audit: initializing netlink subsys (disabled)\n[    0.041085] audit: type=2000 audit(0.032:1): state=initialized audit_enabled=0 res=1\n[    0.042216] thermal_sys: Registered thermal governor 'step_wise'\n[    0.042223] thermal_sys: Registered thermal governor 'power_allocator'\n[    0.042286] cpuidle: using governor menu\n[    0.042494] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.\n[    0.042591] ASID allocator initialised with 65536 entries\n[    0.044541] Serial: AMBA PL011 UART driver\n[    0.055361] Modules: 22080 pages in range for non-PLT usage\n[    0.055374] Modules: 513600 pages in range for PLT usage\n[    0.056321] HugeTLB: registered 1.00 GiB page size, pre-allocated 0 pages\n[    0.056351] HugeTLB: 0 KiB vmemmap can be freed for a 1.00 GiB page\n[    0.056364] HugeTLB: registered 32.0 MiB page size, pre-allocated 0 pages\n[    0.056376] HugeTLB: 0 KiB vmemmap can be freed for a 32.0 MiB page\n[    0.056388] HugeTLB: registered 2.00 MiB page size, pre-allocated 0 pages\n[    0.056399] HugeTLB: 0 KiB vmemmap can be freed for a 2.00 MiB page\n[    0.056411] HugeTLB: registered 64.0 KiB page size, pre-allocated 0 pages\n[    0.056422] HugeTLB: 0 KiB vmemmap can be freed for a 64.0 KiB page\n[    0.058251] ACPI: Interpreter disabled.\n[    0.060000] iommu: Default domain type: Translated\n[    0.060014] iommu: DMA domain TLB invalidation policy: strict mode\n[    0.060304] SCSI subsystem initialized\n[    0.060677] usbcore: registered new interface driver usbfs\n[    0.060716] usbcore: registered new interface driver hub\n[    0.060754] usbcore: registered new device driver usb\n[    0.060880] usb_phy_generic usbphy: dummy supplies not allowed for exclusive requests\n[    0.061530] pps_core: LinuxPPS API ver. 1 registered\n[    0.061543] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;\n[    0.061568] PTP clock support registered\n[    0.061696] EDAC MC: Ver: 3.0.0\n[    0.063944] stratix10-svc soc:firmware:svc: Failed to get IRQ, falling back to polling mode\n[    0.064081] Intel Service Layer Driver Initialized\n[    0.064241] scmi_core: SCMI protocol bus registered\n[    0.064875] FPGA manager framework\n[    0.065013] Advanced Linux Sound Architecture Driver Initialized.\n[    0.066115] vgaarb: loaded\n[    0.066565] clocksource: Switched to clocksource arch_sys_counter\n[    0.066832] VFS: Disk quotas dquot_6.6.0\n[    0.066874] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 bytes)\n[    0.067086] pnp: PnP ACPI: disabled\n[    0.073349] NET: Registered PF_INET protocol family\n[    0.073554] IP idents hash table entries: 32768 (order: 6, 262144 bytes, linear)\n[    0.075189] tcp_listen_portaddr_hash hash table entries: 1024 (order: 2, 16384 bytes, linear)\n[    0.075267] Table-perturb hash table entries: 65536 (order: 6, 262144 bytes, linear)\n[    0.075291] TCP established hash table entries: 16384 (order: 5, 131072 bytes, linear)\n[    0.075414] TCP bind hash table entries: 16384 (order: 7, 524288 bytes, linear)\n[    0.075959] TCP: Hash tables configured (established 16384 bind 16384)\n[    0.076093] UDP hash table entries: 1024 (order: 3, 32768 bytes, linear)\n[    0.076148] UDP-Lite hash table entries: 1024 (order: 3, 32768 bytes, linear)\n[    0.076298] NET: Registered PF_UNIX/PF_LOCAL protocol family\n[    0.076671] RPC: Registered named UNIX socket transport module.\n[    0.076686] RPC: Registered udp transport module.\n[    0.076697] RPC: Registered tcp transport module.\n[    0.076706] RPC: Registered tcp-with-tls transport module.\n[    0.076716] RPC: Registered tcp NFSv4.1 backchannel transport module.\n[    0.076744] PCI: CLS 0 bytes, default 64\n[    0.077250] kvm [1]: IPA Size Limit: 40 bits\n[    0.079438] kvm [1]: vgic interrupt IRQ9\n[    0.079495] kvm [1]: Hyp mode initialized successfully\n[    0.080895] Initialise system trusted keyrings\n[    0.081059] workingset: timestamp_bits=42 max_order=19 bucket_order=0\n[    0.081399] squashfs: version 4.0 (2009/01/31) Phillip Lougher\n[    0.081630] NFS: Registering the id_resolver key type\n[    0.081680] Key type id_resolver registered\n[    0.081691] Key type id_legacy registered\n[    0.081720] nfs4filelayout_init: NFSv4 File Layout Driver Registering...\n[    0.081735] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...\n[    0.081771] jffs2: version 2.2. (NAND) \u00a9 2001-2006 Red Hat, Inc.\n[    0.081966] 9p: Installing v9fs 9p2000 file system support\n[    0.115568] Key type asymmetric registered\n[    0.115583] Asymmetric key parser 'x509' registered\n[    0.115652] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 245)\n[    0.115670] io scheduler mq-deadline registered\n[    0.115683] io scheduler kyber registered\n[    0.115726] io scheduler bfq registered\n[    0.121214] pinctrl-single ffd13000.pinctrl: 40 pins, size 160\n[    0.121359] pinctrl-single ffd13100.pinconf: 8 pins, size 32\n[    0.125742] altera-pcie 90100000.pcie: host bridge /soc/bridge@80000000/pcie@200000000 ranges:\n[    0.125798] altera-pcie 90100000.pcie:      MEM 0x0090100000..0x009fffffff -&gt; 0x0000100000\n[    0.126237] altera-pcie 90100000.pcie: PCI host bridge to bus 0000:00\n[    0.126257] pci_bus 0000:00: root bus resource [bus 00-ff]\n[    0.126275] pci_bus 0000:00: root bus resource [mem 0x90100000-0x9fffffff] (bus address [0x00100000-0x0fffffff])\n[    0.126350] pci 0000:00:00.0: [1172:0000] type 01 class 0x060400\n[    0.126541] pci 0000:00:00.0: PME# supported from D0 D3hot\n[    0.127615] pci 0000:00:00.0: bridge configuration invalid ([bus 00-00]), reconfiguring\n[    0.127786] pci 0000:01:00.0: [c0a9:5419] type 00 class 0x010802\n[    0.127865] pci 0000:01:00.0: reg 0x10: [mem 0x00000000-0x00003fff 64bit]\n[    0.128007] pci 0000:01:00.0: Max Payload Size set to 256 (was 128, max 256)\n[    0.129341] pci_bus 0000:01: busn_res: [bus 01-ff] end is updated to 01\n[    0.129386] pci 0000:00:00.0: BAR 14: assigned [mem 0x90100000-0x901fffff]\n[    0.129407] pci 0000:01:00.0: BAR 0: assigned [mem 0x90100000-0x90103fff 64bit]\n[    0.129454] pci 0000:00:00.0: PCI bridge to [bus 01]\n[    0.129469] pci 0000:00:00.0:   bridge window [mem 0x90100000-0x901fffff]\n[    0.129578] pcieport 0000:00:00.0: enabling device (0000 -&gt; 0002)\n[    0.130830] EINJ: ACPI disabled.\n[    0.152869] Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled\n[    0.156015] ffc02000.serial: ttyS0 at MMIO 0xffc02000 (irq = 20, base_baud = 6250000) is a 16550A\n[    0.156106] printk: console [ttyS0] enabled\n[    1.285528] SuperH (H)SCI(F) driver initialized\n[    1.290489] msm_serial: driver initialized\n[    1.295191] STM32 USART driver initialized\n[    1.305512] loop: module loaded\n[    1.309768] megasas: 07.725.01.00-rc1\n[    1.314875] nvme nvme0: pci function 0000:01:00.0\n[    1.319645] nvme 0000:01:00.0: enabling device (0000 -&gt; 0002)\n[    1.320875] tun: Universal TUN/TAP device driver, 1.6\n[    1.331262] thunder_xcv, ver 1.0\n[    1.334508] thunder_bgx, ver 1.0\n[    1.337764] nicpf, ver 1.0\n[    1.341534] hns3: Hisilicon Ethernet Network Driver for Hip08 Family - version\n[    1.348747] hns3: Copyright (c) 2017 Huawei Corporation.\n[    1.354095] hclge is initializing\n[    1.357450] e1000: Intel(R) PRO/1000 Network Driver\n[    1.362325] e1000: Copyright (c) 1999-2006 Intel Corporation.\n[    1.368091] e1000e: Intel(R) PRO/1000 Network Driver\n[    1.373053] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.\n[    1.379011] igb: Intel(R) Gigabit Ethernet Network Driver\n[    1.384403] igb: Copyright (c) 2007-2014 Intel Corporation.\n[    1.389996] igbvf: Intel(R) Gigabit Virtual Function Network Driver\n[    1.392510] nvme nvme0: 4/0/0 default/read/poll queues\n[    1.396242] igbvf: Copyright (c) 2009 - 2012 Intel Corporation.\n[    1.396546] sky2: driver version 1.30\n[    1.412652] socfpga-dwmac ff800000.ethernet: IRQ eth_wake_irq not found\n[    1.419285] socfpga-dwmac ff800000.ethernet: IRQ eth_lpi not found\n[    1.425852] socfpga-dwmac ff800000.ethernet: User ID: 0x11, Synopsys ID: 0x37\n[    1.432983] socfpga-dwmac ff800000.ethernet:         DWMAC1000\n[    1.438208] socfpga-dwmac ff800000.ethernet: DMA HW capability register supported\n[    1.445675] socfpga-dwmac ff800000.ethernet: RX Checksum Offload Engine supported\n[    1.453139] socfpga-dwmac ff800000.ethernet: COE Type 2\n[    1.458354] socfpga-dwmac ff800000.ethernet: TX Checksum insertion supported\n[    1.465386] socfpga-dwmac ff800000.ethernet: Enhanced/Alternate descriptors\n[    1.472336] socfpga-dwmac ff800000.ethernet: Enabled extended descriptors\n[    1.479109] socfpga-dwmac ff800000.ethernet: Ring mode enabled\n[    1.484930] socfpga-dwmac ff800000.ethernet: Enable RX Mitigation via HW Watchdog Timer\n[    1.497288] usbcore: registered new device driver r8152-cfgselector\n[    1.503615] usbcore: registered new interface driver r8152\n[    1.509117] usbcore: registered new interface driver asix\n[    1.514535] usbcore: registered new interface driver ax88179_178a\n[    1.520636] usbcore: registered new interface driver cdc_ether\n[    1.526478] usbcore: registered new interface driver net1080\n[    1.532145] usbcore: registered new interface driver cdc_subset\n[    1.538072] usbcore: registered new interface driver zaurus\n[    1.543665] usbcore: registered new interface driver cdc_ncm\n[    1.549334] usbcore: registered new interface driver r8153_ecm\n[    1.556391] dwc2 ffb00000.usb: supply vusb_d not found, using dummy regulator\n[    1.563656] dwc2 ffb00000.usb: supply vusb_a not found, using dummy regulator\n[    1.571092] dwc2 ffb00000.usb: EPs: 16, dedicated fifos, 8064 entries in SPRAM\n[    1.578476] dwc2 ffb00000.usb: DWC OTG Controller\n[    1.583197] dwc2 ffb00000.usb: new USB bus registered, assigned bus number 1\n[    1.590249] dwc2 ffb00000.usb: irq 27, io mem 0xffb00000\n[    1.596269] hub 1-0:1.0: USB hub found\n[    1.600056] hub 1-0:1.0: 1 port detected\n[    1.606070] usbcore: registered new interface driver usb-storage\n[    1.614754] i2c_dev: i2c /dev entries driver\n[    1.626658] sdhci: Secure Digital Host Controller Interface driver\n[    1.632856] sdhci: Copyright(c) Pierre Ossman\n[    1.637836] Synopsys Designware Multimedia Card Interface Driver\n[    1.644227] dw_mmc ff808000.mmc: IDMAC supports 32-bit address mode.\n[    1.644680] sdhci-pltfm: SDHCI platform and OF driver helper\n[    1.650592] dw_mmc ff808000.mmc: Using internal DMA controller.\n[    1.662134] dw_mmc ff808000.mmc: Version ID is 280a\n[    1.662181] ledtrig-cpu: registered to indicate activity on CPUs\n[    1.667055] dw_mmc ff808000.mmc: DW MMC controller at irq 29,32 bit host data width,1024 deep fifo\n[    1.682002] SMCCC: SOC_ID: ARCH_SOC_ID not implemented, skipping ....\n[    1.682127] mmc_host mmc0: card is polling.\n[    1.693005] usbcore: registered new interface driver usbhid\n[    1.698574] usbhid: USB HID core driver\n[    1.705252] mmc_host mmc0: Bus speed (slot 0) = 50000000Hz (slot req 400000Hz, actual 396825HZ div = 63)\n[    1.714924] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available\n[    1.727618] NET: Registered PF_PACKET protocol family\n[    1.732794] 9pnet: Installing 9P2000 support\n[    1.737152] Key type dns_resolver registered\n[    1.752012] registered taskstats version 1\n[    1.756353] Loading compiled-in X.509 certificates\n[    1.763052] mmc_host mmc0: Bus speed (slot 0) = 50000000Hz (slot req 50000000Hz, actual 50000000HZ div = 0)\n[    1.772884] mmc0: new high speed SDHC card at address 0001\n[    1.776251] dma-pl330 ffda0000.dma-controller: Loaded driver for PL330 DMAC-341330\n[    1.779157] mmcblk0: mmc0:0001 SD32G 28.8 GiB\n[    1.786045] dma-pl330 ffda0000.dma-controller:       DBUFF-512x8bytes Num_Chans-8 Num_Peri-32 Num_Events-8\n[    1.792465]  mmcblk0: p1 p2\n[    1.805891] of_cfs_init\n[    1.808434] of_cfs_init: OK\n[    1.811357] clk: Disabling unused clocks\n[    1.815340] ALSA device list:\n[    1.818302]   No soundcards found.\n[    1.821978] dw-apb-uart ffc02000.serial: forbid DMA for kernel console\n[    2.022277] EXT4-fs (mmcblk0p2): recovery complete\n[    2.029042] EXT4-fs (mmcblk0p2): mounted filesystem b684fca7-9a42-4537-ac5a-b4e272d39764 r/w with ordered data mode. Quota mode: none.\n[    2.041217] VFS: Mounted root (ext4 filesystem) on device 179:2.\n[    2.048274] devtmpfs: mounted\n[    2.054974] Freeing unused kernel memory: 9280K\n[    2.059698] Run /sbin/init as init process\n[    2.536036] systemd[1]: System time before build time, advancing clock.\n[    2.614649] systemd[1]: systemd 254.4^ running in system mode (-PAM -AUDIT -SELINUX -APPARMOR +IMA -SMACK +SECCOMP -GCRYPT -GNUTLS -OPENSSL +ACL +BLKID -CURL -ELFUTILS -FIDO2 -IDN2 -IDN -IPTC +KMOD -LIBCRYPTSETUP +LIBFDISK -PCRE2 -PWQUALITY -P11KIT -QRENCODE -TPM2 -BZIP2 -LZ4 -XZ -ZLIB +ZSTD -BPF_FRAMEWORK +XKBCOMMON +UTMP +SYSVINIT default-hierarchy=hybrid)\n[    2.646357] systemd[1]: Detected architecture arm64.\n\nWelcome to Poky (Yocto Project Reference Distro) 4.3.2 (nanbield)!\n\n[    2.704251] systemd[1]: Hostname set to &lt;agilex7dkdevagm039fes&gt;.\n[    3.067248] systemd[1]: Binding to IPv6 address not available since kernel does not support IPv6.\n[    3.076203] systemd[1]: Binding to IPv6 address not available since kernel does not support IPv6.\n[    3.286463] systemd[1]: Queued start job for default target Multi-User System.\n[    3.334952] systemd[1]: Created slice Slice /system/getty.\n[  OK  ] Created slice Slice /system/getty.\n[    3.360519] systemd[1]: Created slice Slice /system/modprobe.\n[  OK  ] Created slice Slice /system/modprobe.\n[    3.384329] systemd[1]: Created slice Slice /system/serial-getty.\n[  OK  ] Created slice Slice /system/serial-getty.\n[    3.407915] systemd[1]: Created slice User and Session Slice.\n[  OK  ] Created slice User and Session Slice.\n[    3.422955] systemd[1]: Started Dispatch Password Requests to Console Directory Watch.\n[  OK  ] Started Dispatch Password Requests to Console Directory Watch.\n[    3.442811] systemd[1]: Started Forward Password Requests to Wall Directory Watch.\n[  OK  ] Started Forward Password Requests to Wall Directory Watch.\n[    3.458865] systemd[1]: Reached target Host and Network Name Lookups.\n[  OK  ] Reached target Host and Network Name Lookups.\n[    3.474666] systemd[1]: Reached target Path Units.\n[  OK  ] Reached target Path Units.\n[    3.490702] systemd[1]: Reached target Remote File Systems.\n[  OK  ] Reached target Remote File Systems.\n[    3.506668] systemd[1]: Reached target Slice Units.\n[  OK  ] Reached target Slice Units.\n[    3.522695] systemd[1]: Reached target Swaps.\n[  OK  ] Reached target Swaps.\n[    3.569547] systemd[1]: Listening on RPCbind Server Activation Socket.\n[  OK  ] Listening on RPCbind Server Activation Socket.\n[    3.594896] systemd[1]: Reached target RPC Port Mapper.\n[  OK  ] Reached target RPC Port Mapper.\n[    3.612611] systemd[1]: Listening on Syslog Socket.\n[  OK  ] Listening on Syslog Socket.\n[    3.627013] systemd[1]: Listening on initctl Compatibility Named Pipe.\n[  OK  ] Listening on initctl Compatibility Named Pipe.\n[    3.643693] systemd[1]: Listening on Journal Audit Socket.\n[  OK  ] Listening on Journal Audit Socket.\n[    3.659044] systemd[1]: Listening on Journal Socket (/dev/log).\n[  OK  ] Listening on Journal Socket (/dev/log).\n[    3.675164] systemd[1]: Listening on Journal Socket.\n[  OK  ] Listening on Journal Socket.\n[    3.691248] systemd[1]: Listening on Network Service Netlink Socket.\n[  OK  ] Listening on Network Service Netlink Socket.\n[    3.708105] systemd[1]: Listening on udev Control Socket.\n[  OK  ] Listening on udev Control Socket.\n[    3.723011] systemd[1]: Listening on udev Kernel Socket.\n[  OK  ] Listening on udev Kernel Socket.\n[    3.739057] systemd[1]: Listening on User Database Manager Socket.\n[  OK  ] Listening on User Database Manager Socket.\n[    3.779054] systemd[1]: Mounting Huge Pages File System...\n     Mounting Huge Pages File System...\n[    3.799738] systemd[1]: Mounting POSIX Message Queue File System...\n     Mounting POSIX Message Queue File System...\n[    3.819915] systemd[1]: Mounting Kernel Debug File System...\n     Mounting Kernel Debug File System...\n[    3.843323] systemd[1]: Kernel Trace File System was skipped because of an unmet condition check (ConditionPathExists=/sys/kernel/tracing).\n[    3.862150] systemd[1]: Mounting Temporary Directory /tmp...\n     Mounting Temporary Directory /tmp...\n[    3.883327] systemd[1]: Create List of Static Device Nodes was skipped because of an unmet condition check (ConditionFileNotEmpty=/lib/modules/6.6.51-altera-g775d75991e1d/modules.devname).\n[    3.923396] systemd[1]: Starting Load Kernel Module configfs...\n     Starting Load Kernel Module configfs...\n[    3.944273] systemd[1]: Starting Load Kernel Module drm...\n     Starting Load Kernel Module drm...\n[    3.964514] systemd[1]: Starting Load Kernel Module fuse...\n     Starting Load Kernel Module fuse...\n[    3.985756] systemd[1]: Starting RPC Bind...\n     Starting RPC Bind...\n[    3.999048] systemd[1]: File System Check on Root Device was skipped because of an unmet condition check (ConditionPathIsReadWrite=!/).\n[    4.019226] systemd[1]: Starting Journal Service...\n         Starting Journal Service...\n[    4.060980] systemd[1]: Load Kernel Modules was skipped because no trigger condition checks were met.\n[    4.103545] systemd[1]: Starting Generate network units from Kernel command line...\n         Starting Generate network units from Kernel command line...\n     [    4.115775] systemd-journald[99]: Collecting audit messages is enabled.\n\n[    4.140329] systemd[1]: Starting Remount Root and Kernel File Systems...\n     Starting Remount Root and Kernel File Systems...\n[    4.168742] systemd[1]: Starting Apply Kernel Variables...\n     Starting Apply Kernel Variables...\n[    4.201209] systemd[1]: Starting Create Static Device Nodes in /dev gracefully...\n     Starting Create Static Device Nodes in /dev gracefully...\n[    4.210386] EXT4-fs (mmcblk0p2): re-mounted b684fca7-9a42-4537-ac5a-b4e272d39764 r/w. Quota mode: none.\n[    4.232859] systemd[1]: Starting Coldplug All udev Devices...\n     Starting Coldplug All udev Devices...\n[    4.263193] systemd[1]: Started RPC Bind.\n[  OK  ] Started RPC Bind.\n[    4.283708] systemd[1]: Started Journal Service.\n[  OK  ] Started Journal Service.\n[  OK  ] Mounted Huge Pages File System.\n[  OK  ] Mounted POSIX Message Queue File System.\n[  OK  ] Mounted Kernel Debug File System.\n[  OK  ] Mounted Temporary Directory /tmp.\n[  OK  ] Finished Load Kernel Module configfs.\n[  OK  ] Finished Load Kernel Module drm.\n[  OK  ] Finished Load Kernel Module fuse.\n[  OK  ] Finished Generate network units from Kernel command line.\n[  OK  ] Finished Remount Root and Kernel File Systems.\n[  OK  ] Finished Apply Kernel Variables.\n[  OK  ] Finished Create Static Device Nodes in /dev gracefully.\n         Mounting Kernel Configuration File System...\n         Starting Flush Journal to Persistent Storage...\n         Starting Create Static Device Nodes in /dev...\n[    4.592047] systemd-journald[99]: Received client request to flush runtime journal.\n[  OK  ] Mounted Kernel Configuration File System.\n[  OK  ] Finished Flush Journal to Persistent Storage.\n[  OK  ] Finished Create Static Device Nodes in /dev.\n[  OK  ] Reached target Preparation for Local File Systems.\n         Mounting /var/volatile...\n[    4.749948] audit: type=1334 audit(1695209006.208:2): prog-id=5 op=LOAD\n[    4.756672] audit: type=1334 audit(1695209006.216:3): prog-id=6 op=LOAD\n         Starting Rule-based Manager for Device Events and Files...\n[  OK  ] Mounted /var/volatile.\n         Starting Load/Save OS Random Seed...\n[  OK  ] Reached target Local File Systems.\n         Starting Create Volatile Files and Directories...\n[  OK  ] Finished Create Volatile Files and Directories.\n[  OK  ] Started Rule-based Manager for Device Events and Files.\n         Starting Network Time Synchronization...\n         Starting Record System Boot/Shutdown in UTMP...\n[    5.062903] audit: type=1334 audit(1695209006.516:4): prog-id=7 op=LOAD\n[    5.070543] audit: type=1334 audit(1695209006.516:5): prog-id=8 op=LOAD\n        Starting User Database Manager...\n[  OK  ] Finished Record System Boot/Shutdown in UTMP.\n[  OK  ] Finished Coldplug All udev Devices.\n[  OK  ] Started User Database Manager.\n[  OK  ] Started Network Time Synchronization.\n[  OK  ] Reached target System Initialization.\n[  OK  ] Started Daily Cleanup of Temporary Directories.\n[  OK  ] Reached target System Time Set.\n[  OK  ] Reached target Timer Units.\n[  OK  ] Listening on Avahi mDNS/DNS-SD Stack Activation Socket.\n[    5.770646] random: crng init done\n[  OK  ] Listening on D-Bus System Message Bus Socket.\n        Starting sshd.socket...\n[  OK  ] Finished Load/Save OS Random Seed.\n[  OK  ] Listening on sshd.socket.\n[  OK  ] Reached target Socket Units.\n[  OK  ] Reached target Basic System.\n[  OK  ] Started Kernel Logging Service.\n[  OK  ] Started System Logging Service.\n        Starting D-Bus System Message Bus...\n        Starting Applying Altera base device tree overlay...\n[  OK  ] Started Getty on tty1.\n        Starting IPv6 Packet Filtering Framework...\n        Starting IPv4 Packet Filtering Framework...\n        Starting Lighttpd Daemon...\n        Starting LSB: NFS support for both client and server...\n        Starting Telephony service...\n[  OK  ] Started Serial Getty on ttyS0.\n[  OK  ] Reached target Login Prompts.\n         Starting Intel SoCFPGA GSRD initialization...\n[    6.350702] audit: type=1334 audit(1706434961.744:6): prog-id=9 op=LOAD\n[    6.357503] audit: type=1334 audit(1706434961.752:7): prog-id=10 op=LOAD\n        Starting User Login Management...\n        Starting OpenSSH Key Generation...\n[  OK  ] Started D-Bus System Message Bus.\n[  OK  ] Finished Applying Altera base device tree overlay.\n[  OK  ] Finished IPv6 Packet Filtering Framework.\n[  OK  ] Finished IPv4 Packet Filtering Framework.\n[  OK  ] Started Lighttpd Daemon.\n[  OK  ] Started LSB: NFS support for both client and server.\n[  OK  ] Reached target Preparation for Network.\n[  OK  ] Reached target Hardware activated USB gadget.\n        Starting Connection service...\n        Starting Network Configuration...\n        Starting Virtual Console Setup...\n[  OK  ] Started User Login Management.\n[  OK  ] Started Telephony service.\n[  OK  ] Finished OpenSSH Key Generation.\n[  OK  ] Started Connection service.\n[  OK  ] Finished Virtual Console Setup.\n        Starting Avahi mDNS/DNS-SD Stack...\n[  OK  ] Started Network Configuration.\n[  OK  ] Reached target Network.\n[    7.055515] socfpga-dwmac ff800000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-0\n[  OK  ] Started Avahi mDNS/DNS-SD Stack.\n[    7.134673] socfpga-dwmac ff800000.ethernet eth0: PHY [stmmac-0:04] driver [Micrel KSZ9031 Gigabit PHY] (irq=POLL)\n[    7.155129] socfpga-dwmac ff800000.ethernet eth0: No Safety Features support found\n[    7.162757] socfpga-dwmac ff800000.ethernet eth0: IEEE 1588-2008 Advanced Timestamp supported\n[    7.171682] socfpga-dwmac ff800000.ethernet eth0: registered PTP clock\n[    7.178777] socfpga-dwmac ff800000.ethernet eth0: configuring for phy/rgmii link mode\n         Starting WPA supplicant...\n[    7.616327] audit: type=1334 audit(1706434963.012:8): prog-id=11 op=LOAD\n[    7.623165] audit: type=1334 audit(1706434963.020:9): prog-id=12 op=LOAD\n         Starting Hostname Service...\n[  OK  ] Started WPA supplicant.\n[  OK  ] Started Hostname Service.\n[   10.243439] socfpga-dwmac ff800000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off\n\nPoky (Yocto Project Reference Distro) 4.3.2 agilex7dkdevagm039fes ttyS0\n\nagilex7dkdevagm039fes login: root\n</code></pre> <ul> <li>Execute the <code>lspci</code> command to display information about all PCI devices on the system<pre><code>lspci\n</code></pre> </li> </ul> <p>Console Output:</p> <pre><code>user@agilex7dkdevagm039fes:~# lspci\n00:00.0 PCI bridge: Altera Corporation Device 0000 (rev 01)\n01:00.0 Non-Volatile memory controller: Micron/Crucial Technology Device 5419\n</code></pre> <p>There you will see both PCIe devices Rootport(00:00.0) &amp; End Point(01:00.0)</p> <ul> <li>Run the following command to retrieve detailed information about the Agilex 7 M-Series PCIe Root Port:<pre><code>lspci -vvv -s 00:00.0\n</code></pre> </li> </ul> <p>Console Output:</p> <pre><code>00:00.0 PCI bridge: Altera Corporation Device 0000 (rev 01) (prog-if 00 [Normal decode])\nControl: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-\nStatus: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-\nLatency: 0\nInterrupt: pin A routed to IRQ 0\nBus: primary=00, secondary=01, subordinate=01, sec-latency=0\nI/O behind bridge: 0000f000-00000fff [disabled] [32-bit]\nMemory behind bridge: 90100000-901fffff [size=1M] [32-bit]\nPrefetchable memory behind bridge: 00000000fff00000-00000000000fffff [disabled] [64-bit]\nSecondary status: 66MHz- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &lt;SERR- &lt;PERR-\nBridgeCtl: Parity- SERR+ NoISA- VGA- VGA16- MAbort- &gt;Reset- FastB2B-\n        PriDiscTmr- SecDiscTmr- DiscTmrStat- DiscTmrSERREn-\nCapabilities: [40] Power Management version 3\nFlags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold-)\nStatus: D0 NoSoftRst- PME-Enable- DSel=0 DScale=0 PME-\nCapabilities: [70] Express (v2) Root Port (Slot-), MSI 00\nDevCap: MaxPayload 256 bytes, PhantFunc 0\nExtTag+ RBE+\n        DevCtl: CorrErr+ NonFatalErr+ FatalErr+ UnsupReq+\n                RlxdOrd+ ExtTag+ PhantFunc- AuxPwr- NoSnoop+\n                MaxPayload 256 bytes, MaxReadReq 512 bytes\n        DevSta: CorrErr- NonFatalErr- FatalErr- UnsupReq- AuxPwr+ TransPend-\n        LnkCap: Port #1, Speed 32GT/s, Width x4, ASPM not supported\nClockPM- Surprise- LLActRep+ BwNot+ ASPMOptComp+\n        LnkCtl: ASPM Disabled; RCB 64 bytes, Disabled- CommClk-\n                ExtSynch- ClockPM- AutWidDis- BWInt+ AutBWInt+\n        LnkSta: Speed 32GT/s, Width x4\n                TrErr- Train- SlotClk- DLActive+ BWMgmt- ABWMgmt+\n        RootCap: CRSVisible+\n        RootCtl: ErrCorrectable- ErrNon-Fatal- ErrFatal- PMEIntEna- CRSVisible+\n        RootSta: PME ReqID 0000, PMEStatus- PMEPending-\n        DevCap2: Completion Timeout: Range ABCD, TimeoutDis+ NROPrPrP+ LTR+\n                 10BitTagComp+ 10BitTagReq+ OBFF Not Supported, ExtFmt+ EETLPPrefix+, MaxEETLPPrefixes 1\nEmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-\n                 FRS- LN System CLS Not Supported, TPHComp+ ExtTPHComp- ARIFwd+\n                 AtomicOpsCap: Routing+ 32bit+ 64bit+ 128bitCAS+\n        DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis- LTR+ 10BitTagReq- OBFF Disabled, ARIFwd+\n                 AtomicOpsCtl: ReqEn- EgressBlck-\n        LnkCap2: Supported Link Speeds: 2.5-32GT/s, Crosslink- Retimer+ 2Retimers+ DRS-\n        LnkCtl2: Target Link Speed: 32GT/s, EnterCompliance- SpeedDis-\n                 Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-\n                 Compliance Preset/De-emphasis: -6dB de-emphasis, 0dB preshoot\n        LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete+ EqualizationPhase1+\n                 EqualizationPhase2+ EqualizationPhase3+ LinkEqualizationRequest-\n                 Retimer- 2Retimers- CrosslinkRes: Downstream Port\nCapabilities: [100 v2] Advanced Error Reporting\n        UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-\n        UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-\n        UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-\n        CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-\n        CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+\n        AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn-\n                MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap-\n        HeaderLog: 00000000 00000000 00000000 00000000\nRootCmd: CERptEn- NFERptEn- FERptEn-\n        RootSta: CERcvd- MultCERcvd- UERcvd- MultUERcvd-\n                 FirstFatal- NonFatalMsg- FatalMsg- IntMsg 0\nErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000\nCapabilities: [148 v1] Virtual Channel\n        Caps:   LPEVC=0 RefClk=100ns PATEntryBits=1\nArb:    Fixed- WRR32- WRR64- WRR128-\n        Ctrl:   ArbSelect=Fixed\n        Status: InProgress-\n        VC0:    Caps:   PATOffset=00 MaxTimeSlots=1 RejSnoopTrans-\n                Arb:    Fixed- WRR32- WRR64- WRR128- TWRR128- WRR256-\n                Ctrl:   Enable+ ID=0 ArbSelect=Fixed TC/VC=ff\n                Status: NegoPending- InProgress-\nCapabilities: [184 v1] Secondary PCI Express\n        LnkCtl3: LnkEquIntrruptEn- PerformEqu-\n        LaneErrStat: 0\nCapabilities: [1a4 v1] Physical Layer 16.0 GT/s &lt;?&gt;\nCapabilities: [1cc v1] Lane Margining at the Receiver &lt;?&gt;\nCapabilities: [1f4 v1] Extended Capability ID 0x2a\nCapabilities: [46c v1] Data Link Feature &lt;?&gt;\n</code></pre> <ul> <li>Run the following command to retrieve detailed information about the NVMe PCIe Gen5 EP:<pre><code>lspci -vvv -s 01:00.0\n</code></pre> </li> </ul> <p>Console Output:</p> <pre><code>01:00.0 Non-Volatile memory controller: Micron/Crucial Technology Device 5419 (prog-if 02 [NVM Express])\nSubsystem: Micron/Crucial Technology Device 2100\nControl: I/O- Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+\n    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-\n    Latency: 0\nInterrupt: pin A routed to IRQ 0\nRegion 0: Memory at 90100000 (64-bit, non-prefetchable) [size=16K]\nCapabilities: [80] Express (v2) Endpoint, MSI 00\nDevCap: MaxPayload 256 bytes, PhantFunc 0, Latency L0s unlimited, L1 unlimited\n                    ExtTag+ AttnBtn- AttnInd- PwrInd- RBE+ FLReset+ SlotPowerLimit 0W\n            DevCtl: CorrErr+ NonFatalErr+ FatalErr+ UnsupReq+\n                    RlxdOrd+ ExtTag+ PhantFunc- AuxPwr- NoSnoop+ FLReset-\n                    MaxPayload 256 bytes, MaxReadReq 512 bytes\n            DevSta: CorrErr- NonFatalErr- FatalErr- UnsupReq- AuxPwr- TransPend-\n            LnkCap: Port #0, Speed 32GT/s, Width x4, ASPM L1, Exit Latency L1 unlimited\nClockPM- Surprise- LLActRep- BwNot- ASPMOptComp+\n            LnkCtl: ASPM Disabled; RCB 64 bytes, Disabled- CommClk-\n                    ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-\n            LnkSta: Speed 32GT/s, Width x4\n                    TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-\n            DevCap2: Completion Timeout: Range ABCD, TimeoutDis+ NROPrPrP- LTR+\n                     10BitTagComp+ 10BitTagReq- OBFF Not Supported, ExtFmt+ EETLPPrefix-\n                     EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-\n                     FRS+ TPHComp- ExtTPHComp-\n                     AtomicOpsCap: 32bit- 64bit- 128bitCAS-\n            DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis- LTR+ 10BitTagReq- OBFF Disabled,\n                     AtomicOpsCtl: ReqEn-\n            LnkCap2: Supported Link Speeds: 2.5-32GT/s, Crosslink- Retimer+ 2Retimers+ DRS+\n            LnkCtl2: Target Link Speed: 32GT/s, EnterCompliance- SpeedDis-\n                     Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-\n                     Compliance Preset/De-emphasis: -6dB de-emphasis, 0dB preshoot\n            LnkSta2: Current De-emphasis Level: -3.5dB, EqualizationComplete+ EqualizationPhase1+\n                     EqualizationPhase2+ EqualizationPhase3+ LinkEqualizationRequest-\n                     Retimer- 2Retimers- CrosslinkRes: unsupported\n    Capabilities: [c0] Vital Product Data\n            Product Name: CFexpress High Speed Memory Card\n            Read-only fields:\n                    [RV] Reserved: checksum bad, 21 byte(s) reserved\n            End\n    Capabilities: [d0] MSI-X: Enable+ Count=128 Masked-\n            Vector table: BAR=0 offset=00002000\nPBA: BAR=0 offset=00003000\nCapabilities: [e0] MSI: Enable- Count=1/32 Maskable+ 64bit+\n            Address: 0000000000000000  Data: 0000\nMasking: 00000000  Pending: 00000000\nCapabilities: [f8] Power Management version 3\nFlags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)\nStatus: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME-\n    Capabilities: [100 v1] Latency Tolerance Reporting\n            Max snoop latency: 0ns\n            Max no snoop latency: 0ns\n    Capabilities: [110 v1] L1 PM Substates\n            L1SubCap: PCI-PM_L1.2+ PCI-PM_L1.1+ ASPM_L1.2+ ASPM_L1.1+ L1_PM_Substates+\n                      PortCommonModeRestoreTime=0us PortTPowerOnTime=800us\n            L1SubCtl1: PCI-PM_L1.2- PCI-PM_L1.1- ASPM_L1.2- ASPM_L1.1-\n                       T_CommonMode=0us LTR1.2_Threshold=0ns\n            L1SubCtl2: T_PwrOn=10us\n    Capabilities: [128 v1] Alternative Routing-ID Interpretation (ARI)\nARICap: MFVC- ACS-, Next Function: 0\nARICtl: MFVC- ACS-, Function Group: 0\nCapabilities: [1e0 v1] Data Link Feature &lt;?&gt;\n    Capabilities: [200 v2] Advanced Error Reporting\n            UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-\n            UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-\n            UESvrt: DLP+ SDES- TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-\n            CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-\n            CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+\n            AERCap: First Error Pointer: 00, ECRCGenCap- ECRCGenEn- ECRCChkCap+ ECRCChkEn-\n                    MultHdrRecCap- MultHdrRecEn- TLPPfxPres- HdrLogCap-\n            HeaderLog: 00000000 00000000 00000000 00000000\nCapabilities: [294 v1] Device Serial Number 00-00-00-00-00-00-00-00\n    Capabilities: [2a0 v1] Power Budgeting &lt;?&gt;\n    Capabilities: [300 v1] Secondary PCI Express\n            LnkCtl3: LnkEquIntrruptEn- PerformEqu-\n            LaneErrStat: 0\nCapabilities: [340 v1] Physical Layer 16.0 GT/s &lt;?&gt;\n    Capabilities: [378 v1] Lane Margining at the Receiver &lt;?&gt;\n    Capabilities: [3d0 v1] Extended Capability ID 0x2a\n    Kernel driver in use: nvme\n</code></pre>"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#fio-transactions","title":"fio transactions","text":"<p>Recommended command to perform write transactions on an NVMe SSD:</p> <pre><code>fio --filename=/dev/nvme0n1 --rw=write --gtod_reduce=1 --blocksize=64k --size=2G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs=num_of_job\n</code></pre> <p>Recommended command to perform read transactions on an NVMe SSD:</p> <pre><code>fio --filename=/dev/nvme0n1 --rw=read --gtod_reduce=1 --blocksize=64k --size=2G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs=num_of_job\n</code></pre> <p>Note</p> <p>You could change the parameters --size=xG with 2G or 8G, --rw=x with write or read, --numjobs=x with values 4, 8, 16 or 20, i.e.:</p> <ul> <li>fio --filename=/dev/nvme0n1 --rw= write --gtod_reduce=1 --blocksize=64k --size= 2G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs= 4</li> </ul> <ul> <li>fio --filename=/dev/nvme0n1 --rw= read --gtod_reduce=1 --blocksize=64k --size= 2G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs= 8</li> </ul> <ul> <li>fio --filename=/dev/nvme0n1 --rw= write --gtod_reduce=1 --blocksize=64k --size= 8G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs= 16</li> </ul> <ul> <li>fio --filename=/dev/nvme0n1 --rw= read --gtod_reduce=1 --blocksize=64k --size= 8G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs= 20</li> </ul> <p>Example of the values that we got for the Wr &amp; Rd fio transactions using the recommended commands:</p> numjobs Writes Reads 4 1109 MB/S 1360 MB/S 8 1407 MB/S 1967 MB/S 16 1544 MB/S 2225 MB/S 20 1697 MB/S 2284 MB/S"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#fio-performance-transactions","title":"fio Performance transactions","text":"<p>Performance command to manage write transactions:</p> <pre><code>fio --filename=/dev/nvme0n1 --rw=write --gtod_reduce=1 --blocksize=64k --size=2G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs=4\n</code></pre> <p>Performance command to manage read transactions:</p> <pre><code>fio --filename=/dev/nvme0n1 --rw=read --gtod_reduce=1 --blocksize=64k --size=2G --iodepth=2 --group_reporting --name=myjob --ioengine=libaio --numjobs=4\n</code></pre> <p>Performance Results Gen5</p> numjobs Writes Reads 4 1118 MB/S 1358 MB/S 8 1429 MB/S 1966 MB/S 16 1561 MB/S 2222 MB/S 20 1673 MB/S 2281 MB/S"},{"location":"embedded-designs/agilex-7/m-series/pcie_rp/ug-pcie_rp-agx7m-hbm2e/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure. Performance varies by use, configuration and other factors. Your costs and results may vary. You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards. \u00a9 Altera Corporation. Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation. Other names and brands may be claimed as the property of others.</p> <ol> <li> <p>Crutial T700 1TB Solid State Drive - M.2 2280 Internal - PCI Express NVMe (PCI Express NVMe 5.0 x4) - 600TB TBW - 11700MB/s Maximum Read Transfer\u00a0\u21a9</p> </li> <li> <p>PCIe Gen5 MCIO x4 (SFF-TA-1016) 38P to Gen5 Multilink Drive Receptacle (SFF-8639) 68P, for U.2 2x2 Dual port, for use with Serial Cables Gen5 Switch cards 0.5M\u00a0\u21a9</p> </li> </ol>"},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/","title":"HPS Linux Boot Tutorial Example User Guide for Arria\u00ae 10 SX SoC Development Kit","text":""},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#overview","title":"Overview","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The key differences versus the GSRD are:</p> <ul> <li>Fabric is configured from U-Boot directly with the rbf file, with <code>fpga load</code> command, instead of using the <code>bootm</code> command with the core.rbf part of the kernel.itb file</li> <li>The applications and drivers form <code>meta-intel-fpga-refdes</code> are not included. That includes accessing GPIOs in the fabric for LEDs, push buttons, dip switches, the webserver running on the board, etc.</li> </ul> <p>The following scenarios are covered:</p> <ul> <li>Boot from SD Daughter card</li> <li>Boot from QSPI Daughter card</li> <li>Boot from NAND Daughter card</li> </ul> <p>The instructions on this page are based on the GSRD.</p>"},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the guides from this page:</p> <ul> <li>Arria\u00ae 10 SX SoC Development Kit, ordering code DK-SOC-10AS066S-E.<ul> <li>DDR4 HILO memory card</li> <li>Micro SD boot flash card</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel FPGA Download Cable II</li> <li>Micro SD card (4GB or greater)</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files.</li> </ul>"},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#development-kit","title":"Development Kit","text":"<p>Refer to Development Kit for details about the board.</p>"},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#release-notes","title":"Release Notes","text":"<p>Refer to Release Notes for release readiness information and known issues.</p>"},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#boot-from-sd-card","title":"Boot from SD Card","text":"Setup Environment Yocto Build Prerequisites <p>Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/ref-manual/system-requirements.html</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>1. Create the top folder to store all the build :</p> <pre><code>sudo rm -rf a10_example.sdmmc\nmkdir a10_example.sdmmc\ncd a10_example.sdmmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Setup the environment</p> <pre><code>wget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf.tar.xz\nrm arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin:$PATH\nexport ARCH=arm\nexport CROSS_COMPILE=arm-none-linux-gnueabihf-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf arria10-ed-gsrd\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arria10-ed-gsrd.git\ncd arria10-ed-gsrd\nmake a10-soc-devkit-sdmmc-baseline-all </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/hps_isw_handoff/hps.xml</code></li> <li><code>$TOP_FOLDER/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.sof</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga\n</code></pre> <p>Convert hps.xml handoff file to include file to be used by the device tree:</p> <pre><code>./arch/arm/mach-socfpga/qts-filter-a10.sh \\\n$TOP_FOLDER/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/hps_isw_handoff/hps.xml \\\narch/arm/dts/socfpga_arria10_socdk_sdmmc_handoff.h\n</code></pre> <p>Configure and build U-Boot:</p> <pre><code>make clean &amp;&amp; make mrproper\nmake socfpga_arria10_defconfig\nmake -j 48\ncd ..\n</code></pre> <p>The following files are created:</p> File Description $TOP_FOLDER/u-boot-socfpga/spl/u-boot-splx4.sfp Bootable image, with four SPL binaries, in the format required by BootROM $TOP_FOLDER/u-boot-socfpga/u-boot.img U-Boot image <p>Create the FIT image with the FPGA programming files, used by SPL to configure FPGA:</p> <pre><code>cd $TOP_FOLDER/u-boot-socfpga\nln -s $TOP_FOLDER/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.core.rbf .\nln -s $TOP_FOLDER/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.periph.rbf .\ntools/mkimage -E -f board/altera/arria10-socdk/fit_spl_fpga.its fit_spl_fpga.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/fit_spl_fpga.itb</code></li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\nmake socfpga_defconfig\nmake -j 48 zImage Image dtbs modules\nmake -j 48 modules_install INSTALL_MOD_PATH=modules_install\nrm -rf modules_install/lib/modules/*/build\nrm -rf modules_install/lib/modules/*/source\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm/boot/zImage</li> <li>$TOP_FOLDER/linux-socfpga/arch/arm/boot/Image</li> <li>$TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/socfpga_cyclone5_socdk.dtb</li> <li>$TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/socfpga_arria10_socdk_sdmmc.dtb</li> <li>$TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/socfpga_arria10_socdk_qspi.dtb</li> <li>$TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/socfpga_arria10_socdk_nand.dtb</li> <li>$TOP_FOLDER/linux-socfpga/modules_install/lib/modules</li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"arria10\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>Link all the relevant files to $LINUX_BIN</p> <pre><code>cd $TOP_FOLDER\nrm -rf linux-bin &amp;&amp; mkdir linux-bin\nexport set LINUX_BIN=`pwd`/linux-bin\nln -s $TOP_FOLDER/linux-socfpga/arch/arm/boot/zImage $LINUX_BIN\nln -s $TOP_FOLDER/linux-socfpga/arch/arm/boot/Image $LINUX_BIN\nln -s $TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/intel/socfpga/socfpga_arria10_socdk_sdmmc.dtb $LINUX_BIN\nln -s $TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/intel/socfpga/socfpga_arria10_socdk_qspi.dtb $LINUX_BIN\nln -s $TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/intel/socfpga/socfpga_arria10_socdk_nand.dtb $LINUX_BIN\nln -s $TOP_FOLDER/linux-socfpga/modules_install/lib/modules $LINUX_BIN\nln -s $TOP_FOLDER/yocto/build/tmp/deploy/images/arria10/core-image-minimal-arria10.tar.gz $LINUX_BIN\n</code></pre> <p>The following items are copied in the $LINUX_BIN folder:</p> File Description zImage compressed kernel image Image uncompressed kernel image socfpga_arria10_socdk_sdmmc.dtb arria 10 device tree blob for sdmmc boot socfpga_arria10_socdk_qspi.dtb arria 10 device tree blob for qspi boot socfpga_arria10_socdk_nand.dtb arria 10 device tree blob for nand boot modules kernel loadable modules core-image-minimal-arria10.tar.gz rootfs Create SD Card Image <p>Create SD card folder and the folder for the FAT partition and gather the files: <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/linux-socfpga/arch/arm/boot/zImage .\ncp $TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/intel/socfpga/socfpga_arria10_socdk_sdmmc.dtb .\ncp $TOP_FOLDER/u-boot-socfpga/fit_spl_fpga.itb .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.img .\nmkdir extlinux\necho \"LABEL Arria10 SOCDK SDMMC\" &gt; extlinux/extlinux.conf\necho \"    KERNEL ../zImage\" &gt;&gt; extlinux/extlinux.conf\necho \"    FDT ../socfpga_arria10_socdk_sdmmc.dtb\" &gt;&gt; extlinux/extlinux.conf\necho \"    APPEND root=/dev/mmcblk0p2 rw rootwait earlyprintk console=ttyS0,115200n8\" &gt;&gt; extlinux/extlinux.conf\n</code></pre></p> <p>Create the folder for the rootfs partition: <pre><code>cd $TOP_FOLDER/sd_card\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/arria10/core-image-minimal-arria10.tar.gz\nsudo rm -rf lib/modules/*\n</code></pre></p> <p>Bring over the SPL binary: <pre><code>cd $TOP_FOLDER/sd_card\ncp $TOP_FOLDER/u-boot-socfpga/spl/u-boot-splx4.sfp .\n</code></pre></p> <p>Create the SD card image: <pre><code>cd $TOP_FOLDER/sd_card\nsudo python3 ./make_sdimage_p3.py -f \\\n-P u-boot-splx4.sfp,num=3,format=raw,size=10M,type=A2  \\\n-P sdfs/*,num=1,format=fat32,size=32M \\\n-P rootfs/*,num=2,format=ext3,size=32M \\\n-s 80M \\\n-n sdcard_a10.img\n</code></pre></p> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard_a10.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard_a10.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next:</li> </ul> <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre> <ul> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. Write the image as shown in the next figure:</li> </ul> <p></p> Boot Linux <p>1. Power cycle the board</p> <p>2. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from QSPI.</p> <p>NOTE: This section assumes that the Boot from SD Card section has been already built and the environment setup in that section is still available.</p> <p>1. Create top folder:</p> <pre><code>sudo rm -rf a10_example.qspi\nmkdir $TOP_FOLDER/a10_example.qspi\ncd $TOP_FOLDER/a10_example.qspi\n</code></pre> <p>2. Build GHRD for QSPI:</p> <pre><code>rm -rf arria10-ed-gsrd\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arria10-ed-gsrd.git\ncd arria10-ed-gsrd\nmake a10-soc-devkit-qspi-baseline-all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/arria10-ed-gsrd/hps_isw_handoff/hps.xml</code></li> <li><code>$TOP_FOLDER/arria10-ed-gsrd/output_files/ghrd_10as066n2.sof</code></li> </ul> <p>3. Build U-Boot for QSPI: <pre><code>rm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga\n</code></pre></p> <p>Convert hps.xml handoff file to include file to be used by the device tree:</p> <pre><code>./arch/arm/mach-socfpga/qts-filter-a10.sh \\\n$TOP_FOLDER/a10_example.qspi/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/hps_isw_handoff/hps.xml \\\narch/arm/dts/socfpga_arria10_socdk_qspi_handoff.h\n</code></pre> <p>Configure and build U-Boot:</p> <pre><code>make socfpga_arria10_qspi_defconfig\nmake -j 48\n</code></pre> <p>The following files are created:</p> File Description $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/spl/u-boot-splx4.sfp Bootable image, with four SPL binaries, in the format required by BootROM $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/u-boot.img U-Boot image <p>Create the FIT image with the FPGA programming files, used by SPL to configure FPGA:</p> <pre><code>cd $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/\ncp $TOP_FOLDER/a10_example.qspi/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.core.rbf .\ncp $TOP_FOLDER/a10_example.qspi/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.periph.rbf .\ntools/mkimage -E -f board/altera/arria10-socdk/fit_spl_fpga.its fit_spl_fpga.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/a10_example.qspi/u-boot-socfpga/fit_spl_fpga.itb</code></li> </ul> <p>Create FIT image for the U-Boot:</p> <pre><code>cd $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/\ntools/mkimage -E -f board/altera/arria10-socdk/fit_uboot.its  fit_uboot.itb\n</code></pre> <p>4. Create FIT image for the Linux kernel and device tree: <pre><code>cd $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/\ncp $TOP_FOLDER/linux-socfpga/arch/arm/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/intel/socfpga/socfpga_arria10_socdk_qspi.dtb .\ntools/mkimage -f  board/altera/arria10-socdk/fit_kernel_qspi.its kernel.itb\n</code></pre></p> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/a10_example.qspi/u-boot-socfpga/kernel.itb</code></li> </ul> <p>Create qspi_bin folder and bring all the files:</p> <pre><code>cd $TOP_FOLDER/a10_example.qspi/\nrm -rf qspi_bin &amp;&amp; mkdir qspi_bin &amp;&amp; cd qspi_bin\ncp $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/spl/u-boot-splx4.sfp .\ncp $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/fit_uboot.itb .\ncp $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/fit_spl_fpga.itb .\ncp $TOP_FOLDER/a10_example.qspi/u-boot-socfpga/kernel.itb .\n</code></pre> <p>5. Prepare JFFS2 rootfs image for booting Linux from QSPI:</p> <pre><code>cd $TOP_FOLDER/a10_example.qspi/qspi_bin/\nmkdir core-image-minimal-arria10-rootfs\ncd core-image-minimal-arria10-rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/arria10/core-image-minimal-arria10.tar.gz\nsudo rm -rf lib/modules/*\ncd ..\nsudo mkfs.jffs2 -r core-image-minimal-arria10-rootfs -s 256 -e 64KiB --squash -o core-image-minimal-arria10-rootfs.jffs2\nsudo chown $USER:$USER core-image-minimal-arria10-rootfs.jffs2\nsudo rm -rf core-image-minimal-arria10-rootfs\n</code></pre> <p>At this point the following binaries are available in the $TOP_FOLDER/qspi_bin:</p> File Description $TOP_FOLDER/a10_example.qspi/qspi_bin/u-boot-splx4.sfp Four SPL binaries, with BootROM header $TOP_FOLDER/a10_example.qspi/qspi_bin/fit_uboot.itb U-Boot image $TOP_FOLDER/a10_example.qspi/qspi_bin/fit_spl_fpga.itb FPGA configuration files $TOP_FOLDER/a10_example.qspi/qspi_bin/kernel.itb Linux kerned and device tree $TOP_FOLDER/a10_example.qspi/qspi_bin/core-image-minimal-arria10-rootfs.jffs2 Linux rootfs Write QSPI Flash <p>Program QSPI flash with all the binaries:</p> <pre><code>cd $TOP_FOLDER/a10_example.qspi/qspi_bin/\nquartus_hps -c 1 -o e\nquartus_hps -c 1 -o pv -a 0x0000000 u-boot-splx4.sfp\nquartus_hps -c 1 -o pv -a 0x0100000 fit_uboot.itb\nquartus_hps -c 1 -o pv -a 0x0300000 fit_spl_fpga.itb\nquartus_hps -c 1 -o pv -a 0x1200000 kernel.itb\nquartus_hps -c 1 -o pv -a 0x2720000 core-image-minimal-arria10-rootfs.jffs2\n</code></pre> Write QSPI Flash via TFTP <p>Note that quartus_hps is slow, and a better alternative is to load U-Boot through debugger, download the files through TFTP and write them with U-Boot</p> <p>1. Erase the QSPI flash using quartus_hps, as that is faster than U-Boot: <pre><code>quartus_hps -c 1 -o E\n</code></pre></p> <p>2. Copy the binaries to the TFTP folder on your host machine. Run U-Boot from the debugger as shown in Arria 10 SoC Run U-Boot from Debugger</p> <p>3. Connnect your U-Boot to the network, and specify the IP address of you host machine: <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your_server_ip&gt;\n</code></pre></p> <p>4. In U-Boot, download binaries over TFTP, and write the to QSPI: <pre><code>sf probe\nErase QSPI if not done with quartus_hps::sf erase 0 8000000\ntftp ${loadaddr} u-boot-splx4.sfp;sf write ${loadaddr} 0x0000000  ${filesize}\ntftp ${loadaddr} fit_uboot.itb; sf write ${loadaddr} 0x0100000 ${filesize} tftp ${loadaddr} fit_spl_fpga.itb; sf write ${loadaddr} 0x0300000 ${filesize} tftp ${loadaddr} kernel.itb; sf write ${loadaddr} 0x1200000 ${filesize} tftp ${loadaddr} core-image-minimal-arria10-rootfs.jffs2 ;sf write ${loadaddr} 0x2720000 ${filesize}\n</code></pre></p> Boot Linux <p>1. Power cycle the board</p> <p>2. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/arria-10/sx/soc/boot-examples/ug-linux-boot-a10-soc/#boot-from-nand","title":"Boot from NAND","text":"<p>The instructions in this section assume the standard 1Gb NAND part is used (part number: MT29F1G08ABBEAH4:E, marking: NW360). Newer dev kits may be using a 8Gb part (part number: MT29F8G08ABBCAH4-IT:C, marking: NQ299).</p> <p>The following changes will be needed if the newer 8Gb part number is used:</p> <ul> <li>Make sure that all items in flash are aligned to the new erase block size (256KB)</li> <li>Make sure the JFFS2 image uses the new parameters (256KB block erase size, 2048 page size)</li> <li>Increase the size of the rootfs partition, to use the rest of the flash</li> </ul> <p>1. Create a top folder:</p> <pre><code>sudo rm -rf a10_example.nand\nmkdir a10_example.nand\ncd a10_example.nand\n</code></pre> <p>2. Build the GHRD for NAND boot:</p> <pre><code>rm -rf arria10-ed-gsrd\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arria10-ed-gsrd.git\ncd arria10-ed-gsrd\nmake a10-soc-devkit-nand-baseline-all\n</code></pre> <p>3. Build U-Boot for NAND:</p> <pre><code>cd $TOP_FOLDER/a10_example.nand\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga\n</code></pre> <p>Convert hps.xml handoff file to include file to be used by the device tree:</p> <pre><code>./arch/arm/mach-socfpga/qts-filter-a10.sh \\\n$TOP_FOLDER/a10_example.nand/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/hps_isw_handoff/hps.xml \\\narch/arm/dts/socfpga_arria10_socdk_nand_handoff.h\n</code></pre> <p>Configure and build U-Boot:</p> <pre><code>make socfpga_arria10_nand_defconfig\nmake -j 48\n</code></pre> <p>Create the FIT image with the FPGA programming files, used by SPL to configure FPGA:</p> <pre><code>cd $TOP_FOLDER/a10_example.nand/u-boot-socfpga\ncp $TOP_FOLDER/a10_example.nand/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.core.rbf .\ncp -s $TOP_FOLDER/a10_example.nand/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.periph.rbf .\ntools/mkimage -E -f board/altera/arria10-socdk/fit_spl_fpga.its fit_spl_fpga.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/a10_example.nand/u-boot-socfpga/fit_spl_fpga.itb</code></li> </ul> <p>Create FIT image for the U-Boot:</p> <pre><code>cd $TOP_FOLDER/a10_example.nand/u-boot-socfpga\ntools/mkimage -E -f board/altera/arria10-socdk/fit_uboot.its  fit_uboot.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/a10_example.nand/u-boot-socfpga/fit_uboot.itb</code></li> </ul> <p>Create FIT image for the Linux kernel and device tree:</p> <pre><code>cd $TOP_FOLDER/a10_example.nand/u-boot-socfpga\ncp $TOP_FOLDER/linux-socfpga/arch/arm/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm/boot/dts/intel/socfpga/socfpga_arria10_socdk_nand.dtb .\ntools/mkimage -f  board/altera/arria10-socdk/fit_kernel_nand.its kernel.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/a10_example.nand/u-boot-socfpga/fit_kernel.itb</code></li> </ul> <p>Create nand_bin folder and bring all the files:</p> <pre><code>cd $TOP_FOLDER/a10_example.nand/\nrm -rf nand_bin &amp;&amp; mkdir nand_bin &amp;&amp; cd nand_bin\ncp $TOP_FOLDER/a10_example.nand/u-boot-socfpga/spl/u-boot-splx4.sfp .\ncp $TOP_FOLDER/a10_example.nand/u-boot-socfpga/fit_uboot.itb .\ncp $TOP_FOLDER/a10_example.nand/u-boot-socfpga/fit_spl_fpga.itb .\ncp $TOP_FOLDER/a10_example.nand/u-boot-socfpga/kernel.itb .\n</code></pre> <p>Prepare JFFS2 rootfs image for booting Linux from NAND:</p> <pre><code>cd $TOP_FOLDER/a10_example.nand/nand_bin\nsudo rm -rf rootfs\nmkdir rootfs\ncd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/arria10/core-image-minimal-arria10.tar.gz\nsudo rm -rf lib/modules\ncd ..\nmkfs.jffs2 -r rootfs -n -p --faketime --output=rootfs.jffs2 --squash -s 2048 -e 128KiB\nrm -rf rootfs\n</code></pre> <p>At this point the following binaries are available in the $TOP_FOLDER/nand_bin:</p> File Description u-boot-splx4.sfp Four SPL binaries, with BootROM header fit_uboot.itb U-Boot image fit_spl_fpga.itb FPGA configuration files kernel.itb Linux kerned and device tree rootfs.jffs2 Linux rootfs Write NAND Flash <p>NAND Flash Layout:</p> Address Size File Description 0x0000000 0x00100000 u-boot-splx4.sfp Four SPL binaries, with BootROM header 0x0100000 0x00100000 fit_uboot.itb U-Boot image 0x0200000 0x00100000 n/a U-Boot environment 0x0300000 0x00F00000 fit_spl_fpga.itb FPGA configuration files 0x1200000 0x00E00000 kernel.itb Linux kerned and device tree 0x0200000 0x06000000 rootfs.jffs2 Linux rootfs <p>Program NAND flash with all the binaries, by doing the following:</p> <ul> <li>Copy the binaries to the TFTP folder on your host machine</li> <li>Run U-Boot from the debugger as shown in Arria 10 SoC - Run U-Boot from Debugger</li> <li>Connnect your U-Boot to the network, and specify the IP address of you host machine:</li> </ul> <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your_server_ip&gt;\n</code></pre> <p>In U-Boot, download binaries over TFTP, and write the to NAND:</p> <pre><code>nand erase clean 0x02000000 0x06000000; tftp ${loadaddr} rootfs.jffs2; nand write.trimffs ${loadaddr} 0x02000000 ${filesize}\nnand erase 0x01200000 0x00E00000; tftp ${loadaddr} kernel.itb; nand write ${loadaddr} 0x01200000 ${filesize}\nnand erase 0x00300000 0x00F00000; tftp ${loadaddr} fit_spl_fpga.itb; nand write ${loadaddr} 0x00300000 ${filesize}\nnand erase 0x00100000 0x00100000; tftp ${loadaddr} fit_uboot.itb; nand write ${loadaddr} 0x00100000 ${filesize}\nnand erase 0x00000000 0x00100000; tftp ${loadaddr} u-boot-splx4.sfp; nand write ${loadaddr} 0x00000000 ${filesize}\n</code></pre> Boot Linux <p>1. Power cycle the board</p> <p>2. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/","title":"HPS Linux GSRD Tutorial Example Design for Arria\u00ae 10 SX SoC Development Kit","text":""},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#introduction","title":"Introduction","text":"<p>The Arria\u00ae 10 SX SoC Development Kit Golden System Reference Design (GSRD) provides a set of essential hardware and software system components that can be used as a starting point for various custom user designs.</p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the A10 GSRD:</p> <ul> <li>Arria\u00ae 10 SX SoC Development Kit, ordering code DK-SOC-10AS066S-E.<ul> <li>DDR4 HILO memory card</li> <li>Micro SD boot flash card</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel FPGA Download Cable II</li> </ul> </li> <li>Micro SD card (4GB or greater)</li> <li>Host PC with<ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Micro SD card slot or Micro SD card writer/reader</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board)</li> </ul> <p>Note that the U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC.</p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#latest-binaries-release-content","title":"Latest Binaries Release Content","text":"<p>The release files are accessible at https://releases.rocketboards.org/2025.08/gsrd/a10_gsrd/</p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#ghrd-overview","title":"GHRD Overview","text":"<p>The GHRD is an important part of the GSRD and consists of the following components:</p> <ul> <li>Dual-core ARM Cortex*-A9 MPCore* Hard Processor System (HPS)</li> <li>Hard Memory Controller (HMC)</li> <li>Two user push-button inputs</li> <li>Four user DIP switch inputs</li> <li>Four user I/O for LED outputs</li> <li>256KB of FPGA on-chip memory</li> <li>JTAG to Avalon Master Bridges</li> <li>Interrupt Latency Counter</li> <li>System ID</li> </ul> <p></p> <p>The GHRD allows hardware engineers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module.  This signal-level access is independent of the driver readiness of each peripheral.</p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#cortex-a9-mpu-address-maps","title":"Cortex-A9 MPU Address Maps","text":"HPS-to-FPGA Address Map <p>The memory map of soft IP peripherals, as viewed by the microprocessor unit (MPU) of the HPS, starts at HPS-to-FPGA base address of 0xC000_0000.  The following table lists the offset from 0xC000_0000 of each peripheral in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU, which starts at the lightweight HPS-to-FPGA base address of 0xFF20_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid_qsys 0x0000_0000 8 Unique system ID led_pio 0x0000_0010 8 LED output button_pio 0x0000_0020 8 Push button input dipsw_pio 0x0000_0030 8 DIP switch input ILC 0x0000_0100 256 Interrupt latency counter JTAG Master Address Map <p>There are two JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripherals in the HPS through the FPGA-to-HPS interface.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute sysid_qsys 0x0000_0000 8 Unique system ID led_pio 0x0000_0010 8 4 LED outputs button_pio 0x0000_0020 8 2 push button inputs dipsw_pio 0x0000_0030 8 4 DIP switch inputs ILC 0x0000_0100 256 Interrupt latency counter Interrupt Routing <p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[0] 4 DIP switch inputs button_pio f2h_irq0[1] 2 push button inputs <p>The interrupt sources are also connected to an interrupt latency counter (ILC) module in the system, which enables System Console to be aware of the interrupt status of each peripheral in the FPGA portion of the SoC.</p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#typical-hps-boot-flow","title":"Typical HPS Boot Flow","text":"<p>The GSRD boot flow includes the following stages:</p> <ol> <li>Boot ROM</li> <li>U-Boot</li> <li>Operating System (OS)</li> <li>Application</li> </ol> <p></p> <p>The following table presents a short description of the different boot stages:</p> Stage Description Boot ROM Performs minimal configuration and loads U-Boot into 256KB OCRAM U-Boot SPL Configures IO, FPGA, brings up SDRAM U-Boot Loads Linux kernel Linux Operating system Application User application <p>For more information, please refer to Arria 10 SoC Boot User Guide and Intel Arria 10 Hard Processor System Technical Reference Manual (Booting and Configuration chapter). </p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#running-gsrd-with-pre-built-binaries","title":"Running GSRD with Pre-Built Binaries","text":""},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#booting-linux-using-sd-card-image","title":"Booting Linux Using SD Card Image","text":"Creating SD Card <p>This section explains how to create the SD card necessary to boot Linux, using the SD card image available with the pre-built Linux binaries package. Once the SD card has been created, insert the card into the SD slot of the Micro SD daughter card.</p> Creating SD Card on Linux <p>1. Download and extract the SD card image:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/a10_gsrd/sdimage.tar.gz tar xf sdimage.tar.gz </code></pre> <p>The extacted file is named <code>gsrd-console-image-arria10.wic</code>.</p> <p>2. Determine the device associated with the SD card on the host by running the following command before and after inserting the card.</p> <pre><code>cat /proc/partitions </code></pre> <p>Let's assume it is /dev/sdx.</p> <p>3. Use <code>dd</code> utility to write the SD image to the SD card.</p> <pre><code>sudo dd if=gsrd-console-image-arria10.wic of=/dev/sdx bs=1M </code></pre> <p>Note we are using <code>sudo</code> to be able to write to the card.</p> <p>4. Use <code>sync</code> utility to flush the changes to the SD card.</p> Creating SD Card on Windows <p>1. Download and uncompress the SD card image from https://releases.rocketboards.org/2025.08/gsrd/a10_gsrd/sdimage.tar.gz The extacted file is named <code>gsrd-console-image-arria10.wic</code>.</p> <p>2. Rename the wic file as <code>sdimage.img</code></p> <p>3. Use Win32DiskImager to write the image to the SD card. The tool can be downloaded from https://sourceforge.net/projects/win32diskimager/files/latest/download </p> <p></p> Configuring Board <p>This section presents the necessary board settings in order to run the GSRD on the Arria 10 SoC development board.</p> <p></p> <p>First, confirm the following:</p> <ul> <li>DDR4 memory card is installed on the HPS Memory slot</li> <li>Micro SD boot flash card is installed on the Boot Memory Daughtercard slot</li> </ul> <p>Then, the board switches need to be configured as follows:</p> <ul> <li>SW1: OFF-OFF-ON-ON</li> <li>SW2: All OFF</li> <li>SW3: OFF-ON-ON-ON-ON-OFF-OFF-OFF</li> <li>SW4: All OFF</li> </ul> <p>Also, the board jumpers need to be configured as follows:</p> <ul> <li>Leave the SD Card boot card jumpers placed in their default configuration</li> <li>On the development board:<ul> <li>Place jumpers J16, J17</li> <li>BSEL0(J3) = 1 (left)</li> <li>BSEL1(J4) = 0 (right)</li> <li>BSEL2(J5) = 1 (left)</li> </ul> </li> <li>Leave all other board jumpers unplaced</li> </ul> Configuring Serial Connection <p>The board has a built-in FTDI USB to serial converter chip that allows the host computer to see the board as a virtual serial port.</p> <p>The serial communication parameters are:</p> <ul> <li>Baud rate: 115200</li> <li>Parity: None</li> <li>Flow control: None</li> <li>Stop bits: 1</li> </ul> <p>On Windows, utilities such as TeraTerm or PuTTY can be used to connect the board. They are easily configured from the tool menus.</p> <p>On Linux, the Minicom utility can be used. Here is how to configure it:</p> <p>1. The virtual serial port is usually named <code>/dev/ttyUSB0</code>. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following:</p> <ul> <li>Use the following command to determine which USB serial devices are already installed:</li> </ul> <pre><code>ls /dev/ttyUSB* </code></pre> <ul> <li>Connect mini USB cable from J10 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet.</li> <li>Use the <code>ls /dev/ttyUSB</code> command again to determine which new USB serial device appeared.</li> </ul> <p>2. Install Minicom application on host PC, if not already installed.</p> <ul> <li>On CentOS, use sudo yum install minicom</li> <li>On Ubuntu, use sudo apt-get install minicom</li> </ul> <p>3. Configure Minicom</p> <pre><code>sudo minicom -s </code></pre> <p>Under Serial Port Setup choose the following:</p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary)</li> <li>Bps/Par/Bits: 115200 8N1</li> <li>Hardware Flow Control: No</li> <li>Software Flow Control: No</li> <li>Hit [ESC] to return to the main configuration menu</li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit.</p> Booting Linux <p>This section presents how to boot Linux on the board. The required steps are:</p> <p>1. Start serial terminal (when using Minicom it will connect using the selected settings, for others connect manually).</p> <p>2. Power up the board.</p> <p>3. U-Boot SPL is ran (two banners are displayed)</p> <p>4. U-Boot is ran</p> <p>5. Linux boots.</p> <p>6. The IP address of the target board will be displayed on the first line of the LCD display. Note that the IP address is displayed only at boot time, it is not updated if the IP address is changed later, for example by the user.</p> <p>7. Login using <code>root</code> and no password.</p> <pre><code>U-Boot SPL 2024.04 (Oct 16 2024 * 02:54:45 +0000) DDRCAL: Success DDRCAL: Scrubbing ECC RAM (1024 MiB). DDRCAL: SDRAM-ECC initialized success with 332 ms FPGA: Checking FPGA configuration setting \u2026 FPGA: Skipping configuration \u2026 WDT: Started watchdog@ffd00300 with servicing every 1000ms (10s timeout) Trying to boot from MMC1 U-Boot 2024.04 (Oct 16 2024 * 02:54:45 +0000)socfpga_arria10 CPU: Altera SoCFPGA Arria 10 BOOT: SD/MMC External Transceiver (1.8V) Model: Altera SOCFPGA Arria 10 DRAM: 1 GiB Core: 77 devices, 20 uclasses, devicetree: separate WDT: Started watchdog@ffd00300 with servicing every 1000ms (10s timeout) MMC: dwmmc0@ff808000: 0 Loading Environment from MMC... *** Warning * bad CRC, using default environment In: serial Out: serial Err: serial Model: Altera SOCFPGA Arria 10 Net: Warning: ethernet@ff800000 (eth0) using random MAC address * 76:b6:1f:1f:71:80 eth0: ethernet@ff800000 Hit any key to stop autoboot: 0 Failed to load 'u-boot.scr' 15000796 bytes read in 720 ms (19.9 MiB/s) FPGA core bitstream Full Configuration Succeeded. FPGA: Enter user mode. switch to partitions #0, OK \nmmc0 is current device Scanning mmc 0:1... Found /extlinux/extlinux.conf Retrieving file: /extlinux/extlinux.conf 1: Arria10 SOCDK SDMMC Retrieving file: /extlinux/../zImage append: root=/dev/mmcblk0p2 rootwait rw earlyprintk memmap=16M$0x3F000000 console=ttyS0,115200n8 Retrieving file: /extlinux/../socfpga_arria10_socdk_sdmmc.dtb Kernel image @ 0x1000000 [ 0x000000 * 0x64c298 ] ## Flattened Device Tree blob at 02000000 \nBooting using the fdt blob at 0x2000000 Working FDT set to 2000000 Loading Device Tree to 09ff5000, end 09fff20b \u2026 OK Working FDT set to 9ff5000 Starting kernel \u2026 Deasserting all peripheral resets [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 6.6.37-altera-gb1e69f412732 (oe-user@oe-host) (arm-poky-linux-gnueabi-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240723) #1 SMP Mon Oct 14 01:56:39 UTC 2024 \n[ 0.000000] CPU: ARMv7 Processor [414fc091] revision 1 (ARMv7), cr=10c5387d [ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache [ 0.000000] OF: fdt: Machine model: Altera SOCFPGA Arria 10 [ 0.000000] Memory policy: Data cache writealloc [ 0.000000] Zone ranges: [ 0.000000] Normal [mem 0x0000000000000000-0x000000002fffffff] [ 0.000000] HighMem [mem 0x0000000030000000-0x000000003fffffff] [ 0.000000] Movable zone start for each node [ 0.000000] Early memory node ranges [ 0.000000] node 0: [mem 0x0000000000000000-0x000000003fffffff] [ 0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x000000003fffffff] [ 0.000000] percpu: Embedded 15 pages/cpu s31636 r8192 d21612 u61440 [ 0.000000] Kernel command line: root=/dev/mmcblk0p2 rootwait rw earlyprintk memmap=16M$0x3F000000 console=ttyS0,115200n8 \u2026 [ OK ] Started Network Configuration. [ OK ] Started Avahi mDNS/DNS-SD Stack. [ OK ] Started WPA supplicant. [ OK ] Started Hostname Service. [ OK ] Reached target Network. [ 12.008639] socfpga-dwmac ff800000.ethernet eth0: Link is Up * 1Gbps/Full * flow control rx/tx Poky (Yocto Project Reference Distro) 5.0.5 arria10 ttyS0 arria10 login: root root@arria10:~# </code></pre>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#running-sample-linux-applications","title":"Running Sample Linux Applications","text":"<p>The GSRD includes a number of sample Linux applications that help demonstrate some of the features of the platform:</p> <ul> <li>Display Hello World message</li> <li>Control LEDs</li> <li>Detect interrupts from push buttons and DIP switches</li> </ul> <p>The sample applications can be used as a starting point for users to write their own applications that interact with software IP through Linux drivers.</p> <p>In serial console, or ssh client console, change current folder to be /home/root/altera. This is where the application binaries are stored.</p> <pre><code>root@arria10:~# cd /home/root/intelFPGA/ </code></pre> Display Hello World Message <p>Run the following command to display the Hello World message on the console:</p> <pre><code>root@arria10:~/intelFPGA# ./hello Hello SoC FPGA! </code></pre> Exercise Soft PIO Driver for LED Control <p>The following LEDs are exercised:</p> LED Number Corresponding Board LED 0 D26 1 D25 2 D28 3 D27 <p>1. In order to blink an LED in a loop, with a specific delay in ms, run the following command:</p> <pre><code>./blink &lt;led_number&gt; &lt;delay_ms&gt; </code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The delay_ms is a number that specifies the desired delay in ms between turning the LED on and off.</li> </ul> <p>2. In order to turn an individual LED on or off, run the following command:</p> <pre><code>./toggle &lt;led_number&gt; &lt;state&gt; </code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The state needs to be 0 to turn the LED off, and 1 to turn the LED on.</li> </ul> <p>3. In order to scroll the FPGA LEDs with a specific delay, please run the following command:</p> <pre><code>./scroll_client &lt;delay&gt; </code></pre> <p>The delay specifies the desired scrolling behavior:</p> <ul> <li>delay &gt; 0 - specify new scrolling delay in ms, and start scrolling</li> <li>delay &lt; 0 - stop scrolling</li> <li>delay = 0 - display current scroll delay</li> </ul> Register Interrupts and Call Interrupt Service Routine <p>In order to register an interrupt handler to a specific GPIO, you will first need to determine the GPIO number used.</p> <p>1. Open the Linux Device Tree socfpga_arria10_ghrd.dtsi file and look up the labels for the DIP switches and Push button GPIOs:</p> <pre><code> button_pio: gpio@0x100000020 { compatible = \"altr,pio-1.0\"; reg = &lt;0xff200020 0x10&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 19 1&gt;; altr,gpio-bank-width = &lt;4&gt;; altr,interrupt-type = &lt;2&gt;; altr,interrupt_type = &lt;2&gt;; edge_type = &lt;1&gt;; level_trigger = &lt;0&gt;; resetvalue = &lt;0&gt;; #gpio-cells = &lt;2&gt;; gpio-controller; }; dipsw_pio: gpio@0x100000030 { compatible = \"altr,pio-1.0\"; reg = &lt;0xff200030 0x10&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 20 1&gt;; altr,gpio-bank-width = &lt;4&gt;; altr,interrupt-type = &lt;3&gt;; altr,interrupt_type = &lt;3&gt;; edge_type = &lt;2&gt;; level_trigger = &lt;0&gt;; resetvalue = &lt;0&gt;; #gpio-cells = &lt;2&gt;; gpio-controller; }; </code></pre> <p>Determine which of the GPIO entries from /sys/class/gpio/ matches the offsets by searching for the address in the label entry.</p> <p>2. Run the following to determine the GPIO numbers for the DIP switches</p> <pre><code>root@arria10:~# grep -r \"0x100000030\" /sys/class/gpio/gpiochip*/label /sys/class/gpio/gpiochip1952/label:/soc/gpio@0x100000030 </code></pre> <p>This means that the GPIOs 1952 .. 1955 are allocated to the DIP switches (there are 4 of them).</p> <p>3. Run the followinig to determine the GPIO numbers for the pushbuttons </p> <pre><code>root@arria10:~# grep -r \"0x100000020\" /sys/class/gpio/gpiochip*/label /sys/class/gpio/gpiochip1984/label:/soc/gpio@0x100000020 </code></pre> <p>This means that the GPIOs 1984, 1985 are allocated to the push buttons (there are 2 of them).</p> <p>4. Register interrupt for one of the dipswiches, using the appropriate GPIO number, as determined in a previous step:</p> <pre><code>root@arria10:~# modprobe gpio_interrupt gpio_number=1952 intr_type=3 [ 269.876015] gpio_interrupt: loading out-of-tree module taints kernel. [ 269.887086] Interrupt for GPIO:1952 [ 269.887086] registered </code></pre> <p>5. Toggle the dipswitch a few times, you will see messages from the interrupt handler</p> <pre><code>[ 269.882892] Interrupt happened at gpio:1952 [ 279.913910] Interrupt happened at gpio:1952 [ 279.923967] Interrupt happened at gpio:1952 [ 280.700461] Interrupt happened at gpio:1952 </code></pre> <p>6. Remove the driver</p> <pre><code>root@arria10:~# rmmod gpio_interrupt </code></pre> <p>7. Register the pushbutton interrupt, using the appropriate GPIO number as determine on a previous step</p> <pre><code>root@arria10:~# modprobe gpio_interrupt gpio_number=1984 intr_type=2 [ 317.445090] Interrupt for GPIO:1984 [ 317.445090] registered </code></pre> <p>8. Push the pusbutton a few times, you will see interrupt handler messages</p> <pre><code>[ 325.824591] Interrupt happened at gpio:1984 [ 326.428601] Interrupt happened at gpio:1984 [ 326.966495] Interrupt happened at gpio:1984 [ 327.554294] Interrupt happened at gpio:1984 </code></pre> <p>9. Once done, remove the handler</p> <pre><code>root@arria10:~# rmmod gpio_interrupt </code></pre> <p>Note: If you are on the ssh console, you will need to run the program <code>dmesg</code> after pressing the button in order to see the messages:</p> <pre><code>root@arria10:~# dmesg </code></pre> System Check Application <p>System check application provides a glance of system status of basic peripherals such as:</p> <ul> <li>USB: USB device driver</li> <li>SysID: FPGA system ID</li> <li>Network IP (IPv4): Network IP address</li> <li>HPS LEDs: HPS LED state</li> <li>FPGA LEDs: FPGA LED state</li> </ul> <p>You run the system check application as follows:</p> <pre><code>root@arria10:~/intelFPGA# ./syschk </code></pre> <p>The interface of the application looks like this:</p> <pre><code> ALTERA SYSTEM CHECK IPv4 Address : 192.168.1.49 usb1 : DWC OTG Controller a10sr-led3 : OFF serial0@ffc02000 : disabled fpga_led2 : OFF serial1@ffc02100 : okay a10sr-led1 : OFF fpga_led0 : OFF ff200000.sysid : 3221768200 fpga_led3 : OFF a10sr-led2 : OFF fpga_led1 : OFF a10sr-led0 : OFF </code></pre> <p>To quit the application, press <code>q</code>.</p> <p>Note: System check application works better when viewed via SSH to the target. USB-UART refreshes slower hence the user interface might flicker.</p> Connecting to Board Web Server and SSH Client <p>The GSRD includes a web server running on the target board that can be used to exercise some of the board features:</p> <ul> <li>Displaying text on the alphanumerical LCD screen</li> <li>Turning LEDs ON and OFF</li> <li>Scrolling LEDs in a sequence</li> <li>Displaying the current status of the LEDs</li> </ul> <p>The web page served by the web server also contains links to some relevant information on the Intel website.</p> Connect to Web Server <p>1. Write down the IP address displayed on the first line of the LCD screen. Note that the IP address is displayed only at the boot time, it is not updated if the IP address is changed later, for example by the user. If your board is connected to a network that doesn't have a DHCP server, it will fallback to use IPv4LL IP address after Linux times out waiting for DHCP server's IP, which is about 2 minutes.</p> <p>Note: There are instances where the DHCP have not assigned an IP to the board before the timeout happens, in which case you may check the IP address via the UART by running <code>ifconfig</code>.</p> <pre><code>root@arria10:~# ifconfig eth0 Link encap:Ethernet HWaddr 02:3d:4f:72:c5:02 inet addr:192.168.1.49 Bcast:192.168.1.255 Mask:255.255.255.0 inet6 addr: fe80::3d:4fff:fe72:c502/64 Scope:Link UP BROADCAST RUNNING MULTICAST DYNAMIC MTU:1500 Metric:1 RX packets:15 errors:0 dropped:0 overruns:0 frame:0 TX packets:54 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:2387 (2.3 KiB) TX bytes:10237 (9.9 KiB) Interrupt:27 Base address:0x2000 </code></pre> <p>2. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter.</p> <p></p> <p>3. Scroll the webpage down to the section named Interacting with Arria 10 SoC Development Kit.</p> <p></p> <p>You will be able to perform the following actions:</p> <ul> <li>See which LEDs are ON and which are off in the LED Status. Note that if the LEDs are setup to be scrolling, the displayed scrolling speed will not match the actual scrolling speed on the board.</li> <li>Stop LEDs from scrolling, by clicking START and STOP buttons. The delay between LEDs turning ON and OFF is set in the LED Lightshow box.</li> <li>Turn individual LEDs ON and OFF with the ON and OFF buttons. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> <li>Blink individual LEDs by typing a delay value in ms then clicking the corresponding BLINK button. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> <li>Display text to the alphanumerical LDC display, by typing the text in the Send to LCD button. Note that the text is displayed in the second LCD line, and it is limited to 16 characters.</li> </ul> Connect Using SSH <p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection.</p> <p></p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS:</p> <pre><code>sudo yum install openssh-clients </code></pre> <p>or the following command on Ubuntu:</p> <pre><code>sudo apt-get install openssh-client </code></pre> <p>3. Connect to the board, and run some commands, such as <code>pwd</code>, <code>ls</code> and <code>uname</code> to see Linux in action.</p> <p></p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#building-the-gsrd","title":"Building the GSRD","text":"<p>The current release tags are:</p> Component Location Branch Tag/Commit ID GHRD https://github.com/altera-fpga/arria10-ed-gsrd.git master QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR Build Flow <p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p></p>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#setting-up-environment","title":"Setting Up Environment","text":"<p>Create a top folder, and change the current folder to it. Define an environment variable to refer to the folder.</p> <pre><code>sudo rm -rf a10_gsrd mkdir a10_gsrd cd a10_gsrd export TOP_FOLDER=`pwd` </code></pre>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#compiling-hardware-design","title":"Compiling Hardware Design","text":"<p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <pre><code>cd $TOP_FOLDER\nrm -rf arria10-ed-gsrd\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arria10-ed-gsrd.git\ncd arria10-ed-gsrd\nmake a10-soc-devkit-sdmmc-baseline-all </code></pre> <p>The following files will be created:</p> <ul> <li>. . /output_files/ghrd_10as066n2.periph.rbf : Peripheral configuration file</li> <li>. . /output_files/ghrd_10as066n2.core.rbf : Core FPGA configuration file</li> </ul>"},{"location":"embedded-designs/arria-10/sx/soc/gsrd/ug-gsrd-a10sx-soc/#setting-up-yocto-build-system","title":"Setting Up Yocto Build System","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER rm -rf gsrd-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga.git\ncd gsrd_socfpga . arria10-gsrd-build.sh build_setup </code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga . ./poky/oe-init-build-env arria10-gsrd-rootfs/ </code></pre> Customize Yocto Build <p>1. Make the handoff XML and RBF files resulted from compiling the hardware project available to the Yocto build system, with the specific filenames required by the Yocto recipes:</p> <ul> <li>arria10_gsrd_ghrd_10as066n2.core.rbf</li> <li>arria10_gsrd_ghrd_10as066n2.periph.rbf</li> <li>arria10_gsrd_hps.xml</li> </ul> <p>using the following commands:</p> <pre><code>HANDOFF_XML=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/arria10_gsrd_hps.xml CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/arria10_gsrd_ghrd_10as066n2.periph.rbf PERIPH_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/arria10_gsrd_ghrd_10as066n2.core.rbf ln -s $TOP_FOLDER/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.periph.rbf $CORE_RBF ln -s $TOP_FOLDER/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/output_files/ghrd_10as066n2.core.rbf $PERIPH_RBF ln -s $TOP_FOLDER/arria10-ed-gsrd/a10_soc_devkit_ghrd_pro/hps_isw_handoff/hps.xml $HANDOFF_XML </code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> delete the following lines:</p> <pre><code>SRC_URI[arria10_gsrd_core.sha256sum] = \"2f777d991527ca7b4fd27488bbdb8286c60942628e6c3614c917840574d4a10b\" SRC_URI[arria10_gsrd_periph.sha256sum] = \"2bdc776fc33c7e277785e1c054227297beb3afca5eb5228d4209d256964e4464\" SRC_URI[arria10_gsrd_hps_xml.sha256sum] = \"7a977bb69db241666cd06509eea63f2b726b064ccf0461e95fb6f524ca7efa3d \n</code></pre> <p>using these commands:</p> <pre><code>sed -i \"/SRC_URI\\[arria10_gsrd_core.sha256sum\\]/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb sed -i \"/SRC_URI\\[arria10_gsrd_periph.sha256sum\\]/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb sed -i \"/SRC_URI\\[arria10_gsrd_hps_xml.sha256sum\\]/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>3. In the same Yocto recipe replace the following lines:</p> <pre><code>SRC_URI:arria10 ?= \"\\\n${GHRD_REPO}/arria10_${IMAGE_TYPE}_hps.xml;name=arria10_${IMAGE_TYPE}_hps_xml \\\n${GHRD_REPO}/arria10_${IMAGE_TYPE}_${A10_GHRD_CORE_RBF};name=arria10_${IMAGE_TYPE}_core \\\n${GHRD_REPO}/arria10_${IMAGE_TYPE}_${A10_GHRD_PERIPH_RBF};name=arria10_${IMAGE_TYPE}_periph \\\n${@bb.utils.contains(\"IMAGE_TYPE\", \"pr\", \"${GHRD_REPO}/arria10_${IMAGE_TYPE}_persona0.rbf;name=arria10_pr_persona0\", \"\", d)} \\\n${@bb.utils.contains(\"IMAGE_TYPE\", \"pr\", \"${GHRD_REPO}/arria10_${IMAGE_TYPE}_persona1.rbf;name=arria10_pr_persona1\", \"\", d)} \\\n \" </code></pre> <p>with</p> <pre><code>SRC_URI:arria10 ?= \"\\\n file://arria10_gsrd_hps.xml;sha256sum=xxxx \\\n file://arria10_gsrd_ghrd_10as066n2.periph.rbf;sha256sum=xxxx \\\n file://arria10_gsrd_ghrd_10as066n2.core.rbf;sha256sum=xxxx \\\n \" </code></pre> <p>using these commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") PERIPH_SHA=$(sha256sum $PERIPH_RBF | cut -f1 -d\" \") HANDOFF_SHA=$(sha256sum $HANDOFF_XML | cut -f1 -d\" \") NEW_URI=\"file:\\/\\/arria10_gsrd_hps.xml;sha256sum=$HANDOFF_SHA file:\\/\\/arria10_gsrd_ghrd_10as066n2.periph.rbf;sha256sum=$PERIPH_SHA file:\\/\\/arria10_gsrd_ghrd_10as066n2.core.rbf;sha256sum=$CORE_SHA\" sed -i -e '/SRC_URI:arria10/{n;N;N;N;N;N;d}' $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb sed -i \"s/SRC_URI:arria10 .*/SRC_URI:arria10 ?= \\\"$NEW_URI\\\"/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image </code></pre> <p>Gather files:</p> <pre><code>package </code></pre> <p>The following files will be created in the folder:</p> File Description sdimage.tar.gz SD card image sdimage.tar.gz.md5sum SD card image checksum arria10_gsrd_ghrd/ghrd_10as066n2.core.rbf Core RBF file arria10_gsrd_ghrd/ghrd_10as066n2.periph.rbf Peripheral RBF file arria10_gsrd_ghrd/hps.xml Quartus handoff for HPS u-boot-arria10-socdk-gsrd/u-boot-splx4.sfp SPL bootable image u-boot-arria10-socdk-gsrd/u-boot.img U-Boot image console-image-minimal-arria10.tar.gz Minimal Linux rootfs in compressed archive format console-image-minimal-arria10.wic.xz Minimal SD card image gsrd-console-image-arria10.tar.gz Linux rootfs in compressed archive format gsrd-console-image-arria10.wic SD card image xvfb-console-image-arria10.tar.gz Linux rootfs with frame buffer support xvfb-console-image-arria10.wic.xz SD card image with the frame buffer rootfs socfpga_arria10_socdk_sdmmc-arria10.dtb Linux device tree socfpga_arria10_socdk_sdmmc.dtb Linux device tree extlinux.conf Linux configuration file fit_spl_fpga_gsrd.itb FPGA configuration FIT file fit_uboot_gsrd.itb U-Boot FIT file Image Uncompressed Linux kernel image zImage Compressed Linux kernel image"},{"location":"embedded-designs/cyclone-v/sx/soc/boot-examples/ug-linux-boot-cve-soc/","title":"HPS GHRD Linux Boot Examples for Cyclone\u00ae V SX Development Kit","text":"<p> NOTE: This page is not available in this release. Cyclone V SoC FPGAs are supported by the Quartus Prime Standard Edition software, the latest release is Quartus Prime Standard Edition v25.1. Please refer to this page to access the latest documentation: Cyclone\u00ae V HPS Linux Boot Examples for Cyclone\u00ae V SX Development Kit. </p>"},{"location":"embedded-designs/cyclone-v/sx/soc/gsrd/ug-gsrd-cve-soc/","title":"HPS GSRD User Guide for the Cyclone\u00ae V SX Development Kit","text":"<p> NOTE: This page is not available in this release. Cyclone V SoC FPGAs are supported by the Quartus Prime Standard Edition software, the latest release is Quartus Prime Standard Edition v25.1. Please refer to this page to access the latest documentation: Cyclone\u00ae V HPS Linux Golden System Reference Design. </p>"},{"location":"embedded-designs/doc_modules/component-versions-all/","title":"Component versions all","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/doc_modules/component-versions-eSW-only/","title":"component versions eSW only","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions are used to build the binaries presented in this page: </p> Component Location Branch Commit ID/Tag Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/doc_modules/setup-console/","title":"Setup console","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, the SoC EDS Pro installer automatically installs the required drivers if necessary.</p> <p>The serial communication parameters are:</p> <ul> <li>Baud-rate: 115,200</li> <li>Parity: none</li> <li>Flow control: none</li> <li>Stop bits: 1</li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus.</p> <p>On Linux, the minicom utility can be used. Here is how to configure it:</p> <p>The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following:</p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB*</li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet.</li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared.</li> <li>Install minicom application on host PC, if not installed.</li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom</li> <li>Configure minicom.</li> </ul> <pre><code>$ sudo minicom -s\n</code></pre> <p>Under Serial Port Setup choose the following:</p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary)</li> <li>Bps/Par/Bits: 115200 8N1</li> <li>Hardware Flow Control: No</li> <li>Software Flow Control: No</li> <li>Hit [ESC] to return to the main configuration menu</li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit.</p>"},{"location":"embedded-designs/doc_modules/setup-quartus/","title":"Setup quartus","text":"<p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/doc_modules/setup-toolchain/","title":"Setup toolchain","text":"<p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre>"},{"location":"embedded-designs/doc_modules/setup-yocto/","title":"Setup yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p>"},{"location":"embedded-designs/doc_modules/bootloaders/boot-scratch-regs-usage/","title":"Boot scratch regs usage","text":""},{"location":"embedded-designs/doc_modules/bootloaders/boot-scratch-regs-usage/#boot-scratch-register-usage","title":"Boot Scratch Register Usage","text":"<p>On Stratix\u00ae 10 SoC, Agilex\u2122 7 and N5X\u00ae devices, the boot scratch registers are part of the System Manager and are used to pass values between various software components. The table below summarizes the usage.</p> <p>Note:</p> <ul> <li>If no device is provided it means that it applies for all.</li> <li>If a cell is not specified for a device, then this could be used as a scratch memory.</li> </ul> Address Name Usage SDM U-Boot ATF Linux 0xFFD1 2200 boot_scratch_cold0 Bits[31] N5X. DDR retention Sets this bit Read  (is_ddr_retention_enabled) 0xFFD1 2200 boot_scratch_cold0 Bits[30:28] N5X, Agilex7M. DDR reset type Sets this field Read  (get_reset_type) 0xFFD1 2200 boot_scratch_cold0 Bits[27:0] SOC 64-bit storing qspi ref clock(kHz) Sets this field Sets value cm_set_qspi_controller_clk_hz  Reads value cm_get_qspi_controller_clk_hz 0xFFD1 2204 boot_scratch_cold1 osc1 clock freq Sets and read(cm_get_osc_clk_hz) 0xFFD1 2208 boot_scratch_cold 2 fpga clock freq Sets and read (cm_get_fpga_clk_hz) 0xFFD1 220C boot_scratch_cold3 reserved for customer use 0xFFD1 2210  0xFFD1 2214 boot_scratch_cold4  boot_scratch_cold5 Secondary CPU RELEASE ADDRESS Main core clears it (lowlevel_init) Main CPU Write (bl31_platform_setup) 0xFFD1 2218  0xFFD1 221C boot_scratch_cold6  boot_scratch_cold7 64-bit signature with L2 reset indication done. Writes signature (l2_reset_cpu) Reads the register (lowlevel_init) Writes register (socfpga_system_reset2) Reads register (plat_get_my_entrypoint) 0xFFD1 2220 boot_scratch_cold8 Bit[31:31] N5X, Agilex 7M. DBE status Set by SDM Check if bit is set (is_ddr_dbe_triggered) 0xFFD1 2220 boot_scratch_cold8 Bit[30:30] N5X, Agilex 7M. DDR Init Progress Set and clear bit(ddr_init_inprogress) Read status (is_ddr_init_hang) 0xFFD1 2220 boot_scratch_cold8 Bit[29:29] Agilex 7M. OCRAM_DBE  Error status 0xFFD1 2220 boot_scratch_cold8 Bits[28:27] Agilex 7M. Number of IO96B instances Sets this field (update_io96b_assigned_to_hps) 0xFFD1 2220 boot_scratch_cold8 Bit[19:19] Agilex 7, Agilex 7M, S10. CPU power domain is about to be turned on. Handled call under event (socfpga_pwr_domain_on) 0xFFD1 2220 boot_scratch_cold8 Bit[18:18] Agilex 7, S10. ACF DDR Data rate Set this bit Read this value (sdram_mmr_init_full) 0xFFD1 2220 boot_scratch_cold8 Bit[17,16,1] ECC_DDR1 Error Flag, ECC_DDR0 Error Flag, ECC_OCRAM Error Flag 0xFFD1 2220 boot_scratch_cold8 Checks if any of the flags are set (socfpga_system_reset2) Set via ATF SMC 0xFFD1 2224 boot_scratch_cold9 Write (via ATF SMC) <p>Links:</p> <ul> <li>Stratix\u00ae 10 HPS Registers</li> <li>Agilex\u2122 7 HPS Registers</li> <li>Review device-specific Boot User Guide for more information about these registers.</li> </ul>"},{"location":"embedded-designs/doc_modules/bootloaders/bridge-enable-uboot/","title":"Bridge enable uboot","text":""},{"location":"embedded-designs/doc_modules/bootloaders/bridge-enable-uboot/#enabling-bridges-from-u-boot","title":"Enabling Bridges from U-Boot","text":"<p>U-Boot offers the bridge command for controlling the bridges.</p> <p>The bridge command can be used with either 'enable' or 'disable' parameter, followed by an optional 'mask' parameter indicating which of the bridges needs to be enabled or disabled. When the 'mask' parameter is omitted, all bridges are either enabled or disabled.</p> <p>See bellow the help message for the command:   <pre><code># bridge\nbridge - SoCFPGA HPS FPGA bridge control\n\nUsage:\nbridge enable [mask] - Enable HPS-to-FPGA (Bit 0), LWHPS-to-FPGA (Bit 1), FPGA-to-HPS (Bit 2), F2SDRAM0 (Bit 3), F2SDRAM1 (Bit 4), F2SDRAM2 (Bit 5) bridges \nbridge disable [mask] - Disable HPS-to-FPGA (Bit 0), LWHPS-to-FPGA (Bit 1), FPGA-to-HPS (Bit 2), F2SDRAM0 (Bit 3), F2SDRAM1 (Bit 4), F2SDRAM2 (Bit 5) bridges\nBit 3, Bit 4 and Bit 5 bridges only available in Stratix 10\n</code></pre> The** 'mask'** is a hexadecimal number, with 3 bits available for Agilex\u2122 7, and 6 bits for Stratix\u00ae 10, as indicated above.</p> <p>The following table shows examples of enabling and disabling various bridges:</p> Command Description bridge enable Enable all bridges bridge disable Disable all bridges bridge enable 1 Enable HPS-to-FPGA bridge bridge enable 2 Enable LWHPS-to-FPGA bridge bridge enable 4 Enable FPGA-to-HPS bridge bridge enable 7 Enable HPS-to-FPGA, LWHPS-to-FPGA, FPGA-to-HPS bridges bridge enable 35 Enable HPS-to-FPGA, FPGA-to-HPS, F2SDRAM1, F2SDRAM2 bridges(Stratix\u00ae 10 only) bridge disable 30 Disable F2SDRAM1, F2SDRAM2 bridges (Stratix\u00ae 10 only)"},{"location":"embedded-designs/doc_modules/bootloaders/managing-sec-l3-regs/","title":"Managing sec l3 regs","text":""},{"location":"embedded-designs/doc_modules/bootloaders/managing-sec-l3-regs/#managing-secure-l3-registers-on-stratix-10-agilextm-and-n5x","title":"Managing Secure L3 Registers on Stratix\u00ae 10, Agilex\u2122 and N5X\u00ae","text":"<p>On Stratix\u00ae 10, Agilex\u2122 7 and N5X\u00ae HPS there are specific peripherals which are critical for system operation which can only be accessed from software running at EL3.</p> <p>The following HPS software components run at EL3 on these devices and can access Secure L3 registers:</p> <ul> <li>U-Boot SPL: initial values for the secure L3 registers are set here through the device tree 'secreg' entries. The user can customize them as needed by editing the device tree.</li> <li>Arm Trusted Firmware (ATF): Both U-Boot and Linux call the ATF SMC (Secure Monitor Call) handler to access a restricted subset of secure L3 registers needed for routine system operation.</li> </ul> <p>This section presents the following:</p> <ul> <li>How to use the 'secreg' device tree entries to customize initial secure L3 registers values set by U-Boot SPL</li> <li>How to access registers from the restricted subset from U-Boot, for debug purposes.</li> <li>How to access other secure EL3 register from U-Boot, by by changing the ATF source code to add add them to the restricted subset.</li> </ul>"},{"location":"embedded-designs/doc_modules/bootloaders/managing-sec-l3-regs/#setting-initial-values-of-secure-l3-registers","title":"Setting Initial Values of Secure L3 Registers","text":"<p>The initial values for the Secure L3 registes are set from U-Boot SPL. The register values are specified in secreg entries in the U-Boot device tree file.</p> <p>Refer to u-boot-socfpga/blob/HEAD/doc/device-tree-bindings/misc/socfpga_secreg.txt for documentation the secreg. The  socfpga_v2021.04 version shows the following:   <pre><code>* Firewall and privilege register settings in device tree\n\nRequired properties:\n--------------------\n- compatible: should contain \"intel,socfpga-secreg\"\n- intel,offset-settings: 32-bit offset address of block register, and then\n                       followed by 32-bit value settings.\nExample:\n--------\n      socfpga_secreg: socfpga-secreg {\n          compatible = \"intel,socfpga-secreg\";\n          #address-cells = &lt;1&gt;;\n          #size-cells = &lt;1&gt;;\n          u-boot,dm-pre-reloc;\n\n          i_sys_mgr@ffd12000 {\n              reg = &lt;0xffd12000 0x00000228&gt;;\n              intel,offset-settings =\n                  &lt;0x00000020 0xff010000&gt;,\n                  &lt;0x00000024 0xffffffff&gt;;\n              u-boot,dm-pre-reloc;\n          };\n      };\n</code></pre> Notes about the example:</p> <ul> <li>The u-boot,dm-pre-reloc; statement in the example informs U-Boot the driver will be loaded in SPL.</li> <li>The i_sys_mgr@ffd12000 statement in the example is informative only to enable readers to quickly see what IP is being set up, it is not actually used by the code.</li> <li>The reg =&lt;0xffd12000 0x00000228&gt; entry specifies the IP module base address 0xffd12000 and span of 0x00000228 bytes.</li> <li>The &lt;0x00000020 0xff010000&gt;, specifies that the register at offset 0x00000020 from the IP module base address will be set to value 0xff010000.</li> </ul> <p>These are the files which currently define the initial value of the Secure L3 registers:</p> <ul> <li>Common: u-boot-socfpga/arch/arm/dts/socfpga_soc64_u-boot.dtsi.</li> <li>Stratix\u00ae 10: u-boot-socfpga/arch/arm/dts/socfpga_stratix10-u-boot.dtsi.</li> <li>Agilex\u2122 7: arch/arm/dts/socfpga_agilex-u-boot.dtsi</li> <li>N5X\u00ae: u-boot-socfpga/arch/arm/dts/socfpga_n5x-u-boot.dtsi</li> </ul> <p>You can edit the above files accordingly to change the default values, or set the initial value of more registers.</p>"},{"location":"embedded-designs/doc_modules/bootloaders/managing-sec-l3-regs/#accessing-secure-l3-registers-from-u-boot-command-line","title":"Accessing Secure L3 Registers from U-Boot Command Line","text":"<p>A small subset of critical EL3 restricted access registers are made visible through the ATF SMC handler. The current list of registers is defined in arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c..</p> <p>The secure L3 registers accessible through the ATF SMC handler can also optionally be accessed from U-Boot command line for debug purposes. The feature can be enabled by setting CONFIG_CMD_SMC=y in the U-Boot configuration file.</p> <p>Once the feature is enabled, the following command will be avaible from U-Boot command line interface:</p> <p><pre><code>SOCFPGA # smc\nsmc - Issue a Secure Monitor Call\n\nUsage:\nsmc  [arg1 \u2026 arg6] [id]\n  - fid Function ID\n  - arg SMC arguments, passed to X1-X6 (default to zero)\n  - id  Secure OS ID / Session ID, passed to W7 (defaults to zero)\n</code></pre> The U-Boot environment already includes predefined ids to facilitate the usage of the command:   <pre><code>smc_fid_rd=0xC2000007\nsmc_fid_upd=0xC2000009\nsmc_fid_wr=0xC2000008\n</code></pre> The command can be used as follows:   <pre><code>smc ${smc_fid_rd} &lt;address&gt;\nsmc ${smc_fid_wr} &lt;address&gt; &lt;value&gt;\nsmc ${smc_fid_upd} &lt;address&gt; &lt;mask&gt; &lt;value&gt;\n</code></pre> See below using the new command to access the BOOT_SCRATCH_COLD0 register (note there is no need to access that register, this is just an example):</p> <p>1.- Read the register:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd12200\nRes:  0 400000 4291895808 0\n</code></pre> Note:</p> <ul> <li>First value from Res is the return code, 0 means operation succesfull.</li> <li>Second value represents the read register value in decimal 400000=0x00061a80.</li> <li>Third value is the address in decimal 4291895808=0xffd12200.</li> </ul> <p>2.- Write the register with a new value:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_wr} 0xffd12200 0x00061a81\nRes:  0 400001 4291895808 0\n</code></pre></p> <p>3.-  Read back the register to confirm it has been updated:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd12200\nRes:  0 400001 4291895808 0\n</code></pre></p>"},{"location":"embedded-designs/doc_modules/bootloaders/managing-sec-l3-regs/#enabling-access-to-more-secure-l3-registers-for-debug-purposes","title":"Enabling Access to more Secure L3 Registers for Debug Purposes","text":"<p>By default, only a small subset of critical EL3 restricted access registers are made visible through the ATF SMC handler. The current list of registers is defined in arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c. For debug purposes, you can add more registers to the restricted register list that can be accessed through the ATF SMC handler.</p> <p>Warning: Changing the list of EL3 restricted access registers in ATF is risky, and must be done only for debug purposes only! Do not forget to remove the code once debugging has completed!</p> <p>When trying to access a register which is not made visible by the ATF SMC handler, an error will be reported. See below example trying to read the noc_fw_soc2fpga_soc2fpga_scr register:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd21200\nRes:  4 0 4291957248 0\n</code></pre> Note:</p> <ul> <li>The non-zero (4) return code means the operation was not succesfull.</li> </ul> <p>After editing the file arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c to add this register to the list, and recompiling ATF, the operation is succesfull:</p> <p><pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd21200\nRes:  0 268304641 4291957248\n</code></pre> Note:</p> <ul> <li>Return code is zero, operation was succesfull.</li> <li>Read value is decimal 268304641=0xFFE0101.</li> </ul>"},{"location":"embedded-designs/doc_modules/bootloaders/qspi-ref-clock/","title":"Qspi ref clock","text":""},{"location":"embedded-designs/doc_modules/bootloaders/qspi-ref-clock/#qspi-reference-clock","title":"QSPI Reference Clock","text":"<p>The QSPI peripheral clocks are provided by the SDM, based on the SDM input clocks and configuration clock settings defined in the Quartus\u00ae Pro project. However, the HPS needs to know the QSPI reference clock, so that it can properly set the dividers in the QSPI controller to create the desired external QSPI clock frequency.</p> <p>The HPS obtains the QSPI controller reference clock frequency when it obtains exclusive access to the QSPI from the SDM. The frequency reported by the SDM is stored in the U-Boot environment variable called ${qspi_clock}.</p> <p>Before booting Linux, U-Boot loads the Linux device tree in memory, then runs the command linux_qspi_enable which sets the QSPI controller reference clock appropriately using the value from the ${qspi_clock} environment variable.</p>"},{"location":"embedded-designs/doc_modules/bootloaders/reconfig-from-uboot/","title":"Reconfig from uboot","text":""},{"location":"embedded-designs/doc_modules/bootloaders/reconfig-from-uboot/#reconfiguring-core-fabric-from-u-boot","title":"Reconfiguring Core Fabric from U-Boot","text":"<p>The GSRD configures the FPGA core fabric only once, from U-Boot, by using the bootm command. The example in this page configures the fabric only once, from U-Boot, using fpga load command.</p> <p>Important: If the FPGA fabric is already configured and bridges are enabled, you must call the bridge disable command from U-Boot before issuing the bootm or fppga load commands to reconfigure the fabric. Only do this if you are using an arm-trusted-firmware version more recent than the following:</p> <ul> <li>v2.7.1 = https://github.com/altera-opensource/arm-trusted-firmware/commit/0a5edaed853e0dc1e687706ccace8e844b2a8db7</li> <li>v2.8.0 = https://github.com/altera-opensource/arm-trusted-firmware/commit/bf933536d4582d63d0e29434e807a641941f3937</li> </ul>"},{"location":"embedded-designs/doc_modules/gsrd/update-kernel-itb/","title":"Update kernel itb","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/doc_modules/gsrd/update-sdcard-content/","title":"Update sdcard content","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow.</p>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/","title":"Rsu separate ssbl","text":""},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5, Agilex\u2122 3 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p> <p>Note:  Agilex\u2122 3 HPS Remote System Update User Guide will be released soon.</p>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/doc_modules/tsn/test-tsn-app_txrx/","title":"Test tsn app txrx","text":"<p>The following examples are demonstrated using 2 units of the Agilex 5 platform.  Please take note of the notation \"[Board A or B]\". The following steps assumes both platforms are connected to each other via an Ethernet connection.</p> <p>1. Boot to Linux</p> <p>2. Navigate to the <code>tsn</code> directory</p> <pre><code>cd tsn\n</code></pre> Configuration for Both Boards Step I: Setup Environment Path on Both Boards <p>3. Board A</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib64/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> <p>4. Board B</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib64/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> TXRX-TSN App Step II: Run Configuration Script <p>5. Board A: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up TAPRIO qdisc.</p> <pre><code>./run.sh agilex5 eth0 vs1a setup\n</code></pre> <p>6. Board B: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up ingress qdiscs.</p> <pre><code>./run.sh agilex5 eth0 vs1b setup\n</code></pre> Step III: Start the Application <p>7. Board B: Run the application.</p> <pre><code>./run.sh agilex5 eth0 vs1b run\n</code></pre> <p>8. Board A: Immediately after starting the application on Board B, run the application on Board A.</p> <pre><code>./run.sh agilex5 eth0 vs1a run\n</code></pre> Post-Test Procedure <p>Once the test is completed, copy the following files from Board B (listener) to the host machine:</p> <ul> <li>afpkt-rxtstamps.txt</li> <li>afxdp-rxtstamps.txt</li> </ul> Generating Latency Plot Using Excel <p>Import 'afpkt-rxtstamps.txt' and 'afxdp-rxtstamps.txt' to excel in 2 seperate sheets.</p> <p></p> <p>Plot Column 1 for each sheets using Scatter chart,</p> <p></p> <p>This will generate plot for AFPKT and AFXDP with latency(on Y-axis) against packet count (on X-axis).</p>"},{"location":"embedded-designs/doc_modules/tsn/test-tsn-timesync/","title":"Test tsn timesync","text":"<p>You may use the following command guide to perform time synchronization on the Agilex\u2122 5 system using PTP4L and PHC2SYS, and to obtain delay values</p> <p>End-to-End PTP master and slave synchronization</p> <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -E -2 -m\n</code></pre> <pre><code>-i  eth0: This option specifies the `eth0` as the network interface to use for PTP.\n-s  This option enables the slave-only mode. \n-H  This option enables hardware time stamping. \n-E  This option selects the end-to-end (E2E) delay measurement mechanism. This is the default.The E2E mechanism is also referred to as the delay \u201crequest-response\u201d mechanism.\n-2  Use Ethernet Layer (L2)\n-m  This option enables printing of messages to the standard output.\n</code></pre> </li> </ul> <ul> <li>Boards A (as master):<pre><code>ptp4l -i eth0  -H -E -2 -m\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul> <p>Peer-to-Peer PTP synchronization:</p> <ul> <li>Board B (as slave):     <pre><code>slave: ptp4l -i eth0  -s -H -P -2 -m\n</code></pre><p>-P: This option enables the use of the Peer Delay Mechanism.</p> </li> </ul> <ul> <li>Board A (as master):     <pre><code>master: ptp4l -i eth0  -H -P -2 -m\n</code></pre></li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul> <p>gPTP synchronization:</p> <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>Board A (as master): <pre><code>ptp4l -i eth0  -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m --transportSpecific 1 -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/","title":"HPS GHRD Linux Boot Tutorial Example Design: Stratix\u00ae 10 SX SoC Development Kit","text":""},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#intro","title":"Intro","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The key differences versus the GSRD are:</p> <ul> <li>Fabric is configured from U-Boot directly with the rbf file, with <code>fpga load</code> command, instead of using the <code>bootm</code> command with the core.rbf part of the kernel.itb file</li> <li>Single image boot is disabled in U-Boot, and it boots directly with the slected boot source, not trying them all</li> <li>The applications and drivers form <code>meta-intel-fpga-refdes</code> are not included. That includes acessing GPIOs in the fabric for LEDs, pushbuttons, dip switches, the webserver running on the board, etc.</li> </ul> <p>This instructions from this page target the Stratix\u00ae 10 SX SOC Development kit H-Tile (DK-SOC-1SSX-H-D). </p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p> <p>Starting with SoC EDS Pro version 19.3, the following changes were made: The bootloader source code was removed from SoC EDS. Instead, the user needs to clone the git trees from https://github.com/altera-fpga/u-boot-socfpga.</p> <p>The same U-Boot branch is used for all SoC FPGA devices: Cyclone\u00ae V SoC, Arria\u00ae V SoC, Arria\u00ae 10 SoC, Stratix\u00ae 10 SoC, Agilex\u2122 7 and Agilex\u2122 5.</p> <p>Starting with Quartus\u00ae Pro 20.3, the SoC EDS was discontinued, and the functionality of the tools which were previously part of SoC EDS are provided separately.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#u-boot-build-flow","title":"U-Boot Build Flow","text":"<p>For Stratix\u00ae 10, Agilex\u2122 7 and Agilex\u2122 5 devices, all the handoff information created by the Quartus\u00ae Pro compilation is part of the configuration bitstream. The bsp-editor is not used, and the bootloader build flow does not depend on the Quartus\u00ae outputs.</p> <p> </p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#single-boot-image","title":"Single Boot Image","text":"<p>Starting with U-Boot 2021.07, the following changes were made to enable a single set of binaries to be used with multiple boards and hardware projects:</p> <ul> <li>The Quartus hardware project defines a JTAG User Code which is used by the rest of the system as a board_id to identify the hardware.</li> <li>U-Boot has a single defconfig enabling all possible HPS hardware, and depending on the timeouts to determine which hardware is not actually available.</li> <li>U-Boot has a single device tree FIT file enabling all possible HPS hardware, but with different configurations inside, selected according to the board_id.</li> <li>Linux FIT file also has a different configuration for each board_id. Each configuration includes the kernel, the specific device file, and an optional core.rbf file. If the core.rbf file is specified, the fabric is configured with that file.</li> </ul> <p>Refer to Single Image Boot for more details about this feature.</p> <p>The Stratix\u00ae 10 GSRDs are also updated to use this feature. See the GSRD documentation for details:</p> <ul> <li>Stratix\u00ae 10 GSRD User Guide</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#u-boot-branches","title":"U-Boot Branches","text":"<p>The official Intel SOCFPGA U-Boot repository is located at https://github.com/altera-fpga/u-boot-socfpga.</p> <p>Notes:</p> <ul> <li>A \"RC\" labeled branch is for internal active development use and customer early access without official customer support.</li> <li>Latest stable branch (no RC labeled) is strongly recommended for development and production use outside of Intel.</li> <li>See doc/README.socfpga for Quartus\u00ae Pro and Device support.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#boot-from-sd-card-example","title":"Boot From SD Card Example","text":"<p>This example shows a simple example booting Stratix\u00ae 10 from SD card. Note the following:</p> <ul> <li>Hardware design was customized as follows:      -  Disable SGMII and PR to reduce compilation time and boot time.     -  Override the JTAG User Core to that board_id is 4, and the standard SD Card/OOBE configuration is used.</li> </ul> <ul> <li>U-Boot was customized as follows:     - Disable NAND in the unified defconfig file, as we do not need it.     - Boot only from SD card, as opposed to trying SD, QSPI and NAND.     - Use Dwarf4 for debug information, to be compatible with current Arm DS debugger.     - Configure FPGA fabric from boot command using fpga load command explicitly (instead of using the bootm command to do it).     - Use booti command to boot Linux, with separate files for kernel and device tree.</li> </ul> <p>The above customizations may be useful for debugging purposes for example.</p> <p>The following build instructions produce a QSPI(.jic) and an SDCard Image (.img) which includes the components indicated in the following figure:</p> <p></p> <p>This example uses building U-Boot manually. See Stratix\u00ae 10 SoC H-Tile GSRD for the full fledged booting from SD card example, where U-Boot is built through Yocto recipes.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Host machine running Linux. Ubuntu 22.04 was used, but other versions may work too.</li> <li>Internet connection to download the tools and clone the U-Boot git tree from github. If you are behind a firewall you will need your system administrator to enable you to get to the git trees.</li> <li>Intel Stratix\u00ae 10 H-Tile SoC FPGA Development Kit (DK-SOC-1SSX-H-D).</li> <li>Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> <p>Note that the examples presented on this page boot to Linux and they require Linux kernel, device tree and rootfilesystem to boot. However, you can omit the Linux binaries and just boot to U-Boot prompt if you want to.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#setting-up-environment","title":"Setting Up Environment","text":"<pre><code>sudo rm -rf s10_example.sdmmc\nmkdir s10_example.sdmmc\ncd s10_example.sdmmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#build-hardware-design","title":"Build Hardware Design","text":"<pre><code>cd $TOP_FOLDER\nwget https://github.com/altera-fpga/stratix10-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv stratix10-ed-gsrd-QPDS25.1.1_REL_GSRD_PR stratix10-ed-gsrd\ncd stratix10-ed-gsrd\nmake s10-htile-soc-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>After building the hardware design the following binary is created:</p> <ul> <li>$TOP_FOLDER/stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#build-arm-trusted-firmware","title":"Build Arm Trusted Firmware","text":"<pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 64 bl31 PLAT=stratix10\ncd ..\n</code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#build-u-boot","title":"Build U-Boot","text":"<pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga\n# enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n# remove the NAND configuration from device tree\nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin .\n\n# Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment-stratix10\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# - Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; bridge disable; fpga load 0 \\${loadaddr} \\${filesize};bridge enable;setenv bootfile Image;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# Enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_stratix10_defconfig\n# Use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-stratix10\nmake -j 64\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file. </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries. </li> </ul> <p>Note: The following commands are ran before starting Linux:</p> <ul> <li>run linux_qspi_enable: This passes the QSPI reference clock value to Linux. See QSPI_Reference_Clock section.</li> <li>run rsu_status: This performs some RSU operations that must be done before booting Linux. Only needed when enabling RSU. See: Stratix 10 HPS Remote System Update User Guide.</li> </ul> <p>Important:  Before running the fpga load command, you must first run the bridge disable command as shown in the above example.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#prepare-qspi-image","title":"Prepare QSPI Image","text":"<pre><code>cd $TOP_FOLDER\nquartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=1SX280HU2F50E1VGAS \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/ghrd.hps.jic</li> <li>$TOP_FOLDER/ghrd.core.rbf</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#building-linux-kernel","title":"Building Linux Kernel","text":"<p>Download and compile Linux:</p> <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\nmake clean &amp;&amp; make mrproper\n# enable kernel debugging with RiscFree\n./scripts/config --set-val CONFIG_DEBUG_INFO  y\n./scripts/config --set-val CONFIG_GDB_SCRIPTS y\nmake defconfig\nmake -j 64 Image dtbs\n</code></pre> <p>The following items are built in $TOP_FOLDER:</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb</li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#building-yocto-rootfs","title":"Building Yocto Rootfs","text":"<p>This section presents how to build the Linux rootfs using Yocto recipes. Note that the yocto recipes actually build everything, but are only interested in the rootfs.</p> <p>First, make sure you have Yocto system requirements met: https://docs.yoctoproject.org/3.4.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar   https://github.com/openembedded/meta-openembedded\n# work around issue\necho 'do_package_qa[noexec] = \"1\"' &gt;&gt; $(find meta-intel-fpga -name linux-socfpga_6.6.bb)\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"stratix10\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf  echo 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver devmem2\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#prepare-sd-card-image","title":"Prepare SD Card Image","text":"<pre><code>cd $TOP_FOLDER/\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp; cd fatfs\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb .\ncp $TOP_FOLDER/ghrd.core.rbf .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz\nsudo rm -rf lib/modules/*\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=400M \\\n-s 512M \\\n-n sdcard.img\n</code></pre> <p>After completting the binaries build, the following files will be needed to boot Linux:</p> <ul> <li>$TOP_FOLDER/ghrd.hps.jic</li> <li>$TOP_FOLDER/sd_card/sdcard.img</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#boot-linux","title":"Boot Linux","text":"<p>Write SD card image to SD card and insert it in the slot.</p> <p>Configure the S10 SoC Development Kit as follows:</p> <ul> <li>SW1: 1:OFF, rest:ON</li> <li>SW2: 1:ON 2:ON 3: ON 4: OFF (set MSEL to JTAG)</li> <li>SW3: all OFF</li> <li>SW4: 1:ON 2:OFF 3:OFF 4:ON</li> </ul> <p>Use Quartus\u00ae Pro Programmer to program the QSPI flash:   <pre><code>cd $TOP_FOLDER/\nquartus_pgm -m jtag -o \"pvi;./ghrd.hps.jic\"\n</code></pre> Note:If there was no previous design running, or if the previous design has been running fine, the MSEL does not need to be set to JTAG. It can remain set to QSPI, and you can still program QSPI flash succesfully. In case there was a previous design running, run \"jtagconfig\" to determine if the Stratix\u00ae 10 (SDM) is first or second in the JTAG scan chain. If it is second, change the above command to:</p> <p><pre><code>cd $TOP_FOLDER/\nquartus_pgm -m jtag -o \"pvi;ghrd.hps.jic@2\"  \n</code></pre> Set MSEL back to QSPI:</p> <ul> <li>SW2: 1:ON 2:OFF 3:OFF 4: OFF</li> </ul> <p>Power cycle the board.</p> <p>Linux will boot up. Use 'root' as username, a password will not be required.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#other-examples","title":"Other Examples","text":""},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#boot-from-qspi","title":"Boot from QSPI","text":"<p>See  Stratix\u00ae 10 Boot From QSPI</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#boot-with-nand-storage-on-hps","title":"Boot with NAND Storage on HPS","text":"<p>See Stratix\u00ae 10 Boot From NAND</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#boot-with-emmc-storage-on-hps","title":"Boot with eMMC Storage on HPS","text":"<p>See Stratix\u00ae 10 HPS eMMC Boot Example</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#running-u-boot-with-the-debugger-from-command-line","title":"Running U-Boot with the Debugger from Command Line","text":"<p>This section presents examples of how to run U-Boot with the Arm Development Studio from command line. This offers a simple and convenient way to run U-Boot and use it for example to program onboard flash.</p> <p>1.- Use the binaries built for the Boot From SDCard Example:   <pre><code>cd s10_example.sdmmc\n</code></pre></p> <p>2.-  Run jtagconfig command to determine if the HPS is currently in the JTAG scanchain:   <pre><code>jtagconfig\n1) Stratix 10L SoC Dev Kit [3-3.4.4]\n  6BA00477   S10HPS/AGILEX_HPS\n  C321D0DD   1SX280LH(2|3)/1SX280LN2(|AS)/..\n</code></pre>   If HPS is not present, the line with S10HPS/AGILEX_HPS above will not appear.</p> <p>3.- Configure the FPGA with the debug SOF:   <pre><code>quartus_pgm -c 1 -m jtag -o \"p;stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline_hps_debug.sof@2\"\n</code></pre>   If the HPS is not present in the jtagconfig output above, please remove the \"@2\" from the command line above.</p> <p>4.-  Create debugger script:   <pre><code>cat &lt;&lt;EOT &gt; run-u-boot.ds\ninterrupt\nrestore \"u-boot-socfpga/spl/u-boot-spl-dtb.bin\" binary 0xFFE00000\nloadfile \"u-boot-socfpga/spl/u-boot-spl\"\ncore 1\nset \\$PC = \\$ENTRYPOINT\ncore 2\nset \\$PC = \\$ENTRYPOINT\ncore 3\nset \\$PC = \\$ENTRYPOINT\ncore 0\nset \\$PC = \\$ENTRYPOINT\nthbreak board_boot_order\ncontinue\nwait\nset spl_boot_list[0]=0\nset \\$PC=\\$LR\nrestore \"u-boot-socfpga/u-boot.itb\" binary 0x2000000\ncontinue\nEOT\n</code></pre></p> <p>5.- Run the debugger from command line, using the connection parameters reported above by jtagconfig, shown in red below:</p> <p><pre><code>/opt/arm/developmentstudio-2022.2/bin/armdbg  \\\n--cdb-entry=\"Intel SoC FPGA::Stratix 10::Bare Metal Debug::Bare Metal Debug::Debug Cortex-A53x4 SMP::Intel FPGA Download Cable\" \\\n--cdb-entry-param=\"rvi_address=Stratix 10L SoC Dev Kit on localhost [3-3.4.4]:Stratix 10L SoC Dev Kit 3-3.4.4\" \\\n--continue_on_error=true \\\n--stop_on_connect=false \\\n-s run-u-boot.ds\n</code></pre>   6.- The serial console will show SPL then U-Boot being run:   <pre><code>U-Boot SPL 2025.04-35102-g135e53726d-dirty (Jan 29 2025 - 11:04:08 -0600)\nReset state: Cold\nMPU         1000000 kHz\nL3 main     400000 kHz\nMain VCO    2000000 kHz\nPer VCO     2000000 kHz\nEOSC1       25000 kHz\nHPS MMC     50000 kHz\nUART        100000 kHz\nDDR: 4096 MiB\nSDRAM-ECC: Initialized success with 1175 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 \u2026 OK\n## Checking hash(es) for Image atf \u2026 crc32+ OK\n## Checking hash(es) for Image uboot \u2026 crc32+ OK\n## Checking hash(es) for Image fdt-0 \u2026 crc32+ OK\nNOTICE:  BL31: v2.12.1(release):QPDS25.1.1_REL_GSRD_PR\nNOTICE:  BL31: Built : 11:03:24, Jan 29 2025\n\nU-Boot 2025.04-35102-g135e53726d-dirty (Jan 29 2025 - 11:04:08 -0600)socfpga_stratix10\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Stratix 10 SoCDK\nDRAM:  2 GiB (effective 4 GiB)\nCore:  26 devices, 21 uclasses, devicetree: separate\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:   \nWarning: ethernet@ff800000 (eth0) using random MAC address - d2:31:2d:41:7e:a8\neth0: ethernet@ff800000\nHit any key to stop autoboot:  0 \nSOCFPGA_STRATIX10#\n</code></pre></p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#debugging-u-boot-with-arm-ds-eclipse","title":"Debugging U-Boot with Arm DS Eclipse","text":"<p>This section presents examples of how to debug U-Boot with from the Arm Development Studio Eclipse-based GUI.</p> <p>### Prerequisites  1.- Use the binaries built for the Boot From SDCard Example:   <pre><code>cd s10_example.sdmmc\n</code></pre></p> <p>2.- Run jtagconfig to determine if the HPS is currently in the JTAG scanchain:   <pre><code>jtagconfig\n1) Stratix 10L SoC Dev Kit [3-4.3.1]\n  6BA00477   S10HPS/AGILEX_HPS\n  C321D0DD   1SX280LH(2|3)/1SX280LN2(|AS)/..\n</code></pre></p> <p>If HPS is not present, the line with S10HPS/AGILEX_HPS above will not appear.</p> <p>3.- Configure the FPGA with the debug SOF:   <pre><code>quartus_pgm -c 1 -m jtag -o \"p;stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline_hps_debug.sof@2\"  \n</code></pre></p> <p>If the HPS is not present in the jtagconfig output above, please remove the \"@2\" from the command line above.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#debugging-spl","title":"Debugging SPL","text":"<p>1.- Run the steps from Prerequisites section   2.- Start the Arm Development Studio Eclipse-based GUI:   <pre><code>/opt/arm/developmentstudio-2022.2/bin/armds_ide -data workspace &amp;\n</code></pre></p> <p>Note the above creates a new workspace in the s10_example.sdmmc folder.</p> <p>3.- In Eclipse, Go to Run &gt; Debug Configurations to open the Debug Configurations window. </p> <p>4.- In the Debug Configurations window:    a) Select the Generic Arm C/C++ Application on the left panel and right-click it. From the menu that appears, select New Configuration.   b) Edit the Name field from New_configuration to something more descriptive, such as Debug S10 Bootloader.</p> <p>5.- In the Connection tab:   a) Go to Select target section and select Intel SoC FPGA &gt; Stratix 10 &gt; Bare Metal Debug &gt; Debug Cortex-A53_0   b) Select the Target Connection to be Intel FPGA Download Cable   c) Click the Bare Metal Debug &gt; Connection Browse button and select your cable.</p> <p>The Debug Configurations window should now look like this:    </p> <p>6.- Go to the Debugger tab, and do the following:   a) Select Connect Only   b) Check Execute debugger commands and enter the following commands:</p> <pre><code>```\ninterrupt\nrestore \"u-boot-socfpga/spl/u-boot-spl-dtb.bin\" binary 0xFFE00000\nloadfile \"u-boot-socfpga/spl/u-boot-spl\"\nset $PC = $ENTRYPOINT\n```\n</code></pre> <p>c) Uncheck Host working directory &gt; Use default and edit the value to add \"/../\" so that it looks in the parent folder of the workspace.</p> <p>The Debug Configurations window should now look like this:</p> <p></p> <p>7.- Click the Debug button. Arm Development Studio will run the commands, therefore downloading the SPL to board and starting it. The Eclipse window should now look like this: </p> <p></p> <p>8.- At this point you can use standard debug techniques to debug U-Boot SPL: viewing registers, variables, putting breakpoints, running step-by-step etc.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#debugging-u-boot","title":"Debugging U-Boot","text":"<p>1.- Run the steps from Prerequisites section   2.- Create the Debug S10 Bootloader debug configuration as described in Debugging SPL section.   3.- Change the Execute debugger commands box to contain the following commands:</p> <p><pre><code>interrupt\nrestore \"u-boot-socfpga/spl/u-boot-spl-dtb.bin\" binary 0xFFE00000\nloadfile \"u-boot-socfpga/spl/u-boot-spl\"\nthb board_boot_order\nset $PC = $ENTRYPOINT\ncontinue\nwait 60s\nset spl_boot_list[0]=0\nset $PC=$LR\nrestore \"u-boot-socfpga/u-boot.itb\" binary 0x2000000\nthb el3:0x1000\ncontinue\nwait 60s\nsymbol-file \"u-boot-socfpga/u-boot\"\nthb el2:relocate_code\ncontinue\nwait 60s\nsymbol-file \"u-boot-socfpga/u-boot\" ((gd_t*)$x18)-&gt;reloc_off\nthb board_init_r\ncontinue\nwait 60s\n</code></pre>   What the above does is:   a) Load and run SPL   b) Make SPL report boot from RAM was selected    c) Load ATF+U-Boot image and run it up until U-Boot starts running   d) Load U-Boot symbols   e) Run U-Boot until the relocation routine is called   f) Relocate the U-Boot symbols   g) Run U-Boot until the board_init_r function</p> <p>4.-  Click on the Debug button. All the above will be executed, and Eclipse will show the code stopped at board_init_r function. The Eclipse window should look like this:</p> <p></p> <p>5.- At this point you can use standard debug techniques to debug U-Boot SPL: viewing registers, variables, putting breakpoints, running step-by-step etc.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#managing-secure-l3-registers-on-stratix-10-agilextm-and-n5x","title":"Managing Secure L3 Registers on Stratix\u00ae 10, Agilex\u2122 and N5X\u00ae","text":"<p>On Stratix\u00ae 10, Agilex\u2122 7 and N5X\u00ae HPS there are specific peripherals which are critical for system operation which can only be accessed from software running at EL3.</p> <p>The following HPS software components run at EL3 on these devices and can access Secure L3 registers:</p> <ul> <li>U-Boot SPL: initial values for the secure L3 registers are set here through the device tree 'secreg' entries. The user can customize them as needed by editing the device tree.</li> <li>Arm Trusted Firmware (ATF): Both U-Boot and Linux call the ATF SMC (Secure Monitor Call) handler to access a restricted subset of secure L3 registers needed for routine system operation.</li> </ul> <p>This section presents the following:</p> <ul> <li>How to use the 'secreg' device tree entries to customize initial secure L3 registers values set by U-Boot SPL</li> <li>How to access registers from the restricted subset from U-Boot, for debug purposes.</li> <li>How to access other secure EL3 register from U-Boot, by by changing the ATF source code to add add them to the restricted subset.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#setting-initial-values-of-secure-l3-registers","title":"Setting Initial Values of Secure L3 Registers","text":"<p>The initial values for the Secure L3 registes are set from U-Boot SPL. The register values are specified in secreg entries in the U-Boot device tree file.</p> <p>Refer to u-boot-socfpga/blob/HEAD/doc/device-tree-bindings/misc/socfpga_secreg.txt for documentation the secreg. The  socfpga_v2021.04 version shows the following:   <pre><code>* Firewall and privilege register settings in device tree\n\nRequired properties:\n--------------------\n- compatible: should contain \"intel,socfpga-secreg\"\n- intel,offset-settings: 32-bit offset address of block register, and then\n                       followed by 32-bit value settings.\nExample:\n--------\n      socfpga_secreg: socfpga-secreg {\n          compatible = \"intel,socfpga-secreg\";\n          #address-cells = &lt;1&gt;;\n          #size-cells = &lt;1&gt;;\n          u-boot,dm-pre-reloc;\n\n          i_sys_mgr@ffd12000 {\n              reg = &lt;0xffd12000 0x00000228&gt;;\n              intel,offset-settings =\n                  &lt;0x00000020 0xff010000&gt;,\n                  &lt;0x00000024 0xffffffff&gt;;\n              u-boot,dm-pre-reloc;\n          };\n      };\n</code></pre> Notes about the example:</p> <ul> <li>The u-boot,dm-pre-reloc; statement in the example informs U-Boot the driver will be loaded in SPL.</li> <li>The i_sys_mgr@ffd12000 statement in the example is informative only to enable readers to quickly see what IP is being set up, it is not actually used by the code.</li> <li>The reg =&lt;0xffd12000 0x00000228&gt; entry specifies the IP module base address 0xffd12000 and span of 0x00000228 bytes.</li> <li>The &lt;0x00000020 0xff010000&gt;, specifies that the register at offset 0x00000020 from the IP module base address will be set to value 0xff010000.</li> </ul> <p>These are the files which currently define the initial value of the Secure L3 registers:</p> <ul> <li>Common: u-boot-socfpga/arch/arm/dts/socfpga_soc64_u-boot.dtsi.</li> <li>Stratix\u00ae 10: u-boot-socfpga/arch/arm/dts/socfpga_stratix10-u-boot.dtsi.</li> <li>Agilex\u2122 7: arch/arm/dts/socfpga_agilex-u-boot.dtsi</li> <li>N5X\u00ae: u-boot-socfpga/arch/arm/dts/socfpga_n5x-u-boot.dtsi</li> </ul> <p>You can edit the above files accordingly to change the default values, or set the initial value of more registers.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#accessing-secure-l3-registers-from-u-boot-command-line","title":"Accessing Secure L3 Registers from U-Boot Command Line","text":"<p>A small subset of critical EL3 restricted access registers are made visible through the ATF SMC handler. The current list of registers is defined in arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c..</p> <p>The secure L3 registers accessible through the ATF SMC handler can also optionally be accessed from U-Boot command line for debug purposes. The feature can be enabled by setting CONFIG_CMD_SMC=y in the U-Boot configuration file.</p> <p>Once the feature is enabled, the following command will be avaible from U-Boot command line interface:</p> <p><pre><code>SOCFPGA # smc\nsmc - Issue a Secure Monitor Call\n\nUsage:\nsmc  [arg1 \u2026 arg6] [id]\n  - fid Function ID\n  - arg SMC arguments, passed to X1-X6 (default to zero)\n  - id  Secure OS ID / Session ID, passed to W7 (defaults to zero)\n</code></pre> The U-Boot environment already includes predefined ids to facilitate the usage of the command:   <pre><code>smc_fid_rd=0xC2000007\nsmc_fid_upd=0xC2000009\nsmc_fid_wr=0xC2000008\n</code></pre> The command can be used as follows:   <pre><code>smc ${smc_fid_rd} &lt;address&gt;\nsmc ${smc_fid_wr} &lt;address&gt; &lt;value&gt;\nsmc ${smc_fid_upd} &lt;address&gt; &lt;mask&gt; &lt;value&gt;\n</code></pre> See below using the new command to access the BOOT_SCRATCH_COLD0 register (note there is no need to access that register, this is just an example):</p> <p>1.- Read the register:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd12200\nRes:  0 400000 4291895808 0\n</code></pre> Note:</p> <ul> <li>First value from Res is the return code, 0 means operation succesfull.</li> <li>Second value represents the read register value in decimal 400000=0x00061a80.</li> <li>Third value is the address in decimal 4291895808=0xffd12200.</li> </ul> <p>2.- Write the register with a new value:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_wr} 0xffd12200 0x00061a81\nRes:  0 400001 4291895808 0\n</code></pre></p> <p>3.-  Read back the register to confirm it has been updated:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd12200\nRes:  0 400001 4291895808 0\n</code></pre></p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#enabling-access-to-more-secure-l3-registers-for-debug-purposes","title":"Enabling Access to more Secure L3 Registers for Debug Purposes","text":"<p>By default, only a small subset of critical EL3 restricted access registers are made visible through the ATF SMC handler. The current list of registers is defined in arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c. For debug purposes, you can add more registers to the restricted register list that can be accessed through the ATF SMC handler.</p> <p>Warning: Changing the list of EL3 restricted access registers in ATF is risky, and must be done only for debug purposes only! Do not forget to remove the code once debugging has completed!</p> <p>When trying to access a register which is not made visible by the ATF SMC handler, an error will be reported. See below example trying to read the noc_fw_soc2fpga_soc2fpga_scr register:   <pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd21200\nRes:  4 0 4291957248 0\n</code></pre> Note:</p> <ul> <li>The non-zero (4) return code means the operation was not succesfull.</li> </ul> <p>After editing the file arm-trusted-firmware/blob/HEAD/plat/intel/soc/common/socfpga_sip_svc.c to add this register to the list, and recompiling ATF, the operation is succesfull:</p> <p><pre><code>SOCFPGA_STRATIX10 # smc ${smc_fid_rd} 0xffd21200\nRes:  0 268304641 4291957248\n</code></pre> Note:</p> <ul> <li>Return code is zero, operation was succesfull.</li> <li>Read value is decimal 268304641=0xFFE0101.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#boot-scratch-register-usage","title":"Boot Scratch Register Usage","text":"<p>On Stratix\u00ae 10 SoC, Agilex\u2122 7 and N5X\u00ae devices, the boot scratch registers are part of the System Manager and are used to pass values between various software components. The table below summarizes the usage.</p> <p>Note:</p> <ul> <li>If no device is provided it means that it applies for all.</li> <li>If a cell is not specified for a device, then this could be used as a scratch memory.</li> </ul> Address Name Usage SDM U-Boot ATF Linux 0xFFD1 2200 boot_scratch_cold0 Bits[31] N5X. DDR retention Sets this bit Read  (is_ddr_retention_enabled) 0xFFD1 2200 boot_scratch_cold0 Bits[30:28] N5X, Agilex7M. DDR reset type Sets this field Read  (get_reset_type) 0xFFD1 2200 boot_scratch_cold0 Bits[27:0] SOC 64-bit storing qspi ref clock(kHz) Sets this field Sets value cm_set_qspi_controller_clk_hz  Reads value cm_get_qspi_controller_clk_hz 0xFFD1 2204 boot_scratch_cold1 osc1 clock freq Sets and read(cm_get_osc_clk_hz) 0xFFD1 2208 boot_scratch_cold 2 fpga clock freq Sets and read (cm_get_fpga_clk_hz) 0xFFD1 220C boot_scratch_cold3 reserved for customer use 0xFFD1 2210  0xFFD1 2214 boot_scratch_cold4  boot_scratch_cold5 Secondary CPU RELEASE ADDRESS Main core clears it (lowlevel_init) Main CPU Write (bl31_platform_setup) 0xFFD1 2218  0xFFD1 221C boot_scratch_cold6  boot_scratch_cold7 64-bit signature with L2 reset indication done. Writes signature (l2_reset_cpu) Reads the register (lowlevel_init) Writes register (socfpga_system_reset2) Reads register (plat_get_my_entrypoint) 0xFFD1 2220 boot_scratch_cold8 Bit[31:31] N5X, Agilex 7M. DBE status Set by SDM Check if bit is set (is_ddr_dbe_triggered) 0xFFD1 2220 boot_scratch_cold8 Bit[30:30] N5X, Agilex 7M. DDR Init Progress Set and clear bit(ddr_init_inprogress) Read status (is_ddr_init_hang) 0xFFD1 2220 boot_scratch_cold8 Bit[29:29] Agilex 7M. OCRAM_DBE  Error status 0xFFD1 2220 boot_scratch_cold8 Bits[28:27] Agilex 7M. Number of IO96B instances Sets this field (update_io96b_assigned_to_hps) 0xFFD1 2220 boot_scratch_cold8 Bit[19:19] Agilex 7, Agilex 7M, S10. CPU power domain is about to be turned on. Handled call under event (socfpga_pwr_domain_on) 0xFFD1 2220 boot_scratch_cold8 Bit[18:18] Agilex 7, S10. ACF DDR Data rate Set this bit Read this value (sdram_mmr_init_full) 0xFFD1 2220 boot_scratch_cold8 Bit[17,16,1] ECC_DDR1 Error Flag, ECC_DDR0 Error Flag, ECC_OCRAM Error Flag 0xFFD1 2220 boot_scratch_cold8 Checks if any of the flags are set (socfpga_system_reset2) Set via ATF SMC 0xFFD1 2224 boot_scratch_cold9 Write (via ATF SMC) <p>Links:</p> <ul> <li>Stratix\u00ae 10 HPS Registers</li> <li>Agilex\u2122 7 HPS Registers</li> <li>Review device-specific Boot User Guide for more information about these registers.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#qspi-reference-clock","title":"QSPI Reference Clock","text":"<p>The QSPI peripheral clocks are provided by the SDM, based on the SDM input clocks and configuration clock settings defined in the Quartus\u00ae Pro project. However, the HPS needs to know the QSPI reference clock, so that it can properly set the dividers in the QSPI controller to create the desired external QSPI clock frequency.</p> <p>The HPS obtains the QSPI controller reference clock frequency when it obtains exclusive access to the QSPI from the SDM. The frequency reported by the SDM is stored in the U-Boot environment variable called ${qspi_clock}.</p> <p>Before booting Linux, U-Boot loads the Linux device tree in memory, then runs the command linux_qspi_enable which sets the QSPI controller reference clock appropriately using the value from the ${qspi_clock} environment variable.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#reconfiguring-core-fabric-from-u-boot","title":"Reconfiguring Core Fabric from U-Boot","text":"<p>The GSRD configures the FPGA core fabric only once, from U-Boot, by using the bootm command. The example in this page configures the fabric only once, from U-Boot, using fpga load command.</p> <p>Important: If the FPGA fabric is already configured and bridges are enabled, you must call the bridge disable command from U-Boot before issuing the bootm or fppga load commands to reconfigure the fabric. Only do this if you are using an arm-trusted-firmware version more recent than the following:</p> <ul> <li>v2.7.1 = https://github.com/altera-opensource/arm-trusted-firmware/commit/0a5edaed853e0dc1e687706ccace8e844b2a8db7</li> <li>v2.8.0 = https://github.com/altera-opensource/arm-trusted-firmware/commit/bf933536d4582d63d0e29434e807a641941f3937</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#enabling-bridges-from-u-boot","title":"Enabling Bridges from U-Boot","text":"<p>U-Boot offers the bridge command for controlling the bridges.</p> <p>The bridge command can be used with either 'enable' or 'disable' parameter, followed by an optional 'mask' parameter indicating which of the bridges needs to be enabled or disabled. When the 'mask' parameter is omitted, all bridges are either enabled or disabled.</p> <p>See bellow the help message for the command:   <pre><code># bridge\nbridge - SoCFPGA HPS FPGA bridge control\n\nUsage:\nbridge enable [mask] - Enable HPS-to-FPGA (Bit 0), LWHPS-to-FPGA (Bit 1), FPGA-to-HPS (Bit 2), F2SDRAM0 (Bit 3), F2SDRAM1 (Bit 4), F2SDRAM2 (Bit 5) bridges \nbridge disable [mask] - Disable HPS-to-FPGA (Bit 0), LWHPS-to-FPGA (Bit 1), FPGA-to-HPS (Bit 2), F2SDRAM0 (Bit 3), F2SDRAM1 (Bit 4), F2SDRAM2 (Bit 5) bridges\nBit 3, Bit 4 and Bit 5 bridges only available in Stratix 10\n</code></pre> The** 'mask'** is a hexadecimal number, with 3 bits available for Agilex\u2122 7, and 6 bits for Stratix\u00ae 10, as indicated above.</p> <p>The following table shows examples of enabling and disabling various bridges:</p> Command Description bridge enable Enable all bridges bridge disable Disable all bridges bridge enable 1 Enable HPS-to-FPGA bridge bridge enable 2 Enable LWHPS-to-FPGA bridge bridge enable 4 Enable FPGA-to-HPS bridge bridge enable 7 Enable HPS-to-FPGA, LWHPS-to-FPGA, FPGA-to-HPS bridges bridge enable 35 Enable HPS-to-FPGA, FPGA-to-HPS, F2SDRAM1, F2SDRAM2 bridges(Stratix\u00ae 10 only) bridge disable 30 Disable F2SDRAM1, F2SDRAM2 bridges (Stratix\u00ae 10 only)"},{"location":"embedded-designs/stratix-10/sx/soc/boot-examples/ug-linux-boot-s10-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/","title":"HPS eMMC Boot Example for the Stratix\u00ae 10 SX SoC Development Kit","text":"<p>Note: This example is not availble in this release. Refer to https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/ for the latest available version.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/","title":"SoC Fabric Configuration from Linux Example for the Stratix\u00ae 10 SX SoC Development Kit","text":""},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#introduction","title":"Introduction","text":"<p>When using HPS Boot First method, the FPGA device is first configured with a small Phase 1 bitstream, which configures the periphery, and brings up HPS. Then, at a later time, HPS configures the FPGA fabric using a larger Phase 2 bitstream. </p> <p>The HPS can configure the fabric either from U-Boot or Linux. The Golden System Reference Design (GSRD) configures the fabric from U-Boot. The examples in this page demonstrate how to configure the FPGA fabric from Linux, using device tree overlays. </p> <p>Two different examples are provided: </p> <ul> <li>Example building components separately </li> <li>based on the Building Bootloader for Stratix10 example. </li> <li>Manages overlays directly. </li> <li>Example building everything with Yocto </li> <li>Based on the Stratix\u00ae 10 SoC H-Tile GSRD. </li> <li>Manages overlays with the dtbt utility </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>You will need the following items: </p> <ul> <li>Stratix\u00ae 10 SX SoC Development Kit, production version, H-Tile (ordering code DK-SOC-1SSX-H-D):<ul> <li>NAND/eMMC HPS Daughtercard </li> <li>SDM QSPI Bootcard with MT25QU02G flash device </li> </ul> </li> <li>Linux host PC (Ubuntu 22.04LTS was used for developing this project, but other versions may work too) </li> <li>Internet access (for downloading files attached to this page, and cloning git trees from github) </li> <li>TFTP server running on host computer (or other accessible computer on the local network) </li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> <p>Refer to board documentation for more details about the development kit.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#example-building-components-separately","title":"Example Building Components Separately","text":"<p>This example is build on top of the Building Bootloader for Stratix10 example, with the modification that the fabric is not configured from U-Boot anymore, but from Linux, with a device tree overlay. </p> <p>The device tree overlay and the Phase 2 configuration bitstream core.rbf are stored in the Linux rootfs folder /lib/firmware, where the Linux overlay framework expects them to be by default. </p> <p>Full instructions for building and running the example are provided. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#build-example","title":"Build Example","text":"<p>1. Set Up Environment </p> <pre><code>sudo rm -rf stratix10.fabric_config.separate\nmkdir stratix10.fabric_config.separate cd stratix10.fabric_config.separate\nexport TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Build Hardware Design </p> <pre><code>rm -rf stratix10-ed-gsrd\nwget https://github.com/altera-fpga/stratix10-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm -f QPDS25.1.1_REL_GSRD_PR.zip\nmv stratix10-ed-gsrd-QPDS25.1.1_REL_GSRD_PR stratix10-ed-gsrd\ncd stratix10-ed-gsrd\nmake s10-htile-soc-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>3. Build Arm* Trusted Firmware </p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/arm-trusted-firmware cd arm-trusted-firmware make -j 48 bl31 PLAT=stratix10 cd .. </code></pre> <p>4. Build U-Boot </p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/u-boot-socfpga cd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk # use 'Image' for kernel image instead of 'kernel.itb'\nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi  # Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb \nCONFIG_BOOTFILE=\"Image\" \n# - Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n \nCONFIG_SPL_NAND_SUPPORT=n \nCONFIG_CMD_NAND_TRIMFFS=n \nCONFIG_CMD_NAND_LOCK_UNLOCK=n \nCONFIG_NAND_DENALI_DT=n \nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n \nCONFIG_SPL_NAND_FRAMEWORK=n \nCONFIG_CMD_NAND=n \nCONFIG_MTD_RAW_NAND=n \nCONFIG_CMD_UBI=n \nCONFIG_CMD_UBIFS=n \nCONFIG_MTD_UBI=n \nCONFIG_ENV_IS_IN_UBI=n \nCONFIG_UBI_SILENCE_MSG=n \nCONFIG_UBIFS_SILENCE_MSG=n \n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; bridge disable; fpga load 0 \\${loadaddr} \\${filesize};bridge enable;setenv bootfile Image;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_SPL_DOS_PARTITION=y \nCONFIG_CMD_PART=y \nCONFIG_SPL_CRC32=y \nCONFIG_LZO=y \nCONFIG_CMD_DHCP=y \n# Enable more QSPI flash manufacturers \nCONFIG_SPI_FLASH_MACRONIX=y \nCONFIG_SPI_FLASH_GIGADEVICE=y \nCONFIG_SPI_FLASH_WINBOND=y \nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper make socfpga_stratix10_defconfig # Use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin . # build\nmake -j 64 cd .. </code></pre> <p>5. Build JIC and Core RBF Files </p> <pre><code>cd $TOP_FOLDER rm -f ghrd.hps.jic ghrd.core.rbf quartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof ghrd.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=1SX280HU2 \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o hps=1 </code></pre> <p>6. Build Linux </p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/linux-socfpga cd linux-socfpga make clean &amp;&amp; make mrproper make defconfig # enable device tree overlays and fpga bridges \n./scripts/config --set-val CONFIG_OF_RESOLVE y ./scripts/config --set-val CONFIG_OF_OVERLAY y ./scripts/config --set-val CONFIG_OF_CONFIGFS y ./scripts/config --set-val CONFIG_FPGA_MGR_STRATIX10_SOC y ./scripts/config --set-val CONFIG_FPGA_BRIDGE y ./scripts/config --set-val CONFIG_FPGA_REGION y ./scripts/config --set-val CONFIG_OF_FPGA_REGION y ./scripts/config --set-val CONFIG_OVERLAY_FS y # enable SYSID driver \n./scripts/config --set-val CONFIG_ALTERA_SYSID y make oldconfig make -j 64 Image dtbs </code></pre> <p>7. Create Device Treee Overlay </p> <pre><code>cd $TOP_FOLDER rm -f overlay.dtb overlay.dts cat &lt;&lt; EOF &gt; overlay.dts \n/dts-v1/; \n/plugin/; \n/ { \n fragment@0 { \n target-path = \"/fpga-region\"; \n #address-cells = &lt;0x2&gt;; \n #size-cells = &lt;0x2&gt;; \n __overlay__ { \n #address-cells = &lt;0x2&gt;; \n #size-cells = &lt;0x2&gt;; \n ranges = &lt;0x0 0x0 0x0 0xF9000000 0x0 0x00200000&gt;; \n firmware-name = \"overlay.rbf\"; \n config-complete-timeout-us = &lt;30000000&gt;; \n sysid_qsys_0: sysid@0 { \n compatible = \"altr,sysid-23.4\", \"altr,sysid-1.0\";\n reg = &lt;0x0 0x0 0x0 0x00000010&gt;; \n id = &lt;3405707982&gt;;\n timestamp = &lt;0&gt;; \n }; \n }; \n }; \n}; \nEOF\ndtc -I dts -O dtb -o overlay.dtb overlay.dts </code></pre> <p>Explanation: </p> <ul> <li><code>Fragment@0</code>: Node Name of the Overlay. </li> <li><code>target-path</code>: This refers to fpga_region located in arch/arm64/boot/dts/intel/socfpga_agilex.dtsi. This will invoke the following driver: drivers/fpga/of-fpga-region.c </li> <li>Fragment@0 <code>#address-cells/#size-cells</code>: This specifies the number of cells (32-bit size) to be used for the child's address map. For overlays, we need to set this value to avoid \"default_addr_size\" errors. </li> <li>overlay <code>#address-cells/#size-cells</code>: These fields should match those in arch/arm64/boot/dts/intel/socfpga_agilex.dtsi. </li> <li><code>Ranges</code>: According to the device tree standard, this allows mapping child addresses to parent addresses. In this case: <ul> <li>The first number <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> represents the child's address. </li> <li>The second pair <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> represents the parent's address. </li> <li>The third pair <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> specifies the memory region's size. </li> </ul> </li> <li><code>firmware-name = \"overlay.rbf\"</code>: This should contain the fabric's file name. </li> <li><code>sysid_qsys_0: sysid@0</code>: This specifies the device name as well as its alias. </li> <li><code>reg = &lt;0x0 0x0 0x0 0x00000010&gt;</code>: This refers to the addresses specified in the parent range field. <ul> <li><code>&lt;0x0 0x0 0x0 0x00000010&gt;</code>: This represents the child's address. </li> <li><code>&lt;0x0 0x0 0x0 0x00000010&gt;</code>: This is the size of the memory region. </li> </ul> </li> </ul> <p>8. Build Root Filesystem </p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b walnascar https://git.yoctoproject.org/poky git clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga git clone -b walnascar https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"stratix10\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf bitbake core-image-minimal </code></pre> <p>9. Build SD Card Image </p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py sed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py chmod +x make_sdimage_p3.py mkdir fat &amp;&amp; cd fat cp $TOP_FOLDER/u-boot-socfpga/u-boot.itb . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb . cd .. mkdir rootfs &amp;&amp; cd rootfs sudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz sudo rm -rf lib/modules/* sudo mkdir -p lib/firmware sudo cp $TOP_FOLDER/ghrd.core.rbf lib/firmware/overlay.rbf sudo cp $TOP_FOLDER/overlay.dtb lib/firmware/overlay.dtb cd .. sudo python3 make_sdimage_p3.py -f \\ \n-P fat/*,num=1,format=fat32,size=48M \\ \n-P rootfs/*,num=2,format=ext3,size=32M \\ \n-s 100M \\ \n-n sdcard.img cd .. </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#run-example","title":"Run Example","text":"<p>1. Write QSPI image <code>$TOP_FOLDER/ghrd.hps.jic</code> </p> <p>2. Write SD card image <code>$TOP_FOLDER/sd_card/sdcard.img</code> </p> <p>3. Power up board </p> <p>4. Log into Linux using 'root' as username, no password will be required. </p> <p>5. Create the overlay folder </p> <pre><code>root@stratix10:~# mkdir /sys/kernel/config/device-tree/overlays/0 </code></pre> <p>6. Configure the overlay: </p> <pre><code>root@stratix10:~# echo overlay.dtb &gt; /sys/kernel/config/device-tree/overlays/0/path [ 35.750389] fpga_manager fpga0: writing overlay.rbf to Stratix10 SOC FPGA Manager [ 36.170960] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges [ 36.181456] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/firmware-name [ 36.192486] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/config-complete-timeout-us </code></pre> <p>7. Locate the sysid in the sysfs: </p> <pre><code>root@stratix10:~# find / -name sysid /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid </code></pre> <p>8. Display the sysid id information: </p> <pre><code>root@stratix10:~# cat /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid/id | xargs printf \"0x%08x\\n\" 0xacd5cafe </code></pre> <p>9. Remove the overlay: </p> <pre><code>root@stratix10:~# rmdir /sys/kernel/config/device-tree/overlays/0 </code></pre> <p>10. Confirm that the overlay was removed: </p> <pre><code>root@stratix10:~# find / -name sysid </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#example-building-everything-with-yocto","title":"Example Building Everything with Yocto","text":"<p>This example is build on top of the Stratix 10 SoC L-Tile GSRD, with the modification that the fabric is not configured from U-Boot anymore, instead through a device tree overlay. </p> <p>Full instructions for building and running the example are provided. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#build-example_1","title":"Build Example","text":"<p>1. Set up environment:</p> <pre><code>sudo rm -rf stratix10.fabric_config.yocto mkdir stratix10.fabric_config.yocto\ncd stratix10.fabric_config.yocto\nexport TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Build hardware design:</p> <pre><code>rm -rf stratix10-ed-gsrd\nwget https://github.com/altera-fpga/stratix10-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm -f QPDS25.1.1_REL_GSRD_PR.zip\nmv stratix10-ed-gsrd-QPDS25.1.1_REL_GSRD_PR stratix10-ed-gsrd\ncd stratix10-ed-gsrd\nmake s10-htile-soc-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>3. Build the core.rbf </p> <pre><code>cd $TOP_FOLDER rm -f ghrd.hps.jic ghrd.core.rbf quartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline_hps_debug.sof \\ \nghrd.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=1SX280HU2 \\ \n-o mode=ASX4 \\ \n-o hps=1 rm ghrd.hps.jic </code></pre> <p>4. Clone Yocto script and start the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd-socfpga git clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga cd gsrd-socfpga . stratix10_htile-gsrd-build.sh build_setup </code></pre> <p>5. Get and apply the patch, containing the following changes: </p> <ul> <li>U-Boot boot script is changed to load configuration 0 from the kernel.itb, which does not configure the fabric at boot time </li> <li>Overlay file agilex_fabric_config_overlay.dts was added, pointing to core.rbf file for fabric configuration, and adding the sysid driver </li> <li>core.rbf file is also copied into the /lib/firmware folder where the Linux device tree framwork expects it   =</li> </ul> <pre><code>rm -f stratix10-fabric-config-yocto.patch\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/stratix-10/sx/soc/fabric-config/collateral/stratix10-fabric-config-yocto.patch patch -d meta-intel-fpga-refdes -p1 &lt; stratix10-fabric-config-yocto.patch </code></pre> <p>For reference, the patch looks like this:</p> <pre><code>diff --git a/recipes-bsp/device-tree/device-tree.bb b/recipes-bsp/device-tree/device-tree.bb\nindex 6516834..a283d16 100644\n--- a/recipes-bsp/device-tree/device-tree.bb\n+++ b/recipes-bsp/device-tree/device-tree.bb\n@@ -66,6 +66,7 @@ SRC_URI:append:stratix10 = \" \\\n                   file://stratix10_pr_persona0.dts \\\n                    file://stratix10_pr_persona1.dts \\\n                    file://socfpga_ilc.dtsi \\\n+                   file://fabric_config_overlay.dts \\\n                   \"\n\nSRC_URI:append:stratix10_htile = \" \\\n@@ -75,6 +76,7 @@ SRC_URI:append:stratix10_htile = \" \\\n                   file://stratix10_pr_persona0.dts \\\n                    file://stratix10_pr_persona1.dts \\\n                    file://socfpga_ilc.dtsi \\\n+                   file://fabric_config_overlay.dts \\\n                   \"\n\nSRC_URI:append:agilex5_dk_a5e065bb32aes1 = \" \\\ndiff --git a/recipes-bsp/device-tree/files/fabric_config_overlay.dts b/recipes-bsp/device-tree/files/fabric_config_overlay.dts\nnew file mode 100644\nindex 0000000..98fdf14\n--- /dev/null\n+++ b/recipes-bsp/device-tree/files/fabric_config_overlay.dts\n@@ -0,0 +1,23 @@\n+/dts-v1/;\n+/plugin/;\n+/ {\n+                fragment@0 {\n+                                target-path = \"/fpga-region\";\n+                                #address-cells = &lt;0x2&gt;;\n+                                #size-cells = &lt;0x2&gt;;\n+                                __overlay__ {\n+                                                #address-cells = &lt;0x2&gt;;\n+                                                #size-cells = &lt;0x2&gt;;\n+                                                ranges = &lt;0x0 0x0 0x0 0xF9000000 0x0 0x00200000&gt;;\n+                                                firmware-name = \"ghrd.core.rbf\";\n+                                                config-complete-timeout-us = &lt;30000000&gt;;\n+\n+                                                sysid_qsys_0: sysid@0 {\n+                                                    compatible = \"altr,sysid-23.4\", \"altr,sysid-1.0\";\n+                                                    reg = &lt;0x0 0x00000000 0x0 0x00000010&gt;;\n+                                                    id = &lt;3405707982&gt;;\n+                                                    timestamp = &lt;0&gt;;\n+                                                };\n+                                };\n+                };\n+};\ndiff --git a/recipes-bsp/ghrd/hw-ref-design.bb b/recipes-bsp/ghrd/hw-ref-design.bb\nindex eccd99d..0b3c639 100644\n--- a/recipes-bsp/ghrd/hw-ref-design.bb\n+++ b/recipes-bsp/ghrd/hw-ref-design.bb\n@@ -233,6 +233,7 @@ do_install () {\n       install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_${ARM64_GHRD_CORE_RBF} ${D}/boot/ghrd_pr.core.rbf\n        install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_persona0.rbf ${D}${base_libdir}/firmware/persona0.rbf\n        install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_persona1.rbf ${D}${base_libdir}/firmware/persona1.rbf\n+       install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_gsrd_${ARM64_GHRD_CORE_RBF} ${D}${base_libdir}/firmware/${ARM64_GHRD_CORE_RBF}\n   fi\n\n   if ${@bb.utils.contains(\"MACHINE\", \"stratix10_htile\", \"true\", \"false\", d)}; then\n@@ -241,6 +242,7 @@ do_install () {\n       install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_${ARM64_GHRD_CORE_RBF} ${D}/boot/ghrd_pr.core.rbf\n        install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_persona0.rbf ${D}${base_libdir}/firmware/persona0.rbf\n        install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_pr_persona1.rbf ${D}${base_libdir}/firmware/persona1.rbf\n+       install -D -m 0644 ${WORKDIR}/sources/${MACHINE}_gsrd_${ARM64_GHRD_CORE_RBF} ${D}${base_libdir}/firmware/${ARM64_GHRD_CORE_RBF}\n   fi\n\n   if ${@bb.utils.contains(\"MACHINE\", \"cyclone5\", \"true\", \"false\", d)}; then\ndiff --git a/recipes-bsp/u-boot/files/uboot.txt b/recipes-bsp/u-boot/files/uboot.txt\nindex 8577186..370695b 100644\n--- a/recipes-bsp/u-boot/files/uboot.txt\n+++ b/recipes-bsp/u-boot/files/uboot.txt\n@@ -30,5 +30,5 @@ if test ${target} = \"nand\"; then\n   ubi readvol ${loadaddr} kernel;\n    ubi detach;\n    setenv bootargs \"earlycon panic=-1 root=${nandroot} rw rootwait rootfstype=ubifs ubi.mtd=1\";\n-   bootm ${loadaddr}#board-${board_id};\n+   bootm ${loadaddr}#board-0;\nfi\n</code></pre> <p>6. Customize Yocto Build: </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/stratix10_htile_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd.core.rbf $CORE_RBF OLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_htile_gsrd_\\${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core\" NEW_CORE_URI=\"file:\\/\\/stratix10_htile_gsrd_ghrd.core.rbf\" CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") RECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb sed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_CORE_SHA=\"SRC_URI\\[stratix10_htile_gsrd_core\\.sha256sum\\] = .*\" NEW_CORE_SHA=\"SRC_URI[stratix10_htile_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE </code></pre> <p>7. Build Yocto: </p> <pre><code>bitbake_image package </code></pre> <p>8. Build JIC file: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof \\ \nghrd.jic \\ \n-o hps_path=gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\ \n-o device=MT25QU128 \\ \n-o flash_loader=1SX280HU2 \\ \n-o mode=ASX4 \\ \n-o hps=1 </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#run-example_1","title":"Run Example","text":"<p>1. Write QSPI image <code>$TOP_FOLDER/ghrd.hps.jic</code> </p> <p>2. Write SD card image <code>$TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/gsrd-console-image-stratix10.wic</code> </p> <p>3. Power up board </p> <p>4. Log into Linux using 'root' as username, no password will be required. </p> <p>5. Apply the overlay: </p> <pre><code>root@stratix10:~# dtbt -a stratix10_fabric_config_overlay.dtbo -p /boot/devicetree Set dtbo search path to /boot/devicetree [ 116.946137] fpga_manager fpga0: writing ghrd.core.rbf to Stratix10 SOC FPGA Manager Applying dtbo: stratix10_fabric_config_overlay.dtbo [ 117.304564] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges [ 117.315044] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/firmware-name [ 117.326087] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/config-complete-timeout-us [ 117.338292] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/sysid_qsys_0 </code></pre> <p>6. List the applied overlays: </p> <pre><code>root@stratix10:~# dtbt -l 1 fabric_config_overlay.dtbo applied /sys/kernel/config/device-tree/overlays/1-fabric_config_overlay.dtbo\n</code></pre> <p>7. Locate the sysid in the sysfs: </p> <pre><code>root@stratix10:~# find / -name sysid /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid </code></pre> <p>8. Display the sysid id information: </p> <pre><code>root@stratix10:~# cat /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid/id | xargs printf \"0x%08x\\n\" 0xacd5cafe </code></pre> <p>9. Remove the overlay: </p> <pre><code>root@stratix10:~# dtbt -r fabric_config_overlay.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\nRemoving dtbo: 1-fabric_config_overlay.dtbo\n</code></pre> <p>10. Confirm that the overlay was removed: </p> <pre><code>root@stratix10:~# dtbt -l </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/","title":"HPS GSRD User Guide for the Stratix\u00ae 10 SX SoC Development Kit","text":""},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#overview","title":"Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Intel Stratix 10 SX SoC Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul> <p>Note: This page and associated binaries refers to the current version of the board, with ordering code DK-SOC-1SSX-H-D, aka \"H-Tile\". There was an older version of this board, ordering code DK-SOC-1SSX-L-D, aka \"L-Tile\", which is now discontinued. See the previous version of this page https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/ for an example on how to build the GSRD for that version of the board.</p> <p>Note: Refer to the previous version of this page https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/ for an example of Partial Reconfiguration (PR).</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the S10 GSRD:</p> <ul> <li>Stratix 10 SoC Development Kit, ordering code DK-SOC-1SSX-H-D<ul> <li>4GB DDR4 HILO memory card</li> <li>SD/MMC HPS Daughtercard</li> <li>SDM QSPI Bootcard(MT25QU02G)</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel FPGA Download Cable II</li> <li>Micro SD card (4GB or greater)</li> </ul> </li> </ul> <ul> <li>Host PC with<ul> <li>Linux - Ubuntu 22.04 was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Micro SD card slot or Micro SD card writer/reader</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board)</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://github.com/altera-opensource/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#prebuilt-binaries","title":"Prebuilt Binaries","text":"Binaries for SD Card Boot <p>The release files are accessible at https://releases.rocketboards.org/2025.08/gsrd/s10_htile_gsrd/</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>:</p> File Description linux-socfpga-v6.12.19-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2025.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.12.1-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p> Binaries for NAND Boot <p>The release files are accessible at https://releases.rocketboards.org/2025.08/nand/s10_htile_nand/</p> Binaries for QSPI Boot <p>The release files are accessible at https://releases.rocketboards.org/2025.08/qspi/s10_htile_qspi/</p> <p>Note: To boot from QSPI is needed to remove SD card memory as SD Card memory has higher precedence in the boot order.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li> <p>Hard Processor System (HPS)</p> <ul> <li>Quad Arm Cortex-A53 MPCore Processor</li> <li>HPS Peripherals connected to Out-of-Box Experience (OOBE) Daughter Card:<ul> <li>Micro SD for HPS storage</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>I2C</li> <li>USB UART</li> <li>USB 2.0 OTG</li> <li>Two Push buttons and Three LEDs</li> </ul> </li> </ul> <ul> <li>Hard Memory Controller (HMC) for HPS External Memory Interface (EMIF)</li> </ul> </li> </ul> <ul> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>Three user LED outputs</li> <li>Four user DIP switch inputs</li> <li>Four user push-button inputs</li> <li>Interrupt Latency Counter</li> <li>System ID</li> </ul> </li> </ul> <ul> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <ul> <li>JTAG to Avalon Master Bridges connected to:<ul> <li>FPGA-to-SDRAM 0/\u00bd Interfaces</li> <li>FPGA-to-HPS AXI Bridge</li> </ul> </li> </ul> <p></p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#mpu-address-maps","title":"MPU Address Maps","text":"<p>This section presents the address maps as seen from the MPU (Cortex-A53) side.</p> HPS-to-FPGA Address Map <p>The MPU region provide windows of 4 GB into the FPGA slave address space. The lower 1.5 GB of this space is mapped to two separate addresses - firstly from 0x8000_0000 to 0xDFFF_FFFF and secondly from 0x20_0000_0000 to 0x20_5FFF_FFFF. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU (Cortex-A53), which starts at the lightweight HPS-to-FPGA base address of 0xF900_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0000_0000 8 Unique system ID led_pio 0x0000_1080 16 LED outputs button_pio 0x0000_1060 16 Push button inputs dipsw_pio 0x0000_1070 16 DIP switch inputs ILC 0x0000_1100 256 Interrupt latency counter (ILC)"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#jtag-master-address-map","title":"JTAG Master Address Map","text":"<p>There are two JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0000_0000 8 Unique system ID led_pio 0x0000_1080 16 LED outputs button_pio 0x0000_1060 16 Push button inputs dipsw_pio 0x0000_1070 16 DIP switch inputs ILC 0x0000_1100 256 Interrupt latency counter (ILC)"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#interrupt-routing","title":"Interrupt Routing","text":"<p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[0] 4 DIP switch inputs button_pio f2h_irq0[1] 4 Push button inputs <p>The interrupt sources are also connected to an interrupt latency counter (ILC) module in the system, which enables System Console to be aware of the interrupt status of each peripheral in the FPGA portion of the SoC.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#typical-hps-boot-flow","title":"Typical HPS Boot Flow","text":"<p>The GSRD boot flow includes the following stages:</p> <p>1. SDM</p> <p>2. U-Boot SPL</p> <p>3. ATF</p> <p>4. U-Boot</p> <p>5. Linux</p> <p>6. Application</p> <p></p> <p>The following table presents a short description of the different boot stages:</p> Stage Description SDM Secure Device Manager boots first U-Boot SPL Configures IO, FPGA, brings up SDRAM ATF Arm Trusted Firmware, provides SMC handler U-Boot Loads Linux kernel Linux Operating system Application User application <p>For more information, please refer to Intel Stratix 10 SoC Boot User Guide and Intel Stratix 10 Hard Processor System Technical Reference Manual (Booting and Configuration chapter).</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#exercise-prebuilt-gsrd","title":"Exercise Prebuilt GSRD","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p> <p>The following topics are  included:</p> <ul> <li>Configure the board and serial terminal</li> <li>Boot from SD Card</li> <li>Boot from QSPI</li> <li>Boot from NAND</li> </ul> <p>Most of the applications and features presented in the Boot from SD Card scenario are also available in the other scenarios.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#configure-board","title":"Configure Board","text":"<p>This section presents the necessary board settings in order to run the GSRD on the Intel FPGA Stratix 10 SoC development board.</p> <p></p> <p>First, confirm the following:</p> <ul> <li>DDR4 memory card is installed on HPS HiLo memory socket</li> <li>OOBE Daughter card is installed on HPS Daughter card socket</li> </ul> <p>Then the board switches need to be configured as follows:</p> <ul> <li>SW1: OFF-OFF-ON-ON-ON-ON-ON-ON</li> <li>SW2: ON-ON-ON (SW2.4 is not connected)</li> <li>SW3: All OFF</li> <li>SW4: ON-OFF-OFF-ON</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#configure-serial-connection","title":"Configure Serial Connection","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, the SoC EDS Pro installer automatically installs the required drivers if necessary.</p> <p>The serial communication parameters are:</p> <ul> <li>Baud-rate: 115,200</li> <li>Parity: none</li> <li>Flow control: none</li> <li>Stop bits: 1</li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus.</p> <p>On Linux, the minicom utility can be used. Here is how to configure it:</p> <p>The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following:</p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB*</li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet.</li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared.</li> <li>Install minicom application on host PC, if not installed.</li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom</li> <li>Configure minicom.</li> </ul> <pre><code>$ sudo minicom -s\n</code></pre> <p>Under Serial Port Setup choose the following:</p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary)</li> <li>Bps/Par/Bits: 115200 8N1</li> <li>Hardware Flow Control: No</li> <li>Software Flow Control: No</li> <li>Hit [ESC] to return to the main configuration menu</li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>This section presents how to write the QSPI Flash and SD Card image files, configure the board and boot Linux.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-qspi-image","title":"Write QSPI Image","text":"<p>The QSPI JIC image contains the FPGA configuration bitstream, and the U-Boot SPL.</p> <p>1. Download and extract the image file:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/gsrd/s10_htile_gsrd/ghrd_1sx280hu2f50e1vgas.jic.tar.gz\n\ntar xf ghrd_1sx280hu2f50e1vgas.jic.tar.gz\n</code></pre> <p>2. Configure MSEL to JTAG:</p> <ul> <li>SW2: ON-ON-ON (SW2.4 is not connected)</li> </ul> <p>3. Power cycle the board</p> <p>4. Write the image using the following commands:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_1sx280hu2f50e1vgas.jic\"\n</code></pre> <p>5. Configure MSEL back to QSPI:</p> <ul> <li>SW2: ON-OFF-OFF (SW2.4 is not connected)</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-sd-card-image","title":"Write SD Card Image","text":"<p>This section explains how to create the SD card necessary to boot Linux, using the SD card image available with the pre-built Linux binaries package. Once the SD card has been created, insert the card into the SD slot of the Micro SD daughter card.</p> Write SD Card on Linux <p>1. Download the SD card image from https://releases.rocketboards.org/2025.08/gsrd/s10_htile_gsrd/sdimage.tar.gz and extract it.</p> <p>The extacted file is named <code>gsrd-console-image-stratix10.wic</code>.</p> <p>2. Determine the device associated with the SD card on the host by running the following command before and after inserting the card.</p> <pre><code>$ cat /proc/partitions\n</code></pre> <p>Let's assume it is /dev/sdx.</p> <p>3. Use dd utility to write the SD image to the SD card.</p> <pre><code>$ sudo dd if=gsrd-console-image-stratix10.wic of=/dev/sdx bs=1M\n</code></pre> <p>Note we are using sudo to be able to write to the card.</p> <p>4. Use sync utility to flush the changes to the SD card.</p> <pre><code>$ sudo sync\n</code></pre> Write SD Card on Windows <p>1. Download the SD card image from https://releases.rocketboards.org/2025.08/gsrd/s10_htile_gsrd/sdimage.tar.gz and extract it.</p> <p>The extacted file is named <code>gsrd-console-image-stratix10.wic</code>.</p> <p>2. Rename the wic file as <code>sdcard.img</code></p> <p>3. Use Win32DiskImager to write the image to the SD card. The tool can be downloaded from https://sourceforge.net/projects/win32diskimager/files/latest/download</p> <p></p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-linux","title":"Boot Linux","text":"<p>This section presents how to boot Linux on the board. The required steps are:</p> <p>1. Start serial terminal (when using Minicom it will connect using the selected settings, for others connect manually).</p> <p>2. Power up the board.</p> <p>3. U-Boot SPL is ran</p> <p>4. U-Boot is ran</p> <p>5. Linux boots.</p> <p>6. Login using 'root' and no password.</p> <p>7. Run 'ifconfig' command to determine the IP of the board</p> <pre><code>root@stratix10:~# ifconfig\neth0: flags=4163 mtu 1500\ninet 192.168.1.48 netmask 255.255.255.0 broadcast 192.168.1.255\n inet6 fe80::d429:5dff:fe20:d6f4 prefixlen 64 scopeid 0x20\n ether d6:29:5d:20:d6:f4 txqueuelen 1000 (Ethernet)\nRX packets 57 bytes 9330 (9.1 KiB)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 57 bytes 8062 (7.8 KiB)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 21 base 0x2000\n\neth1: flags=4099 mtu 1500\nether 8a:c5:fe:e4:b5:97 txqueuelen 1000 (Ethernet)\nRX packets 0 bytes 0 (0.0 B)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 0 bytes 0 (0.0 B)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 22 base 0xc000\n\neth2: flags=4099 mtu 1500\nether 66:fd:43:7f:bc:66 txqueuelen 1000 (Ethernet)\nRX packets 0 bytes 0 (0.0 B)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 0 bytes 0 (0.0 B)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 23 base 0xe000\n\nlo: flags=73 mtu 65536\ninet 127.0.0.1 netmask 255.0.0.0\n inet6 ::1 prefixlen 128 scopeid 0x10\n loop txqueuelen 1000 (Local Loopback)\nRX packets 100 bytes 8440 (8.2 KiB)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 100 bytes 8440 (8.2 KiB)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\n</code></pre> <p>Note: there are three network cards, one connected to the Ethernet port on the HPS Daughtercard, and two to the Ethernet ports on the DevKit, which are connected throgh SGMII.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#run-sample-applications","title":"Run Sample Applications","text":"<p>The GSRD includes a number of sample Linux applications that help demonstrate some of the features of the platform:</p> <ul> <li>Display Hello World message</li> <li>Control LEDs</li> <li>Detect interrupts from push buttons and DIP switches</li> </ul> <p>The sample applications can be used as a starting point for users to write their own applications that interact with software IP through Linux drivers.</p> Prerequisites <p>1. Boot Linux on the target board as described in Booting Linux. You will not need to use the serial terminal if you plan on using ssh connection.</p> <p>2. Connect to the board using one of the following options:</p> <ul> <li>Connect using serial console, as described in Booting Linux</li> <li>Connect using ssh, as described in Connect Using SSH</li> </ul> <p>3. In serial console, or ssh client console, change current folder to be /home/root/intelFPGA. This is where the application binaries are stored.</p> <pre><code>root@stratix10:~# cd /home/root/intelFPGA/\n</code></pre> Display Hello World Message <p>Run the following command to display the Hello World message on the console:</p> <pre><code>root@stratix10:~/intelFPGA# ./hello\nHello SoC FPGA!\n</code></pre> Exercise Soft PIO Driver for LED Control <p>The following LEDs are exercised:</p> User FPGA LED Number Corresponding Board LED 0 D21 1 D23 2 D25 <p>Note: User FPGA LED #3 / D27 is quickly blinking, and cannot be controlled from software.</p> <p>1. In order to blink an LED in a loop, with a specific delay in ms, run the following command:</p> <pre><code>./blink &lt;led_number&gt; &lt;delay_ms&gt;\n</code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The delay_ms is a number that specifies the desired delay in ms between turning the LED on and off.</li> </ul> <p>2. In order to turn an individual LED on or off, run the following command:</p> <pre><code>./toggle &lt;led_number&gt; &lt;state&gt;\n</code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The state needs to be 0 to turn the LED off, and 1 to turn the LED on.</li> </ul> <p>3. In order to scroll the FPGA LEDs with a specific delay, please run the following command:</p> <pre><code>./scroll_client &lt;delay&gt;\n</code></pre> <p>The delay specifies the desired scrolling behavior:</p> <ul> <li>delay &gt; 0 - specify new scrolling delay in ms, and start scrolling</li> <li>delay &lt; 0 - stop scrolling</li> <li>delay = 0 - display current scroll delay</li> </ul> System Check Application <p>System check application provides a glance of system status of basic peripherals such as:</p> <ul> <li>USB: USB device driver</li> <li>Network IP (IPv4): Network IP address</li> <li>HPS LEDs: HPS LED state</li> <li>FPGA LEDs: FPGA LED state</li> </ul> <p>Run the application by issuing the following command:</p> <pre><code>root@stratix10:~/intelFPGA# ./syschk\n</code></pre> <p>The window will look as shown below - press 'q' to exit:</p> <pre><code> ALTERA SYSTEM CHECK\n\nIPv4 Address : 192.168.1.48 usb1 : DWC OTG Controller\n\nfpga_led2 : OFF serial1@ffc02100 : disabled\nhps_led2 : OFF serial0@ffc02000 : okay\nfpga_led0 : OFF\nhps_led0 : OFF\nfpga_led3 : OFF\nfpga_led1 : OFF\nhps_led1 : OFF\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#register-interrupts","title":"Register Interrupts","text":"<p>The following are exercised:</p> <ul> <li>User FPGA DIP switches<ul> <li>SW3.1</li> <li>SW3.2</li> <li>SW3.3</li> <li>SW3.4</li> </ul> </li> </ul> <ul> <li>User FPGA push buttons<ul> <li>0: S4</li> <li>1: S5</li> <li>2: S6</li> <li>3: S7</li> </ul> </li> </ul> <p>In order to register an interrupt handler to a specific GPIO, you will first need to determine the GPIO number used.</p> <p>1. Open the Linux Device Tree socfpga_stratix10_qse_pcie_sgmii_ghrd.dtsi file and look up the labels for the DIP switches and Push button GPIOs:</p> <pre><code> button_pio: gpio@f9001060 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0xf9001060 0x10&gt;;\ninterrupt-parent = &lt;&amp;intc&gt;;\ninterrupts = &lt;0 18 4&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;2&gt;;\naltr,interrupt_type = &lt;2&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\ndipsw_pio: gpio@f9001070 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0xf9001070 0x10&gt;;\ninterrupt-parent = &lt;&amp;intc&gt;;\ninterrupts = &lt;0 17 4&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;3&gt;;\naltr,interrupt_type = &lt;3&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\n</code></pre> <p>2. Run the following to determine the GPIO numbers for the DIP switches</p> <pre><code>root@stratix10:~/intelFPGA# grep -r \"gpio@f9001070\" /sys/class/gpio/gpiochip*/label\n/sys/class/gpio/gpiochip1928/label:/soc/gpio@f9001070\n</code></pre> <p>This means that the GPIOs 1928 .. 1931 are allocated to the DIP switches (there are 4 of them).</p> <p>3. Run the followinig to determine the GPIO numbers for the pushbuttons</p> <pre><code>root@stratix10:~/intelFPGA# grep -r \"gpio@f9001060\" /sys/class/gpio/gpiochip*/label\n/sys/class/gpio/gpiochip1960/label:/soc/gpio@f9001060\n</code></pre> <p>This means that the GPIOs 1960 \u2026 1963 are allocated to the push buttons (there are 4 of them).</p> <p>4. Register interrupt for one of the dipswiches, using the appropriate GPIO number, as determined in a previous step:</p> <pre><code>root@stratix10:~/intelFPGA# modprobe gpio_interrupt gpio_number=1928 intr_type=3\n[ 1090.973366] Interrupt for GPIO:1928\n[ 1090.973366] registered\n</code></pre> <p>5. Toggle the dipswitch a few times, you will see messages from the interrupt handler</p> <pre><code>[ 1096.537830] Interrupt happened at gpio:1928\n[ 1096.547744] Interrupt happened at gpio:1928\n[ 1098.736386] Interrupt happened at gpio:1928\n[ 1098.740482] Interrupt happened at gpio:1928\n</code></pre> <p>6. Remove the driver</p> <pre><code>root@stratix10:~/intelFPGA# rmmod gpio_interrupt\n</code></pre> <p>7. Register the pushbutton interrupt, using the appropriate GPIO number as determine on a previous step</p> <pre><code>rroot@stratix10:~/intelFPGA# modprobe gpio_interrupt gpio_number=1960 intr_type=2\n[ 1138.025297] Interrupt for GPIO:1960\n[ 1138.025297] registered\n</code></pre> <p>8. Push the pusbutton a few times, you will see interrupt handler messages</p> <pre><code>[ 1141.672192] Interrupt happened at gpio:1960\n[ 1142.110673] Interrupt happened at gpio:1960\n[ 1142.499468] Interrupt happened at gpio:1960\n[ 1142.884199] Interrupt happened at gpio:1960\n</code></pre> <p>9. Once done, remove the handler</p> <pre><code>root@stratix10:~/intelFPGA# rmmod gpio_interrupt\n</code></pre> <p>Note: If you are on the ssh console, you will need to run the program dmesg after pressing the button in order to see the messages:</p> <pre><code>root@stratix10:~/intelFPGA# dmesg\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#connect-to-web-server","title":"Connect to Web Server","text":"<p>The GSRD includes a web server running on the target board that can be used to exercise some of the board features:</p> <ul> <li>Turning LEDs ON and OFF</li> <li>Scrolling LEDs in a sequence</li> <li>Displaying the current status of the LEDs</li> </ul> <p>The web page served by the web server also contains links to some relevant information on the Intel website.</p> <p>Perform the following steps to connect to the board web server:</p> <p>1. Boot Linux as described in Booting Linux.</p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be three network interfaces, you can use anyone which is connected to the local network and gets an IP from the DHCP server.</p> <p>Note: There are instances where the DHCP have not assigned an IP to the board before the timeout happens, in which case you may check the IP address via the UART by running ifconfig.</p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter.</p> <p></p> <p>4. Scroll the webpage down to the section named Interacting with Stratix 10 SoC Development Kit.</p> <p></p> <p>You will be able to perform the following actions:</p> <ul> <li>See which LEDs are ON and which are off in the LED Status. Note that if the LEDs are setup to be scrolling, the displayed scrolling speed will not match the actual scrolling speed on the board.</li> <li>Stop LEDs from scrolling, by clicking START and STOP buttons. The delay between LEDs turning ON and OFF is set in the LED Lightshow box.</li> <li>Turn individual LEDs ON and OFF with the ON and OFF buttons. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> <li>Blink individual LEDs by typing a delay value in ms then clicking the corresponding BLINK button. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#connect-using-ssh","title":"Connect Using SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection.</p> <p></p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS:</p> <pre><code>$ sudo yum install openssh-clients\n</code></pre> <p>or the following command on Ubuntu:</p> <pre><code>$ sudo apt-get install openssh-client\n</code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action.</p> <pre><code>radu@ubuntu:~$ ssh root@192.168.1.48\nThe authenticity of host '192.168.1.40 (192.168.1.40)' can't be established.\nECDSA key fingerprint is SHA256:fTZa4u/xMgLj7LB0YbeVG0qDumxD2yKCLPsObHqcVXQ.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added '192.168.1.40' (ECDSA) to the list of known hosts.\nLast login: Wed Jan 25 22:12:53 2023\nroot@stratix10:~# pwd\n/home/root\nroot@stratix10:~# ls\nREADME linux-socfpga-v5.15.70-lts-src.tar.gz\narm-trusted-firmware-v2.7-src.tar.gz u-boot-socfpga-v2022.07-src.tar.gz\nintelFPGA\nroot@stratix10:~# uname -a\nLinux stratix10 5.15.70-altera #1 SMP PREEMPT Thu Dec 15 08:50:33 UTC 2022 aarch64 GNU/Linux\nroot@stratix10:~#\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section presents how to boot HPS from QSPI. In this scenario, in addition to the initial FPGA configuration bitstream and the HPS FSBL, the QSPI also contains the rest of the HPS software: U-Boot, Linux and Linux rootfs.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-qspi-image_1","title":"Write QSPI Image","text":"<p>1. Configure MSEL to JTAG:</p> <ul> <li>SW2: ON-ON-ON (SW2.4 is not connected)</li> </ul> <p>2. Power cycle the board</p> <p>3. Retrieve the QSPI image from the prebuilt location:</p> <p>4. Write the image using the following commands:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;flash_image.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-linux_1","title":"Boot Linux","text":"<p>1. Configure MSEL back to QSPI:</p> <ul> <li>SW2: ON-OFF-OFF (SW2.4 is not connected)</li> </ul> <p>2. Important! Remove SD card, otherwise U-Boot may try to boot from it.</p> <p>3. Power cycle. Board will boot up to Linux prompt, where you can login as 'root' without a password.</p> <p>Note: First time Linux is booted, the UBIFS rootfs will be initialized, the step taking approximately 3 minutes, as shown in the log below:</p> <pre><code>[ 12.523260] platform soc:leds: deferred probe pending\n \u2026 3 minute 'gap' here ...\n[ 205.105071] UBIFS (ubi0:4): free space fixup complete\n[ 205.234501] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[ 205.241896] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[ 205.251273] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size 8650240 bytes (8 MiB, 133 LEBs)\n</code></pre> <p>On the first boot empty pages are identifies and erased, to ensure all pages are 0xFF and avoid problematic non-0xFF empty page. This is controlled by the \"-F\" parameter passed when creating the rootfs.ubifs image. The next boots will not have this this step. Refer to http://www.linux-mtd.infradead.org/faq/ubifs.html for more details.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-nand","title":"Boot from NAND","text":"<p>This section presents how to exercise the boot from NAND scenario for the GSRD.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#nand-daughtercard","title":"NAND Daughtercard","text":"<p>The NAND/eMMC HPS daughtercard that comes with the S10 SoC DevKit supports both NAND and eMMC.</p> <p>To configure the card for NAND operation, please set the jumpers as shown below:</p> Jumper Setting J2 unpopulated J9 unpopulated J10 populated 2-3 J11 populated 1-1 <p>For reference, the NAND/eMMC schematic is available at https://www.intel.com/content/dam/altera-www/global/en_US/support/boards-kits/arria10/soc/hps_io48_nand_dc.pdf.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-nand-binaries","title":"Write NAND Binaries","text":"<p>1. Copy files to your TFTP server folder:</p> <pre><code>cp -f $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot.itb&lt;your-tftp-server-folder&gt;\ncp -f $TOP_FOLDER/nand-bin/root.ubi &lt;your-tftp-server-folder&gt;\n</code></pre> <p>2. Run U-Boot with the debugger, similar to how it is described at https://rocketboards.org/foswiki/Documentation/BuildingBootloader#Stratix_10_SOC_45_Run_U_45Boot_from_Debugger just change the script to use the binaries directly from <code>$TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/</code>.</p> <p>3. Stop at U-Boot prompt, and run the following instructions to download and write NAND binaries to flash:</p> <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your-tftp-server-ip&gt;\n\ntftp $loadaddr u-boot.itb\nnand erase.part u-boot\nnand write $loadaddr u-boot $filesize\ntftp $loadaddr root.ubi\nnand erase.part clean root\nnand write.trimffs $loadaddr root $filesize\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-qspi-image_2","title":"Write QSPI Image","text":"<p>1. Power off board</p> <p>2. Set MSEL to JTAG</p> <p>3. Power on board</p> <p>4. Write jic image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_1sx280hu2f50e1vgas.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-linux_2","title":"Boot Linux","text":"<p>1. Power off the board. Make sure MSEL is set to QSPI.</p> <p>2. Power on the board.</p> <p>3. Linux will boot, use 'root' as username, with no password.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#rebuild-the-gsrd","title":"Rebuild the GSRD","text":"<p>This section presents how to rebuild the GSRD for various scenarios covered by this release.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-sd-card_1","title":"Boot from SD Card","text":""},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf stratix10_gsrd\nmkdir stratix10_gsrd\ncd stratix10_gsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-hardware-design","title":"Build Hardware Design","text":"<pre><code>cd $TOP_FOLDER\nrm -rf stratix10-ed-gsrd\nwget https://github.com/altera-fpga/stratix10-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm -f QPDS25.1.1_REL_GSRD_PR.zip\nmv stratix10-ed-gsrd-QPDS25.1.1_REL_GSRD_PR stratix10-ed-gsrd\ncd stratix10-ed-gsrd\nmake s10-htile-soc-devkit-oobe-baseline-all\ncd ..\n</code></pre> <p>The following files are created in $TOP_FOLDER/s10_soc_devkit_ghrd/output_files:</p> <ul> <li><code>$TOP_FOLDER/stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof</code>: FPGA SOF file, without HPS FSBL</li> <li><code>$TOP_FOLDER/stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline_hps_debug.sof</code>: FPGA SOF, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline_hps_debug.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_1sx280hu2f50e1vgas.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. stratix10_htile-gsrd-build.sh\nbuild_setup\n</code></pre> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env stratix10-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>stratix10_htile_gsrd_ghrd.core.rbf</li> <li>stratix10_htile_pr_persona0.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_htile_pr_persona1.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_htile_nand_ghrd.core.rbf: not applicable, as we have not rebuilt the NAND version</li> </ul> <p>This can be accomplished using the following instructions:</p> <pre><code>GHRD_LOC=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files\nCORE_RBF=$GHRD_LOC/stratix10_htile_gsrd_ghrd.core.rbf\ncp $TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf $CORE_RBF\n</code></pre> <p>2. Update the Yocto recipe at <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> to change the <code>SRC_URI:stratix10</code> from the orginal value:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n${GHRD_REPO}/stratix10_htile_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core \\\n${GHRD_REPO}/stratix10_htile_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n \"\n</code></pre> <p>to be:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n file://stratix10_htile_gsrd_ghrd.core.rbf \\\n${GHRD_REPO}/stratix10_htile_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands from the console:</p> <pre><code>OLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_htile_gsrd_\\${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core\"\nNEW_CORE_URI=\"file:\\/\\/stratix10_htile_gsrd_ghrd.core.rbf\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\n</code></pre> <p>Note we have left the PR and NAND files alone, that will be downloaded from rocketboards.</p> <p>3. Update the same Yocto recipe to change the SHA checksums for the new files:</p> <pre><code>SRC_URI[stratix10_htile_gsrd_core.sha256sum] = \"ea26a77ebc1b3141193de6dd32e22f332785e05c956de85118c3790392141d3c\"\n</code></pre> <p>to the new values using the following commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nOLD_CORE_SHA=\"SRC_URI\\[stratix10_htile_gsrd_core\\.sha256sum\\] = .*\"\nNEW_CORE_SHA=\"SRC_URI[stratix10_htile_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\"\nsed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li> <p>fit_kernel_stratix10.its - its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD and NAND board configurations</li> <li>Core RBF files for SD and NAND board configurations</li> <li>Board configurations for SD and NAND cases</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>stratix10_htile_gsrd_rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>stratix10_htile_gsrd_images</code>: the build script copies here relevant files built by Yocto from the <code>stratix10_htile_gsrd_rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-qspi-image","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o hps_path=gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric. We already have the same file on the SD card.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-qspi_1","title":"Boot from QSPI","text":"<p>This section presents how to boot the Stratix 10 SoC from QSPI, using the rebuilt GSRD binaries.</p> <p>The same binaries as when booting from SD card can be used to boot from QSPI, because:</p> <ul> <li>The QSPI resides on the DevKit board, and not on the HPS daughtercard, so there are no board changes:</li> <li>The same GHRD configuration can be used</li> <li>The same U-Boot devce tree can be used</li> <li>The same Linux device tree can be used</li> <li>U-Boot uses distroboot, which will try first booting from SD/MMC, then from QSPI, then from NAND, so the same U-Boot can be used.</li> </ul> <p>Note: As the QSPI has a much smaller size than the SD card (256MB vs 2GB) the rootfs is smaller, and less functionality is provided. The purpose of this section is just to show Linux booting.</p> <p>Note: The HPS speed for accessing SDM QSPI is limited to ~4MB/s. It is up to you to decide whether this level of performance is sufficient for your application. If not, it is recommended you use an SD card or eMMC device to store the HPS components such as the rootfs. Note that the QSPI speed limitation does not apply when SDM accesses the QSPI, it is just for HPS accessing SDM QSPI.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#qspi-flash-layout","title":"QSPI Flash Layout","text":"MTD PartitionUBI VolumeVolume NameTypeImage/FileSize 0 (bitstream &amp; uboot)N/AN/ARAWbitstream (FPGA image, SDM firmware)64MB N/AN/ARAWu-boot.itb2MB 1 (root.ubi)0envUBIu-boot.env256KB 1scriptUBIu-boot.scr128KB 2kernelUBIkernel.itb24MB 3dtbUBIkernel.dtb256KB 4rootfsUBIFSrootfs.ubifs160MB"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-qspi-image_1","title":"Create QSPI Image","text":"<p>1. Create a folder to contain all the qspi binaries, and create symlinks to actual location for all files:</p> <pre><code>cd $TOP_FOLDER\nrm -rf qspi-boot &amp;&amp; mkdir qspi-boot &amp;&amp; cd qspi-boot\nln -s $TOP_FOLDER/stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof fpga.sof\nln -s $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex spl.hex\nln -s $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/console-image-minimal-stratix10_nor.ubifs rootfs.ubifs\n</code></pre> <p>2. Create U-Boot image:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncp $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>4. Create hps.ubi file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncat &lt;&lt;EOT &gt;ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOT\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>5. Create the QSPI image using the provided Quartus Programming File Generator (PFG) file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/stratix-10/sx/soc/gsrd/collateral/stratix10_gsrd.pfg\nquartus_pfg -c stratix10_gsrd.pfg\n</code></pre> <p>The following files will be generated:</p> <ul> <li>$TOP_FOLDER/qspi-boot/flash_image.hps.jic - JIC QSPI flash image</li> <li>$TOP_FOLDER/qspi-boot/s10_flash_image.core.rbf - fabric configuration file, already generated previously with the debug HPS FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-programming-file-generator-file","title":"Create Programming File Generator File","text":"<p>This section presents how to manually re-create the PFG file provided at https://altera-fpga.github.io/rel-25.1.1/embedded-designs/stratix-10/sx/soc/gsrd/collateral/stratix10_gsrd.pfg</p> <p>1. Start Quartus Programming File Generator GUI:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nqpfgw &amp;\n</code></pre> <p>2. In PFG Output Files tab:</p> <ul> <li>Select Device Family as \"Stratix 10\"</li> <li>Select Configuration Mode as \"Active Serial x4\"</li> <li>Edit Name as \"flash_image\"</li> <li>Check Raw Binary File for HPS Core Configuration (.rbf) option</li> <li>Check the following sub-options:</li> <li>Check JTAG Indirect Configuration File (.jic)</li> <li>Check Memory Map File (.map)</li> </ul> <p></p> <p>3. In PFG Input Files tab:</p> <ul> <li>Click Add Bitstream\", then browse to \"fpga.sof\" link, and add click *Open to add it.</li> <li>Click Bitstream_1&gt;fpga.sof then click Properties the click HPS Bootloader, browse to \"spl.hex\" then click Open to add it.  Note: By the time the fpga.sof file is read the following error is displayed, this was addressed by adding the spl.hex file to the Bitstream:   File fpga.sof is incomplete- HPS is present but bootloader information is missing.</li> <li>Click Add Raw Data then change the extension filter to .bin then browse to \"u-boot.bin\" and click Open to add it.</li> <li>Click on the \"u-boot.bin\" then click \"Properties\" then select Bit swap option to \"On\"</li> <li>Repeat the above 2 steps for the following file:</li> <li>hps.bin</li> </ul> <p>The Input Files tab will now look something like this:</p> <p></p> <p>4. In the PFG Configuration Device tab:</p> <ul> <li>Click Add Device, select the Micron MT25QU02G device then click Add</li> <li>Click the MT25QU02G device, then click Add Partition, select the options as following then click OK:</li> </ul> <p></p> <ul> <li>Click the MT25QU02G device, then click Add Partition, select the options as following then click OK:</li> </ul> <p></p> <ul> <li>Repeat the above step for the rest of binary files, choosing the following offsets:</li> <li>hps: 0x04200000</li> <li>Click Flash Loader &gt; Select then browse to the device used on the devkit then click OK:</li> </ul> <p></p> <p>The Configuration Device tab will now look something like this:</p> <p></p> <p>3. Go to File &gt; Save As and save the configuration file as \"s10_flash_image_qspi.pfg\".</p> <p>4. [Optional] Open the file \"stratix10_gsrd.pfg\" with a text editor and change absolute paths to relative paths.</p> <p>The file will look like this:</p> <pre><code>&lt;pfg version=\"1\"&gt;\n&lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n&lt;output_files&gt;\n&lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n&lt;file_options/&gt;\n&lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n&lt;/output_file&gt;\n&lt;/output_files&gt;\n&lt;bitstreams&gt;\n&lt;bitstream id=\"Bitstream_1\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;/bitstreams&gt;\n&lt;raw_files&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n&lt;/raw_files&gt;\n&lt;flash_devices&gt;\n&lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x000FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"u-boot\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"hps\" size=\"0\"/&gt;\n&lt;/flash_device&gt;\n&lt;flash_loader&gt;1SX280HU2&lt;/flash_loader&gt;\n&lt;/flash_devices&gt;\n&lt;assignments&gt;\n&lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n&lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"0\" partition_id=\"u-boot\"&gt;\n&lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"0\" partition_id=\"hps\"&gt;\n&lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;/assignments&gt;\n&lt;/pfg&gt;\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-nand_1","title":"Boot from NAND","text":"<p>This section presents how to boot the Stratix 10 SoC from NAND, including how to build all binaries.</p> <p>Build instructions are the same as for standard SD or QSPI boot. The U-Boot, ATF and Linux binaries are all the same. The only differences are:</p> <ul> <li>GHRD is configured for the NAND HPS Daughtercard, then recompiled</li> <li>The PR persona.rbf files are the ones compiled by the GHRD configured for NAND</li> </ul> <p>Note: As the NAND used on the devkit has a smaller size than the SD card (1GB vs 2GB) the rootfs is smaller, and less functionality is provided. The purpose of this section is just to show Linux booting.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#nand-flash-layout","title":"NAND Flash Layout","text":"MTD PartitionUBI VolumeVolume NameTypeImage/FileFlash OffsetSizeSize in Hex 0 (u-boot)N/AN/ARAWu-boot.itb0x000000002MB0x00200000 1 (root.ubi)0envUBIu-boot.env0x00200000256KB0x40000 1scriptUBIu-boot.scr0x00240000128KB0x0020000 2kernelUBIkernel.itb0x00260000 onwards64MB0x04000000 3dtbUBIkernel.dtb256KB0x0004000 4rootfsUBIFSrootfs.ubifs&lt;957MB&lt;0x3BD70000"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-environment_1","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf stratix10_gsrd.nand\nmkdir stratix10_gsrd.nand\ncd stratix10_gsrd.nand\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-hardware-design_1","title":"Build Hardware Design","text":"<p>Build the GHRD targeting the NAND HPS daughtercard, by passing the correct parameter to the make utility:</p> <pre><code>cd $TOP_FOLDER\nrm -rf stratix10-ed-gsrd\nwget https://github.com/altera-fpga/stratix10-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm -f QPDS25.1.1_REL_GSRD_PR.zip\nmv stratix10-ed-gsrd-QPDS25.1.1_REL_GSRD_PR stratix10-ed-gsrd\ncd stratix10-ed-gsrd\nmake s10-htile-soc-devkit-nand-baseline-all  cd ..\n</code></pre> <p>The following files are created in $TOP_FOLDER/s10_soc_devkit_ghrd/output_files:</p> <ul> <li><code>$TOP_FOLDER/stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_nand_baseline.sof</code>: FPGA SOF file, without HPS FSBL</li> <li><code>$TOP_FOLDER/stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_nand_baseline_hps_debug.sof</code>: FPGA SOF, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-core-rbf_1","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_nand_baseline_hps_debug.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_1sx280hu2f50e1vgas.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-yocto_1","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\n. stratix10_htile-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env stratix10-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#customize-yocto_1","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>stratix10_htile_gsrd_ghrd.core.rbf: not applicable, as we have not rebuilt the standard GSRD version supporting SD card in this case</li> <li>stratix10_htile_pr_persona0.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_htile_pr_persona1.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_htile_nand_ghrd.core.rbf</li> </ul> <p>This can be accomplished using the following instructions:</p> <pre><code>GHRD_LOC=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files\nCORE_RBF=$GHRD_LOC/stratix10_htile_nand_ghrd.core.rbf\ncp $TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf $CORE_RBF\n</code></pre> <p>2. Update the Yocto recipe at <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> to change the <code>SRC_URI:stratix10</code> from the orginal value:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n${GHRD_REPO}/stratix10_htile_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core \\\n${GHRD_REPO}/stratix10_htile_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n \"\n</code></pre> <p>to be:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n${GHRD_REPO}/stratix10_htile_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core \\\n file://stratix10_htile_nand_ghrd.core.rbf \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands from the console:</p> <pre><code>OLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_htile_nand_\\${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core\"\nNEW_CORE_URI=\"file:\\/\\/stratix10_htile_nand_ghrd.core.rbf\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\n</code></pre> <p>Note we have left the NAND file alone, that will be downloaded from rocketboards.</p> <p>3. Update the same Yocto recipe to change the SHA checksums for the new files:</p> <pre><code>SRC_URI[stratix10_htile_gsrd_core.sha256sum] = \"ea26a77ebc1b3141193de6dd32e22f332785e05c956de85118c3790392141d3c\"\nSRC_URI[stratix10_htile_nand_core.sha256sum] = \"d782c05085f8f13cb792b687fd002773e0897e4d7ecf5451994b1823d62cdc92\"\n</code></pre> <p>to the new values using the following commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nOLD_CORE_SHA=\"SRC_URI\\[stratix10_htile_nand_core\\.sha256sum\\] = .*\"\nNEW_CORE_SHA=\"SRC_URI[stratix10_htile_nand_core.sha256sum] = \\\"$CORE_SHA\\\"\"\nsed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li> <p>fit_kernel_stratix10.its - its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD and NAND board configurations</li> <li>Core RBF files for SD and NAND board configurations</li> <li>Board configurations for SD and NAND cases</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-yocto_1","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>stratix10_htile_gsrd_rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>stratix10_htile_gsrd_images</code>: the build script copies here relevant files built by Yocto from the <code>stratix10_htile_gsrd_rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images</code> folder are:</p> File Description gsrd-console-image-stratix10_htile_nand.ubifs UBI root partition image u-boot-stratix10-socdk-gsrd-atf/u-boot.itb U-Boot FIT image u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-qspi-image_2","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_nand_baseline.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o hps_path=gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric. We already have the same file on the SD card.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-nand-binaries","title":"Build NAND Binaries","text":"<p>1. Gather the files into a single folder, using symlinks:</p> <pre><code>cd $TOP_FOLDER\nrm -rf nand-bin &amp;&amp; mkdir nand-bin &amp;&amp; cd nand-bin\nln -s $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/gsrd-console-image-stratix10_nand.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/socfpga_stratix10_socdk_nand.dtb .\n</code></pre> <p>2. Install <code>mtd-tools</code> if not already installed. On Ubuntu the command is:</p> <pre><code>sudo apt-get install mtd-tools\n</code></pre> <p>3. Create UBI configuration file for the root partition;</p> <pre><code>cat &lt;&lt;EOT &gt;ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=64MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nimage=socfpga_stratix10_socdk_nand.dtb\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=400MiB\nvol_flag=autoresizeENDCOLOR%\nEOT\n</code></pre> <p>4. Create the <code>root.ubi</code> file:</p> <pre><code>ubinize -o root.ubi -p 128KiB -m 2048 -s 2048 ubinize.cfg\n</code></pre> <p>This is what the above parameters mean:</p> <ul> <li>-p: physical eraseblock size of the flash</li> <li>-m: minimum input/output unit size of the flash</li> <li>-s: sub-pages and sub-page size, ubinize will take into account and put the VID header to same NAND page as the EC header</li> </ul> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/nand-bin/root.ubi</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#how-to-manually-update-the-kernelitb-file","title":"How to Manually Update the kernel.itb file","text":"<p>The kernel.itb file is a Flattattened Image Tree (FIT) file that includes the following components:</p> <ul> <li>Linux kernel.</li> <li>Several board configurations that indicate what components from the kernel.itb (Linux kernel, device tree and 2nd Phase fabric design) should be used for a specific board.</li> <li>Linux device tree*.</li> <li>2nd Phase Fabric Design*.</li> </ul> <p>* One or more of these components to support the different board configurations.</p> <p>The kernel.itb is created from a .its (Image Tree Source file) that describes its structure. In the GSRD, the  kernel.itb file is located in the following directory, where you can find also all the components needed to create it, including the .its file:</p> <ul> <li>$TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device devkit&gt;-standard-build/</li> </ul> <p>If you want to modify the kernel.itb by replacing one of the component or modifying any board configuration, you can do the following:</p> <ol> <li> <p>Install mtools package in your Linux machine.    <pre><code>$ sudo apt update\n$ sudo apt install mtools\n</code></pre></p> </li> <li> <p>Go to the in which the kernel.itb is being created under the GSRD.    <pre><code>$ cd $TOP_FOLDER/gsrd-socfpga/&lt;device-devkit&gt;-gsrd-rootfs/tmp/work/&lt;device-devkit&gt;-poky-linux/linux-socfpga-lts/&lt;linux branch&gt;+git/linux-&lt;device-devkit&gt;-standard-build/\n$ ls *.its\nfit_kernel_&lt;device-devkit&gt;.its\n</code></pre></p> </li> <li> <p>In the .its file, observe the components that integrates the kernel.itb identifying the nodes as indicated next:</p> <p>images node:  - kernel node - Linux kernel defined with the data parameter in the node.  - fdt-X node    - Device tree X defined with the data parameter in the node.  - fpga-X node -  2nd Phase FPGA Configuration .rbf defined with the data parameter in the node.</p> <p>configurations node:  - board-X node - Board configuration with the name defined with the description parameter. The components for a specific board configuration are defined with the kernel, fdt and fpga parameters.   </p> </li> <li> <p>In this directory, you can replace any of the files corresponding to any of the components that integrate the kernel.itb, or you can also modify the .its to change the name/location of any of the components or change the board configuration.</p> </li> <li> <p>Finally, you need to re-generate the new kernel.itb as indicated next.    <pre><code>$ rm kernel.itb\n$ mkimage -f fit_kernel_&lt;device-devkit&gt;.its kernel.itb\n</code></pre></p> </li> </ol> <p>At this point you can use the new kernel.itb as needed. Some options could be:</p> <ul> <li>Use U-Boot to bring it to your SDRAM board through TFTP to boot Linux or to write it to a SD Card device</li> <li>Update the flash image (QSPI, SD Card, eMMC or NAND) from your working machine.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#how-to-manually-update-the-content-of-the-sd-card-image","title":"How to Manually Update the Content of the SD Card Image","text":"<p>As part of the Yocto GSRD build flow, the SD Card image is built for the SD Card boot flow. This image includes a couple of partitions. One of these partition (a FAT32) includes the U-Boot proper, a Distroboot boot script and the Linux.itb - which includes the Linux kernel image, , the Linux device tree, the 2nd phase fabric design and board configuration (actually several versions of these last 3 components). The 2nd partition (an EXT3 or EXT4 ) includes the Linux file system. </p> <p></p> <p>If you want to replace any the components or add a new item in any of these partitions, without having to run again the Yocto build flow. </p> <p>This can be done through the wic application available on the Poky repository that is included as part of the GSRD build directory: $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic </p> <p>This command allows you to inspect the content of a SD Card image, delete, add or replace any component inside of the image. This command is also provided with help support:</p> <p><pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic help\nCreates a customized OpenEmbedded image.\n\nUsage:  wic [--version]\nwic help [COMMAND or TOPIC]\nwic COMMAND [ARGS]\nusage 1: Returns the current version of Wic\n    usage 2: Returns detailed help for a COMMAND or TOPIC\n    usage 3: Executes COMMAND\n\nCOMMAND:\n\nlist   -   List available canned images and source plugins\n ls     -   List contents of partitioned image or partition\n rm     -   Remove files or directories from the vfat or ext* partitions\n help   -   Show help for a wic COMMAND or TOPIC\n write  -   Write an image to a device\n cp     -   Copy files and directories to the vfat or ext* partitions\n create -   Create a new OpenEmbedded image\n :\n :\n</code></pre>    The following steps show you how to replace the kernel.itb file inside of the fat32 partition in a .wic image.</p> <ol> <li> <p>The wic ls command allows you to inspect or navigate over the directory structure inside of the SD Card image. For example you can observe the partitions  in the SD Card image in this way:</p> <pre><code># Here you can inspect the content a wic image see the 2 partitions inside of the SD Card image\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic\nNum     Start        End          Size      Fstype\n1       1048576    525336575    524288000  fat32    2     525336576   2098200575   1572864000  ext4   # Here you can naviagate inside of the partition 1\n$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic ls my_image.wic:1\nVolume in drive : is boot       Volume Serial Number is 9D2B-6341\nDirectory for ::/\n\nBOOTSC~1 UIM      2431 2011-04-05  23:00  boot.scr.uimg\nkernel   itb  15160867 2011-04-05  23:00 u-boot   itb   1052180 2011-04-05  23:00 3 files          16 215 478 bytes\n                     506 990 592 bytes free\n</code></pre> </li> <li> <p>The wic rm command allows you to delete any of the components in the selected partition. For example, you can delete the kernel.itb image from the partition 1(fat32 partition).</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic rm my_image.wic:1/kernel.itb\n</code></pre> </li> <li> <p>The wic cp command allows you to copy any new item or file from your Linux machine to a specific partition and location inside of the SD Card image. For example, you can copy a new kernel.itb to the partition 1.</p> <pre><code>$ $TOP_FOLDER/gsrd-socfpga/poky/scripts/wic cp &lt;path_new_kernel.itb&gt; my_image.wic:1/kernel.itb\n</code></pre> </li> </ol> <p>NOTE: The wic application also allows you to modify any image with compatible vfat and ext* type partitions which also covers images used for eMMC boot flow. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/","title":"SoC FPGA Remote Debug Tutorial Example Design User Guide: Stratix\u00ae 10 SX SoC Development Kit","text":""},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#introduction","title":"Introduction","text":"<p>Altera offers an integrated set of System Level Debug (SLD) tools, including:</p> <ul> <li>SignalTap II Logic Analyzer</li> <li>In-System Sources and Probes (ISSP),</li> <li>In-System Memory Content Editor)</li> </ul> <p>Typically, the System-Level Debugging (SLD) communication solution was interfacing with the outside world through the JTAG. Then either an USB or Ethernet Blaster could be used to interface JTAG to the host PC.</p> <p></p> <p></p> <p>Another alternative approach is also available, to interface the SLD to the outside world directly through Ethernet on board, without requiring either an USB or Ethernet Blaster.</p> <p></p> <p>This page presents an example on how enable this remote debug feature on top of the GSRD.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#architecture","title":"Architecture","text":"<p>In the traditional approach the SLD communication solution was based on the Altera JTAG Interface (AJI) which interfaced with the JTAG TAP controller (hard atom in Altera devices which implements the JTAG protocol). The SLD tools used the JTAG channel for communication between software and hardware.</p> <p></p> <p>The remote FPGA debugging solution consists of the following:</p> <ul> <li>JTAG-Over Protocol (JOP) Component: Platform Designer component which enables access to debug information through an Avalon\u00ae-MM slave bus</li> <li>Etherlink: HPS application exporting debug information over Ethernet, available on github: https://github.com/altera-opensource/remote-debug-for-intel-fpga</li> </ul> <p></p> <p>The JOP component requires reset and clocking and also provides an Avalon\u00ae-MM slave bus through which is configured and debug information is accessed.</p> <p>Th Etherlink application runs on HPS, accesses the JOP component slave bus to access the debug information, and provides a TCP/IP link from the host PC running the Quartus Pro debug tools to the board.</p> <p>The etherlink works with the standard UIO Linux kernel driver.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#example","title":"Example","text":"<p>This section shows an example of how to use the Remote Debug feature. Communication is established from the board to the host PC through Ethernet, so that the board appears as another JTAG device, listed by jtagconfig utility.</p> <p>The example is based on the GSRD, with the following changes:</p> <ul> <li>Adding JOP component to the GHRD</li> <li>Adding JOP to the Linux device tree</li> </ul> <p>Notes:</p> <ul> <li>UIO driver is enabled as module in the default kernel configuration file</li> <li>etherlink is already part of the rootfs, built by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Stratix\u00ae 10 SX SoC Development Kit, production version, H-Tile (ordering code DK-SOC-1SSX-H-D)<ul> <li>4GB DDR4 HILO memory card</li> <li>SD/MMC HPS Daughtercard</li> <li>SDM QSPI Bootcard(MT25QU02G)</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel\u00ae FPGA Download Cable II</li> </ul> </li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera Quartus\u00ae Prime Pro Edition Version 25.1.1</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for more details about the development kit.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf stratix10.remote_debug\nmkdir stratix10.remote_debug\ncd stratix10.remote_debug\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>The hardware design is based on the GSRD, with the JOP component added.</p> <p>1. Generate the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf stratix10-ed-gsrd\nwget https://github.com/altera-fpga/stratix10-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm -f QPDS25.1.1_REL_GSRD_PR.zip\nmv stratix10-ed-gsrd-QPDS25.1.1_REL_GSRD_PR stratix10-ed-gsrd\ncd stratix10-ed-gsrd\nmake s10-htile-soc-devkit-oobe-baseline-generate-design\ncd ..\n</code></pre> <p>2. Open the project in Quartus, open the <code>qsys_top.qsys</code> file in Platform Designer.</p> <p>3. In the IP Catalog search for jop and double-click the component to add it to the system:</p> <p></p> <p>4. Configure the JOP component as follows:</p> <p></p> <p>5. Connect the reset and clock to JOP component, also connect it's slave bus to the HPS LW bridge, and map it at offset 0x0002_0000:</p> <p></p> <p>6. Alternatively, steps 2-5 can be peformed from command line, using the provided tcl script:</p> <pre><code>cd $TOP_FOLDER/stratix10-ed-gsrd\ncd s10_soc_devkit_ghrd\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/stratix-10/sx/soc/remote-debug/collateral/s10-ghrd-add-jop.tcl\nqsys-script --qpf=ghrd_1sx280hu2f50e1vgas.qpf --script=s10-ghrd-add-jop.tcl --system-file=qsys_top.qsys\ncd ..\nmake s10-htile-soc-devkit-oobe-baseline-package-design\nmake s10-htile-soc-devkit-oobe-baseline-prep\nmake s10-htile-soc-devkit-oobe-baseline-build\nmake s10-htile-soc-devkit-oobe-baseline-sw-build\nmake s10-htile-soc-devkit-oobe-baseline-test\nmake s10-htile-soc-devkit-oobe-baseline-install-sof\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof</code>: FPGA SOF file, without HPS FSBL</li> <li><code>$TOP_FOLDER/stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline_hps_debug.sof</code>: FPGA SOF, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#build-corerbf-file","title":"Build Core.RBF File","text":"<p>This section shows how to create the core RBF file, which is needed by the Yocto recipes:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline_hps_debug.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2F50E1VGAS \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_1sx280hu2f50e1vgas.hps.jic\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf</code></li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#build-yocto","title":"Build Yocto","text":"<p>Perform the following steps to build Yocto:</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS25.1.1_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. stratix10_htile-gsrd-build.sh\nbuild_setup\n</code></pre> <p>3. Enable the JOP UIO driver in the Linux device tree, by editing the file <code>meta-intel-fpga-refdes</code> to inlcude the changes shown below:</p> <pre><code>diff --git a/recipes-bsp/device-tree/files/socfpga_ilc.dtsi b/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\nindex 387d8bd..156dbb8 100644\n--- a/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\n+++ b/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\n@@ -14,5 +14,10 @@\n            status = \"disabled\";\n            altr,sw-fifo-depth = &lt;32&gt;;\n        };\n+        jop@f9008000{\n+                                compatible = \"generic-uio\";\n+                                reg = &lt;0xf9008000 0x5000&gt;;\n+                                reg-names = \"jop\";\n+                };\n    };\n };\n</code></pre> <p>Note that the range of memory where the JOP is located is <code>0xf9008000</code> .. <code>0xf900dfff</code>.</p> <p>This can be done with the provided patch file:</p> <pre><code>rm -f s10-dts-add-jop.patch\nwget https://altera-fpga.github.io/rel-25.1.1/embedded-designs/stratix-10/sx/soc/remote-debug/collateral/s10-dts-add-jop.patch\npushd meta-intel-fpga-refdes\npatch -p1 &lt; ../s10-dts-add-jop.patch\npopd\n</code></pre> <p>4. Update the recipe to not use a broken version of =etherlink=:</p> <pre><code>sed -i 's/3a3eb126321429c0845276ef9c200df7786dbf74/b6a13b03fe7e9566063eae65d99bd8bc1190ce62/g' meta-intel-fpga-refdes/recipes-tools/remote-debug-app/remote-debug-app_1.0.bb\n</code></pre> <p>5. Update your Yocto recipes to use the core RBF file you have built, similar to how the GSRD does it:</p> <pre><code>GHRD_LOC=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files\nCORE_RBF=$GHRD_LOC/stratix10_htile_gsrd_ghrd.core.rbf\ncp $TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf $CORE_RBF\nOLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_htile_gsrd_\\${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core\"\nNEW_CORE_URI=\"file:\\/\\/stratix10_htile_gsrd_ghrd.core.rbf\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nOLD_CORE_SHA=\"SRC_URI\\[stratix10_htile_gsrd_core\\.sha256sum\\] = .*\"\nNEW_CORE_SHA=\"SRC_URI[stratix10_htile_gsrd_core.sha256sum] =  \\\"$CORE_SHA\\\"\"\nsed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE\n</code></pre> <p>6. Build the Yocto recipes:</p> <pre><code>bitbake_image\n</code></pre> <p>7. Gather the Yocto binaries:</p> <pre><code>package\n</code></pre> <p>The following relevant files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/gsrd-console-image-stratix10.wic</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#build-qspi-image","title":"Build QSPI Image","text":"<p>Run the following commands to build the QSPI image:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c stratix10-ed-gsrd/install/designs/s10_htile_soc_devkit_oobe_baseline.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=1SX280HU2 \\\n-o hps_path=gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.hps.jic</code></li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#run-example","title":"Run Example","text":"<p>The instructions from this section present how to run the remote debug example. Refer to the GSRD for more detailed instructions on how to set up the board, serial port, and write the binaries.</p> <p>1. Write the QSPI image <code>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.jic</code> to flash.</p> <p>2. Extract and write the SD card image <code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/gsrd-console-image-stratix10.wic</code> to the SD card</p> <p>3. Boot board and log into Linux.</p> <p>4. Determine board IP address by running the <code>ifconfig</code> command:</p> <pre><code>root@stratix10:~# ifconfig\neth0: flags=4163  mtu 1500\ninet 10.122.105.175  netmask 255.255.255.0  broadcast 10.122.105.255\n        inet6 fe80::b830:37ff:fe25:aa4b  prefixlen 64  scopeid 0x20\n        ether ba:30:37:25:aa:4b  txqueuelen 1000  (Ethernet)\nRX packets 35  bytes 5398 (5.2 KiB)\nRX errors 0  dropped 1  overruns 0  frame 0\nTX packets 51  bytes 8687 (8.4 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 19  base 0x2000  </code></pre> <p>5. Remove pre-existing instances of the driver, and load it again:</p> <pre><code>root@stratix10:~# rmmod uio_pdrv_genirq\nroot@stratix10:~# modprobe uio_pdrv_genirq of_id=\"generic-uio\"\n</code></pre> <p>6. Start the etherlink application, specifying which port to accept connections on as shown below:</p> <pre><code>root@stratix10:~# etherlink --port=33301\nINFO: Etherlink Server Configuration:\nINFO:    H2T/T2H Memory Size  : 4096\nINFO:    Listening Port       : 33301\nINFO:    IP Address           : 0.0.0.0\nINFO: UIO Platform Configuration:\nINFO:    Driver Path: /dev/uio0\nINFO:    Address Span: 20480\nINFO:    Start Address: 0x0\nINFO: Server socket is listening on port: 33301\n</code></pre> <p>7. On the host, establish the JTAG communication to the board through Ethernet, using the board IP and the selected port number:</p> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0\n</code></pre> <p>8. Also on the host, run the 'jtagconfig' command to show the newly added connection:</p> <pre><code>$ jtagconfig\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0]\n020D10DD   VTAP10\n</code></pre> <p>At this point, the connection can be used by the tools which need a JTAG connection, like SignalTap.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/","title":"HPS Remote System Update Tutorial Example Design: Stratix\u00ae 10 SX SoC Development Kit","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D), including the following.</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> </ul> <ul> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> </ul> <ul> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>Refer to Stratix\u00ae 10 Hard Processor System Remote System Update User Guide for details about the Remote System Update. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p> <p>Note: intel-rsu repository uses master branch.</p> <p>For RSU example previous 24.2 version, please refer to Stratix 10 HPS Remote System Update.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus\u00ae Prime Pro Edition Version 25.1.1 for compiling the hardware projects, generating the flash images and writing to flash </li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li> Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) production version  for running the example. </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are listed next.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul> <p>Note: To build binaries for a different development kit than the one used in this page, please refer to the Building the Hardware Projects section in the corresponding  GSRD page for that development kit, which is the section that may differ from the instructions presented here.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf s10-rsu mkdir s10-rsu cd s10-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next. </p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below. </p> <pre><code>cd $TOP_FOLDER\nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw\nwget https://github.com/altera-fpga/stratix10-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv stratix10-ed-gsrd-QPDS25.1.1_REL_GSRD_PR stratix10-ed-gsrd\n# boot from FPGA \nexport BOOTS_FIRST=fpga # enable watchdog \nexport ENABLE_WATCHDOG_RST=1 # treat watchdog timeout as configuration failure to trigger RSU \nexport WATCHDOG_RST_ACTION=remote_update\n# Customize parms in tcl\nsed -i '/STRATIX_JTAG_USER_CODE 4/i set_global_assignment -name RSU_MAX_RETRY_COUNT 3' stratix10-ed-gsrd/s10_soc_devkit_ghrd/create_ghrd_quartus.tcl\nfor version in {0..3}\ndo\nrm -rf ghrd.$version\ncp -r stratix10-ed-gsrd ghrd.$version\ncd ghrd.$version\n# update sysid to make binaries slightly different \nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' s10_soc_devkit_ghrd/create_ghrd_qsys.tcl\n# Finsish customization and now building the hardware design\nmake s10-htile-soc-devkit-oobe-baseline-all\ncd ..\ndone\nrm -rf stratix10-ed-gsrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created are listed next. </p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/install/designs/s10_htile_soc_devkit_oobe_baseline.sof</li> <li>$TOP_FOLDER/hw/ghrd.1/install/designs/s10_htile_soc_devkit_oobe_baseline.sof</li> <li>$TOP_FOLDER/hw/ghrd.2/install/designs/s10_htile_soc_devkit_oobe_baseline.sof</li> <li>$TOP_FOLDER/hw/ghrd.3/install/designs/s10_htile_soc_devkit_oobe_baseline.sof</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone https://github.com/altera-fpga/arm-trusted-firmware\ncd arm-trusted-firmware\n# checkout the branch used for this document, comment out to use default\n# git checkout -b test -t origin/socfpga_v2.12.1\nmake bl31 PLAT=stratix10\ncd ..\n</code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux. </p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga\ngit clone https://github.com/altera-fpga/linux-socfpga\ncd linux-socfpga\n# checkout the branch used for this document, comment out to use default\n# git checkout -b test -t origin/socfpga-6.12.19-lts\n# configure the RSU driver to be built into the kernel\nmake clean &amp;&amp; make mrproper\nmake defconfig\n./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y\nmake oldconfig\nmake -j 48 Image dtbs\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created. </p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone https://github.com/altera-fpga/u-boot-socfpga\ncd u-boot-socfpga\n# comment out next line to use the latest default branch\n# git checkout -b test -t origin/socfpga_v2025.04\n# enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# use 'Image' for kernel image instead of 'kernel.itb'\nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n# remove the NAND configuration from device tree\nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin .\n\n# Create configuration custom file.\ncat &lt;&lt; EOF &gt; config-fragment-stratix10\n# - Disable NAND/UBI related settings from defconfig.\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# - Disable distroboot and use specific boot command.\nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable; setenv bootfile Image; run mmcload; run linux_qspi_enable;run rsu_status;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper\nmake socfpga_stratix10_defconfig\n# Use created custom configuration file to merge with the default configuration obtained in .config file.\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-stratix10\nmake -j 48\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is provided below so and you can easily create the initial flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER\ncat &lt;&lt; EOF &gt; initial_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.0/install/designs/s10_htile_soc_devkit_oobe_baseline.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n        &lt;bitstream id=\"Bitstream_2\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.1/install/designs/s10_htile_soc_devkit_oobe_baseline.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0010FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00110000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x02000000\" e_addr=\"0x02FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03000000\" e_addr=\"0x03FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;1SX280HU2F50E1VGAS&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/altera_pro/25.1/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg\n</code></pre> <p>Here are the complete instructions on how to create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER\nqpfgw &amp;\n</code></pre> </li> <li> <p>Select the Device family as Stratix 10, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bitswap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file s10_htile_soc_devkit_oobe_baseline.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/install/designs/s10_htile_soc_devkit_oobe_baseline.sof image. This is the initial application image. The tab now looks like below. </p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. This opens the window to browse for the FSBL and select authentication and encryption settings. </p> <p> </p> </li> <li> <p>Click the Bootloader (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the MT25QU02G in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (ghrd_1sx280hu2f50e1vgas). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0090FFFF in order to reserve 8MB for the factory image. This end address was calculated by adding 8MB to the end of the BOOT_INFO partition. Click OK. </p> <p>Note: There is a requirement that the starting address of the SPT0 partition is aligned to 64KB. In order to warranty this, the End Address of the FACTORY_IMAGE must finish at an address ending with 0xXXXXFFFF.</p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be trieed after all the application images failed. </p> </li> <li> <p>Select the MT25QU02G flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(s10_htile_soc_devkit_oobe_baseline.sof). This becomes the initial application image. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x01000000 and End Address = 0x01FFFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.    The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image. </p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions) and set the start and end addresses as follows.</p> <p>* P2: Start Address = 0x02000000 and End Address = 0x02FFFFFF.     * P3: Start Address = 0x03000000 and End Address = 0x03FFFFFF. </p> <p>Note: Make sure that all the partitions created for the applications fit in the appropriate QSPI partition or partitions defined in device corresponding device tree in U-Boot and Linux. In the case of Linux, also make sure that the QSPI partition or partitions defined in the device tree to store the applications partitions are also defined in the qspi.rc file in LIBRSU.</p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER quartus_pfg -c initial_image.pfg\n</code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example. </p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -rf images/application2.rpd\nquartus_pfg -c hw/ghrd.2/install/designs/s10_htile_soc_devkit_oobe_baseline.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON\n</code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/factory_update.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/s10_htile_soc_devkit_oobe_baseline.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created.</p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example. </p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/decision_firmware_update.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/s10_htile_soc_devkit_oobe_baseline.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decision firmware update image is created.</p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/install/designs/s10_htile_soc_devkit_oobe_baseline.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/install/designs/s10_htile_soc_devkit_oobe_baseline.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul> <p>Notes:</p> <ul> <li>The first SOF file contains the factory image, from which data is taken to fill out the new decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from this SOF file is not used.</li> <li>The app_image parameter contains the SOF that is used for the application image section of the combined image.</li> <li>The hps_path parameter is unused, and may be removed in the future.</li> <li>The app_image_hps_path parameter contains the HPS FSBL hex file to be used for the application imge section of the combined image.</li> <li>When using HPS first, the additional parameter \"-o hps=1\" needs to be added, and the following files are created combined_application.hps.rpd (combined application image)  and combined_application.core.rbf (corresponding fabric configuration file).</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system. </p> <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b walnascar https://git.yoctoproject.org/poky\ngit clone -b walnascar https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b walnascar https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"stratix10\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf zlib-1.3.1\nwget http://zlib.net/zlib-1.3.1.tar.gz\ntar xf zlib-1.3.1.tar.gz\nrm zlib-1.3.1.tar.gz\ncd zlib-1.3.1/\nexport CROSS_PREFIX=${CROSS_COMPILE}\n./configure\nmake\nexport ZLIB_PATH=`pwd`\ncd ..\n</code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.2.11/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.2.11/libz.so - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application.</p> <pre><code>cd $TOP_FOLDER rm -rf intel-rsu\ngit clone https://github.com/altera-fpga/intel-rsu\ncd intel-rsu\n# checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/master\ncd lib\n# add -I$(ZLIB_PATH) to CFLAGS \nsed -i 's/\\(CFLAGS := .*\\)$/\\1 -I\\$\\(ZLIB_PATH\\)/g' makefile\nmake\ncd ..\ncd example\n# add -L$(ZLIB_PATH) to LDFLAGS \nsed -i 's/\\(LDFLAGS := .*\\)$/\\1 -L\\$\\(ZLIB_PATH\\)/g' makefile\nmake\ncd ..\ncd ..\n</code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/intel-rsu/lib/librsu.so - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/intel-rsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/intel-rsu/example/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example. </p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2021.04/gsrd/\\ \ntools/make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n# prepare the fat contents\nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents \nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/\\\ncore-image-minimal-stratix10.rootfs.tar.gz\nsudo sed -i 's/stratix10/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\nsudo cp $TOP_FOLDER/intel-rsu/example/rsu_client home/root/\nsudo cp $TOP_FOLDER/intel-rsu/lib/librsu.so lib/\nsudo cp $TOP_FOLDER/intel-rsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\ncd ..\n# create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as. </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card.</p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Stratix 10 SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Stratix 10 SoC Development Kit as follows, to have MSEL set to JTAG:</p> <p>- SW1: 1:OFF, rest:ON    - SW2: 1:ON 2:ON 3: ON 4:N/A (SW2.4 is is not connected)    - SW3: all OFF    - SW4: 1:ON 2:OFF 3:OFF 4:ON </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer. </p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\" </code></pre> </li> <li> <p>Configure the Stratix 10 SoC Development Kit tas follows, to have MSEL set to QSPI.</p> <p>- SW2: 1:ON 2:OFF 3:OFF 4: OFF </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Stratix 10 SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <ol> <li> <p>Power cycle the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2025.04-35102-g135e53726d-dirty (Jan 28 2025 - 13:23:54 -0600)\nReset state: Cold\nMPU         1200000 kHz\nL3 main     400000 kHz\nMain VCO    2400000 kHz\nPer VCO     2000000 kHz\nEOSC1       25000 kHz\nHPS MMC     50000 kHz\nUART        100000 kHz\nDDR: 4096 MiB\nSDRAM-ECC: Initialized success with 986 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nNOTICE:  BL31: v2.12.1(release): QPDS25.1.1_REL_GSRD_PR\nNOTICE:  BL31: Built : 13:23:25, Jan 28 2025\nU-Boot 2025.04-35102-g135e53726d-dirty (Jan 28 2025 - 13:23:54 -0600)socfpga_stratix10\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Stratix 10 SoCDK\nDRAM:  2 GiB (effective 4 GiB)\nCore:  26 devices, 21 uclasses, devicetree: separate\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:   Warning: ethernet@ff800000 (eth0) using random MAC address - 66:b9:e3:95:2d:82\neth0: ethernet@ff800000\nHit any key to stop autoboot:  0 SOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options.</p> <pre><code>SOCFPGA # rsu \nrsu - Stratix 10 SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name &lt;name&gt; - find slot by name and display the slot number slot_count - display the slot count slot_disable &lt;slot&gt; - remove slot from CPB slot_enable &lt;slot&gt; - make slot the highest priority slot_erase &lt;slot&gt; - erase slot slot_get_info &lt;slot&gt; - display slot information slot_load &lt;slot&gt; - load slot immediately slot_load_factory - load factory immediately slot_priority &lt;slot&gt; - display slot priority slot_program_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program buffer into slot, and make it highest priority slot_program_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program raw buffer into slot slot_program_factory_update_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program factory update buffer into slot, and make it highest priority slot_rename &lt;slot&gt; &lt;name&gt; - rename slot slot_delete &lt;slot&gt; - delete slot slot_create &lt;name&gt; &lt;address&gt; &lt;size&gt; - create slot slot_size &lt;slot&gt; - display slot size slot_verify_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against buffer slot_verify_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against raw buffer status_log - display RSU status update &lt;flash_offset&gt; - Initiate firmware to load bitstream as specified byflash_offset notify &lt;value&gt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt &lt;address&gt; - restore SPT from an address save_spt &lt;address&gt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb &lt;address&gt; - restore CPB from an address save_cpb &lt;address&gt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status.</p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 LastFail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\n</code></pre> </li> <li> <p>Display information about the slots:      <pre><code>SOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 16777216. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 16777216. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 16777216. </code></pre></p> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n3358720 bytes read in 153 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000002000000 size=3358720. </code></pre> </li> <li> <p>Verify that the application image was written correctly: </p> <pre><code>SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000002000000 size=3358720. </code></pre> </li> <li> <p>Confirm that slot 1 (partition P2) contains now the highest priority image:      <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre></p> </li> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands.</p> <pre><code>SOCFPGA # rsu update 0x01000000 \nRSU: RSU update to 0x0000000001000000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log      to confirm it:      <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre></p> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following.</p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code>SOCFPGA # mw.l 0xffd00204 0 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value.</p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf0061234 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it.</p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nCPBs are GOOD!!! Slot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n3485696 bytes read in 158 ms (21 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nCPBs are GOOD!!! Slot 2 was programmed with buffer=0x0000000002000000 size=3485696. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=3485696. </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB:      <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre></p> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2.</p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x02000000 0x10000 \nSF: 16384 bytes @ 0x2000000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status.</p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 256KB).</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB,     total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x80000 0x10000 \nSF: 4096 bytes @ 0x80000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x10000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 2 \nNAME P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB,    total 256 MiB SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d00f Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs.</p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image : 0x01000000 Last Fail Image : 0x00100000 State : 0xf004d010 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted Current Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d011 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected.</p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <pre><code>SOCFPGA # rsu clear_error_status \n</code></pre> <p>Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds.</p> <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status: </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes.</p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF Bad SPT0 magic number 0xFFFFFFFF no valid SPT0 and SPT1 found Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails.</p> <pre><code>SOCFPGA # rsu slot_count \ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#using-the-combined-application-image","title":"Using the Combined Application Image","text":"<p>This section shows an example of using a combined application image, from U-Boot. Similar commands can be used from Linux.</p> <p>The combined application images are used the exact same way as regular application images, just that they first update the decision firmware and decision firmware data if necessary, before the device is configured with the functionality from the application SOF.</p> <p>Note: The combined application images do not have absolute pointers inside like the regular application images, the factory update images, or the decision firmware update images. Because of this, they can be written to flash with any of the U-Boot and LibRSU APIs that write to slots.</p> <ol> <li> <p>Program the RSU initial image created with the previous version ($TOP_FOLDER/initial_image_prev.jic).</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_prev.jic\"\n</code></pre> </li> <li> <p>Power cyle the board, stop to U-Boot prompt and query the decision firmware information from U-Boot, this should be a previous version.</p> <pre><code>SOCFPGA # rsu display_dcmf_version\nDCMF0 version = 25.1.0\nDCMF1 version = 25.1.0\nDCMF2 version = 25.1.0\nDCMF3 version = 25.1.0\n</code></pre> </li> <li> <p>Find an unused slot (slot 1, P2), erase it, write the combined application image to it, verify that it was programmed successfully  and check it is now the highest priority.</p> <pre><code>SOCFPGA # rsu slot_erase 1\nSlot 1 erased.\nSOCFPGA # fatload mmc 0:1 ${loadaddr} combined_application.rpd\n151552 bytes read in 9 ms (16.1 MiB/s)\nSOCFPGA # rsu slot_program_buf 1 ${loadaddr} ${filesize}\nSlot 1 was programmed with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_verify_buf 1 ${loadaddr} ${filesize}\nSlot 1 was verified with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_get_info 1\nNAME: P2\nOFFSET: 0x0000000002000000\nSIZE: 0x01000000\nPRIORITY: 1\n</code></pre> </li> <li> <p>Pass control to the combined application update image.</p> <pre><code>SOCFPGA # rsu slot_load 1\n</code></pre> </li> <li> <p>The combined application image checks the currently used decision firmware copy, it sees that it is older, then it updates the decision firmware and decision firmware data, then it loads the actual application image section. Everything takes a few seconds.</p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware is updated, and the application image is running fine.</p> <pre><code>SOCFPGA # rsu status_log\nCurrent Image : 0x02000000\nLast Fail Image : 0x00000000\nState : 0x00000000\nVersion : 0x00000202\nError location : 0x00000000\nError details : 0x00000000\nRetry counter : 0x00000000\nSOCFPGA # rsu display_dcmf_version\nDCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\n</code></pre> </li> <li> <p>Power cycle the board, the same combined application image is loaded, as it is the highest priority. But it takes a couple of seconds less, as the decision firmware does not need to be updated.</p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <ol> <li> <p>Power cycle the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message.</p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 25.1.1\nDCMF1 version = 25.1.1\nDCMF2 version = 25.1.1\nDCMF3 version = 25.1.1\nOperation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status. It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following.</p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power cycle the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report. </p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux. </p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number.</p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power cycle the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power cycle the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.   - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB.</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot. </p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes.</p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is requried to have the status availabe in Linux. </p> <ol> <li> <p>Power cycle the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x80000 0x10000 \nSF: 4096 bytes @ 0x80000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed rootlinux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requries a valid CPB - verify it is not rejected. </p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Ther are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash. </p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin \nOperation completed \nroot@linux:~# sync \n</code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.    Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails.</p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5, Agilex\u2122 3 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p> <p>Note:  Agilex\u2122 3 HPS Remote System Update User Guide will be released soon.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.   </p>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/","title":"Secure Boot Tutorial Example Design User Guide","text":""},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#introduction","title":"Introduction","text":"<p>The secure boot demo design demonstrates an end-to-end authenticated boot flow, from device power on until the Linux kernel is loaded. There are two main components of this design - the Secure Device Manager (SDM) which authenticates the configuration bitstream, and U-boot with the Verified Boot feature. This design is demonstrated on the  Intel Stratix\u00ae 10 H-Tile SoC FPGA Development Kit (DK-SOC-1SSX-H-D)  but can be easily ported to other boards as well. </p> <p>This demo design requires: </p> <ul> <li>QKY file to program virtual key for SDM authentication </li> <li>Signed RBF file (configuration bitstream) that consists of Intel Stratix 10 GHRD and U-boot FSBL </li> <li>U-boot FSBL and SSBL with Verified Boot features </li> <li>Linux LTSI </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#overview","title":"Overview","text":"<p>The main purpose of a secure boot system is to ensure that the software running in the Hard Processor System (HPS) is trusted. Upon power-up, a trusted first stage of the boot will be executed - subsequent stages are only loaded and executed if it is authenticated by the current boot stage. In the Intel Stratix\u00ae 10 SoC  device, the Secure Device Manager (SDM) is the entry point for all configuration and booting scenarios. As such, the SDM is the root of trust and will be authenticating the configuration bitstream before any HPS software is loaded. </p> <p>Note: In this demo design, only the authentication feature of the SDM is being demonstrated. The SDM supports other security features such as bitstream encryption, Physically Unclonable Function (PUF), and many more. For more information regarding the SDM or Intel Stratix\u00ae 10 security features, refer to the Intel Stratix 10 Device Security User Guide. </p> <p>A detailed diagram of the authenticated boot flow is shown below: </p> <p> </p> <p>Detailed explanation of each Boot Stage </p> <ol> <li>Power on reset</li> </ol> <ul> <li>Upon power up, the SDM will read the security state of the eFuses and obtain the configuration bitstream from the boot source (as determined by the MSEL pins). By default, all SDM firmware authentication is enforced when user creates the configuration bitstream in Intel Quartus Prime Pro. </li> </ul> <ol> <li>SDM</li> </ol> <ul> <li>On top of the SDM firmware authentication, the user can enable the owner authentication feature to increase the security state of the device. </li> <li>SDM will then check and ensure that the hash of the public root key used to sign the bitstream matches the value stored in the virtual keys or eFuses (indicated by the red key and lock symbol). For this design example, virtual keys are used (provided via JTAG) </li> <li>If authentication is successful, SDM will configure the device, copies the U-boot FSBL to the HPS on-chip RAM and release the HPS from reset. </li> </ul> <ol> <li>U-boot FSBL </li> </ol> <ul> <li>Once U-boot FSBL is loaded and running, it will retrieve the U-boot SSBL from the HPS Flash Storage (in this example, the HPS SD card is used). Alternatively user have the option to store the U-boot SSBL in the SDM Flash. </li> <li>The U-boot SSBL image contains a hash signature that is created when the user hash and sign the image with private key (indicated by the blue lock). </li> <li>Using the public key information in its DTB (indicated by the blue key), U-boot FSBL will hash the image and ensures that the hash signature matches. </li> <li>If authentication is successful, the U-boot FSBL will load and hand over the control to SSBL. </li> </ul> <ol> <li>U-Boot SSBL</li> </ol> <ul> <li>U-boot SSBL will load the Flat Image Tree (FIT) Image file from HPS Flash Storage (in this example, the HPS SD Card is used). </li> </ul> <ul> <li>The FIT image contains a signature that is created when the user hashes and signs the image with a private key (indicated by the green lock). </li> </ul> <ul> <li>Similarly, using the public key information in its DTB (indicated by the green key), U-boot SSBL will hash the image and ensure that the signature matches. </li> </ul> <ul> <li>If authentication is successful U-boot SSBL will load and hand over the control to kernel. </li> </ul> <ol> <li>Operating System</li> </ol> <ul> <li>Once Linux is loaded, the secure boot process is complete </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#environment-setup","title":"Environment Setup","text":"<ol> <li>Create the main directory of the design: </li> </ol> <pre><code>cd ~ mkdir S10_Secure &amp;&amp; cd S10_Secure &amp;&amp; export TOP_DIR=$(pwd) </code></pre> <ol> <li>Download and extract the Linaro toolchain. Then, configure your environment to access the Linaro cross compiler: </li> </ol> <pre><code>cd $TOP_DIR wget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz tar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz rm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz export PATH=$TOP_DIR/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH export ARCH=arm64 export CROSS_COMPILE=aarch64-none-linux-gnu- </code></pre> <ol> <li>Enable Quartus tools to be called from command line:</li> </ol> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#building-the-system-image","title":"Building the System Image","text":""},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#build-arm-trusted-firmware","title":"Build Arm Trusted Firmware","text":"<pre><code>cd $TOP_DIR git clone https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware git checkout -b socfpga_v2.8.1_vab origin/socfpga_v2.8.1 make realclean make bl31 CROSS_COMPILE=aarch64-none-linux-gnu- PLAT=stratix10 DEPRECATED=1 HANDLE_EA_EL3_FIRST=1 cd .. </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#build-u-boot","title":"Build U-Boot","text":"<pre><code>cd $TOP_DIR git clone https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga/ git checkout -b test -t origin/socfpga_v2023.07 ln $TOP_DIR/arm-trusted-firmware/build/stratix10/release/bl31.bin . cat &lt;&lt; EOF &gt; config-fragment-stratix10 \n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"setenv bootargs 'earlycon panic=-1 root=/dev/mmcblk0p2 rw rootwait'; load mmc 0:1 $loadaddr signed_bitstream_core.rbf; fpga load 0 $loadaddr $filesize; bridge enable; load mmc 0:1 0x10000000 kernel-sign.fit; bootm 0x10000000\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_CMD_PART=y \n# Some Security features for U-boot \nCONFIG_FIT_ENABLE_SHA256_SUPPORT=y \nCONFIG_FIT_SIGNATURE=y \nCONFIG_FIT_VERBOSE=y \nCONFIG_CMD_CACHE=y \nCONFIG_CMD_DHCP=y \nCONFIG_ENV_IS_NOWHERE=n \nCONFIG_ENV_IS_MMC=y \nCONFIG_SPL_SHA256_SUPPORT=y \nCONFIG_SPL_CRYPTO_SUPPORT=y \nCONFIG_SPL_HASH_SUPPORT=y \nCONFIG_RSA=y \nCONFIG_SPL_RSA=y \nCONFIG_SHA256=y \nEOF make clean &amp;&amp; make mrproper make socfpga_stratix10_defconfig ./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-stratix10 make -j 24 </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#build-linux-kernel","title":"Build Linux Kernel","text":"<pre><code>cd $TOP_DIR git clone https://github.com/altera-opensource/linux-socfpga cd linux-socfpga git checkout -b test-kernel -t origin/socfpga-6.1.55-lts make clean &amp;&amp; make mrproper make defconfig make -j 64 Image dtbs </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#generate-signature-chains","title":"Generate Signature Chains","text":"<pre><code>cd $TOP_DIR mkdir -p privatekeys &amp;&amp; mkdir -p publickeys &amp;&amp; mkdir -p qky ~/intelFPGA_pro/23.4/nios2eds/nios2_command_shell.sh quartus_sign --family=stratix10 --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/root0.pem quartus_sign --family=stratix10 --operation=make_public_pem privatekeys/root0.pem publickeys/root0_public.pem quartus_sign --family=stratix10 --operation=make_root publickeys/root0_public.pem qky/root0.qky quartus_sign --family=stratix10 --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/sign0.pem quartus_sign --family=stratix10 --operation=make_public_pem privatekeys/sign0.pem publickeys/sign0_public.pem quartus_sign --family=stratix10 --operation=make_private_pem --curve=secp384r1 --no_passphrase privatekeys/software0.pem quartus_sign --family=stratix10 --operation=make_public_pem privatekeys/software0.pem publickeys/software0_public.pem quartus_sign --family=stratix10 --operation=append_key --previous_pem=privatekeys/root0.pem --previous_qky=qky/root0.qky --permission=6 --cancel=0 --input_pem=publickeys/sign0_public.pem qky/sign0_cancel1.qky </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#build-the-hardware-design","title":"Build the Hardware Design","text":""},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#build-the-ghrd","title":"Build the GHRD","text":"<pre><code>cd $TOP_DIR git clone -b QPDS23.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/s10_soc_devkit_ghrd . rm -rf ghrd-socfpga cd s10_soc_devkit_ghrd export QUARTUS_DEVICE=1SX280HU2F50E1VGAS make scrub_clean_all make generate_from_tcl make all </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#enable-security-features-authentication","title":"Enable Security Features: Authentication","text":"<p>For the FPGA configuration bitstream to be properly signed, enable the Quartus key File in the Quartus Project. </p> <ul> <li>Open the GHRD project in Quartus. </li> <li>From the Assignments Menu, navigate to Device &gt; Device and Pin Options &gt; Security. Under the Quartus key file, browse and select qky/sign0_cancel1.qky. </li> <li>Alternatively, you can add the following assignment to the .qsf file: \"set_global_assignment -name QKY_FILE \" </li> </ul> <p>Regenerate the sof by running the Assembler. </p> <ul> <li>From the Processing menu, select Compilation Dashboard. In the Compilation Dashboard, select Assembler to regenerate the sof. </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#generate-and-sign-fpga-and-hps-rbf-files","title":"Generate and Sign FPGA and HPS RBF Files","text":"<pre><code>cd $TOP_DIR mkdir bitstreams cd $TOP_DIR/s10_soc_devkit_ghrd/output_files quartus_pfg -c ghrd_1sx280hu2f50e1vgas.sof ghrd.rbf -o hps_path=$TOP_DIR/u-boot-socfpga/spl/u-boot-spl-dtb.hex -o hps=1 -o sign_later=ON quartus_sign --family=stratix10 --operation=sign --qky=../../qky/sign0_cancel1.qky --pem=../../privatekeys/sign0.pem ghrd.core.rbf ../../bitstreams/signed_bitstream_core.rbf quartus_sign --family=stratix10 --operation=sign --qky=../../qky/sign0_cancel1.qky --pem=../../privatekeys/sign0.pem ghrd.hps.rbf ../../bitstreams/signed_bitstream_hps.rbf </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#prepare-the-signed-images","title":"Prepare the Signed Images","text":""},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#create-the-u-boot-and-linux-keypair-files","title":"Create the U-Boot and Linux Keypair Files","text":"<p>Create the keypair used for U-Boot verification: </p> <pre><code>cd $TOP_DIR mkdir uboot-key &amp;&amp; cd uboot-key openssl genrsa -F4 -out uboot.key 4096 openssl req -batch -new -x509 -key uboot.key -out uboot.crt </code></pre> <p>Create the keypair used for Linux and DTB verification: </p> <pre><code>cd $TOP_DIR mkdir linux-key &amp;&amp; cd linux-key openssl genrsa -F4 -out linux.key 4096 openssl req -batch -new -x509 -key linux.key -out linux.crt </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#sign-linux-kernel-and-dtb-files","title":"Sign Linux kernel and DTB Files","text":"<p>Create the kernel-sign.its file using the following commands: </p> <pre><code>cd $TOP_DIR/u-boot-socfpga/ cat &lt;&lt;EOF &gt; kernel-sign.its \n/dts-v1/;\n/ {\n    description = \"Linux kernel image with FDT blob\";\n    #address-cells = &lt;1&gt;;\n    images {\n        kernel {\n            description = \"Linux Kernel\";\n            data = /incbin/(\"Image\");\n            type = \"kernel\";\n            arch = \"arm64\";\n            os = \"linux\";\n            compression = \"none\";\n            load = &lt;0x6000000&gt;;\n            entry = &lt;0x6000000&gt;;\n            hash {\n                algo = \"sha256\";\n            };\n        };\n        fdt {\n            description = \"Linux DTB\";\n            data = /incbin/(\"socfpga_stratix10_socdk.dtb\");\n            type = \"flat_dt\";\n            arch = \"arm64\";\n            compression = \"none\";\n            hash {\n                algo = \"sha256\";\n            };\n        };\n    };\n    configurations {\n        default = \"conf\";\n        conf {\n            description = \"Linux boot configuration\";\n            kernel = \"kernel\";\n            fdt = \"fdt\";\n            signature {\n                algo = \"sha256,rsa4096\";\n                key-name-hint = \"linux\";\n                sign-images = \"fdt\", \"kernel\";\n            };\n        };\n    };\n}; \nEOF\n</code></pre> <p>Copy the Linux Image and DTB files from Linux Build: </p> <pre><code>cp $TOP_DIR/linux-socfpga/arch/arm64/boot/Image . cp $TOP_DIR/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb . </code></pre> <p>Build U-Boot to include the key information for Linux and DTB signatures. The generated file is the kernel-sign.fit has the kernel image and the dtb file that will be used for Linux boot. </p> <pre><code>tools/mkimage -k /home/fawaz/hps/S10_Secure/linux_key/ -K socfpga_stratix10_socdk.dtb -f kernel-sign.its -r kernel-sign.fit make </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#sign-u-boot-file","title":"Sign U-Boot File","text":"<p>Create the uboot-sign.its file using the following commands:\ufeff </p> <pre><code>cd $TOP_DIR/u-boot-socfpga/ cat &lt;&lt;EOF &gt; uboot-sign.its \n/dts-v1/;\n/ {\n        description = \"Authenticator\";\n        #address-cells = &lt;1&gt;;\n        images {\n                standalone {\n                        description = \"Authenticator binary\";\n                        data = /incbin/(\"u-boot-dtb.bin\");\n                        type = \"standalone\";\n                        arch = \"arm64\";\n                        compression = \"none\";\n                        load = &lt;0x00200000&gt;;\n                        entry = &lt;0x00200000&gt;;\n                        os = \"u-boot\";\n                        hash {\n                                algo = \"sha256\";\n                        };\n                };\n                atf {\n                        description = \"ARM Trusted Firmware\";\n                        data = /incbin/(\"bl31.bin\");\n                        type = \"firmware\";\n                        os = \"arm-trusted-firmware\";\n                        arch = \"arm64\";\n                        compression = \"none\";\n                        load = &lt;0x00001000&gt;;\n                        entry = &lt;0x00001000&gt;;\n                        hash {\n                                algo = \"sha256\";\n                        };\n                };\n        };\n        configurations {\n                default = \"conf\";\n                conf {\n                        description = \"Authenticator fitImage\";\n                        firmware = \"atf\";\n                        loadables = \"standalone\";\n                        signature {\n                                algo = \"sha256,rsa4096\";\n                                key-name-hint = \"uboot\";\n                                sign-images = \"firmware\", \"loadables\";\n                        };\n                };\n        };\n};\nEOF\n</code></pre> <p>Build U-Boot to include the key information for FSBL and U-Boot DTB signatures. The generated file is the uboot-sign.fit must be renamed to u-boot.itb after generating it. </p> <pre><code>tools/mkimage -k $TOP_DIR/uboot-key/ -K spl/u-boot-spl.dtb -f uboot-sign.its -r u-boot-sign.fit make </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#create-rootfs","title":"Create Rootfs","text":"<pre><code>cd $TOP_DIR mkdir yocto &amp;&amp; cd yocto git clone -b nanbield https://git.yoctoproject.org/poky git clone -b nanbield https://git.yoctoproject.org/meta-intel-fpga git clone -b nanbield https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"stratix10\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver devmem2\"' &gt;&gt; conf/local.conf bitbake core-image-minimal </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#create-sd-card-image","title":"Create SD Card Image","text":"<p>Create the required directories and download the python script to create the sdcard image: </p> <pre><code>cd $TOP_DIR mkdir sdcard &amp;&amp; cd sdcard mkdir sdfs rootfs wget https://releases.rocketboards.org/2020.11/gsrd/tools/make_sdimage_p3.py chmod +x make_sdimage_p3.py </code></pre> <p>Copy the kernel, dtb, uboot, and core rbf files: </p> <pre><code>cd sdfs cp $TOP_DIR/u-boot-socfpga/kernel-sign.fit . cp $TOP_DIR/u-boot-socfpga/u-boot-sign.fit u-boot.itb cp $TOP_DIR/bitstreams/signed_bitstream_core.rbf . </code></pre> <p>Extract the generated rootfs: </p> <pre><code>cd ../rootfs sudo tar xf $TOP_DIR/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz cd .. </code></pre> <p>Run the python script to generate the sdcard image file: </p> <pre><code>sudo python3 make_sdimage_p3.py -f \\ \n-P sdfs/*,num=1,format=fat,size=70M \\ \n-P rootfs/*,num=2,format=ext3,size=400M \\ \n-s 512M \\ \n-n s10_secure_boot.img </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/security/secure-boot/hps-first/ug-secure-boot-hps-first-s10sx-soc/#run-the-design-on-stratix-10-soc-development-kit","title":"Run the Design on Stratix\u00ae 10 SoC Development Kit","text":"<p>Once the sdcard image file is written to the sdcard, mount it to the board, and make sure to set the MSEL to JTAG configuration MSEL[1111]. </p> <p>Next, connect your board to the HPS UART and JTAG connection, then power-up. After that, download the quartus key and hps rbf files using the following commands: </p> <pre><code>cd $TOP_DIR quartus_pgm -c 1 -m jtag -o \"pi;qky/root0.qky\" quartus_pgm -c 1 -m jtag -o \"p;bitstreams/signed_bitstream_hps.rbf\" </code></pre> <p>You should see your HPS UART terminal showing the SPL boot message as below. The messages in the red color indicate the authentication of U-Boot and ATF. The messages in blue color indicate the authenticated FPGA core configuration. Finally, the green color messages indicate the authentication of Linux kernel and DTB. </p> <pre><code>U-Boot SPL 2023.07-rc6-30089-gdab86d36f1-dirty (Jan 08 2024 - 21:06:00 -0600) Reset state: Cold MPU 1200000 kHz L3 main 400000 kHz Main VCO 2400000 kHz Per VCO 2000000 kHz EOSC1 25000 kHz HPS MMC 50000 kHz UART 100000 kHz DDR: 4096 MiB SDRAM-ECC: Initialized success with 987 ms QSPI: Reference clock at 400000 kHz WDT: Started watchdog@ffd00200 with servicing every 1000ms (10s timeout) denali-nand-dt nand@ffb90000: timeout while waiting for irq 0x2000 denali-nand-dt nand@ffb90000: reset not completed. Trying to boot from MMC1 ## Checking hash(es) for config conf ... sha256,rsa4096:uboot+ OK \n## Checking hash(es) for Image atf ... sha256+ OK \n## Checking hash(es) for Image standalone ... sha256+ OK \nNOTICE: BL31: bl31_setup NOTICE: BL31: bl31_plat_arch_setup NOTICE: BL31: v2.8.1(release):QPDS23.2_REL_GSRD_PR NOTICE: BL31: Built : 14:09:49, Dec 8 2023 U-Boot 2023.07-rc6-30089-gdab86d36f1-dirty (Jan 08 2024 - 21:05:44 -0600)socfpga_stratix10 CPU: Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53) Model: SoCFPGA Stratix 10 SoCDK DRAM: 2 GiB (effective 4 GiB) Core: 27 devices, 22 uclasses, devicetree: separate Warning: Device tree includes old 'u-boot,dm-' tags: please fix by 2023.07! WDT: Started watchdog@ffd00200 with servicing every 1000ms (10s timeout) NAND: denali-nand-dt nand@ffb90000: timeout while waiting for irq 0x2000 denali-nand-dt nand@ffb90000: reset not completed. Failed to initialize Denali NAND controller. (error -5) 0 MiB MMC: dwmmc0@ff808000: 0 Loading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1... Loading Environment from UBI... denali-nand-dt nand@ffb90000: timeout while waiting for irq 0x2000 denali-nand-dt nand@ffb90000: reset not completed. SF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB Could not find a valid device for ffb90000.nand.0 Volume env not found! \\** Unable to read env from root:env \\** In: serial0@ffc02000 Out: serial0@ffc02000 Err: serial0@ffc02000 Net: Warning: ethernet@ff800000 (eth0) using random MAC address - 7a:88:78:08:67:59 eth0: ethernet@ff800000 Hit any key to stop autoboot: 0 3788800 bytes read in 177 ms (20.4 MiB/s) ....FPGA reconfiguration OK! 38844038 bytes read in 1789 ms (20.7 MiB/s) ## Loading kernel from FIT Image at 10000000 ... \nUsing 'conf' configuration Verifying Hash Integrity ... sha256,rsa4096:linux+ OK Trying 'kernel' kernel subimage Description: Linux Kernel Type: Kernel Image Compression: uncompressed Data Start: 0x100000d0 Data Size: 38822400 Bytes = 37 MiB Architecture: AArch64 OS: Linux Load Address: 0x06000000 Entry Point: 0x06000000 Hash algo: sha256 Hash value: 5a01fea3cdb4c53108c907cecb5176a1f6d298b1621e1da2d2c64536c08681fa Verifying Hash Integrity ... sha256+ OK ## Loading fdt from FIT Image at 10000000 ... \nUsing 'conf' configuration Verifying Hash Integrity ... sha256,rsa4096:linux+ OK Trying 'fdt' fdt subimage Description: Linux DTB Type: Flat Device Tree Compression: uncompressed Data Start: 0x125063c0 Data Size: 18744 Bytes = 18.3 KiB Architecture: AArch64 Hash algo: sha256 Hash value: 3f864bacd52ca036f866b2ebab5048d717260b82b197c535bfafa8ba9a933b2d Verifying Hash Integrity ... sha256+ OK Booting using the fdt blob at 0x125063c0 Working FDT set to 125063c0 Loading Kernel Image Loading Device Tree to 000000007eace000, end 000000007ead5937 ... OK ....... </code></pre>"},{"location":"host-attach-util/fpgaconf/fpgaconf/","title":"fpgaconf","text":""},{"location":"host-attach-util/fpgaconf/fpgaconf/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgaconf [-hvVn] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] &lt;gbs&gt;</code></p>"},{"location":"host-attach-util/fpgaconf/fpgaconf/#description","title":"DESCRIPTION","text":"<p><code>fpgaconf</code> configures the FPGA with the accelerator function (AF). It also checks the AF for compatibility with  the targeted FPGA and the FPGA Interface Manager (FIM). <code>fpgaconf</code> takes the following arguments: </p> <p><code>-h, --help</code></p> <pre><code>Prints usage information.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-V, --verbose</code></p> <pre><code>Prints more verbose messages while enumerating and configuring. Can be\nrequested more than once.\n</code></pre> <p><code>-n, --dry-run</code></p> <pre><code>Performs enumeration. Skips any operations with side-effects such as the\nactual AF configuration.\n</code></pre> <p><code>-S, --segment</code></p> <pre><code>PCIe segment number of the target FPGA.\n</code></pre> <p><code>-B, --bus</code></p> <pre><code>PCIe bus number of the target FPGA.\n</code></pre> <p><code>-D, --device</code></p> <pre><code>PCIe device number of the target FPGA.\n</code></pre> <p><code>-F, --function</code></p> <pre><code>PCIe function number of the target FPGA.\n</code></pre> <p><code>--force</code></p> <pre><code>Reconfigure the AFU even if it is in use.\n</code></pre> <p><code>fpgaconf</code> enumerates available FPGA devices in the system and selects compatible FPGAs for configuration. If more than one FPGA is compatible with the AF, <code>fpgaconf</code> exits and asks you to be more specific in selecting the target FPGAs by specifying a a PCIe BDF.</p>"},{"location":"host-attach-util/fpgaconf/fpgaconf/#examples","title":"EXAMPLES","text":"<p><code>fpgaconf my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to a compatible FPGA.\n</code></pre> <p><code>fpgaconf -V -B 0x3b my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA in bus 0x3b, if compatible,\nwhile printing out slightly more verbose information.\n</code></pre> <p><code>fpgaconf 0000:3b:00.0 my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA at address 0000:3b:00.0.\n</code></pre>"},{"location":"host-attach-util/fpgad/fpgad/","title":"fpgad","text":""},{"location":"host-attach-util/fpgad/fpgad/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgad --daemon [--version] [--directory=&lt;dir&gt;] [--logfile=&lt;file&gt;] [--pidfile=&lt;file&gt;] [--umask=&lt;mode&gt;] [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code> <code>fpgad [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code></p>"},{"location":"host-attach-util/fpgad/fpgad/#description","title":"DESCRIPTION","text":"<p>fpgad monitors the device sensors, checking for sensor values that are out of the prescribed range. </p> <p>When any of the sensors is detected to be out of bounds, fpgad will focus on keeping the server from rebooting by masking PCIE AER, and send a message to system administrator. System administrator can take further actions like stop the application and stop the FPGA, but fpgad just focus on monitor the sensors and will not take any cooling actions. </p> <p>Note: fpgad must be running (as root) and actively monitoring devices when a sensor anomaly occurs in order to initiate Graceful Shutdown.  If fpgad is not loaded during such a sensor anomaly, the out-of-bounds scenario will not be detected, and the resulting effect on the hardware is undefined.</p>"},{"location":"host-attach-util/fpgad/fpgad/#arguments","title":"ARGUMENTS","text":"<p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-d, --daemon</code></p> <pre><code>When specified, fpgad executes as a system daemon process.\n</code></pre> <p><code>-D, --directory &lt;dir&gt;</code></p> <pre><code>When running in daemon mode, run from the specified directory.\nIf omitted when daemonizing, `fpgad` uses /tmp.\n</code></pre> <p><code>-l, --logfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, send output to file. When not in daemon mode, the output goes to stdout.\nIf omitted when daemonizaing, fpgad uses /tmp/fpgad.log.\n</code></pre> <p><code>-p, --pidfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, write the daemon's process id to a file.\nIf omitted when daemonizing, fpgad uses /tmp/fpgad.pid.\n</code></pre> <p><code>-m, --umask &lt;mode&gt;</code></p> <pre><code>When running in daemon mode, use the mode value as the file mode creation mask passed to umask.\nIf omitted when daemonizing, fpgad uses 0.\n</code></pre> <p><code>-s, --socket &lt;sock&gt;</code></p> <pre><code>Listen for event API registration requests on the UNIX domain socket on the specified path. \nThe default=/tmp/fpga_event_socket.\n</code></pre> <p><code>-n, --null-bitstream &lt;file&gt;</code></p> <pre><code>Specify the NULL bitstream to program when an AP6 event occurs. This option may be specified multiple\ntimes. The AF, if any, that matches the FPGA's PR interface ID is programmed when an AP6\nevent occurs.\n</code></pre>"},{"location":"host-attach-util/fpgad/fpgad/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>If you encounter any issues, you can get debug information in two ways:</p> <ol> <li>By examining the log file when in daemon mode.</li> <li>By running in non-daemon mode and viewing stdout.</li> </ol>"},{"location":"host-attach-util/fpgad/fpgad/#examples","title":"EXAMPLES","text":"<p><code>fpgad --daemon --null-bitstream=my_null_bits.gbs</code></p> <p>This command starts fpgad as a system daemon process: <pre><code>sudo systemctl start fpgad\n</code></pre></p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/","title":"fpgainfo","text":""},{"location":"host-attach-util/fpgainfo/fpgainfo/#synopsis","title":"SYNOPSIS","text":"<pre><code>   fpgainfo [-h] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR]\n            {errors,power,temp,fme,port,bmc,mac,phy,security}\n</code></pre>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#description","title":"DESCRIPTION","text":"<p>fpgainfo displays FPGA information derived from sysfs files. The command argument is one of the following: <code>errors</code>, <code>power</code>, <code>temp</code>, <code>port</code>, <code>fme</code>, <code>bmc</code>, <code>phy</code> or <code>mac</code>,<code>security</code>,<code>events</code>. Some commands may also have other arguments or options that control their behavior.</p> <p>For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#fpgainfo-commands","title":"FPGAINFO COMMANDS","text":"<p><code>errors</code></p> <p>Show/clear errors of an FPGA resource that the first argument specifies. <code>fpgainfo</code> displays information in human readable form.</p> <p><code>power</code></p> <p>Show total the power in watts that the FPGA hardware consumes.</p> <p><code>temp</code></p> <p>Show FPGA temperature values in degrees Celcius.</p> <p><code>port</code></p> <p>Show information about the port such as the AFU ID of currently loaded AFU.</p> <p><code>fme</code></p> <p>Show information about the FPGA platform including the partial reconfiguration (PR) Interface ID, the OPAE version, and the FPGA Interface Manager (FIM) ID.</p> <p><code>bmc</code></p> <p>Show all Board Management Controller sensor values for the FPGA resource, if available.</p> <p><code>phy</code></p> <p>Show information about the PHY integrated in the FPGA, if available.</p> <p><code>mac</code></p> <p>Show information about the MAC address in ROM attached to the FPGA, if available.</p> <p><code>security</code></p> <p>Show information about the security keys, hashs and flash count, if available.</p> <p><code>events</code></p> <p>Show information about events and sensors, if available.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p> <p><code>--version, -v</code></p> <p>Prints version information and exit.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#common-arguments","title":"COMMON ARGUMENTS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-S, --segment</code></p> <p>PCIe segment number of resource.</p> <p><code>-B, --bus</code></p> <p>PCIe bus number of resource.</p> <p><code>-D, --device</code></p> <p>PCIe device number of resource.</p> <p><code>-F, --function</code></p> <p>PCIe function number of resource.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#errors-arguments","title":"ERRORS ARGUMENTS","text":"<p>The first argument to the <code>errors</code> command specifies the resource type. It must be one of the following:    <code>fme</code>,<code>port</code>,<code>all</code></p> <p><code>fme</code></p> <p>Show/clear FME errors. </p> <p><code>port</code></p> <p>Show/clear PORT errors.</p> <p><code>all</code></p> <p>Show/clear errors for all resources.</p> <p>The optional <code>&lt;command-args&gt;</code> arguments are:</p> <p><code>--clear, -c</code></p> <p>Clear errors for the given FPGA resource.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#phy-arguments","title":"PHY ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--group, -G</code></p> <p>Select which PHY group(s) information to show.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#events-arguments","title":"EVENTS ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--list,-l</code></p> <p>List boots (implies --all).</p> <p><code>--boot,-b</code></p> <p>Boot index to use, i.e: \u00a0\u00a0\u00a0\u00a00 for current boot (default). \u00a0\u00a0\u00a0\u00a01 for previous boot, etc.</p> <p><code>--count,-c</code></p> <p>Number of events to print.</p> <p><code>--all,-a</code></p> <p>Print all events.</p> <p><code>--sensors,-s</code></p> <p>Print sensor data too.</p> <p><code>--bits,-i</code></p> <p>Print bit values too.</p> <p><code>--help,-h</code></p> <p>Print this help.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#examples","title":"EXAMPLES","text":"<p>This command shows the current power telemetry: <pre><code>./fpgainfo power\n</code></pre></p> <p>This command shows the current temperature readings: <pre><code>./fpgainfo temp\n</code></pre></p> <p>This command shows FME resource errors: <pre><code>./fpgainfo errors fme\n</code></pre> This command clears all errors on all resources: <pre><code>./fpgainfo errors all -c\n</code></pre> This command shows information of the FME on bus 0x5e <pre><code>./fpgainfo fme -B 0x5e\n</code></pre> This command shows information of the FPGA security on bus 0x5e <pre><code>./fpgainfo security -B 0x5e\n</code></pre> This command shows all events and sensors information including sensor bits: <pre><code>./fpgainfo events -asi\n</code></pre></p>"},{"location":"host-attach-util/fpgaport/fpgaport/","title":"fpgaport","text":""},{"location":"host-attach-util/fpgaport/fpgaport/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgaport [-h] [-N NUMVFS] [-X] [--debug] {assign,release} device [port]\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#description","title":"DESCRIPTION","text":"<p>The <code>fpgaport</code> enables and disables virtualization. It assigns and releases control of the port to the virtual function (VF). By default, the driver assigns the port to the physical function (PF) in the non-virtualization use case.</p>"},{"location":"host-attach-util/fpgaport/fpgaport/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{assign, release}</code></p> <pre><code>Action to perform.\n</code></pre> <p><code>device</code></p> <pre><code>The FPGA device being targeted with this action.\n</code></pre> <p><code>port</code></p> <pre><code>The number of the port.\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-N NUMVFS, --numvfs NUMVFS</code></p> <pre><code>Create NUMVFS virtual functions. The typical value is 1.\n</code></pre> <p><code>-X, --destroy-vfs</code></p> <pre><code>Destroy all virtual functions prior to assigning.\n</code></pre> <p><code>--debug</code></p> <pre><code>Display additional log information.\n</code></pre> <p><code>-h, --help</code></p> <pre><code>Print usage information.\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#example","title":"EXAMPLE","text":"<p><code>fpgaport release /dev/dfl-fme.0 0</code></p> <pre><code>Release port 0 from physical function control.\n</code></pre> <p><code>fpgaport assign /dev/dfl-fme.0 0</code></p> <pre><code>Assign port 0 to physical function control.\n</code></pre>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/","title":"fpgasupdate","text":""},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgasupdate [--log-level=&lt;level&gt;] file [bdf]</code></p>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#description","title":"DESCRIPTION","text":"<p>The <code>fpgasupdate</code> command implements a secure firmware update for the following programmable accelerator cards (PACs): * Intel\u00ae PAC with Intel Arria\u00ae 10 GX FPGA * Intel\u00ae FPGA PAC D5005 * Intel\u00ae PAC N3000 * Intel\u00ae FPGA SmartNIC N6001-PL with Intel&amp;reg Agilex&amp;reg FPGA * Intel\u00ae FPGA IPU F2000X-PL</p> <p><code>--log-level &lt;level&gt;</code></p> <pre><code>Specifies the `log-level` which is the level of information output to your command tool.\nThe following seven levels  are available: `state`, `ioctl`, `debug`, `info`, `warning`,\n`error`, `critical`. Setting `--log-level=state` provides the most verbose output.\nSetting `--log-level=ioctl` provides the second most information, and so on. The default\nlevel is `info`.\n</code></pre> <p><code>file</code></p> <pre><code>Specifies the secure update firmware file to be programmed. This file may be to program a\nstatic region (SR), programmable region (PR), root entry hash, key cancellation, or other\ndevice-specific firmware.\n</code></pre> <p><code>bdf</code></p> <pre><code>The PCIe&amp;reg; address of the PAC to program. `bdf` is of the form `[ssss:]bb:dd:f`,\ncorresponding to PCIe segment, bus, device, function. The segment is optional. If\nyou do not specify a segment, the segment defaults to `0000`. If the system has only\none PAC you can omit the `bdf` and let `fpgasupdate`  determine the address\nautomatically.\n</code></pre>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>To gather more debug output, decrease the <code>--log-level</code> parameter. </p>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#examples","title":"EXAMPLES","text":"<p><code>fpgasupdate firmware.bin</code> <code>fpgasupdate firmware.bin 05:00.0</code> <code>fpgasupdate firmware.bin 0001:04:02.0 --log-level=ioctl</code></p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/","title":"host_exerciser","text":""},{"location":"host-attach-util/host_exerciser/host_exerciser/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: host_exerciser [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=warning\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mode UINT:value in {lpbk-&gt;0,read-&gt;1,trput-&gt;3,write-&gt;2} OR {0,1,3,2}=lpbk\n                              host exerciser mode {lpbk,read, write, trput}\n  --cls UINT:value in {cl_1-&gt;0,cl_2-&gt;1,cl_4-&gt;2,cl_8-&gt;3} OR {0,1,2,3}=cl_1\n                              number of CLs per request{cl_1, cl_2, cl_4, cl_8}\n  --continuousmode BOOLEAN=false\n                              test rollover or test termination\n  --atomic UINT:value in {cas_4-&gt;9,cas_8-&gt;11,fadd_4-&gt;1,fadd_8-&gt;3,off-&gt;0,swap_4-&gt;5,swap_8-&gt;7} OR {9,11,1,3,0,5,7}=off\n                              atomic requests (only permitted in combination with lpbk/cl_1)\n  --encoding UINT:value in {default-&gt;0,dm-&gt;1,pu-&gt;2,random-&gt;3} OR {0,1,2,3}=default\n                              data mover or power user encoding -- random interleaves both in the same stream\n  -d,--delay BOOLEAN=false    Enables random delay insertion between requests\n  --interleave UINT=0         Interleave requests pattern to use in throughput mode {0, 1, 2}\n                              indicating one of the following series of read/write requests:\n                              0: rd-wr-rd-wr\n                              1: rd-rd-wr-wr\n                              2: rd-rd-rd-rd-wr-wr-wr-wr\n  --interrupt UINT:INT in [0 - 3]\n                              The Interrupt Vector Number for the device\n  --contmodetime UINT=1       Continuous mode time in seconds\n  --testall BOOLEAN=false     Run all tests\n  --clock-mhz UINT=0          Clock frequency (MHz) -- when zero, read the frequency from the AFU\nSubcommands:\n  lpbk                        run simple loopback test\n  mem                         run simple mem test\n</code></pre>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#description","title":"DESCRIPTION","text":"<p>A host exerciser is used to exercise and characterize the various host-FPGA interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-loopback-he-lb","title":"Host Exerciser Loopback (HE-LB)","text":"<p>The HE-LB module is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth.  Host Exerciser Loopback (HE-LB) AFU can move data between host memory and FPGA.</p> <p>HE-LB IP supports: 1. Latency (AFU to Host memory read) 2. MMIO latency (Write+Read) 3. MMIO BW (64B MMIO writes) 4. BW (Read/Write, Read only, Wr only)</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-memory-he-mem","title":"Host Exerciser Memory (HE-MEM)","text":"<p>The HE-MEM module is used to exercise use of FPGA connected DDR; data read from the host is  written to DDR, and the same data is read from DDR before sending it back to the  host. HE-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized version of the AVMM interface to communicate with the EMIF memory controller.</p> <p>Execution of these exercisors requires the user to bind specific VF endpoint to vfio-pci Bind the correct endpoint for a device with B/D/F 0000:b1:00.0</p> <p><code>[user@localhost]: sudo opae.io init -d 0000:b1:00.2 user:user</code></p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-sub-commands","title":"HOST EXERCISER SUB COMMANDS","text":"<p><code>lpbk</code></p> <p>run host exerciser loopback test</p> <p><code>mem</code></p> <p>run host exerciser memory test</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set host exerciser tool log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>host exerciser tool time out, by default time out 60000</p> <p><code>-m,--mode</code></p> <p>host exerciser test modes are lpbk, read, write, trput</p> <p><code>--cls</code></p> <p>Number of cachelines per request 1, 2, 3, 4.</p> <p><code>--continuousmode</code></p> <p>Configures test rollover or test termination mode.</p> <p><code>--atomic</code></p> <p>atomic requests.</p> <p><code>--encoding</code></p> <p>select data mover mode or power user mode or random.</p> <p><code>-d,--delay</code></p> <p>Enables random delay insertion between requests.</p> <p><code>--interleave</code></p> <p>Enables interleave requests in throughput mode. Value:3'b000-Rd,Wr,Rd,Wr Value:3'b001-Rd,Rd,Wr,Wr Value:3'b010-Rd,Rd,Rd,Rd,Wr,Wr,Wr,Wr Value:3'b011-Not supported</p> <p><code>--interrupt</code></p> <p>Accelerator interrupt vector Number.</p> <p><code>--contmodetime</code></p> <p>Continuous mode time in seconds.</p> <p><code>--testall</code></p> <p>Run all host exerciser tests.</p> <p><code>--clock-mhz</code></p> <p>pcie clock frequency, default value 350Mhz.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#examples","title":"EXAMPLES","text":"<p>This command exerciser Loopback afu: <pre><code>host_exerciser lpbk\n</code></pre></p> <p>This command exerciser memory afu: <pre><code>host_exerciser mem\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0: <pre><code>host_exerciser --pci-address 000:3b:00.0    lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run in write mode: <pre><code>host_exerciser --pci-address 000:3b:00.0   --mode write lpbl\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run 2 cache lines per request: <pre><code>host_exerciser --pci-address 000:3b:00.0   --cls cl_2  lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run continuous mode for 10 seconds: <pre><code>host_exerciser --pci-address 000:3b:00.0   -cls cl_1   -m 0 --continuousmode true --contmodetime 10 lpbk\n</code></pre></p>"},{"location":"host-attach-util/hssi/hssi/","title":"hssi","text":""},{"location":"host-attach-util/hssi/hssi/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi COMMON_OPTIONS MODE MODE_OPTIONS</code></p>"},{"location":"host-attach-util/hssi/hssi/#description","title":"DESCRIPTION","text":"<p>The <code>hssi</code> application provides a means of interacting with the 10G, 100G, and 200G/400F HE-HSSI AFUs. In all operating modes, the application initializes the AFU and completes the desired transfer as described by the mode- specific options.</p> <p>COMMON_OPTIONS - application options common to the 10G, 100g, and 200G/400G modes.</p> <p><code>-h, --help</code></p> <pre><code>Display common command-line help and exit.\n</code></pre> <p><code>-p, --pci-address ADDR</code></p> <pre><code>The PCIe address of the desired accelerator in ssss:bb:dd.f format.\n</code></pre> <p><code>-s, --shared on|off</code></p> <pre><code>Whether to open the accelerator in shared mode. The default is off.\n</code></pre> <p><code>-t, --timeout VALUE</code></p> <pre><code>The application timeout value in milliseconds. The default timeout is 60000 msec.\n</code></pre> <p>MODE - select AFU. Valid values are hssi_10g, hssi_100g, hssi_200g_400g.</p> <p>MODE_OPTIONS [hssi_10g] - application options specific to the 10G AFU.</p> <p><code>-h, --help</code></p> <pre><code>Display 10G AFU specific command-line help and exit.\n</code></pre> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--random-length fixed|random</code></p> <pre><code>Specify packet length randomization. Valid values are fixed and\nrandom. The default is fixed (no randomization).\n</code></pre> <p><code>--random-payload incremental|random</code></p> <pre><code>Specify payload randomization. Valid values are incremental and\nrandom. The default is incremental.\n</code></pre> <p><code>--packet-length LENGTH</code></p> <pre><code>Specify packet length. The default is 64 bytes.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--rnd-seed0 SEED0</code></p> <pre><code>Specify the prbs generator bits [31:0]. The default is 1592590336.\n</code></pre> <p><code>--rnd-seed1 SEED1</code></p> <pre><code>Specify the prbs generator bits [47:32]. The default is 1592590337.\n</code></pre> <p><code>--rnd-seed2 SEED2</code></p> <pre><code>Specify the prbs generator bits [91:64]. The default is 155373.\n</code></pre> <p>MODE_OPTIONS [hssi_100g] - application options specific to the 100G AFU.</p> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--gap random|none</code></p> <pre><code>Inter-packet gap. Valid values are random and none. The default is none.\n</code></pre> <p><code>--pattern random|fixed|increment</code></p> <pre><code>Pattern mode. Valid values are random, fixed, or increment. The default\nis random.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--start-size SIZE</code></p> <pre><code>Specify the packet size in bytes, or the first packet size for --pattern increment.\n</code></pre> <p><code>--end-size SIZE</code></p> <pre><code>Specify the end packet size in bytes.\n</code></pre> <p><code>--end-select pkt_num|gen_idle</code></p> <pre><code>Specify packet generation end mode.\n</code></pre> <p>MODE_OPTIONS [pkt_filt_10g] - application options specific to the Packet Filter 10G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.0\n</code></pre> <p>MODE_OPTIONS [pkt_filt_100g] - application options specific to the Packet Filter 100G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.1\n</code></pre> <p>MODE_OPTIONS [hssi_200g_400g] - application options specific to the 200G/400G AFU.</p> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. Must be a multiple of 32. Default value is 32. Increasing the timeout (--timeout) may be necessary if specifying a large number of packets.\n</code></pre>"},{"location":"host-attach-util/hssi/hssi/#examples","title":"EXAMPLES","text":"<p><code>hssi -h</code> <code>hssi hssi_10g -h</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_10g --eth-loopback=on --num-packets=500</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_100g --pattern=increment</code> <code>sudo hssi --pci-address=0000:0d:00.6 hssi_200g_400g --num-packets=640000</code></p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/","title":"HSSI ethernet loopback","text":""},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssiloopback [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS] --loopback [{enable,disable}]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#description","title":"DESCRIPTION","text":"<p>The <code>hssiloopback</code>  tool enables and disable ethernet loopback.</p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p> <p><code>--loopback [{enable,disable}]</code></p> <p>Ethernet enable or disable loopback.</p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#examples","title":"EXAMPLES","text":"<p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback enable</code></p> <p>Enables ethernet loopback</p> <p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback disable</code></p> <p>Disable ethernet loopback</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/","title":"HSSI ethernet mac","text":""},{"location":"host-attach-util/hssi_ethernet/hssimac/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssimac [-h] --pcie-address PCIE_ADDRESS [--port PORT]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#description","title":"DESCRIPTION","text":"<p>The <code>hssimac</code>  tool provides Maximum TX and RX frame size.</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0).</p> <p><code>--port PORT</code></p> <p>hssi port number.</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#examples","title":"EXAMPLES","text":"<p><code>hssimac --pcie-address  0000:04:00.0 --port 1</code></p> <p>prints Maximum TX and RX frame size for port 1.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/","title":"HSSI ethernet statistics","text":""},{"location":"host-attach-util/hssi_ethernet/hssistats/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssistats [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#description","title":"DESCRIPTION","text":"<p>The <code>hssistats</code>  tool provides the MAC statistics.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#examples","title":"EXAMPLES","text":"<p><code>hssistats --pcie-address  0000:04:00.0</code></p> <p>prints the MAC statistics </p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/","title":"hssi_loopback","text":""},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#name","title":"NAME","text":"<p>hssi_loopback - Software utility to run HSSI loopback tests on FPGA</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi_loopback [[--bus|-b &lt;bus number&gt;] [--device | -d &lt;device number&gt;] [--function | -f &lt;function number&gt;]]|[--socket-id &lt;socket-id&gt;]       [--mode|-m auto|e40|e10]        [send [&lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]] |status [clear] | stop | readmacs</code></p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#description","title":"DESCRIPTION","text":"<p>The <code>hssi_loopback</code> utility works in conjunction with a packet generator accelerator function unit (AFU) to test high-speed serial interface (HSSI) cards. The <code>hssi_loopback</code> utility tests both external and internal loopbacks. <code>hssi_loopback</code> runs an external loopback test when the command line arguments include both source and destination ports. <code>hssi_loopback</code> runs an internal loopback test when command line arguments include a single port. <code>hssi_loopback</code> only runs on the Intel Xeon with Arria 10 FPGA. You cannot run it on the Intel PAC (programmable accelerator card).</p> <p>NOTE: The following limitations apply to the current version of hssi_loopback:</p> <ul> <li>For the external loopback the two port arguments can be the same. For the e10 design, the ports should be the same.</li> <li>The <code>hssi_loopback</code> test supports only the e40 and e10 E2E AFUs.  The e10 E2E AFU tests HSSI with a retimer card.</li> <li>The <code>hssi_loopback</code> test uses the control and status registers (CSRs) defined in the AFU.</li> </ul>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#options","title":"OPTIONS","text":"<p><code>-S SOCKET_ID, --socket-id SOCKET_ID</code></p> <p>Socket ID FPGA resource.</p> <p><code>-B BUS, --bus BUS</code></p> <p>Bus ID of FPGA resource.</p> <p><code>-D DEVICE, --device DEVICE</code></p> <p>Device ID of FPGA resource.</p> <p><code>-F FUNCTION, --function FUNCTION</code></p> <p>Function ID of FPGA resource.</p> <p><code>-G, --guid</code></p> <p>Specifies guid for the resource enumeration.</p> <p><code>-m, --mode</code></p> <p>One of the following: [<code>auto</code>, <code>e40</code>, <code>e10</code>] <code>auto</code> is the default and indicates that the software runs the mode based on the first accelerator functional unit it identifies.</p> <p><code>-t, --timeout</code></p> <p>Timeout (in seconds) before the application terminates in continuous mode. Continuous mode is the default when you do not specify the number of packets.</p> <p><code>-y, --delay</code></p> <p>Delay (in seconds) between printing out a simple status line. Default is 0.100 seconds (100 milliseconds).</p> <p><code>-c, --packet-count</code></p> <p>The number of packets to send.</p> <p><code>-d, --packet-delay</code></p> <p>The delay in between packets. This delay is the number of 100 MHz clock cycles, roughly 10 nanoseconds.</p> <p><code>-s, --packet-size</code></p> <p>The packet size to send. The minimum is 46 bytes and the maximum is 1500 bytes. The default is 46 bytes.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#commands","title":"COMMANDS","text":"<p><code>send &lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]</code></p> <p>Send packets from one port to the other. If the command line does not specify a destination port, the test runs an internal  loopback. Otherwise, the test runs an external loopback from the source port to the destination port.</p> <p><code>status [clear]</code></p> <p>Read and interpret the status registers and print to the screen. <code>clear</code> clears the status registers.</p> <p><code>stop</code></p> <p>Issue a stop command to all Ethernet controllers in the AFU.</p> <p><code>readmacs</code></p> <p>Read and display the port MAC addresses. An EEPROM stores the MAC addresses.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#exit-codes","title":"EXIT CODES","text":"<p>0    Success - Number of packets received are equal to the number of packets sent and no errors           are reported.</p> <p>-1    Loopback failure - Either number of packets does not match or the test detected errors.</p> <p>-2    Errors parsing arguments.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#examples","title":"EXAMPLES","text":"<p>Read the MAC addresses of the AFU loaded on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback readmacs -B 0x5e\n</code></pre> <p>Run an external loopback, sending 100 packets from port 0 to port 1. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 1 -c 100\n</code></pre> <p>Run an internal loopback until a timeout of 5 seconds is reached. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 -t 5\n</code></pre>"},{"location":"host-attach-util/mem_tg/mem_tg/","title":"mem_tg","text":""},{"location":"host-attach-util/mem_tg/mem_tg/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: mem_tg [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -g,--guid TEXT=4DADEA34-2C78-48CB-A3DC-5B831F5CECBB\n                              GUID\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=info\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mem-channel UINT=0     Target memory bank for test to run on (0 indexed)\n  --loops UINT=1              Number of read/write loops to be run\n  -w,--writes UINT=1          Number of unique write transactions per loop\n  -r,--reads UINT=1           Number of unique read transactions per loop\n  -b,--bls UINT=1             Burst length of each request\n  --stride UINT=1             Address stride for each sequential transaction\n  --data UINT:value in {fixed-&gt;0,prbs15-&gt;2,prbs31-&gt;3,prbs7-&gt;1,rot1-&gt;3} OR {0,2,3,1,3}=fixed\n                              Memory traffic data pattern: fixed, prbs7, prbs15, prbs31, rot1\n  -f,--mem-frequency UINT=0   Memory traffic clock frequency in MHz\nSubcommands:\n  tg_test                     configure &amp; run mem traffic generator test\n</code></pre>"},{"location":"host-attach-util/mem_tg/mem_tg/#description","title":"DESCRIPTION","text":"<p>The memory traffic generator (TG) used to exercise and test available memory channels with a configurable traffic pattern.</p> <p>Execution of this application requires the user to bind the specific VF endpoint containing the mem_tg AFU id to vfio-pci</p> <p>In the TG, read responses are checked against a specified pattern. If the application is configured to perform a read only test on a region of memory that has not previously been initialized to contain that pattern it will flag a test failure.</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set application log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>mem_tg application time out, by default time out 60000</p> <p><code>-m,--mem-channel</code></p> <p>Target memory bank for test to run on (0 indexed)  default: 0</p> <p><code>--loops</code></p> <p>Number of read/write loops to be run  default: 1</p> <p><code>-w,--writes</code></p> <p>Number of unique write transactions per loop.  default: 1</p> <p><code>-r,--reads</code></p> <p>Number of unique read transactions per loop  default: 1</p> <p><code>-b,--bls</code></p> <p>AXI4 burst length of each request.  Supports 1-256 transfers beginning from 0. default: 0</p> <p><code>--stride</code></p> <p>Address stride for each sequential transaction (&gt;= burst length)  default: 1</p> <p><code>--data</code></p> <p>Memory traffic data pattern. 0 = fixed {0xFF, 0x00} 1 = prbs7 2 = prbs15 3 = prbs31 4 = rot1</p> <p>default: fixed</p> <p><code>-f, --mem-frequency</code></p> <p>Memory traffic clock frequency in MHz  default: 300 MHz</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#examples","title":"EXAMPLES","text":"<p>This command will run a basic read/write test on the channel 0 traffic generator: <pre><code>mem_tg tg_test\n</code></pre></p> <p>This command will run the application for an afu on pcie 000:b1:00.7: <pre><code>mem_tg --pci-address 000:b1:00.7 tg_test\n</code></pre></p> <p>This command will test channel 2 write bandwidth: <pre><code>mem_tg -loops 1000 -w 1000 -r 0 -m 2 tg_test\n</code></pre></p> <p>This command will perform a read bandwidth test with a burst of 16 on channel 1 and perform a data comparison with the prbs7 pattern: <pre><code>mem_tg -loops 1000 -w 0 -r 1000 -b 0xF --data prbs7 -m 1 tg_test\n</code></pre></p> <p>This command will perform a read/write test with 1 MB strided access to channel 0 memory: <pre><code>mem_tg -loops 10000 --stride 0x100000 tg_test\n</code></pre></p>"},{"location":"host-attach-util/mmlink/mmlink/","title":"mmlink","text":""},{"location":"host-attach-util/mmlink/mmlink/#synopsis","title":"Synopsis","text":"<p><code>mmlink [-v] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;TCP port&gt;] [-I &lt;IP Address&gt;]</code></p>"},{"location":"host-attach-util/mmlink/mmlink/#description","title":"Description","text":"<p>The Remote Signal Tap logic analyzer provides real-time hardware debugging for the Accelerator Function Unit (AFU).  It provides a signal trace capability that the Quartus Prime software adds to the AFU. The Remote Signal Tap logic analyzer provides access to the Remote Signal Tap part of the Port MMIO space and then runs the remote protocol.</p>"},{"location":"host-attach-util/mmlink/mmlink/#examples","title":"Examples","text":"<p><code>./mmlink  -B 0x5e -P 3333</code></p> <p>MMLink app starts and listens for connection.</p>"},{"location":"host-attach-util/mmlink/mmlink/#options","title":"Options","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-S,--socket</code> </p> <p>FPGA socket number.</p> <p><code>-P,--port</code> </p> <p>TCP port number.</p> <p><code>-I,--ip</code> </p> <p>IP address of FPGA system. </p>"},{"location":"host-attach-util/mmlink/mmlink/#notes","title":"Notes","text":"<p>Driver privilege:</p> <p>Change AFU driver privilege to user:</p> <pre><code>$ chmod 777 /dev/intel-fpga-port.0\n</code></pre> <p>Change locked memory size:</p> <p>edit the file /etc/security/limits.conf</p> <pre><code>$ sudo vi /etc/security/limits.conf\n\nuser    hard   memlock           10000\n\nuser    soft   memlock           10000\n</code></pre> <p>Exit terminal and log into a new terminal.</p> <p>Verify that the locked memory is now set:  ``` $ ulimit -l 10000</p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/","title":"ofs.uio","text":""},{"location":"host-attach-util/ofs_uio/ofs_uio/#synopsis","title":"SYNOPSIS","text":"<p><code>ofs.uio [-h] [--pcie-address PCIE_ADDRESS] [--uio uiox] [--feature-id FEATURE_ID] [--region-index REGION_INDEX]                   [--mailbox-cmdcsr offset] [--bit-size {8,16,32,64}] [--peek offset] [--poke offset value]                   [--mailbox-read offset] [--mailbox-dump address size] [--mailbox-write address value]</code></p> <p><code>ofs.uio [--uio uiox] [--peek offset]</code> <code>ofs.uio [--uio uiox] [--poke offset value]</code> <code>ofs.uio [--uio uiox] [--mailbox-read address]</code> <code>ofs.uio [--uio uiox] [--mailbox-write address value]</code> <code>ofs.uio [--uio uiox] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#description","title":"DESCRIPTION","text":"<p><code>ofs.uio</code> is a tool that provides user space access to DFL UIO devices, command line options like peek, poke, mailbox-read, mailbox-write, mailbox-dump to  access Configuration and Status Registers (CSRs).</p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#options","title":"OPTIONS","text":""},{"location":"host-attach-util/ofs_uio/ofs_uio/#peek","title":"Peek","text":"<p>Peek/Read UIO CSR offset <code>ofs.uio [--uio uio] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#poke","title":"Poke","text":"<p>Poke/Write value to UIO CSR offset <code>ofs.uio [--uio uio] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-read","title":"Mailbox Read","text":"<p>Read CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-write","title":"Mailbox Write","text":"<p>Write value to CSR address using mailbox  <code>ofs.uio [--uio uio] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-dump","title":"Mailbox Dump","text":"<p>Reads/Dumps block size of CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#bit-size","title":"Bit size","text":"<p>Read/Write bit-field 8,16,32,64 sizes <code>ofs.uio [--uio uio] --bit-size 8 [--peek offset]</code> <code>ofs.uio [--uio uio] --bit-size 32 [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#pcie-address","title":"PCIe Address","text":"<p>PCIE_ADDR PCIe address of FPGA device <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#uio-region-index","title":"UIO region index","text":"<p>UIO region index, default region index is 0  <code>ofs.uio [--uio uio] --region-index 0 [--peek offset]</code> <code>ofs.uio [--uio uio] --region-index 1 [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-command-status-csr-offset","title":"Mailbox command status csr offset","text":"<p>Mailbox command status csr offset,  default value set to dfl pcie subsystem system feature mailbox command status register offset 0x28  <code>ofs.uio [--uio uio] --mailbox-cmdcsr 0xa8 [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] --mailbox-cmdcsr 0xa8  [--mailbox-read address]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#examples","title":"EXAMPLES","text":"<p>Peek/Read <pre><code>ofs.uio --uio uio0 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio6 --peek 0x0\npeek(0x0): 0x3000000100000020\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio0 --peek 0x0 --bit-size 32\npeek(0x0): 0x10002015\n</code></pre></p> <p>Poke/Write <pre><code>ofs.uio --uio uio6 --peek 0x8\npeek(0x8): 0x0\nofs.uio --uio uio6 --poke  0x8 0xabcdd12345\npoke(0x8):0xabcdd12345\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x8): 0x0\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --poke  0x8 0x1234\npoke(0x8):0x1234\n</code></pre></p> <p>Mailbox Read <pre><code>ofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --uio uio6 --mailbox-read 0x8\nMailboxRead(0x8): 0x110c000\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x8 \nMailboxRead(0x8): 0x110c000\n</code></pre></p> <p>Mailbox Write <pre><code>ofs.uio --uio uio6 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0):0x1234\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0 \nMailboxRead(0x0):0x1234\n</code></pre></p> <p>Mailbox Dump <pre><code>ofs.uio --uio uio6 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n</code></pre></p>"},{"location":"host-attach-util/opae_io/opae_io/","title":"opae.io","text":""},{"location":"host-attach-util/opae_io/opae_io/#synopsis","title":"SYNOPSIS","text":"<p><code>opae.io ls [-v,--viddid VIDDID] [-s,--sub-viddid SUB_VIDDID] [--all] [--system-class]</code> <code>opae.io init [-d,--device PCI_ADDR] [USER[:GROUP]]</code> <code>opae.io release [-d,--device PCI_ADDR]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] walk [--offset [OFFSET]] [-u,--show-uuid] [-D,--dump] [-c,--count COUNT] [-y,--delay DELAY] [-s,--safe]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] dump [--offset [OFFSET]] [-o,--output OUTPUT] [-f,--format {bin,hex}] [-c,--count COUNT]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] peek OFFSET</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] poke OFFSET VALUE</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] script SCRIPT ARG1 ARG2 ... ARGN</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION]</code></p>"},{"location":"host-attach-util/opae_io/opae_io/#description","title":"DESCRIPTION","text":"<p><code>opae.io</code> is an interactive Python environment packaged on top of <code>libopaevfio.so</code>, which provides user space access to PCIe devices via the vfio-pci driver. The main feature of opae.io is its built-in Python command interpreter, along with some Python bindings that provide a means to access Configuration and Status Registers (CSRs) that reside on the PCIe device.</p> <p><code>opae.io</code> has two operating modes: command line mode and interactive mode.</p>"},{"location":"host-attach-util/opae_io/opae_io/#command-line-mode","title":"COMMAND LINE MODE","text":"<p>To view the accelerator devices that are present on the system, <code>opae.io</code> provides the <code>ls</code> command option.</p> <p><code>opae.io ls [-v,--viddid VIDDID] [-s,--sub-viddid SUB_VIDDID] [--all] [--system-class]</code></p> <p>Each accelerator device is listed along with the PCIe address, the PCIe vendor/device ID, a brief description of the device, and the driver to which the device is currently bound.</p> <p>Device filtering is available by providing a Vendor ID:Device ID pair, eg -v 8086:bcce. Further filtering can be done by providing a sub- Vendor ID:sub-Device ID pair, eg -s 8086:1771. The --all option provides a list of all of the PCIe devices in the system, which an be quite verbose. The --system-class option prints the PCIe database class of the accelerator device, rather than the product name.</p> <p><code>opae.io</code> provides an option to initialize a PCIe device for use with the vfio-pci driver. In order for the device CSRs to be accessed from user space, the device must first be bound to the vfio-pci driver. This is the job of the <code>init</code> command option.</p> <p><code>opae.io init [-d,--device PCI_ADDR] [USER[:GROUP]]</code></p> <p>The <code>init</code> command unbinds the specified device from its current driver and binds it to vfio-pci. This creates a new vfio group under /dev/vfio. This group path is then used by the <code>libopaevfio.so</code> library to interact with the device.</p> <p>To release the PCIe device from vfio-pci and return it to use with its previous driver, the <code>release</code> command option is used.</p> <p><code>opae.io release [-d,--device PCI_ADDR]</code></p> <p>The <code>release</code> command option reverses the actions of the last <code>init</code> command, releasing the device from vfio-pci and binding it to the driver which was bound at the time the <code>init</code> command was issued.</p> <p>The <code>walk</code> command option traverses and displays the Device Feature List of the given region.</p> <p><code>opae.io walk [--offset [OFFSET]] [-u,--show-uuid] [-D,--dump] [-c,--count COUNT] [-y,--delay DELAY] [-s,--safe]</code></p> <p>The various fields of each Device Feature Header are displayed. The <code>--show-uuid</code> option additionally displays the GUID for each feature. OFFSET can be used to specify the beginning of the DFL in the MMIO region. --dump displays the raw DFH contents in hex format. COUNT limits the number of DFH entries traversed. DELAY causes a pause between each printout. --safe examines each DFH offset for proper alignment.</p> <p>The <code>dump</code> command provides a means to dump the MMIO space in ASCII hex or binary format.</p> <p><code>opae.io dump [--offset [OFFSET]] [-o,--output OUTPUT] [-f,--format {bin,hex}] [-c,--count COUNT]</code></p> <p>OFFSET specifies the starting MMIO offset. OUTPUT gives the name of a file to capture the dump output, where sys.stdout is used by default. --format allows changing the output format. COUNT specifies the number of qwords to dump.</p> <p>The <code>peek</code> command option reads and displays a CSR value.</p> <p><code>opae.io peek OFFSET</code></p> <p>The <code>poke</code> command option writes a given value to a CSR.</p> <p><code>opae.io poke OFFSET VALUE</code></p> <p><code>opae.io</code> can also execute Python scripts from the command line. These Python scripts may contain calls to the device built-in functions that are available during an interactive session. Refer to the description of interactive mode for details.</p> <p><code>opae.io script myscript.py a b c</code></p> <p>In order to enter the interactive mode of <code>opae.io</code>, simply invoke it and optionally pass the desired device address and MMIO region options.</p> <p><code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION]</code></p>"},{"location":"host-attach-util/opae_io/opae_io/#interactive-mode","title":"INTERACTIVE MODE","text":"<p>Upon entering interactive mode, <code>opae.io</code> begins a Python interpreter session and displays the command prompt shown below:</p> <p>0000:3f:00.0[0]&gt;&gt;</p> <p>The first portion of the prompt shows the address of the active PCIe device, here 0000:3f:00.0. The part in square brackets shows the active MMIO region, here [0].</p> <p>The interpreter waits for a valid Python command, then attempts to execute the given command in the usual way. The only differences between the traditional Python command intepreter and <code>opae.io</code> are that opae.io provides 1) the notion of an active PCIe device and MMIO region and 2) several built-in functions and objects that allow manipulating the active device and MMIO region.</p>"},{"location":"host-attach-util/opae_io/opae_io/#built-in-functions","title":"BUILT-IN FUNCTIONS","text":"<p>The <code>opae.io</code> built-in functions assume an active device and MMIO region. Attempting to use the built-in functions without first opening a device and region will result in errors.</p> <p><code>peek(OFFSET)</code></p> <p>The <code>peek</code> built-in function reads and displays a CSR value from the active device and region, at the offset supplied by its argument.</p> <p>0000:3f:00.0[0]&gt;&gt; peek(0x28) 0xdeadbeef</p> <p><code>poke(OFFSET, VALUE)</code></p> <p>The <code>poke</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; poke(0x28, 0xdeadbeef)</p> <p><code>read_csr(OFFSET)</code></p> <p>The <code>read_csr</code> built-in function returns the value of the CSR at the active MMIO region and the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; print('0x{:0x}'.format(read_csr(0x28))) 0xdeadbeef</p> <p><code>write_csr(OFFSET, VALUE)</code></p> <p>The <code>write_csr</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; write_csr(0x28, 0xdeadbeef)</p> <p><code>device(PCI_ADDR)</code></p> <p>The <code>device</code> built-in function allows changing the active PCIe device.</p> <p>0000:3f:00.0[0]&gt;&gt; device('0000:2b:00.0') 0000:2b:00.0&gt;&gt;</p> <p><code>region(REGION)</code></p> <p>The <code>region</code> built-in function allows changing the active MMIO region.</p> <p>0000:2b:00.0&gt;&gt; region(0) 0000:2b:00.0[0]&gt;&gt;</p> <p><code>allocate_buffer(SIZE)</code></p> <p>The <code>allocate_buffer</code> built-in function creates and returns a DMA buffer object. The underlying buffer will be SIZE bytes in length.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = allocate_buffer(4096) 0000:2b:00.0[0]&gt;&gt; print(b1.size, '0x{:0x}'.format(b1.address), b1.io_address) 4096 0x7f9361c66000 0</p> <p><code>version()</code></p> <p>The <code>version</code> built-in function returns a tuple containing the four components used to identify the opae.io version:</p> <p>0000:2b:00.0[0]&gt;&gt; print(version()) ('opae.io', 0, 2, 0)</p>"},{"location":"host-attach-util/opae_io/opae_io/#built-in-objects","title":"BUILT-IN OBJECTS","text":"<p><code>opae.io</code> interactive mode provides two global objects corresponding to the current device and that device's current MMIO region. These objects are referred to by global variables <code>the_device</code> and <code>the_region</code>, respectively.</p> <p>The <code>device</code> class:</p> <p>the_device.descriptor() : method that returns the integer file descriptor of the <code>VFIO container</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.descriptor()) 5</p> <p>the_device.repr() : method that is invoked when a <code>device</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device) 0000:2b:00.0</p> <p>the_device.allocate(SIZE) : method that allocates and returns a <code>system_buffer</code> object. The buffer will be mapped into the DMA space of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = the_device.allocate(4096)</p> <p>the_device.pci_address() : read-only property that returns the PCIe address of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.pci_address) 0000:2b:00.0</p> <p>the_device.num_regions : read-only property that returns the number of MMIO regions in <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.num_regions) 2</p> <p>the_device.regions : read-only property that returns a list of the active MMIO regions of <code>the_device</code>:</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.regions) [0, 2]</p> <p>The <code>region</code> class:</p> <p>the_region.write32(OFFSET, VALUE) : method that writes a 32-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read32(OFFSET) : method that returns a 32-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write32(0x28, 0xdeadbeef) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read32(0x28))) 0xdeadbeef</p> <p>the_region.write64(OFFSET, VALUE): method that writes a 64-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read64(OFFSET): method that returns a 64-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write64(0x28, 0xbaddecaf) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read64(0x28))) 0xbaddecaf</p> <p>the_region.index(): method that returns the MMIO index of <code>the_region</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region.index()) 0</p> <p>the_region.repr(): method that is invoked when a <code>region</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region) 0</p> <p>the_region.len(): method that is invoked to determine the MMIO region size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(len(the_region)) 524288</p> <p>The <code>allocate_buffer()</code> built-in function and the <code>device.allocate()</code> method return objects of type <code>system_buffer</code>.</p> <p>The <code>system_buffer</code> class is as follows:</p> <p><code>buf.size</code>: read-only property that gives the buffer size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(b1.size) 4096</p> <p><code>buf.address</code>: read-only property that gives the buffer's user mode virtual address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.address)) 0x7f2c15d8200</p> <p><code>buf.io_address</code>: read-only property that gives the buffer's IO address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.io_address)) 0x0</p> <p><code>buf.__getitem__</code> and <code>buf.__setitem__</code>: indexing get/set of 64-bit data item.</p> <p>0000:2b:00.0[0]&gt;&gt; b1[0] = 0xdecafbad 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1[0])) 0xdecafbad</p> <p><code>buf.read8(OFFSET)</code> <code>buf.read16(OFFSET)</code> <code>buf.read32(OFFSET)</code> <code>buf.read64(OFFSET)</code> : methods that read the given size data item from the given buffer OFFSET.</p> <p><code>buf.fill8(VALUE)</code> <code>buf.fill16(VALUE)</code> <code>buf.fill32(VALUE)</code> <code>buf.fill64(VALUE)</code> : methods that fill the buffer with the given VALUE, using the given size.</p> <p><code>b1.compare(b2)</code>: method that compares buffers. The method returns the index of the first byte that miscompares, or the length of b1.</p>"},{"location":"host-attach-util/opaeuio/opaeuio/","title":"opaeuio","text":""},{"location":"host-attach-util/opaeuio/opaeuio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaeuio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-v] [device]</code></p>"},{"location":"host-attach-util/opaeuio/opaeuio/#description","title":"DESCRIPTION","text":"<p>The <code>opaeuio</code> command enables the binding/unbinding of a DFL device to/from the dfl-uio-pdev device driver. See https://kernel.org/doc/html/v4.14/driver-api/uio-howto.html for a description of uio.</p>"},{"location":"host-attach-util/opaeuio/opaeuio/#options","title":"OPTIONS","text":"<p><code>device</code>     The DFL device name, eg dfl_dev.10</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given device for uio.\nUsed in conjunction with -u, -g, and -d.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given device from uio.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when binding to uio.\nThe default value is dfl-uio-pdev.\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to uio. A new device node is created in\n/dev when the device is bound to uio. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to uio. Use this option to specify the\nnew device group for the device created in /dev.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/opaeuio/opaeuio/#examples","title":"EXAMPLES","text":"<p><code>opaeuio -h</code> <code>opaeuio -v</code> <code>sudo opaeuio -i -u lab -g labusers dfl_dev.10</code> <code>sudo opaeuio -r dfl_dev.10</code></p>"},{"location":"host-attach-util/opaevfio/opaevfio/","title":"opaevfio","text":""},{"location":"host-attach-util/opaevfio/opaevfio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaevfio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-n] [-v] [addr]</code></p>"},{"location":"host-attach-util/opaevfio/opaevfio/#description","title":"DESCRIPTION","text":"<p>The <code>opaevfio</code> command enables the binding/unbinding of a PCIe device to/from the vfio-pci device driver. See https://kernel.org/doc/Documentation/vfio.txt for a description of vfio-pci.</p>"},{"location":"host-attach-util/opaevfio/opaevfio/#options","title":"OPTIONS","text":"<p><code>addr</code>     The PCIe address of the device in ssss:bb:dd.f format, eg 0000:7f:00.0</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given addr for vfio.\nUsed in conjunction with -u, -g, and -n.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given addr from vfio.\nUsed in conjunction with -d.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when releasing from vfio.\nWhen omitted, the device is not rebound to a driver (default).\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to vfio. A new device node is created in\n/dev/vfio when the device is bound to vfio-pci. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to vfio. Use this option to specify the\nnew device group for the device created in /dev/vfio.\n</code></pre> <p><code>-n, --no-sriov</code></p> <pre><code>Do not enable SR-IOV when binding to vfio. The default value for this option\nis FALSE, ie the script should specify SR-IOV functionality when binding to\nthe vfio-pci driver. When omitted, the modprobe command which loads the vfio-pci\ndriver will contain the `enable_sriov=1` option. When given, it will not.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/opaevfio/opaevfio/#examples","title":"EXAMPLES","text":"<p><code>opaevfio -h</code> <code>opaevfio -v</code> <code>sudo opaevfio -i -u lab -g labusers 0000:7f:00.0</code> <code>sudo opaevfio -r 0000:7f:00.0</code></p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/","title":"pac_hssi_config","text":"<pre><code># pac_hssi_config #\n\n## SYNOPSIS ##\n```console\npac_hssi_config.py [-h] subcommand [subarg] [bdf]\n</code></pre>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#description","title":"DESCRIPTION","text":"<p>The <code>pac_hssi_config.py</code> tool exercises the Ethernet 10 Gbps (10GbE) and 40GbE transceivers for designs using the Intel\u00ae Programmable Acceleration Card (PAC) with Intel Arria\u00ae 10 GX FPGA. This tool does not support the  Intel Xeon\u00ae Processor with Integrated FPGA. </p> <p></p> <p>The two required arguments to the <code>pac_hssi_config.py</code> tool specify the subcommand and bus, device, and function (BDF) for the PCIe device under test. You must provide the BDF parameter for systems with more than one PCIe card. </p> <pre><code>.. note::\n    If you do not provide the BDF when required, the command prints a list of valid BDFs for the system. You can also\n    determine the BDF using the ``lspci`` command.\n</code></pre> <p>For usage help, type the following at a command prompt:</p> <p><code>pac_hssi_config.py [-h|--help]</code></p> <p>To configure the network ports, send data, and read statistics, use the following form of the <code>pac_hssi_config.py</code> script:</p> <p><code>pac_hssi_config.py subcommand [subarg] [bdf]</code></p> <p>Only a subset of subcommand arguments support <code>subarg</code>. </p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-1-general-subcommands","title":"Table 1. General Subcommands","text":"Subcommand Subarg Description <code>stat</code> N/A Prints high speed serial interface (HSSI) controller statistics. <code>eeprom</code> N/A Reads the 128-bit unique board ID, MAC address, and board-specific IDs from EEPROM."},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-2-1040-gbe-traffic-generation-subcommands","title":"Table 2. 10/40 GbE Traffic Generation Subcommands","text":"Subcommand Subarg Description <code>e10init</code> and <code>e40init</code> N/A Initializes HSSI PHY to 10GbE or 40GbE mode.  Clears statistics and enable internal HSSI transceiver loopback. <code>e10loop</code> and <code>e40loop</code> On/Off Turns on or off internal HSSI transceiver loopback. <code>e10reset</code> and <code>e40reset</code> On/Off Asserts or deasserts AFU reset.  Clears packet statistics and disables internal HSSI transceiver loopback. <code>e10send</code> and <code>e40send</code> N/A Sends 1,000,000 1500-byte packets. For 10GbE sends packets on all four ports. 40GbE has a single port. <code>e10stat</code> and <code>e40stat</code> N/A Prints packet statistics. <code>e10statclr</code> and <code>e40statclr</code> N/A Clears packet statistics.  Use this command after switching loopback modes to clear any transient statistics accumulated during the mode switch. <p>The transceiver equalization <code>eqwrite</code> and <code>eqread</code> subcommands write and read transceiver equalization settings.  These subcommands require you to specify the transceiver channel, the equalization setting, and the value (for writes).  Use the following form for the <code>eqwrite</code> command:</p> <p><code>pac_hssi_config.py eqwrite [transceiver channel number] [equalization setting] [equalization value] [bdf]</code></p> <p>Use the following form for the <code>eqread</code>command:</p> <p><code>pac_hssi_config.py eqread [transceiver channel number] [equalization setting] [bdf]</code> </p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-3-transceiver-equalization-subcommands","title":"Table 3. Transceiver Equalization Subcommands","text":"Subcommand Channel Number Equalization Setting Value <code>eqwrite</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) Specifies the value for the specified equalization setting. <code>eqread</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) N/A <p>For more information about reconfiguring transceiver analog parameter settings In Arria\u00ae 10 devices, refer to \"Changing PMA Analog Parameters\" in the  Intel\u00ae Arria\u00ae 10 Transceiver PHY User Guide.</p>"},{"location":"host-attach-util/packager/packager/","title":"packager","text":""},{"location":"host-attach-util/packager/packager/#synopsis","title":"SYNOPSIS","text":"<p><code>packager &lt;cmd&gt; [arguments]</code></p>"},{"location":"host-attach-util/packager/packager/#description","title":"Description","text":"<p>The packager provides tools that Accelerator Functional Unit (AFU) developers use to create Accelerator Function (AF)  files. The AF file is the programming file for an AFU on Intel\u00ae FPGA platforms. The packager tool concatenates the metadata from the JSON file to a raw binary file <code>(.rbf)</code> that the Intel Quartus\u00ae Prime software generates. </p> <p>The packager's only function is to create an AF file. Refer to Packager Command Syntax for more information about invoking the packager. The packager depends on a JSON file to describe AFU metadata. Refer to  Accelerator Description File for more information about the JSON file.</p> <p>The packager requires Python 2.7.1 and Python 2.7.3. The tool indicates if it is being called with a compatible  of Python.</p>"},{"location":"host-attach-util/packager/packager/#packager-command-syntax","title":"Packager Command Syntax","text":"<p>The packager is a command line tool with the following syntax:</p> <p><code>$ packager &lt;cmd&gt; [arguments]</code></p> <p>The following table describes the <code>&lt;CMD&gt;</code> arguments:</p> Command Arguments Description <code>create-gbs</code> <code>--rbf=&lt;RBF_PATH&gt;</code> <code>--afu=&lt;AFU_JSON_PATH&gt;</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> Creates the AF file. The engineering name for this file is the green bit stream, abbreviated gbs. The <code>--rbf</code> and <code>--afu</code>   arguments are required.  <code>&lt;RBF_PATH&gt;</code> is the path to the RBF file for the AFU. The Quartus\u00ae Prime software generates this RBF by compiling the AFU design. <code>&lt;AFU_JSON_PATH&gt;</code> is the path to the Accelerator Description file. This is a JSON file that describes the metadata that <code>create-gbs</code> appends to the RBF. <code>&lt;GBS_PATH&gt;</code> is the path to the RBF file for the FPGA Interface Manager (FIM) that contains the FPGA interface unit and other interfaces. If you do not specify the <code>--gbs</code>, the command defaults to <code>&lt;rbf_name&gt;.gbs</code>. You can use the optional <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>modify-gbs</code> <code>--gbs=&lt;gbs_PATH&gt;</code> Modifies the AF file. The <code>--input-gbs</code>argument is required. If you do not provide the <code>--output-gbs</code> argument, <code>modify-gbs</code> overwrites the <code>--input-gbs</code> file. Use the <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>gbs-info</code> <code>--input-gbs=&lt;gbs_PATH&gt;</code> Prints information about the AF file. The <code>--input-gbs</code> argument is required. <code>get-rbf</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--rbf=&lt;RBF_PATH&gt;</code> Creates the RBF by extracting it from the AF file. The <code>--gbs</code>argument is required. If you do not specify the <code>--rbf</code> argument, the command defaults to <code>&lt;gbs_name.rbf</code> . None, or any <code>&lt;CMD&gt;</code> <code>--help</code> Summarizes the <code>&lt;CMD&gt;</code> options. Typing <code>packager --help</code> gives a list of <code>&lt;CMD&gt;</code> values. Typing <code>packager &lt;CMD&gt; --help</code> provides detailed help for <code>&lt;CMD&gt;</code>"},{"location":"host-attach-util/packager/packager/#examples","title":"Examples","text":"<p>To generate an AF file, run:</p> <p><code>$ packager create-gbs --rbf=&lt;RBF_PATH&gt; --afu=&lt;AFU_JSON_PATH&gt; --gbs=&lt;GBS_PATH&gt;</code></p> <p>TIP: JSON files are very particular about syntax such as trailing commas. If you are getting errors, use <code>jsonlint.com</code> to validate that your JSON is formatted correctly. </p> <p>To modify metadata in an existing AF, run the following command:</p> <p><code>$ packager modify-gbs --input-gbs=&lt;PATH_TO_GBS_TO_BE_MODIFIED&gt; --outputgbs=&lt;NAME_FOR_NEW_GBS&gt; --set-value &lt;key&gt;:&lt;value&gt;</code></p> <p>You can pass in a number of : pairs with --set-value to update values in an AF.  <p>To print the metadata of an existing AF: </p> <p><code>$ packager get-info --gbs=&lt;GBS_PATH&gt;</code> </p> <p>To extract the RBF from the AF:</p> <p><code>$ packager get-rbf --gbs=&lt;GBS_PATH&gt; --rbf=&lt;NAME_FOR_RBF&gt;</code></p>"},{"location":"host-attach-util/packager/packager/#accelerator-description-file","title":"Accelerator Description File","text":"<p>The Accelerator Description File is a JSON file that describes the metadata associated with an AFU. The Open Progammable Accelerator Engine (OPAE) uses this metadata during reconfiguration. Here is an example file:</p> <p><pre><code>{\n   \"version\": 1,\n   \"platform-name\": \"DCP\",\n   \"afu-image\": {\n      \"magic-no\": 488605312,\n      \"interface-uuid\": \"01234567-89AB-CDEF-0123-456789ABCDEF\",\n      \"power\": 0,\n      \"accelerator-clusters\": [{\n         \"name\": \"dma_test_afu\",\n         \"total-contexts\": 1,   \n         \"accelerator-type-uuid\": \"331DB30C-9885-41EA-9081-F88B8F655CAA\"\n      }\n      ]  \n   }\n}\n</code></pre> The packager stores these parameter values in the resultant AF. After reprogramming the AFU using partial reconfiguration (PR), the  software driver reconfigures the PLLs by writing the clock-frequency-high and clock-frequency-low values (if present) over the  PCIe\u00ae and CCI interfaces. </p> <p>.. note:: <pre><code>The JSON file format may change as the architecture evolves. Any changes to the current format trigger an update\nto the version number.  \n</code></pre></p> <p>CATEGORY | NAME | TYPE | DESCRIPTION | MANDATORY ---------|------|------|-------------|:----------:| Per-AFU  | version | Integer | Version of the metadata format. | Yes Per-AFU  | magic-no (to be deprecated)| Integer | Magic no. Associated with the FPGA Interface Manager. | No Per-AFU  | platform-name | String | Name of the platform for which the metadata is intended. The field value is \u201cDCP\u201d for Intel  Acceleration Stack for FPGAs. | No Per-AFU  | interface-uuid | UUID | Interface id associated with the FPGA Interface Manager. | Yes Per-AFU  | power | Integer | Accelerator Function power consumption, in watts. Set to 0 for Intel Acceleration Stack for FPGAs platforms. | Yes Per-AFU  | clock-frequency-low | Float | Clock frequency for 1st PLL (Clock network)1 in MHz. | No Per-AFU  | clock-frequency-high | Float | Clock frequency for 2nd PLL (0 if absent) in MHz. | No Per-AFC Cluster | total-contexts | Integer | Number of AFCs in this cluster. Always be 1 in current architectures. | Yes Per-AFC Cluster | afc-type-uuid |  UUID | AFC type = AFU ID in current architectures. | Yes Per-AFC Cluster | name | string | AFC name = AFU name in current architectures. | Yes</p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"host-attach-util/pci_device/pci_device/","title":"pci_device","text":""},{"location":"host-attach-util/pci_device/pci_device/#synopsis","title":"SYNOPSIS","text":"<p><code>pci_device [-h] [-E] device-filter [{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}]</code></p>"},{"location":"host-attach-util/pci_device/pci_device/#description","title":"DESCRIPTION","text":"<p>pci_device is a tool to aid in common operations for managing PCIe devices and drivers.</p>"},{"location":"host-attach-util/pci_device/pci_device/#options","title":"OPTIONS","text":""},{"location":"host-attach-util/pci_device/pci_device/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<pre><code>`device filter`\n\nPCIe address of a device or vendor/device ID pair.\nThe PCIe address follows the format of [segment:]bus:device.function\nwhile the vendor/device ID pair follows the format [vendor ID]:[device ID]\nwhere at least one of these must be present.\n\n`{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}`\n\naction to perform on device\n\n`aer`\nPerform AER (Advanced Error Reporting) operations.\nThe aer action has its own sub-commands which are listed below:\n\n* `dump` sub-command will print out the AER error counters as reported\n   by the sysfs files for the device.\n* `mask` can either print out the current AER mask bits or set them\n  * If `show` or `print` (or nothing) is given after the `mask`\n    command, it will show the current mask bits for AER.\nBy default output will be written in stdout but can be written to an\noutput file if `-o|--output FILENAME` argument is given.\n  * If `all` is given after the `mask` command, it will mask all bits\n    (by setting the values to 0xffffffff and 0xffffffff).\n  * If `off` is given after the `mask` command, it will unmask all\n    bits (by setting the values to 0x0 and 0x0).\n  * If two numbers are present after the `mask` command, those two\n    numbers will be used to set the mask bits.\nValues for setting the mask can also be read in from an input file if\n`-i|--input FILENAME` argument is given.\n\n_NOTE_: mask related operations require root privileges\n\n`bind`\n\nAssociate a device with its driver.\n\n`plug`\n\nRestore a device that was previously given to `pci_device &lt;device&gt; unplug`\n\n`remove`\n\nRemove the pci device from the pci bus\n\n`rescan`\n\nRescan the bus as identified by the bus component of the PCIe device address\n\n'topology`\n\nPrint the PCIe topology from the root port to the PCIe device.\nThis shows the PCIe tree rooted at the PCIe root port.\nEach line shows the the PCIe address, vendor ID, and device ID along with\nthe driver bound to the device. The indentation is used to show\nparent/child relationship of devices.\n\nThe line listing the target PCIe device as identified by the given PCIe\naddress will be highlighted in green while the endpoints will be\nhighlighted in cyan.\n\nThe example below shows the topology of an N3000 device with eight virtual\nfunctions created from one of the Ethernet controllers:\n\n```console\n[pci_address(0000:3a:00.0), pci_id(0x8086, 0x2030)] (pcieport)\n    [pci_address(0000:3b:00.0), pci_id(0x10b5, 0x8747)] (pcieport)\n        [pci_address(0000:3c:09.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3f:00.0), pci_id(0x8086, 0x0b30)] (dfl-pci)\n        [pci_address(0000:3c:11.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:43:00.0), pci_id(0x8086, 0x0b32)] (no driver)\n    [pci_address(0000:3c:08.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3d:02.0), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.7), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.5), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.3), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.1), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.6), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.4), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.2), pci_id(0x8086, 0x154c)] (iavf)\n        [pci_address(0000:3c:10.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:41:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:41:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n\n```\n\n`unbind`\n\nUnbind the driver bound to the device.\n\n`unplug`\n\nRemove device from PCI bus in anticipation of a RSU event by configuring its root port and associated endpoints.\n\n`vf`\n\nCreate/destroy VFs (virtual functions) by setting the number here.\nThe number given here will be written to sriov_numvfs sysfs file triggering\nthe PCIe subsystem to create/destroy VFs so that the current number of VFs\nwill be equal to the given number. If the number given is outside of the total VFs supported, an error message will be displayed to indicate this.\n</code></pre>"},{"location":"host-attach-util/pci_device/pci_device/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<pre><code>`-h, --help`\n\nshow this help message and exit\n\n`-E, --other-endpoints`\n\nperform action on peer PCIe devices\n</code></pre>"},{"location":"host-attach-util/pci_device/pci_device/#examples","title":"EXAMPLES","text":"<pre><code>pci_device 0000:3d:00.0 remove\npci_device 0000:3d:00.0 rescan\npci_device 3d:00.0 topology\npci_device :0b30 topology\npci_device :0b30 aer\npci_device :0b30 aer mask\npci_device :0b30 aer mask all\npci_device :0b30 aer mask -o mask.dat\npci_device :0b30 aer mask -i mask.dat\n</code></pre>"},{"location":"host-attach-util/rsu/rsu/","title":"rsu","text":""},{"location":"host-attach-util/rsu/rsu/#synopsis","title":"SYNOPSIS","text":"<pre><code>rsu [-h] [-d] {bmc,bmcimg,retimer,fpga,sdm,fpgadefault} [PCIE_ADDR]\n</code></pre>"},{"location":"host-attach-util/rsu/rsu/#description","title":"DESCRIPTION","text":""},{"location":"host-attach-util/rsu/rsu/#mode-1-rsu","title":"Mode 1: RSU","text":"<pre><code>rsu bmc --page=(user|factory) [PCIE_ADDR]\nrsu retimer [PCIE_ADDR]\nrsu fpga --page=(user1|user2|factory) [PCIE_ADDR]\nrsu sdm --type=(sr|pr|sr_cancel|pr_cancel) [PCIE_ADDR]\n</code></pre> <p>Perform RSU (remote system update) operation on PAC device given its PCIe address. An RSU operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either BMC, Retimer, SDM, (on devices that support these) or the FPGA.</p>"},{"location":"host-attach-util/rsu/rsu/#mode-2-default-fpga-image","title":"Mode 2: Default FPGA Image","text":"<pre><code>rsu fpgadefault --page=(user1|user2|factory) --fallback=&lt;csv&gt; [PCIE_ADDR]\n</code></pre> <p>Set the default FPGA boot sequence. The --page option determines the primary FPGA boot image. The --fallback option allows a comma-separated list of values to specify fallback images.</p>"},{"location":"host-attach-util/rsu/rsu/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{bmc,bmcimg,retimer,fpga,sdm,fpgadefault}</code></p> <p>type of RSU operation or set Default FPGA Image operation.</p> <p><code>PCIE_ADDR</code>  PCIe address of device to do rsu (e.g. 04:00.0 or 0000:04:00.0) </p>"},{"location":"host-attach-util/rsu/rsu/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code> show this help message and exit</p> <p><code>-d, --debug</code> log debug statements</p> <p><code>--force</code> force rsu operation</p>"},{"location":"host-attach-util/rsu/rsu/#example","title":"EXAMPLE","text":"<pre><code># rsu bmc --page=user 25:00.0\n</code></pre> <p>Triggers a boot of the BMC image (user page) for the device with PCIe  address 25:00.0.</p> <pre><code># rsu bmc --page=factory 25:00.0\n</code></pre> <p>Triggers a factory boot of the BMC image for the device with  PCIe address 25:00.0.</p> <pre><code># rsu fpga --page=user2 25:00.0\n</code></pre> <p>Triggers a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0.</p> <pre><code># rsu --force fpga --page=user2 25:00.0\n</code></pre> <p>Forces a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0. Default behavior is to not perform  the rsu operation if DPC (downstream port containment) is not supported  and AER (advanced error reporting) is also not supported. Using --force  changes this behavior to perform rsu operation regardless but may result  in a surprise removal of pci devices which may cause the Linux kernel  to panic.</p> <pre><code># rsu fpga --page=factory 25:00.0\n</code></pre> <p>Triggers a factory reconfiguration of the FPGA for the device  with PCIe address 25:00.0.</p> <pre><code># rsu sdm --type=sr 25:00.0\n</code></pre> <p>Triggers Static Region key programming for the device with  PCIE address 25:00.0.</p> <pre><code># rsu fpgadefault --page=factory --fallback=user1,user2 25:00.0\n</code></pre> <p>Sets the FPGA boot sequence to factory with fallbacks user1, user2.</p>"},{"location":"host-attach-util/userclk/userclk/","title":"userclk","text":""},{"location":"host-attach-util/userclk/userclk/#synopsis","title":"SYNOPSIS","text":"<p><code>userclk [-hv] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] [-H &lt;User clock high frequency&gt;] -L &lt;User clock low frequency&gt;]</code></p>"},{"location":"host-attach-util/userclk/userclk/#description","title":"DESCRIPTION","text":"<p>userclk sets the frequency range for an AFU. </p>"},{"location":"host-attach-util/userclk/userclk/#examples","title":"EXAMPLES","text":"<p><code>./userclk -B 0x5e -H 400 -L 200</code></p> <p>Sets AFU frequency.</p>"},{"location":"host-attach-util/userclk/userclk/#options","title":"OPTIONS","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-S,--segment</code> </p> <p>FPGA segment number.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-H,--freq-high</code> </p> <p>User clock high frequency. </p> <p><code>-L,--freq-low</code> </p> <p>User clock low frequency. </p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"host-attach-util/vabtool/vabtool/","title":"vabtool","text":""},{"location":"host-attach-util/vabtool/vabtool/#synopsis","title":"SYNOPSIS","text":"<p><code>vabtool [-r RETRIES] [-d] [-y] [-v] &lt;ACTION&gt;</code></p> <p>Where ACTION is defined as one of the following:</p> <p><code>vabtool sr_key_provision PCIE_ADDRESS SR_RKH_FILE FPGA_IMG_FILE</code> <code>vabtool sr_status PCIE_ADDRESS</code> <code>vabtool pr_key_provision PCIE_ADDRESS PR_AUTH_CERT_FILE PR_RKH_FILE</code> <code>vabtool pr_status PCIE_ADDRESS</code> <code>vabtool sr_key_cancel PCIE_ADDRESS SR_RKH_CANCEL_FILE</code> <code>vabtool sr_cancel_status PCIE_ADDRESS</code> <code>vabtool pr_key_cancel PCIE_ADDRESS PR_RKH_CANCEL_FILE</code> <code>vabtool pr_cancel_status PCIE_ADDRESS</code></p>"},{"location":"host-attach-util/vabtool/vabtool/#description","title":"DESCRIPTION","text":"<p>The <code>vabtool</code> command helps perform Vendor Authenticated Boot provisioning of Static Region and Partial Reconfiguration Region key hashes and helps perform SR and PR hash cancellation and status reporting.</p>"},{"location":"host-attach-util/vabtool/vabtool/#options","title":"OPTIONS","text":"<p><code>-r RETRIES, --retries RETRIES</code></p> <pre><code>Specifies the number of times a failed SR or PR key provision is to be\nretried. The default value for RETRIES is 3.\n</code></pre> <p><code>-d, --dry-run</code></p> <pre><code>Don't execute the actual fpgasupdate and rsu commands, but only print\nthe commands that would be executed during a normal run of the script.\n</code></pre> <p><code>-y, --yes</code></p> <pre><code>The tool will respond with an automatic Yes answer to all confirmation\nprompts posed by the sub-tools.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/vabtool/vabtool/#examples","title":"EXAMPLES","text":"<p><code>sudo vabtool -y sr_key_provision 0000:bc:00.0 my_sr_rkh.bin my_fpga.bin</code> <code>sudo vabtool sr_status 0000:bc:00.0</code> <code>sudo vabtool -y pr_key_provision 0000:bc:00.0 pr_auth_cert.bin my_pr_rkh.bin</code> <code>sudo vabtool pr_status 0000:bc:00.0</code> <code>sudo vabtool sr_key_cancel 0000:bc:00.0 my_sr_rhk_cancel.bin</code> <code>sudo vabtool sr_cancel_status 0000:bc:00.0</code> <code>sudo vabtool pr_key_cancel 0000:bc:00.0 my_pr_rhk_cancel.bin</code> <code>sudo vabtool pr_cancel_status 0000:bc:00.0</code></p>"},{"location":"linux-dfl/dfl/dfl/","title":"Device Feature List Driver","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl/dfl/#introduction","title":"Introduction","text":"<p>This driver defines a feature list structure that creates a linked list of feature headers (DFHs) within the MMIO space to provide an extensible way of adding features for FPGA. The driver can walk through feature headers to enumerate feature devices (e.g. FPGA Management Engine, Port and Accelerator Function Unit) and their private features for FPGA devices that support the DFL structure. This linked list is then itself traversed and each feature/private feature is associated with a driver.</p> Driver Mapping Source(s) Required for DFL dfl.ko Device Feature List Driver drivers/fpga/dfl.c Y <p>An example DFL:</p> <p></p> <p>Also known as the DFL \"walker\", <code>dfl-ko</code> walks the DFL and instantiates other DFL-enabled drivers. The same driver is used on both host-attach and in HPS, assuming they are connected by either a soft or hard PCIe IP. The same DFL walker is used regardless of the chosen OFS attach method (PCIe Attach, Direct Attach). This driver is required for all DFL-enabled FPGA designs.</p> <p>The following chart visualizes DFL discovery:</p> <p></p>"},{"location":"linux-dfl/dfl/dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl.c</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl.c?h=master.</p>"},{"location":"linux-dfl/dfl/dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Access PCIe BAR to create a linked list within MMIO for all DFL features</li> </ul>"},{"location":"linux-dfl/dfl/dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL</p> <p></p>"},{"location":"linux-dfl/dfl/dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl/dfl/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl/dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/","title":"Accelerator Functional Unit (aka workload) Driver For Host Attach","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#introduction","title":"Introduction","text":"<p>This driver extends the capability of the Accelerator Functional Unit or application workload by implementing management features. You can connect to FPGA infrastructure through the AFU's port interface. An application layer, called Open Programmable Acceleration Engine (OPAE) is built on top of the AFU driver group and can directly communicate with the AFU port regardless of whether the workload sits in a partial reconfiguration region or not. The AFU driver is composed of 4 source files that define its core functionality.</p> Driver Mapping Source(s) Required or Optional DFL Driver? dfl-afu.ko AFU Driver drivers/fpga/dfl-afu.h Optional <p><code>dfl-afu-dma-region.c</code> (Upstream) provides DMA region management. It can pin/unpin pages in memory for transfers to occur, create/destroy/find DMA regions, and map/unmap regions of memory.</p> <p><code>dfl-afu-error.c</code> (Upstream) handles error reporting from the AFU / Port. It can mask/unmask port errors, clear errors, and show various errors associated with the AFU.</p> <p><code>dfl-afu-region.c</code> (Upstream) provides the portion of the driver responsible for MMIO Region Management. It can add/destroy MMIO regions, and find regions by offset or index.</p> <p><code>dfl-afu-main.c</code> (Upstream) handles management capabilities of the AFU / Port. It can enable/disable/reset AFU ports, open/close/probe access to AFU devices, and show the current state of the AFU's power consumption, <code>userclk</code> frequency, and AFU ID, and provides various other capabilities related to port management.</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#accelerator-functional-unit","title":"Accelerator Functional Unit","text":"<p>The AFU region is the region where a user can put their custom application logic.  It can optionally contain a Partial Reconfiguration region for dynamic workload updates.</p> <p></p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga.</p> <p>The Upstream source code for this driver can be found at [(https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga?h=master]((https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga?h=master).</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Create AFU MMIO Regions, DMAs</li> <li>Report on AFU related errors</li> <li>Create Memory Mappings and pin memory between device and host</li> </ul>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_AFU</p> <p></p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs that support an AFU region. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/","title":"Host Attach Memory Subsystem IP Driver","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#introduction","title":"Introduction","text":"<p>This driver is for the Memory Subsystem IP private feature implemented under FPGA Device Feature List (DFL) framework. It is used to expose memory interface status information as well as memory clearing control.</p> Driver Mapping Source(s) Required or Optional DFL Driver? dfl-emif.ko FPGA DFL EMIF Driver drivers/memory/dfl-emif.c Optional"},{"location":"linux-dfl/dfl_emif/dfl_emif/#agilex-7-f-series-and-i-series-fpga-memory-subsystem-ip","title":"Agilex 7 F-Series and I-Series FPGA Memory Subsystem IP","text":"<p>The memory subsystem IP is a high-level solution on top of the External Memory Interfaces Agilex\u00ae 7 FPGA IP, providing an easy way to instantiate up to 8 external memory interfaces (EMIFs) with application-level optimizations.  The memory subsystem IP provides the following components:</p> <ul> <li>Up to 8 lookup IP instances.</li> <li>Up to 8 EMIF instances.</li> <li>A memory controller that implements all the memory commands and protocol-level requirements.</li> <li>A soft logic adapter to boost memory throughput by traffic shaping.</li> </ul> <p>The memory subsystem supports DDR4 and DIMMs. For more information about this IP, please refer to the Agilex 7 F-Series and I-Series FPGA Memory Subsystem IP User Guide.</p> <p></p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#stratix-10-external-memory-interface","title":"Stratix 10 External Memory Interface","text":"<p>The External Memory Interfaces Stratix 10 FPGA IP provides an physical later interface which builds the data path and manages timing transfers between the FPGA and the memory device.  It also includes a memory controller which implements all the memory commands and protocol level requirements.  This IP supports a variety of memory types including DDR4, QDR-IV and DIMMs.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/memory/dfl-emif.c#L4</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/memory/dfl-emif.c?h=master.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Access status of memory calibration</li> <li>Memory clearing control</li> </ul>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_EMIF</p> <p></p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#example-designs","title":"Example Designs","text":"<p>This driver is used in the PCIe Attach shell designs for Agilex 7 and in the PCIe Attach shell design for Stratix 10 FPGA.  Please refer to the Open FPGA Documentation site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/","title":"Host Attach DFL FPGA Management Engine IP Driver","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#introduction","title":"Introduction","text":"<p>This set of drivers is designed to support FME functionality, as implemented under FPGA Device Feature List (DFL) framework. It is used to expose FME capabilities.</p> Driver Mapping Source(s) Required for DFL dfl-fme.ko FPGA Management Engine IP drivers/fpga/ - dfl-fme.h, dfl-fme-main.c, dfl-fme-pr.c, dfl-fme-error.c, dfl-fme-perf.c Y dfl-fme-mgr.ko PR IP drivers/fpga/dfl-fme-mgr.c N dfl-fme-br.ko SW Dependency drivers/fpga/dfl-fme-br.c N dfl-fme-region.ko SW Dependency drivers/fpga/dfl-fme-region.c N <pre><code>graph TD;\n    A[dfl-fme]--&gt;B[dfl-fme-mgr];\n    A[dfl-fme]--&gt;C[dfl-fme-br];\n    A[dfl-fme]--&gt;D[dfl-fme-region]; </code></pre>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#fpga-management-engine-ip","title":"FPGA Management Engine IP","text":"<p>The FPGA Management Engine IP provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA. Implementation of a PR region is optional.</p> <p>Each FME feature exposes its capability to host software drivers through a device feature header (DFH) register found at the beginning of its control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link. For more information about DFHs, refer to the Device Feature Header (DFH) structure.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for these drivers can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga, where branches labelled fpga-ofs-dev-*-lts correspond with the latest developmental versions of the DFL driver suite on that specific kernel version.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/fpga?h=master.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#driver-capabilities","title":"Driver Capabilities","text":"<p>This driver set is a DFL specific implementation of generic FPGA drivers available in the kernel. <code>dfl-fme-mgr</code> is a DFL specific instantiation of the generic FPGA manager (drivers/linux/fpga/fpga-mgr.c), <code>dfl-fme-br</code> builds on top of a generic FPGA bridge (drivers/fpga/fpga-bridge.c), and <code>dfl-fme-region</code> instantiates an FPGA region. All three supplementary DFL Drivers depend on <code>dfl-fme</code>.</p> <p>The DFL FME driver is a feature device implemented under the Device Feature List (DFL) framework. It enables the platform driver for the FME IP and implements all FPGA platform level management features. Only one FME is created per DFL based FPGA device. The DFL Bridge, Manager, and Region drivers are only required when attempting to configure a PR region in the FIM.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_FME</p> <p></p> <p>FPGA_DFL_FME_MGR</p> <p></p> <p>FPGA_DFL_FME_BRIDGE</p> <p></p> <p>FPGA_DFL_FME_REGION</p> <p></p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#example-designs","title":"Example Designs","text":"<p>The FPGA Management Engine IP is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/","title":"FPGA DFL NIOS Driver for Intel PAC N3000","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Arria 10 GX</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#introduction","title":"Introduction","text":"<p>This is the driver for the N3000 Nios private feature on Intel PAC (Programmable Acceleration Card) N3000. It communicates with the embedded Nios processor to configure the retimers on the card. It also instantiates the SPI master (spi-altera) for the card's BMC (Board Management Controller). It matches and probes based on the Nios private feature node on a DFL from an Intel N3000 device. This driver also depends on the generic DFL driver.</p> Driver Mapping Source(s) Required for DFL dfl-n3000-nios.ko FPGA DFL NIOS Driver for Intel PAC N3000 drivers/fpga/dfl-n3000-nios.c N"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl-n3000-nios.c#L4.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl-n3000-nios.c.</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Instantiate the SPI interface for an N3000</li> <li>Communicate with N3000 retimers</li> </ul>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_NIOS_INTEL_PAC_N3000</p> <p></p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/","title":"DFL PCI Express Subsystem IP Driver","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#introduction","title":"Introduction","text":"<p>This driver enables PCIe functionality for PCIe based FPGA solutions that implement the DFL. This driver provides interfaces for user-space applications to configure, enumerate, open and access FPGA accelerators on the FPGA DFL devices, enables system level management functions such as FPGA partial reconfiguration, power management and virtualization with DFL framework.</p> <p>The <code>dfl-pci</code> driver is a DFL specific instantiation of the generic <code>pci.ko</code> driver.</p> Driver Mapping Source(s) Required for DFL dfl-pci.ko FPGA DFL PCIe Device Driver drivers/fpga/dfl-pci.c Y"},{"location":"linux-dfl/dfl_pci/dfl_pci/#agilex-7-pcie-susbystem","title":"Agilex 7 PCIe Susbystem","text":"<p>The PCIe Subsystem is one of three subsystems supported by the OFS FIM. It contains configuration registers for the Vendor, Device and Subsystem Vendor IDs. These registers are used in PCIe add-in cards to uniquely identify the card for assignment to software drivers.</p> <p>The host-side PCIe SS supports PCIe Gen 4x16 speeds using an AXI-ST Data mover interface across a hardened P-Tile. Is natively supports multiple configurations - including 2 PFs, and 1 PF with multiple VFs. It contains optional support for DMA engines and Single-root I/O Virtualization (SR-IOV). Full documentation on the FPGA IP Subsystem for PCI Express IP User Guide can be found on the Open FPGA Stack Git site.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl-pci.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl-pci.c?h=master.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize DFL-enabled PCIe SS instances</li> <li>Probe for DFLs in PCIe BAR space, and enumerate their features</li> <li>Configure SR-IOV</li> </ul>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_PCI</p> <p></p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#example-designs","title":"Example Designs","text":"<p>The PCIe SS is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/","title":"Max\u00ae 10 Board Management Controller Driver","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <ul> <li><code>intel-m10-bmc-log</code> is not upstreamed.</li> </ul> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#introduction","title":"Introduction","text":"<p>This driver is designed to support the core functionality of the Max 10 Board Management Controller. It provides support for accessing the BMC, and supports all operations that are in turn supported by the BMC itself including configuring non-volatile FPGA flash, reading telemetry data, and remotely updating the FPGA and BMC images.</p> Driver Mapping Source(s) Required for DFL intel-m10-bmc-core.ko MAX 10 Board Management Controller drivers/mfd/intel-m10-bmc-core.c N intel-m10-bmc-pmci.ko MAX 10 Board Management Controller with PMCI drivers/mfd/intel-m10-bmc-pmci.c N intel-m10-bmc-spi.ko MAX 10 Board Management Controller with SPI drivers/mfd/intel-m10-bmc-spi.c N intel-m10-bmc-sec-update.ko MAX10 BMC Secure Update driver drivers/fpga/intel-m10-bmc-sec-update.c N intel-m10-bmc-hwmon.ko MAX10 BMC Hardware Monitoring drivers/hwmon/intel-m10-bmc-hwmon.c N <pre><code>graph TD;\n    A[intel-m10-bmc-core]--&gt;B[intel-m10-bmc-spi] \n    A[intel-m10-bmc-core]--&gt;C[intel-m10-bmc-pmci]\n    A[intel-m10-bmc-core]--&gt;E[intel-m10-bmc-hwmon]\n    A[intel-m10-bmc-core]--&gt;F[intel-m10-bmc-sec-update]</code></pre> <p><code>intel-m10-bmc-core</code> provides common code for the Board Management Controller chip. It polls the M10 handshake register, can access and update BMC CSRs, display version information, and read MAC statistics.</p> <p>Either <code>intel-m10-bmc-spi</code> or <code>intel-m10-bmc-pmci</code> are required for a given BMC, depending on which communication standard is supported by the board as provide by its DFH. D5005 uses SPI, Agilex 7 devices use PMCI. Both of these drivers assist in communicating across the connection between the FPGA fabric and the Max 10 by acting as a master device. As the SPI master the driver will covert SPI messages to Avalon transactions. Both drivers consume the common code present in <code>intel-m10-bmc-core</code>.</p> <p><code>intel-m10-bmc-hwmon</code> hooks into the generic Linux <code>hwmon</code> framework already present in the Kernel and instantiations the Max 10 BMC instance. This includes support for all on-board sensors for voltage, current, and temperature.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#board-management-controller","title":"Board Management Controller","text":"<p>The Board Management Controller (BMC) supports features such as board power management, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate Max\u00ae 10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver suite can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/, and under the <code>fpga</code>, <code>mfd</code>, and <code>hwmon</code> directories.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mfd?h=master.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Communicate with BMC handshake register, issue supported commands</li> <li>Read / write to BMC attached flash</li> <li>Register on-board sensors with kernel hwmon framework</li> </ul>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#kernel-configurations","title":"Kernel Configurations","text":"<p>MFD_INTEL_M10_BMC_CORE</p> <p></p> <p>MFD_INTEL_M10_BMC_SPI</p> <p></p> <p>MFD_INTEL_M10_BMC_PMCI</p> <p></p> <p>FPGA_M10_BMC_SEC_UPDATE</p> <p></p> <p>SENSORS_INTEL_M10_BMC_HWMON</p> <p></p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/","title":"Intel HSSI configurable ethernet phy driver","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#introduction","title":"Introduction","text":"<p>This is the Intel HSSI configurable ethernet phy driver. It provides the ability to view and change some of the transceiver tuner parameters for a QSFP interface on legacy D5005 designs.</p> Driver Mapping Source(s) Required for DFL intel-s10-phy.ko Intel HSSI configurable ethernet phy driver drivers/net/phy/intel-s10-phy.c N"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/fpga-ofs-dev-6.1-lts/drivers/net/phy/intel-s10-phy.c.</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Read and write XCVR status and statistics</li> </ul>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#kernel-configurations","title":"Kernel Configurations","text":"<p>INTEL_S10_PHY</p> <p></p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/","title":"Ethernet IEEE 1588 Time of Day Clock FPGA IP Driver for Host Attach","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#introduction","title":"Introduction","text":"<p>This page provides an overview of the Time-of-day driver for the Time of Day Clock FPGA IP that is used in the 1588PTP Design examples.  The Time of Day Clock FPGA IP is exposed as PTP Hardware Clock (PHC) device to the Linux PTP stack to synchronize the system clock to its ToD information using phc2sys utility of the Linux PTP stack.</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#time-of-day-clock-fpga-ip","title":"Time of Day Clock FPGA IP","text":"<p>The Time-of-day (TOD) Clock streams 96-bit and 64-bit time-of-day to one or more timestamping units in an IEEE 1588v2 solution. For information regarding this soft IP core, please refer to the Ethernet Design Example Components User Guide.</p> <p></p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/ptp/ptp_dfl_tod.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/ptp/ptp_dfl_tod.c?h=master.</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Reads and writes time in Time of Day timestamp registers.</li> <li>Performs fine and course clock offset adjustment.</li> <li>Periodic time drift adjustment.</li> <li>Only tested on Host attach Agilex 7</li> </ul>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_PTP_DFL_TOD</p> <p></p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/","title":"Memory Based QSFP Support Driver for Host Attach","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10, Arria 10 GX</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#introduction","title":"Introduction","text":"<p>This legacy driver builds on top of the QSFP Module and Ethernet IP drivers and enables them in a DFL design. This DFL-based driver will shadow the QSFP module's memory pages in memory. It leverages the core driver code from <code>qsfp-mem-core.ko</code>.</p> Driver Mapping Source(s) Required for DFL qsfp-mem-dfl.ko Memory Based QSFP Support for DFL drivers/net/phy/qsfp-mem-dfl.c N qsfp-mem-platform.ko Memory based QSFP support drivers/net/phy/qsfp-mem-platform.c N qsfp-mem-core.ko Memory based QSFP support drivers/net/phy/qsfp-mem-core.c N <pre><code>graph TD;\n    A[regmap-mmio]--&gt;B[qsfp-mem-core];\n    B[qsfp-mem-core]--&gt;C[qsfp-mem-platform];\n    B[qsfp-mem-core]--&gt;D[qsfp-mem-dfl];</code></pre>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/fpga-ofs-dev-6.1-lts/drivers/net/phy.</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probe and match the corresponding DFL Device</li> <li>Init a QSFP Device</li> <li>Send data over I2C</li> </ul>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>QSFP_MEM_CORE</p> <p></p> <p>QSFP_MEM</p> <p></p> <p>QSFP_MEM_DFL</p> <p></p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/s10hssi/s10hssi/","title":"Control Plane Driver for Stratix 10 HSSI","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#introduction","title":"Introduction","text":"<p>This driver provides control plane support for a Stratix 10 High Speed Serial Interface. The Stratix 10 High Speed Serial Interface provides a data path between the FPGA and the external QSFP interfaces. This data path does not involve packets transferred between host memory and the fpga. As such a very limited set of networking functionality is provided.</p> Driver Mapping Source(s) Required for DFL s10hssi.ko Control Plane Driver for Stratix 10 HSSI drivers/net/ethernet/s10hssi.c N"},{"location":"linux-dfl/s10hssi/s10hssi/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/fpga-ofs-dev-6.1-lts/drivers/net/ethernet/intel/s10hssi.c.</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Read and write XCVR status and statistics</li> <li>Set MAC address</li> <li>Enable loopback</li> </ul>"},{"location":"linux-dfl/s10hssi/s10hssi/#kernel-configurations","title":"Kernel Configurations","text":"<p>S10HSSI</p> <p></p>"},{"location":"linux-dfl/s10hssi/s10hssi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/","title":"Generic Serial Flash Interface Intel FPGA IP Driver","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#introduction","title":"Introduction","text":"<p>This driver is the DFL specific implementation of the Generic Serial Flash Interface Intel FPGA IP driver, which provides access to Serial Peripheral Interface (SPI) flash devices. This is a DFL bus driver for the Altera SPI master controller, which is connected to a SPI slave to Avalon bridge in an Intel Max10 BMC. It handles the probing for available DFL-enabled SPI devices, will initialize any discovered SPI devices, and allows you to read and write over an available interface. The driver supports writing both Configuration memory (configuration data for Active Serial configuration schemes) and General purpose memory. Generic Serial Flash Interface Intel\u00ae FPGA IP User Guide. This driver also depends on the generic DFL driver.</p> Driver Mapping Source(s) Required for DFL spi-altera-core.ko Altera SPI Controller core code drivers/spi/spi-altera-core.c N spi-altera-platform.ko Device Feature List Driver drivers/spi/spi-altera-platform.c N spi-altera-dfl.ko Device Feature List Driver drivers/spi/spi-altera-dfl.c N <pre><code>graph TD;\n    A[spi-altera-core]--&gt;B[spi-altera-platform];\n    A[spi-altera-core]--&gt;C[spi-altera-dfl];\n    D[dfl]--&gt;C[spi-altera-dfl]; </code></pre>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/spi.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl.c?h=master.</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Match and probe DFL-enabled SPI interfaces on the DFL</li> <li>Read / write into memory over a given interface</li> </ul>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>SPI_ALTERA</p> <p></p> <p>SPI_ALTERA_CORE</p> <p></p> <p>SPI_ALTERA_DFL</p> <p></p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/uart_16550/uart_16550/","title":"Altera 16550 Compatible UART Core Driver for Host Attach","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#introduction","title":"Introduction","text":"<p>This driver for the 16550 Compatible UART Core to establish TTY communications to FPGA through PCIe.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#16550-compatible-uart-core","title":"16550 Compatible UART Core","text":"<p>The 16550 UART (Universal Asynchronous Receiver/Transmitter) soft IP core with Avalon\u00ae interface is designed to be register space compatible with the de-facto standard 16550 found in the PC industry. The core provides RS-232 Signaling interface, False start detection, Modem control signal and registers, Receiver error detection and Break character generation/detection. The core also has an Avalon\u00ae Memory-Mapped ( Avalon\u00ae -MM) agent interface that allows Avalon\u00ae -MM host peripherals (such as Nios\u00ae II and Nios\u00ae V processors) to communicate with the core simply by reading and writing control and data registers. For information regarding this soft IP core, please refer to the Embedded Peripherals IP User Guide.</p> <p></p>"},{"location":"linux-dfl/uart_16550/uart_16550/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/tty/serial/8250/8250_dfl.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/serial/8250/8250_dfl.c?h=master.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Establishes serial connection with FPGA.</li> </ul>"},{"location":"linux-dfl/uart_16550/uart_16550/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SERIAL_8250_DFL</p> <p></p>"},{"location":"linux-dfl/uart_16550/uart_16550/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#example-designs","title":"Example Designs","text":"<p>This driver is used in the PCIe Attach shell designs for Agilex 7.  Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/","title":"Generic DFL driver for Userspace I/O devices","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Stratix 10</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#introduction","title":"Introduction","text":"<p>This DFL based driver provides direct access to DFL devices from userspace. A sample userspace application using this driver is available for download in a git repository: git clone https://github.com/OPAE/opae-sdk.git It can be found at: opae-sdk/libraries/libopaeuio/.</p> Driver Mapping Source(s) Required for DFL uio_dfl.ko Generic DFL driver for Userspace I/O devices drivers/uio/uio_dfl.c Y <pre><code>graph TD;\n    A[uio]--&gt;C[uio-dfl];\n    B[dfl]--&gt;C[uio-dfl];</code></pre>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/uio/uio_dfl.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/uio/uio_dfl.c.</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probe and match DFL UIO device(s)</li> </ul>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>UIO_DFL</p> <p></p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/apb_timers/apb_timers/","title":"General-Purpose Timers Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Device Supported: Agilex 5 , Agilex 7</p>"},{"location":"linux-embedded/drivers/apb_timers/apb_timers/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides four 32-bit general-purpose timers connected to the level 4 (L4) peripheral bus. The timers optionally generate an interrupt when the 32-bit binary count-down timer reaches zero.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/drivers/apb_timers/apb_timers/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/clocksource/dw_apb_timer.c.</p>"},{"location":"linux-embedded/drivers/apb_timers/apb_timers/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supports interrupt generation</li> <li>Supports free-running mode</li> <li>Supports user-defined count mode</li> </ul>"},{"location":"linux-embedded/drivers/apb_timers/apb_timers/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_APB_TIMER</p> <p></p>"},{"location":"linux-embedded/drivers/apb_timers/apb_timers/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/apb_timers/apb_timers/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/apb_timers/apb_timers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/","title":"Clock Manager Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: No</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#introduction","title":"Introduction","text":"<p>Hard Processor System (HPS) clock generation is centralized in the clock manager. The clock manager is responsible for providing software-programmable clock control to configure all clocks generated in the HPS. Clocks are organized into clock groups.</p> <p>A clock group is a set of clock signals that originate from the same clock source which may be synchronous to each other. The Clock Manager has a two Phase-Locked Loop (PLL) clock group where the clock source is a common PLL voltage-controlled oscillator (VCO). A clock group which is independent and asynchronous to other clocks may only have a single clock, also known as clock slice. Peripheral clocks are a group of independent clock slices.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#features","title":"Features","text":"<ul> <li>Generates and manages clocks in the HPS.</li> <li>Contains two flexible PLL blocks Main PLL and Peripheral PLL.</li> <li>Generates clock gate controls for enabling and disabling most of the clocks.</li> <li>Allows software to program clock characteristics.</li> <li>Supports interrupting the Cortex-A53 MPCore on PLL-lock and loss-of-lock.</li> </ul>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/clk/socfpga/clk-agilex5.c.</p>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Support to configure peripherals clock through common clock framework.</li> <li>Support to enable or disable software-managed clocks.</li> </ul>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_CLK_INTEL_SOCFPGA64</p> <pre><code>Symbol: CLK_INTEL_SOCFPGA64 [=n]\nType  : bool\nDefined at drivers/clk/socfpga/Kconfig:15\n  Prompt: Intel Stratix / Agilex / N5X clock / Agilex5 controller support\n  Depends on: COMMON_CLK [=y] &amp;&amp; CLK_INTEL_SOCFPGA [=n]\n  Visible if: COMMON_CLK [=y] &amp;&amp; CLK_INTEL_SOCFPGA [=n] &amp;&amp; COMPILE_TEST [=n] &amp;&amp; (!ARM64 || !ARCH_INTEL_SOCFPGA)\n  Location:\n    \u2192 Device Drivers\n(1)     \u2192 Common Clock Framework (COMMON_CLK [=y])\n        \u2192 Intel SoCFPGA family clock support (CLK_INTEL_SOCFPGA [=n])\n          \u2192 Intel Stratix / Agilex / N5X clock / Agilex5 controller support (CLK_INTEL_SOCFPGA64 [=n])\n</code></pre>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi <pre><code>clkmgr: clock-controller@10d10000 {\n    compatible = \"intel,agilex5-clkmgr\";\n    reg = &lt;0x10d10000 0x1000&gt;;\n    #clock-cells = &lt;1&gt;;\n};\n</code></pre></p> <p>Also dt-bindings can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/include/dt-bindings/clock/agilex5-clock.h</p>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#using-f2s_free_clk","title":"Using f2s_free_clk","text":"<p>When using the f2s_free_clk, you need to update the device tree to specify the frequency of the clock, as shown in the following example where 100MHz is specified:</p> <pre><code>f2s_free_clk: f2s-free-clk {\n            #clock-cells = &lt;0&gt;;\n            compatible = \"fixed-clock\";\n            clock-frequency = &lt;100000000&gt;;\n};\n</code></pre> <p>If you do not change the frequency of the f2s_free_clk in the device tree, the default value of 0 will be used, which means there is no clock coming from the fabric.</p>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/clock_manager/clock_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/dma/dma/","title":"Direct Memory Access Controller (DMAC) Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/dma/dma/#introduction","title":"Introduction","text":"<p>The DMAC driver supports two DMACs with a maximum of four channels each. This driver transfers data between memory and peripherals and other memory locations in the system.</p>"},{"location":"linux-embedded/drivers/dma/dma/#hps-direct-memory-access-controller-dmac","title":"HPS Direct Memory Access Controller (DMAC)","text":"<p>The DMAC is part of the Hard Processor System (HPS) of the FPGA.  The HPS provides two DMACs to handle the data transfer between memory-mapped peripherals and memories, off-loading this work from the MPU system complex. Some common features are listed below.</p> <ul> <li>Software programmable with dedicated register field</li> <li>Supports multiple transfer types</li> <li>Each DMAC channels supports four channels</li> <li>Each DMAC supports interrupt interface to the Generic Interrupt Controller (GIC)</li> <li>Supports up to 48 peripheral request interfaces</li> </ul> <p></p> <p>For more information please refer to the following guide: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"linux-embedded/drivers/dma/dma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c</p>"},{"location":"linux-embedded/drivers/dma/dma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>DMA bus width configuration</li> <li>Transaction configuration</li> <li>Interrupt control and handling</li> </ul>"},{"location":"linux-embedded/drivers/dma/dma/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_AXI_DMAC</p> <p></p>"},{"location":"linux-embedded/drivers/dma/dma/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the dma: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/dma/dma/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/dma/dma/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/edac/edac/","title":"Error Detection and Correction (EDAC) Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/edac/edac/#introduction","title":"Introduction","text":"<p>The Error Detection and Correction (EDAC) driver supports use of the Error Checking and Correction (ECC) Controller in the HPS.  The ECC controllers are implemented in the on-chip RAM, USB OTG 2.0 and 3.1 and Ethernet MACs in the HPS.  To find out more about the ECC controller please refer to the Hard Processor Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/drivers/edac/edac/#driver-sources","title":"Driver Sources","text":"<p>The source code for the driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/edac/altera_edac.c.</p>"},{"location":"linux-embedded/drivers/edac/edac/#driver-capabilities","title":"Driver Capabilities","text":"<p>The Error Detection and Correction (EDAC) driver comprises the ECC manager main component and sub-components of the supported EDAC SoC components.</p> <p>The driver's main functions are to register the EDAC platform drivers in Linux, initialize the EDAC sub-components by performing initial setup of the IRQ interrupt handlers and soft-error handling for uncorrected error events, and to support debugging features like soft-error injections and reads of the error counters.</p> <p>The data flow diagram of EDAC is shown below:</p> <p></p>"},{"location":"linux-embedded/drivers/edac/edac/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_EDAC_ALTERA</p> <p></p>"},{"location":"linux-embedded/drivers/edac/edac/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/edac/edac/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/emac/emac/","title":"Ethernet Media Access Controller (EMAC) Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/emac/emac/#introduction","title":"Introduction","text":"<p>The Ethernet Media Access Controller (EMAC) Driver controls initialization, configuration and traffic shaping of the three EMACs in the Hard Processor System (HPS).</p> Driver Capability /drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c Sets PHY layer configuration such as GMII, RGMII, RMII and speed. /drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c Obtains the features EMAC features supported to main driver /drivers/net/ethernet/stmicro/stmmac/stmmac_main.c Sets ethtool operations Initializes hardware Initializes traffic control Calls networking API (NAPI) Registers IP as netdev Initialize PHY, DMA, MAC Transaction Layer, Management MAC counters, Precision Time Protocol, Watchdog Timer, Ring Length, PCS protocol and TCP Segmentation Offload /drivers/net/ethernet/stmicro/stmmac/hwif.c Initializes hardware interface and obtains device ID and IP version /drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c Configures filters, link speed, MDIO/MII bus /drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c Provides bus interface for MII registers <p>The following group of drivers is required to support EMAC functionality:</p> <pre><code>graph TD;\n    A[dwmac-socfpga.c]--&gt;B[stmmac_platform.c];\n    B[stmmac_platform.c]--&gt;C[stmmac_main.c];\n    C[stmmac_main.c]--&gt;D[hwif.c]; \n    D[hwif.c]--&gt;E[dwxgmac2_core.c];\n    E[dwxgmac2_core.c]--&gt;F[stmmac_mdio.c];  </code></pre>"},{"location":"linux-embedded/drivers/emac/emac/#emac-ip","title":"EMAC IP","text":"<p>The hard processor system (HPS) provides three Ethernet media access controller (EMAC) peripherals. Each EMAC can be used to transmit and receive data at 10M/100M/1G/2.5G speeds over Ethernet connections in compliance with the IEEE 802.3-2018 specification and enable support for Time Sensitive Networking (TSN) applications.</p> <p>The EMAC has an extensive memory-mapped Control and Status Register (CSR) set, which can be accessed by the on-board Arm processors.</p> <p>The EMAC is an integration of the Synopsys Ethernet XGMAC IP with the SMTG hub and external memory. The EMAC can be accessed from HPS or FPGA fabric over an AXI interface. For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <ul> <li>IEEE 1588-2008 Advanced Timestamp: Precision Time Protocol (PTP), 2-steps, PTP offload and timestamping</li> <li>IEEE 802.1AS: Timing and synchronization</li> <li>IEEE 802.1Qav: Time-sensitive streams forwarding queuing</li> <li>The XGMAC supports the following features<ul> <li>Full-duplex operation at 10M/100M/1G/2.5 Gbps (GMII)</li> <li>Full-duplex RGMII support (10M/100M/1 G)</li> <li>Half-duplex operation in 10/100 Mbps modes</li> <li>Separate transmission, reception, and configuration (control and status register) interfaces to the application</li> <li>MDIO interface for multiple PHY devices and their configuration and management</li> <li>Programmable frame length, supporting standard or jumbo Ethernet frames up to 9 KB</li> </ul> </li> </ul> <p></p>"},{"location":"linux-embedded/drivers/emac/emac/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/net/ethernet/stmicro/stmmac/.  </p>"},{"location":"linux-embedded/drivers/emac/emac/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Set PHY layer configurations such as GMII, RGMII, RMII and speed.</li> <li>Initializes hardware, traffic control, calls networking API (NAPI), registers IP as netdev, initializes PHY, DMA, MAC Transaction Layer, Management MAC Counters, Precision Time Protocol, Watchdog Timer, Ring Length, PCS Protocol, and TCP Segmentation Offload.</li> <li>Initializes the hardware interface and obtains the device ID and IP version.</li> <li>Configures filters, link speed, MDIO/MII bus.</li> <li>Provides a bus interface for MII registers.</li> </ul>"},{"location":"linux-embedded/drivers/emac/emac/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_STMMAC_ETH</p> <p></p>"},{"location":"linux-embedded/drivers/emac/emac/#device-tree","title":"Device Tree","text":"<p>Example Device tree location: https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/emac/emac/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/emac/emac/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/gpio/gpio/","title":"General Purpose I/O Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5, Agilex 7</p>"},{"location":"linux-embedded/drivers/gpio/gpio/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides two General-Purpose I/O (GPIO) interface modules.</p> <p>The GPIO interface supports Digital debounce, configurable interrupt mode, and has up to 48 dedicated I/O pins. For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p>The figure below shows a block diagram of the GPIO interface:</p> <p></p>"},{"location":"linux-embedded/drivers/gpio/gpio/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpio/gpio-dwapb.c.</p>"},{"location":"linux-embedded/drivers/gpio/gpio/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>GPIO muxed between I2C and SPI.</li> <li>Interrupt propagation between the device and logic on board.</li> <li>Control other circuitry on board.</li> <li>Digital debounce.</li> <li>Configurable interrupt mode.</li> </ul>"},{"location":"linux-embedded/drivers/gpio/gpio/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_GPIO_DWAPB</p> <p></p>"},{"location":"linux-embedded/drivers/gpio/gpio/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/gpio/gpio/#test-procedure","title":"Test Procedure","text":"<p>In the following sub-sections are described  some common GPIO operations that are performed through the GPIO driver. These are exercised from the Linux shell once the GPIO driver has been probed. The test procedures are exercised using the /sys/class/gpio interface.</p> <p>This test procedure was exercised on Agilex 5 E-Series Premium Development Kit using the GSRD for HPS Enablement Board (booting from SD Card)  from 24.3.1 release which uses Linux Kernel 6.6.51.</p> <p>When the driver has been initialized you will se the following under this GPIO interface:</p> <pre><code>  ls /sys/class/gpio/\nexport  gpiochip512  gpiochip536  gpiochip560  gpiochip592  gpiochip624  unexport\n</code></pre> <p>NOTE: You can determine which GPIOs are available using the information provided by the gpiochipXYZ directories  included in the /sys/class/interface interface. Each one of the gpiochipXYZ represents a GPIO controller. In the following example you can see that the GPIO controller referred as gpiochip512 starts in the GPIO 512 and is extended to 24 pins going from 512 to 535 using the information provided by base and ngpio. You can also see which is the base address of this GPIO controller in the memory map using the information in label.</p> <pre><code>ls /sys/class/gpio/gpiochip512/          base       device/    label      ngpio      power/     subsystem/ uevent\ncat /sys/class/gpio/gpiochip512/base\n512\ncat /sys/class/gpio/gpiochip512/ngpio 24  cat /sys/class/gpio/gpiochip512/label 10c03200.gpio    </code></pre>"},{"location":"linux-embedded/drivers/gpio/gpio/#step-1-export-a-gpio-pin","title":"Step 1: Export a GPIO Pin","text":"<ol> <li> <p>Export a GPIO Pin: You export a pin to make it available to the user for control through the /sys/class/gpio/ interface. Use the <code>echo</code> command to export a GPIO pin. For example, to export GPIO pin 512:</p> <p><pre><code>echo 512 &gt; /sys/class/gpio/export\nls /sys/class/gpio\nexport    gpio512  gpiochip512  gpiochip536  gpiochip560  gpiochip592  gpiochip624  unexport\nls /sys/class/gpio/gpio512\nactive_low  device  direction  edge  power  subsystem  uevent  value\n</code></pre> Observe that once the pin has been export, a new interface named gpio512 is created. This provides additional interfaced under this that will help to configure, control and get information from this pin.</p> </li> <li> <p>Set Direction: Set the direction of the GPIO pin to either input or output. To set it as an output:</p> <pre><code>echo out &gt; /sys/class/gpio/gpio512/direction\n</code></pre> </li> </ol>"},{"location":"linux-embedded/drivers/gpio/gpio/#step-2-toggle-gpio-pin-value","title":"Step 2: Toggle GPIO Pin Value","text":"<ol> <li> <p>Write a Value: Write a value (either 0 or 1) to the GPIO pin. Set a value of 1:</p> <pre><code>echo 1 &gt; /sys/class/gpio/gpio512/value\n</code></pre> </li> <li> <p>Read the Value: Read back the current value of the GPIO pin.</p> <pre><code>cat /sys/class/gpio/gpio512/value\n</code></pre> </li> <li> <p>Toggle the value: Change the value to the opposite and verify it.</p> <pre><code>echo 0 &gt; /sys/class/gpio/gpio512/value\ncat /sys/class/gpio/gpio512/value\n</code></pre> </li> </ol>"},{"location":"linux-embedded/drivers/gpio/gpio/#step-3-unexport-the-gpio-pin","title":"Step 3: Unexport the GPIO Pin","text":"<ol> <li> <p>Unexport the GPIO Pin: After you are done, unexport the GPIO pin to free up resources.</p> <pre><code>echo 512 &gt; /sys/class/gpio/unexport\n</code></pre> </li> </ol>"},{"location":"linux-embedded/drivers/gpio/gpio/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/gpio/gpio/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/hssi/hssi/","title":"Ethernet Subsystem (HSSI) Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/drivers/hssi/hssi/#introduction","title":"Introduction","text":"<p>The Ethernet Subsystem FPGA IP driver acts as a bridge between the software operating in the HPS and the Ethernet Subsystem within the FPGA. It provides various levels of abstraction to simplify communication with the underlying Ethernet Subsystem IP. The Ethernet Subsystem driver exposes Ethernet <code>netdev</code> driver APIs that higher-level software layers can utilize to interact with the Ethernet Subsystem IP</p>"},{"location":"linux-embedded/drivers/hssi/hssi/#ethernet-subsystem-fpga-ip","title":"Ethernet Subsystem FPGA IP","text":"<p>The Ethernet Subsystem FPGA IP is a subsystem IP that includes a configurable, Media Access Control (MAC) and Physical Coding Sublayer (PCS) presenting a consistent interface to user logic. It consists of 20 ports. Depending on the tile chosen, each port is implemented based on either the Agilex\u00ae 7 E-Tile Hard IP for Ethernet FPGA IP Core or the F-Tile Hard IP for Ethernet FPGA IP core.</p> <p>This IP provides a seamless and fast way to instantiate a multi-port design, given that it integrates the required discrete Hard IP and Soft IP ingredients. Furthermore, the Subsystem IP provides a user interface to facilitate enabling required features and parameters of operation.</p> <p>For E-Tile, this subsystem IP provides Ethernet data rate profiles of 10Gbps, 25Gbps, and 100Gbps with optional RS-FEC and 1588 Precision Time Protocol (PTP). The subsystem also provides profiles for PCS, OTN, FlexE and CPRI.</p> <p>For F-Tile, this subsystem IP provides Ethernet data rate profiles of 10Gbps, 25Gbps, 40Gbps, 50Gbps, 100Gbps, 200Gbps, and 400Gbps with optional RS-FEC and 1588 Precision Time Protocol (PTP). Quartus\u00ae Prime software version 23.2 supports only Media Access Control (MAC) and Physical Coding Sublayer (PCS) sub-profile.</p> <p>For more information please refer to the Ethernet Subsystem FPGA IP User Guide.</p> <p></p>"},{"location":"linux-embedded/drivers/hssi/hssi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_fpga_hssiss.c</p>"},{"location":"linux-embedded/drivers/hssi/hssi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Get Link state.</li> <li>Get MAC stats. These abstractions are used by the HSSI ethernet netdev driver to provide ethernet functionality to the above layers.</li> </ul>"},{"location":"linux-embedded/drivers/hssi/hssi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_HSSISS</p> <p></p>"},{"location":"linux-embedded/drivers/hssi/hssi/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the HSSI:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/hssi/hssi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/hssi/hssi/#example-designs","title":"Example Designs","text":"<p>HSSI SS driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/drivers/hssi/hssi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/","title":"Ethernet Subsystem Intel FPGA IP Tile Specific Ethernet MAC Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#introduction","title":"Introduction","text":"<p>The Ethernet MAC driver is used to manage the configuration parameters of the particular tile. It currently supports F-tile and E-tile of the Ethernet Subsystem Intel FPGA IP</p>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#f-tile-and-e-tile-fpga-ip","title":"F-tile and E-tile FPGA IP","text":"<p>To get more information on F-tile Hard IP please refer to the F-tile Architecture and PMA and FEC Direct PHY IP User Guide.</p> <p>And for E-tile Hard IP please refer to the E-Tile Hard IP User Guide: E-Tile Hard IP for Ethernet and E-Tile CPRI PHY IPs.</p>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#driver-sources","title":"Driver Sources","text":"<p>The source code to generate <code>intel_fpga_hssi_xtile.o</code> can be found at the following directory location:</p> <p>https://github.com/altera-opensource/linux-socfpga/tree/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera</p> <pre><code>graph TD;\n    A[intel_fpga_hssi_xtile.o]--&gt;B[intel_fpga_eth_main.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;C[intel_fpga_hssi_etile_fec.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;D[intel_fpga_etile_driver.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;E[intel_fpga_hssi_etile_ethtool.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;F[intel_fpga_ftile_driver];\n    A[intel_fpga_hssi_xtile.o]--&gt;G[intel_fpga_hssi_ftile_fec.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;H[intel_fpga_hssi_ftile_ethtool.c];</code></pre>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>To set the tile specific parameters, like enable support for interrupts, DMA and also the ethtool related configuration.</li> </ul>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_HSSI_XTILE</p> <p></p>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#device-tree","title":"Device Tree","text":"<p>Example of Device tree location to configure the hssi_xtile: </p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#example-designs","title":"Example Designs","text":"<p>HSSI xtile (E-tile/F-tile) driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP </p> <p></p>"},{"location":"linux-embedded/drivers/hssi_xtile/hssi_xtile/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/hwmon/hwmon/","title":"Altera\u00ae Hardware Monitor Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status:  Not Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5, Agilex 7</p>"},{"location":"linux-embedded/drivers/hwmon/hwmon/#introduction","title":"Introduction","text":"<p>The devices in which this driver is supported provide you with on-chip voltage and temperature sensors. You can use these sensors to monitor on-chip operation conditions such as the internal power rail and on-chip junction temperature. Some of the sensors also allow you the measure external voltages.</p> <p>The sensor monitoring system in the secure device manager (SDM) is in charge of sampling signals and keeping the latest digital value for each sensor available,  so this data can be provided under request. You can read the voltage and temperature values in the SDM by using the Mailbox Client FPGA IP or the Mailbox Client with Avalon\u00ae Streaming Interface Intel\u00ae FPGA IP.</p> <p>The Hard Processor System (HPS) is also capable of retrieve the voltage and temperature levels from the HPS-to-SDM mailbox. The Linux driver performs all the operations needed to facilitate the access to the sampled values from the sensors from the user space.</p> <p></p>"},{"location":"linux-embedded/drivers/hwmon/hwmon/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/HEAD/drivers/hwmon/soc64-hwmon.c</p>"},{"location":"linux-embedded/drivers/hwmon/hwmon/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>The driver is supported by the Linux Kernel hardware monitor framework.</li> <li>Identification of meassurement points for voltage and temperature (i.e. sensor location) are defined through device tree nodes. Up to 16 sensors for each one can be defined.</li> <li>The driver registers each one of the meassurement point as a device under /sys/class/hwmon/hwmon0. The voltage and temperature value is avaiable in the User space through the reading of the corresponding file.</li> <li>The driver performs an ATF SVC call to ask for the value in certain sensor identified through a parameter. The ATF interacts with SDM to ask for this value and once it gets it, this forwards the value to the driver.</li> <li>Voltage values are converted to mV (millivolts) while temperature values are provided in mC (milliCelsius).</li> </ul>"},{"location":"linux-embedded/drivers/hwmon/hwmon/#detailed-description","title":"Detailed Description","text":"<p>The Hardware Monitor Linux driver allows you to read from the user space the voltage and temperature values from the on-chip sensors. These sensors are located at specific locations in the SoC so an application can monitor them either to observe the current state of the device or identify any possible fail condition. In Agilex\u2122 7 and Agilex\u2122 5 devices is possible also to use some of the sensors to monitor external signals.</p> <p>The diagram below describes the components that are involved on the voltage and temperature monitor system in the SoC and the also the software flows related to this process. The diagram is described in detail next.</p> <p></p> <ol> <li> <p>There are voltage and temperature sensors in different locations of the SoC. The sensors and their locations are defined  in the device corresponding Power Management User Guide (Sensor Monitoring System chapter).  The SoC also includes ADCs  used to sample these variables and convert them to a digital value. The SDM is in charge of the sampling of the voltage and temperature signals and also convert them to a meaningful digital value using a reference voltage. This sampling is performed constantly and the corresponding last digital value is always available in case any agent request this to the SDM.</p> <p>NOTE: The temperature sensors in the SoC are active only if the corresponding location is also active in the device. For example, sensors in the core fabric are only available if the core fabric has been programed. The same case for sensors in the tiles, they will become active only if they has been instantiated in the design. The sensor in the SDM is always available. </p> </li> <li> <p>In the Linux side, the Altera\u00ae hardware monitor driver (drivers/hwmon/soc64-hwmon.c) performs the following actions:</p> <ul> <li> <p>Parses the device tree to identify the nodes for each one of the sensors described. Up to 16 voltage sensors and 16 temperature sensors can be defined. The sensor nodes are defined under firmware &gt;&gt; svc &gt;&gt; hwmon &gt;&gt; temperature and firmware &gt;&gt; svc &gt;&gt; hwmon &gt;&gt;  voltage nodes respectively. The driver, supported by the hardware monitor framework (drivers/hwmon/hwmon.c), creates a device (seen as a file) under /sys/class/hwmon/hwmon0 for each one of these nodes defined in the device tree. These devices are accessible from the user space and reading them corresponds to reading the lecture from the corresponding sensor. The driver also creates a file/device to identify the corresponding sensor returning the name of the sensor (referred as label). The following table describes the format of the device name created and also the starting index of these devices.</p> Sensor type Device name (value) Device name (identifier) Starting index Voltage inX_input inX_label 0 Temperature tempX_input tempX_label 1 <p>The following image shows an example of the device created when defining 9 voltage sensors and 15 temperature sensors. </p> <p>Refer to the Device Tree section for more information about the sensor definition in the device tree.</p> </li> </ul> <ul> <li>As indicated earlier, the SDM is in charge of capturing the voltage and temperature levels from the sensors. The Linux driver performs the voltage read operation through the soc64_read() function which uses SVC (service client) call to the ATF to ask this to request to the SDM the current value of a specific sensor. The driver indicates to the SVC if it wants to read a voltage or a temperature through a command (COMMAND_HWMON_READTEMP or COMMAND_HWMON_READVOLT). It also specifies which of the sensors need to be read using an argument in the SVC message. The driver obtains this argument information about the sensor to read from the reg field in the corresponding sensor node in the device tree (refer to Device Tree section for more information about this). Once the SVC message is sent, the driver waits for a response from the ATF. This response includes the value of the voltage or temperature that was returned by the SDM. The driver do some additional conversion so the value that this returns is in milli Celsius(mC) for temperature and milli Volts (mV) for voltage. The value that this function returns is the actual value that you will observe from the inX_input or tempX_input device under /sys/class.     </li> </ul> </li> <li> <p>In the ATF side, the SVC message sent by the Linux driver to request the reading of a temperature or voltage level is received by the SIP SMC handler, sip_smc_handler_V1(). This handler process the incoming command to identify if  voltage or temperature read is requested. Following the software flow, the ATF converts the SVC message into a HPS to SDM mailbox message (MBOX_HWMON_READTEMP and MBOX_HWMON_READVOLT) to request the SDM to provide the latest temperature or voltage sample taken. Once that the SDM responds to this request, the ATF also responds to the SVC message with the signal level provided by the SDM.</p> </li> <li>As indicated earlier, the SDM already has available the latest value of temperature of voltage of all the sensors, so when it receives the mailbox request from ATF to provide the latest value taken from any of the sensors, the SDM just responds the mailbox message with the value requested.</li> </ol>"},{"location":"linux-embedded/drivers/hwmon/hwmon/#kernel-configurations","title":"Kernel Configurations","text":"<p>In order to include into the Linux kernel the hardware monitor and all the components required for the voltage and temperature monitor system, the following Kernel configurations are required:</p> Kernel Configuration Description CONFIG_HWMON=y This enables the build and inclusion into the Linux kernel of the hardware monitor kernel framework (drivers/hwmon/hwmon.c) CONFIG_SENSORS_SOC64=y This enables the build inclusion into the Linux kernel of the Altera\u00ae hardware monitor driver to read temperature and voltage from the on-chip sensors (drivers/hwmon/soc64-hwmon.c). CONFIG_INTEL_STRATIX10_SERVICE=y This enables the build and inclusion into the Linux kernel of the SVC service client support needed to used the ATF resident software( /drivers/firmware/stratix10-svc.c)."},{"location":"linux-embedded/drivers/hwmon/hwmon/#device-tree","title":"Device Tree","text":"<p>The Altera\u00ae hardware monitor driver relies on the definition of the temperature and voltage sensors in the device tree. Up to 16 sensors of each type can be defined in the device tree. Since there is dependency on the SVC services to get the value of the sampled data from the sensors, the voltage and temperature nodes need to be defined  under svc node. The Linux driver is probed using the \"intel,soc64-hwmon\" compatible statement, so a child node for the hardware monitor is defined and under these the voltage and temperature nodes are defined. An example of the structure is shown next:</p> <pre><code>firmware {\nsvc {\ncompatible = \"intel,agilex5-svc\";\n:\n              temp_volt: hwmon {\ncompatible = \"intel,soc64-hwmon\";\n};\n};\n:\n&amp;temp_volt {\ntemperature {\n#address-cells = &lt;1&gt;;\n#size-cells = &lt;0&gt;;\n&lt;temperature node&gt;\n          &lt;temperature node&gt;\n          :\n          &lt;temperature node&gt;\n\n};\nvoltage {\n#address-cells = &lt;1&gt;;\n#size-cells = &lt;0&gt;;\n&lt;voltage node&gt;\n         &lt;voltage node&gt;\n         :\n         &lt;voltage node&gt;\n      };              };\n</code></pre> <p>The format of the node is shown next: <pre><code>  input@sensor_id_value {\nlabel = \"sensor_name\";\nreg = &lt;sensor_id_value&gt;;\n};\n</code></pre> Each one of the sensors nodes requires the following fields:</p> Field Description label Name of the sensor. The name may be related to the voltage that is being meassured or the location of the temperature sensor that is being meassured.  This text will be the one displayed when reading /sys/class/hwmon/hwmon0/_label. reg This is a 32-bit value that is used to identify the sensor to which the node corresponds to. The format of this identifier may varies depending on the type of sensor. In the case of voltage sensors the value indicates the ADC channel to read (0, 1, 2 ,3, etc.). For temperature sensors the value is composed by the sensor location (bits 31:16, values 0,1,2,3, etc.) and the sensor number in that location (bits 15:0, values 0,1,2,3,...). The driver converts the value in reg to the appropriate value that needs to be sent to the ATF and later to the SDM to read the sensor value.    For more information about the sensor identification please refer to the device corresponding Power Management User Guide (Sensor Monitoring System chapter). <p>You can refer to the following example in which the Agilex\u2122 5 Linux device tree is patch to observe how some voltage and temperature nodes are defined under the hwmon node: Example of sensors nodes definition for Agilex\u2122 5</p>"},{"location":"linux-embedded/drivers/hwmon/hwmon/#reading-of-voltage-and-temperature-sensors-from-user-space","title":"Reading of Voltage and Temperature Sensors from User Space","text":"<p>The following Shell script shows an example about how the voltage and temperature from the sensors defined in the device tree can be read from the user space by reading the value and label from the devices created under /sys/class/hwmon/hwmon0/. This was executed in an Agilex\u2122 5 Premium Devkit. In this example 9 voltage sensors and 15 temperature sensors were defined in the device tree. In the example the cat command is used to get the value of the voltage/temperature value.</p> <p><pre><code>#!/bin/bash\necho \"Voltage Sensors:\" for i in 0 1 2 3 4 5 6 7 8\ndo\nvalPath=\"/sys/class/hwmon/hwmon0/in${i}_input\"\nlabelPath=\"/sys/class/hwmon/hwmon0/in${i}_label\"\nval=$(cat $valPath)\nlabel=$(cat $labelPath)        echo \"Sensor: ${i} ${label}: ${val} mv\"    done\necho \"Temperature Sensors:\" for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\ndo\nvalPath=\"/sys/class/hwmon/hwmon0/temp${i}_input\"\nlabelPath=\"/sys/class/hwmon/hwmon0/temp${i}_label\"\nval=$(cat $valPath)\nlabel=$(cat $labelPath)        echo \"Sensor: ${i} ${label}: ${val} mC\" done\n</code></pre> The output of the script is shown next:</p> <pre><code>root@agilex5_dk_a5e065bb32aes1:~# ./readSensors Voltage Sensors:\nSensor: 0 VSIGP: 1 mv\nSensor: 1 VSIGN: 0 mv\nSensor: 2 VCC: 693 mv\nSensor: 3 VCCIO_SDM: 1800 mv\nSensor: 4 VCCPT: 1800 mv\nSensor: 5 VCCRCORE: 1208 mv\nSensor: 6 VCCH_SDM: 924 mv\nSensor: 7 VCCL_SDM: 694 mv\nSensor: 8 VCCADC: 1816 mv\nTemperature Sensors:\nSensor: 1 SDM: 32125 mC\nSensor: 2 LOWER LEFT MAX: 42500 mC\nSensor: 3 LOWER LEFT CORNER: 42500 mC\nSensor: 4 LOWER LEFT XCVR 2: 26125 mC\nSensor: 5 LOWER LEFT XCVR 3: 26125 mC\nSensor: 6 LOWER LEFT CENTER: 25750 mC\nSensor: 7 LOWER RIGHT MAX: 42500 mC\nSensor: 8 LOWER RIGHT CORNER: 42875 mC\nSensor: 9 LOWER RIGHT XCVR 2: 25500 mC\nSensor: 10 LOWER RIGHT XCVR 3: 25750 mC\nSensor: 11 UPPER RIGHT MAX: 43125 mC\nSensor: 12 UPPER RIGHT CORNER: 43125 mC\nSensor: 13 UPPER RIGHT XCVR 3: 26750 mC\nSensor: 14 UPPER RIGHT CENTER: 26375 mC\nSensor: 15 HPS: 27000 mC   </code></pre>"},{"location":"linux-embedded/drivers/hwmon/hwmon/#known-issues","title":"Known Issues","text":"<ul> <li>At the moment of the writing of this page, in Agilex\u2122 5, the Altera hardware monitor driver is being probed twice. The first time it fails since the SVC driver has not been initialized yet. By the time the SVC driver is initialized, the hardware monitor is probed again, succeeding this time.</li> </ul>"},{"location":"linux-embedded/drivers/hwmon/hwmon/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/i2c/i2c/","title":"I2C Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5, Agilex 7</p>"},{"location":"linux-embedded/drivers/i2c/i2c/#introduction","title":"Introduction","text":"<p>The I2C controller provides support for a communication link between integrated circuits on a board. It is a simple two-wire bus which consists of a serial data line (SDA) and a serial clock (SCL).</p> <p>The hard processor system (HPS) provides five I2C controllers to enable system software to communicate serially with I2C buses. Each I2C controller can operate in master or slave mode and support standard mode of up to 100 Kbps or fast mode of up to 400 Kbps. These I2C controllers are instances of the Synopsys DesignWare controller.</p> <p>Each I2C controller must be programmed to operate in either master or slave mode only. Operating as a master and slave simultaneously is not supported.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/drivers/i2c/i2c/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/i2c/busses.</p> <pre><code>graph TD;\n    A[i2c-core-base]--&gt;B[i2c_designware_core];\n    B[i2c_designware_core]--&gt;C[i2c_designware_master]\n    C[i2c_designware_master]--&gt;E[i2c_designware_slave]</code></pre>"},{"location":"linux-embedded/drivers/i2c/i2c/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the communication for I2C Master buses as well as Slave.</li> <li>Handle the data transfer between connected devices over the I2C bus.</li> </ul>"},{"location":"linux-embedded/drivers/i2c/i2c/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_I2C_DESIGNWARE_CORE</p> <p></p> <p>CONFIG_I2C_DESIGNWARE_SLAVE</p> <p></p>"},{"location":"linux-embedded/drivers/i2c/i2c/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the i2c:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/i2c/i2c/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/i2c/i2c/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/i3c/i3c/","title":"I3C Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/i3c/i3c/#introduction","title":"Introduction","text":"<p>The I3C controller device driver only supports running as a master. The main master is a specialized master that comes up after power-on-reset, and is responsible for assigning dynamic addresses to the I3C devices. The secondary master is an I3C instance capable of both master and slave functionality. It comes up as a slave upon power-on-reset. The secondary master must get ownership of the I3C bus to become a current master before initiating any transfer to its associated slaves.</p> <p>I3C slave controller is not supported. The latest Linux kernel does not support the slave I3C framework.</p> <p>I3C master controller slave DMA is not be supported even though I3C also supports external DMA. The latest Linux kernel does not support DMA.</p>"},{"location":"linux-embedded/drivers/i3c/i3c/#i3c-fpga-ip","title":"I3C FPGA IP","text":"<p>The I3C interface is a high-bandwidth bus interface for connecting peripherals to HPS. The I3C interface is intended to improve upon the features of the I2C interface, while preserving backward compatibility. This interface is targeted for applications such as event camera sensors which require I3C interface capability.</p> <p>The hard processor system (HPS) provides two I3C controllers to enable system software to communicate serially with I3C buses. For information regarding this soft IP core, please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/drivers/i3c/i3c/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/i3c/master/dw-i3c-master.c.</p>"},{"location":"linux-embedded/drivers/i3c/i3c/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configure the I3C Controller driver at system boot-up.</li> <li>Provide support for device detection and enumeration for compatible I3C devices.</li> <li>Support the Dynamic address assignment.</li> </ul>"},{"location":"linux-embedded/drivers/i3c/i3c/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_I3C</p> <p></p>"},{"location":"linux-embedded/drivers/i3c/i3c/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the I3C:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/i3c/i3c/#known-issues","title":"Known Issues","text":"<ul> <li>I3C slave controller shall not be supported. The latest Linux kernel does not support the slave i3c framework.</li> <li>I3C master controller slave DMA shall not be supported even-though I3C also supports external DMA. The latest Linux kernel does not support DMA</li> </ul>"},{"location":"linux-embedded/drivers/i3c/i3c/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/interrupt_controller_GICv3/irq_gic_v3/","title":"Interrupt controller (GICv3) Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/interrupt_controller_GICv3/irq_gic_v3/#introduction","title":"Introduction","text":"<p>The interrupt controller driver handles general initialization of the interrupt controller in the HPS.</p> <p>The Arm\u00ae Generic Interrupt Controller (GIC) handles interrupts from peripherals to the cores and between cores. To find out more about the features and functions of the GIC controller, please refer to Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/drivers/interrupt_controller_GICv3/irq_gic_v3/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/irqchip/irq-gic-v3.c</p>"},{"location":"linux-embedded/drivers/interrupt_controller_GICv3/irq_gic_v3/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configure the GICv3 interrupt controller hardware during system boot-up.</li> <li>Handles interrupts generated by various sources in the system.</li> <li>Routes interrupt from their sources to the appropriate CPU cores.</li> <li>Provides generic API to manage interrupts.</li> <li>Support distributed interrupts across multiple GIC instances.</li> </ul>"},{"location":"linux-embedded/drivers/interrupt_controller_GICv3/irq_gic_v3/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ARM_GIC_V3</p> <p></p> <p>CONFIG_ARM_GIC_V3_ITS</p> <p></p>"},{"location":"linux-embedded/drivers/interrupt_controller_GICv3/irq_gic_v3/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the irq_gic_v3:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/interrupt_controller_GICv3/irq_gic_v3/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/interrupt_controller_GICv3/irq_gic_v3/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/msgdma/msgdma/","title":"A Modular Scatter-Gather DMA (mSGDMA) Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/drivers/msgdma/msgdma/#introduction","title":"Introduction","text":"<p>In a processor subsystem, data transfers between two memory spaces can happen frequently. In order to offload the processor from moving data around a system, a Direct Memory Access (DMA) engine is introduced to perform this function instead. The Modular Scatter-Gather DMA (mSGDMA) is capable of performing data movement operations with preloaded instructions, called descriptors. Multiple descriptors with different transfer sizes, and source and destination addresses have the option to trigger interrupts.</p>"},{"location":"linux-embedded/drivers/msgdma/msgdma/#msgdma-fpga-ip","title":"mSGDMA FPGA IP","text":"<p>The mSGDMA provides three configuration structures for handling data transfers: between the Avalon-MM to Avalon-MM, Avalon-MM to Avalon-ST, and Avalon-ST to Avalon-MM. The sub-core of the mSGDMA is instantiated automatically according to the structure configured for the mSGDMA use model. For more information on MSGDMA IP core please refer to https://www.intel.com/content/www/us/en/docs/programmable/683130/23-1/modular-scatter-gather-dma-core.html.</p>"},{"location":"linux-embedded/drivers/msgdma/msgdma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/dma/altera-msgdma.c</p>"},{"location":"linux-embedded/drivers/msgdma/msgdma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage multiple DMA channels provided by the MSGDMA IP core.</li> <li>Provides support for interrupt handling.</li> <li>Provides support for Scatter-gather DMA operation through a set of buffer descriptors.</li> <li>Data transfer to non-contiguous memory space.</li> </ul>"},{"location":"linux-embedded/drivers/msgdma/msgdma/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ALTERA_MSGDMA</p> <p></p>"},{"location":"linux-embedded/drivers/msgdma/msgdma/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/msgdma/msgdma/#example-designs","title":"Example Designs","text":"<p>Moified version of MSGDMA driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP and also the source code is available at https://github.com/altera-opensource/linux-socfpga/tree/socfpga-6.1.55-lts/drivers/net/ethernet/altera.</p> <p></p>"},{"location":"linux-embedded/drivers/msgdma/msgdma/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/nand/nand/","title":"NAND Flash Controller Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/nand/nand/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides a NAND Flash controller to interface with external NAND Flash memory in Intel system-on-a-chip (SoC) systems. External Flash memory can be used to store software, or as extra storage capacity for large applications or user data. For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"linux-embedded/drivers/nand/nand/#features","title":"Features","text":"<ul> <li>The triple-level cell (TLC) devices are supported only in parts that are compatible with the ONFI specification</li> <li>Supports three operation modes that make the controller easy to operate while also providing enough flexibility to be adapted to your project's needs.</li> <li>Supports DMA data transfer which optimizes the transfer rate for read and write operations using DMA primary and DMA secondary interfaces.</li> <li>Supports devices with page sizes up to 64 KB.</li> <li>Support up to 8 operation threads that can be executed in parallel.</li> <li>Provides data buffering where necessary in order to achieve maximum performance.</li> </ul>"},{"location":"linux-embedded/drivers/nand/nand/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mtd/nand/raw/cadence-nand-controller.c.</p>"},{"location":"linux-embedded/drivers/nand/nand/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialization and configuration of the NAND controller hardware.</li> <li>Determine the characteristics like page size and block size.</li> </ul>"},{"location":"linux-embedded/drivers/nand/nand/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MTD_NAND_CADENCE</p> <p></p>"},{"location":"linux-embedded/drivers/nand/nand/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/nand/nand/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/nand/nand/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/","title":"Ethernet 1588 PTP Time of Day Clock IP Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#introduction","title":"Introduction","text":"<p>The driver for the Ethernet 1588 PTP Time of Day Clock FPGA IP is used in the 1588 PTP Design examples provided by Altera. The Time of Day Clock FPGA IP is exposed as a PTP Hardware Clock (PHC) device to the Linux PTP stack to synchronize the system clock to its ToD information using <code>phc2sys</code> utility in the Linux PTP stack.</p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#time-of-day-clock-fpga-ip","title":"Time of Day Clock FPGA IP","text":"<p>The Time-of-day (TOD) Clock streams 96-bit and 64-bit time-of-day to one or more time stamping units in an IEEE 1588v2 solution. For information regarding this soft IP core, please refer to the Ethernet Design Example Components User Guide.</p> <p></p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_fpga_tod.c.</p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Registers PTP clock driver to kernel</li> <li>Calculates the ToD of clock offset adjustments</li> </ul>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_TOD</p> <p></p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the TOD:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#example-designs","title":"Example Designs","text":"<p>This driver is used in the Agilex 7 SoC F-Tile Design Example for 25GbE and 10GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/drivers/ptp_tod/ptp_emb_tod/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/qsfp/qsfp/","title":"QSFP Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/drivers/qsfp/qsfp/#introduction","title":"Introduction","text":"<p>The QSFP driver is responsible for interacting with the onboard QSFP module. It reads the QSFP Serial Electrically Erasable Programmable Read-Only Memory (SEEP) and controls the power and interrupt pins of the QSFP.</p>"},{"location":"linux-embedded/drivers/qsfp/qsfp/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/phy/qsfp.c.</p>"},{"location":"linux-embedded/drivers/qsfp/qsfp/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Registers QSFP driver to kernel.</li> <li>Reads the registers through the I2C bus and provide information to high level software stack.</li> </ul>"},{"location":"linux-embedded/drivers/qsfp/qsfp/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_QSFP</p> <p></p>"},{"location":"linux-embedded/drivers/qsfp/qsfp/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_10g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/qsfp/qsfp/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/qsfp/qsfp/#example-designs","title":"Example Designs","text":"<p>This driver is used in the Agilex 7 SoC F-Tile Design Example for 25GbE and 10GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/drivers/qsfp/qsfp/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/qspi/qspi/","title":"QSPI Driver for Hard Processor System (HPS)","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/qspi/qspi/#introduction","title":"Introduction","text":"<p>The Quad Serial Peripheral Interface (QSPI) driver manages the QSPI controller in the HPS.  The QSPI has the capability to access serial NOR Flash connected to the Secure Device Manager (SDM) QSPI. The QSPI controller supports standard SPI Flash devices as well as high-performance dual and quad SPI Flash devices. The QSPI controller module features are:</p> <ul> <li>SPIx1, SPIx2, or SPIx4 (QSPI) serial NOR flash devices</li> <li>Supported clock frequencies up to 166 MHz</li> <li>Direct access and indirect access modes</li> <li>Single I/O, dual I/O, or quad I/O instructions</li> <li>Up to four chip selects</li> <li>Configurable clock polarity and phase</li> <li>Programmable write-protected regions</li> <li>Programmable delays between transactions</li> </ul> <p>To find out more about the QSPI controller within the HPS please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual. </p>"},{"location":"linux-embedded/drivers/qspi/qspi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configuration of the QSPI controller.</li> <li>Handles data transfer and address.</li> </ul>"},{"location":"linux-embedded/drivers/qspi/qspi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/spi/spi-cadence-quadspi.c.</p>"},{"location":"linux-embedded/drivers/qspi/qspi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SPI_CADENCE_QUADSPI</p> <p></p> <p>In Linux you can select the QSPI erase sector size to be 4 KB or 64 KB using CONFIG_MTD_SPI_NOR_USE_4K_SECTORS config:</p> <ul> <li>CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=Y  indicates a Erase sector size of 4 KB.</li> <li>CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=N  indicates a Erase sector size of 64 KB.</li> </ul>"},{"location":"linux-embedded/drivers/qspi/qspi/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/qspi/qspi/#test-procedure","title":"Test Procedure","text":"<p>The following test procedure consist on performing erase, write and read operations into the QSPI flash device using the mtd_debug Linux application, which is included as part of the GSRD.</p> <p>Note: In the Bootloaders build flow (building the software components independently),  the mtd_debug application is supported by including the mtd-utils package in CORE_IMAGE_EXTRA_INSTALL when building the file system. In this build flow, you also need to configure the Linux QSPI reference clock from U-Boot by running \"run  linux_qspi_enable\" after that the Linux device tree has been loaded.</p> <p>As additional pre-requisites  to exercise this test procedure, you need to get enabled the QSPI controller enabled, Linux has booted  and this has loaded the QSPI driver. </p> <p>You can verify that the driver has been loaded by looking for messages from the QSPI driver in the boot log:</p> <pre><code>root@testsocfpga:~# dmesg | grep spi\n[    1.540541] cadence-qspi 108d2000.spi: detected FIFO depth (1024) different from config (128)\n[    1.550670] 2 fixed-partitions partitions found on MTD device 108d2000.spi.0\n[    1.557731] Creating 2 MTD partitions on \"108d2000.spi.0\":\n</code></pre> <p>Observe that the 0x108d2000 address corresponds to the address of the QSPI controller in Agilex 5 device.</p> <ol> <li>List the MTD partitions and verify these exist in the Linux file system:    <pre><code>root@testsocfpga:~# cat /proc/mtd\ndev:    size   erasesize  name\nmtd0: 04200000 00010000 \"u-boot\"\nmtd1: 0be00000 00010000 \"root\"\nroot@testsocfpga:~# ls /dev/mtd**\n/dev/mtd0  /dev/mtd0ro   /dev/mtd1  /dev/mtd1ro  /dev/mtdblock0   /dev/mtdblock1\n</code></pre>    Here you can see that 2 mtd partitions exists (these are defined in the device tree) and they have a 64KB erase sector size. The following table describes the memory regions of these partitions and the location of the last sector in these partitions. This test procedure will operate on the last sector of the mtd1 partition.</li> </ol> MTD Partition Regions in Chip Limits in Region Last Sector Location in the partition mtd0 0x0000_0000 - 0x041F_FFFF 0x0000_0000 - 0x041F_FFFF 0x041f_0000 mtd1 0x0420_0000 - 0x0FFE_FFFF 0x0000_0000 - 0x0BDF_FFFF 0x0BDF_0000 <ol> <li> <p>Back up the sector that will be erased and written, so it does not loose its original content. The sector size is 64 KB (0x10000). The original content is stored in the readBackup.img file.</p> <pre><code>root@testsocfpga:~# mtd_debug read /dev/mtd1 0x0BDF0000 0x10000 readBackup.img\nCopied 65536 bytes from address 0x0bdf0000 in flash to readBackup.img\n</code></pre> </li> <li> <p>Erase Test. Erase the sector, so it can be written later:</p> <pre><code>root@testsocfpga:~# mtd_debug erase /dev/mtd1 0x0BDF0000 0x10000\nErased 65536 bytes from address 0x0bdf0000 in flash\n</code></pre> </li> <li> <p>Create one image with random content that later will be used to write in the QSPI sector selected. The image is stored in the empty.img file.</p> <pre><code>root@testsocfpga:~# dd if=/dev/urandom of=empty.img bs=1k count=64\n64+0 records in\n64+0 records out\n65536 bytes (66 kB, 64 KiB) copied, 0.00205477 s, 31.9 MB/s\n</code></pre> </li> <li> <p>Write Test. Write the image with random data in the empty.img file to the sector selected.</p> <p><pre><code>root@testsocfpga:~# mtd_debug write /dev/mtd1 0x0BDF0000 0x10000 empty.img\nCopied 65536 bytes from empty.img to address 0x0bdf0000 in flash\n</code></pre> 6. Read Test. Read back the data in the sector so it can later be compared against the original data. The data read is stored in the read.img file.</p> <pre><code>root@testsocfpga:~# mtd_debug read /dev/mtd1 0x0BDF0000 0x10000 read.img\nCopied 65536 bytes from address 0x0bdf0000 in flash to read.img\n</code></pre> </li> <li> <p>Compare the data read in read.img file against the random data writen stored in the empty.img file. Observed that no output indicates that the files match.</p> <p><pre><code>root@testsocfpga:~# diff -q empty.img read.img\n</code></pre> 8. Restore the original data in the QSPI sector selected so this could be unaffected by the testing. For that you need to erase and then write the content in the readBackup.img file.</p> <pre><code>root@testsocfpga:~# mtd_debug erase /dev/mtd1 0x0BDF0000 0x10000\nErased 65536 bytes from address 0x0bdf0000 in flash\nroot@testsocfpga:~# mtd_debug write /dev/mtd1 0x0BDF0000 0x10000 readBackup.img\nCopied 65536 bytes from readBackup.img to address 0x0bdf0000 in flash \n</code></pre> </li> </ol> <p>At this point, you can power cycle the board and observe that the system is able to boot to Linux again.</p>"},{"location":"linux-embedded/drivers/qspi/qspi/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/qspi/qspi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/reset_manager/reset_manager/","title":"Reset Manager Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/reset_manager/reset_manager/#introduction","title":"Introduction","text":"<p>The reset manager generates module reset signals based on reset requests from various sources in the HPS, and performs software writing to the module-reset control registers.</p> <p>The HPS contains multiple reset domains. Each reset domain can be reset independently. A reset can be initiated externally, internally, or through software.  For more information about the reset manager, please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/drivers/reset_manager/reset_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/reset/reset-simple.c</p>"},{"location":"linux-embedded/drivers/reset_manager/reset_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the system level reset.</li> <li>Support Assert and De-assert of the reset signal.</li> <li>Monitor the status of the reset signal.</li> </ul>"},{"location":"linux-embedded/drivers/reset_manager/reset_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_RESET_SIMPLE</p> <p></p>"},{"location":"linux-embedded/drivers/reset_manager/reset_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location for reset signal parameter:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p> <p>Also dt-bindings can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/include/dt-bindings/reset/altr%2Crst-mgr-agilex5.h</p>"},{"location":"linux-embedded/drivers/reset_manager/reset_manager/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/reset_manager/reset_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/sd-emmc/sd-emmc/","title":"SD-EMMC Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/sd-emmc/sd-emmc/#introduction","title":"Introduction","text":"<p>The Secure Digital/Embedded Multimedia Card (SD/eMMC) driver supports the SD/eMMC controller in the Hard Processor System (HPS) which interfaces with external SD Flash cards, secure digital I/O (SDIO) devices, and eMMC storage devices.</p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/drivers/sd-emmc/sd-emmc/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mmc/host/sdhci-cadence.c</p>"},{"location":"linux-embedded/drivers/sd-emmc/sd-emmc/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage SD/eMMC features such as configuration and reset and timeout clock frequency</li> <li>Supports SDMA and ADMA modes.</li> <li>Handles data transfer to/from the SD/eMMC.</li> </ul>"},{"location":"linux-embedded/drivers/sd-emmc/sd-emmc/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MMC_SDHCI_CADENCE</p> <p></p>"},{"location":"linux-embedded/drivers/sd-emmc/sd-emmc/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the SD/eMMC:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga_agilex5-ES_RC/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/sd-emmc/sd-emmc/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/sd-emmc/sd-emmc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/smmu/smmu/","title":"System Memory Management Unit (SMMU) Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/smmu/smmu/#introduction","title":"Introduction","text":"<p>SMMU converts virtual addresses to physical addresses for external peripheral devices. This allows multiple external devices to perform direct memory access (DMA) to the entire range of the system physical memory.</p> <p>As an example, certain peripheral devices limited to accessing only 24 bits of address space would now be able to access all 64 bits addresssing through the memory translation tables of the SMMU.</p> <p>The SDM SMMU is used solely by the FCS Cryptography feature. The accelerator like FCS_Crytpo sends a VA to SMMU and SMMU queries the PA from the page table.</p> <p>SMMU registers are configured through ARM Trusted firmware (ATF) BL31 SMC calls by the Crytography device drivers. The ATF performs default SMMU initializations of the stream IDs through the system manager and SMMU secure registers configuration during the boot-up process.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/drivers/smmu/smmu/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/iommu/arm/arm-smmu-v3</p>"},{"location":"linux-embedded/drivers/smmu/smmu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Queue manipulation, sizing</li> <li>Command queue locking or insertion</li> <li>Error reporting</li> <li>Updating Stream Table Entry</li> </ul>"},{"location":"linux-embedded/drivers/smmu/smmu/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ARM_SMMU_V3</p> <p></p>"},{"location":"linux-embedded/drivers/smmu/smmu/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the smmu:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga_agilex5-ES_RC/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/smmu/smmu/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/smmu/smmu/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/spi/spi/","title":"SPI Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5, Agilex 7</p>"},{"location":"linux-embedded/drivers/spi/spi/#introduction","title":"Introduction","text":"<p>Serial master and serial slave controllers are instances of the Synopsys DesignWare Synchronous Serial Interface (SSI) controller.   These enable serial communication with serial-master or serial-slave peripheral devices. Each SPI master has a maximum bit rate of 60 Mbps. Each SPI slave has a maximum bit rate of 33.33 Mbps. The DMA controller interface is integrated with the HPS DMA controller.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/drivers/spi/spi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/spi/spi-dw-mmio.c.</p>"},{"location":"linux-embedded/drivers/spi/spi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Handle the data transfer between connected devices over the SPI bus.</li> <li>Support the peripheral slave DMA.</li> </ul>"},{"location":"linux-embedded/drivers/spi/spi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SPI_DW_MMIO</p> <pre><code>Symbol: SPI_DW_MMIO [=y]                                                                               \n  Type  : tristate                                                                                       \n  Defined at drivers/spi/Kconfig:313                                                                     \n     Prompt: Memory-mapped io interface driver for DW SPI core                                           \n     Depends on: SPI [=y] &amp;&amp; SPI_MASTER [=y] &amp;&amp; SPI_DESIGNWARE [=y] &amp;&amp; \\                                 \n     HAS_IOMEM [=y]                                                                                         \n     Location:                                                                                             \n       -&gt; Device Drivers                                                                                    \n         -&gt; SPI support (SPI [=y])                                                                        \n           -&gt; DesignWare SPI controller core support (SPI_DESIGNWARE [=y])                                 \n             -&gt; Memory-mapped io interface driver for DW SPI core (SPI_DW_MMIO [=y])\n</code></pre> <p>SPI_DW_DMA</p> <pre><code>Symbol: SPI_DW_DMA [=y]                                                                                  \n   Type  : bool                                                                                          \n   Defined at drivers/spi/Kconfig:306                                                                      \n     Prompt: DMA support for DW SPI controller                                                              \n     Depends on: SPI [=y] &amp;&amp; SPI_MASTER [=y] &amp;&amp; SPI_DESIGNWARE [=y]                                         \n     Location:                                                                                              \n       -&gt; Device Drivers                                                                                    \n         -&gt; SPI support (SPI [=y])                                                                          \n           -&gt; DesignWare SPI controller core support (SPI_DESIGNWARE [=y])                                  \n             -&gt; DMA support for DW SPI controller (SPI_DW_DMA [=y])  \n</code></pre> <p>Note: The DMA feature in the SPI controller depends on the HPS DMA controller driver. This driver uses the CONFIG_DW_AXI_DMAC configuration which need to be set to y to be included in the kernel image.</p>"},{"location":"linux-embedded/drivers/spi/spi/#device-tree","title":"Device Tree","text":"<p>An example of the device tree configuration of the SPI driver for the Synopsys DesignWare Synchronous Serial Interface (SSI) controller in the HPS is shown next:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <pre><code>spi0: spi@10da4000 {\n            compatible = \"snps,dw-apb-ssi\";\n            reg = &lt;0x10da4000 0x1000&gt;;\n            #address-cells = &lt;1&gt;;\n            #size-cells = &lt;0&gt;;\n            interrupts = &lt;GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH&gt;;\n            resets = &lt;&amp;rst SPIM0_RESET&gt;;\n            reset-names = \"spi\";\n            reg-io-width = &lt;4&gt;;\n            num-cs = &lt;4&gt;;\n            clocks = &lt;&amp;clkmgr AGILEX5_L4_MAIN_CLK&gt;;\n            dmas = &lt;&amp;dmac0 16&gt;, &lt;&amp;dmac0 17&gt;;\n            dma-names =\"tx\", \"rx\";\n            status = \"disable\";\n        };\n</code></pre> <p>Note: This node is disabled by default in the socfpga_agilex5.dtsi. This is enabled in the arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_debug.dts as shown in the Test procedure section. </p>"},{"location":"linux-embedded/drivers/spi/spi/#test-procedure","title":"Test Procedure","text":"<p>The spidev_test tool can be used to demonstrate the SPI capabilities on Linux. This application can be made available for Linux in any of the following ways:</p> <ul> <li>From GSRD build flow: Include this application during Customize Yocto stage by adding spidev-test to the list of tools in the packagegroup-dev-tools-essential.bb Yocto recipe.</li> <li>From the Linux Boot example build flow: Include this application during the Build Rootfs stage by adding  spidev-test to the list of applications to be included in the file system defined with the CORE_IMAGE_EXTRA_INSTALL configuration.</li> </ul> <p>The spidev-test application depends on the drivers/spi/spidev.c driver to access the SPI devices throught regular userspace I/O calls. This driver is built through the CONFIG_SPI_SPIDEV kernel configuration. This driver also must be enabled in the device tree through the spidev node  as shown next. This is already done in the arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_debug.dts file.</p> <pre><code>&amp;spi0 {\n    status= \"okay\";\n    spidev@0{\n        compatible = \"rohm,dh2228fv\";\n        reg = &lt;0&gt;;\n        spi-max-frequency = &lt;10000000&gt;;\n    };\n};\n</code></pre> <p>Note: When building binaries to exercise this test procedure using the Linux Boot example build flow, it is necessary to enable the drivers and their dependencies as indicated in Kernel Configurations section. In the case of the GSRB build flow, all the required drivers are already included either as part of the kernel image (included through kernel configuration) or including and loading the .ko driver file from the file system. </p> <p>The following test procedure can be exercised using the Agilex 5 E-Series device using the DEBUG2 daughter card for the Premium development kit, in which the spidev-test application targets the built-in Microchip 25AA128 EEPROM device. The spidev driver is compatible with this device.</p> <p>The test procedure consist on enabling the writing in the EEPROM device, then writing a byte (0xC6) to a memory location (0x68D) and then reading this back.</p> <ol> <li> <p>Send the 'Transmits the Write Enable' (WREN) instruction code (0x06). <pre><code>root@testsocfpga# spidev_test -D /dev/spidev1.0 -v -p \"\\x06\"\nspi mode: 0x0\nbits per word: 8\nmax speed: 500000 Hz (500 kHz)\nTX | 06 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |.|\nRX | FF __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |.|\n</code></pre></p> </li> <li> <p>Perform byte write (instruction code x02) with random value (xC6) and offset (MSB x06, LSB x8D) <pre><code>root@testsocfpga# spidev_test -D /dev/spidev1.0 -v -p \"\\x02\\x06\\x8D\\xC6\"\nspi mode: 0x0\nbits per word: 8\nmax speed: 500000 Hz (500 kHz)\nTX | 02 06 8D C6 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\nRX | FF FF FF FF __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\n</code></pre></p> </li> <li> <p>Perform byte read (instruction code x03) on the previously written offset. xC6 will be received. <pre><code>root@testsocfpga# spidev_test -D /dev/spidev1.0 -v -p \"\\x03\\x06\\x8D\\x00\"\nspi mode: 0x0\nbits per word: 8\nmax speed: 500000 Hz (500 kHz)\nTX | 03 06 8D 00 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\nRX | FF FF FF C6 __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  |....|\n</code></pre></p> </li> </ol>"},{"location":"linux-embedded/drivers/spi/spi/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/spi/spi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/system_manager/system_manager/","title":"System Manager Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/system_manager/system_manager/#introduction","title":"Introduction","text":"<p>The system manager contains the memory-mapped control and status registers (CSRs) and logic to control system level functionality in a hard processor system (HPS).</p> <p>The system manager connects to different modules in the HPS such as a Direct memory access (DMA) controller, Microprocessor unit (MPU) system complex, NAND flash controller, Secure Digital/Embedded Multimedia Card (SD/eMMC) controller, or GPIO interface between HPS and other modules.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/drivers/system_manager/system_manager/#features","title":"Features","text":"<ul> <li>Provides memory-mapped control signals to other modules and peripherals</li> <li>Provides watchdogs stop functionality on debug requests.</li> <li>Provides software access to control and status signals of other HPS modules.</li> <li>Enables and disables HPS peripheral interfaces to the FPGA.</li> <li>Provides ten 32-bit registers to store handoff information between the preloader and the operating system.</li> </ul>"},{"location":"linux-embedded/drivers/system_manager/system_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Handle the probing and resource allocation.</li> <li>Provides API to perform read/write operations.</li> <li>Access the CSRs in the system manager to control and monitor various functions of modules.</li> </ul>"},{"location":"linux-embedded/drivers/system_manager/system_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mfd/altera-sysmgr.c.</p>"},{"location":"linux-embedded/drivers/system_manager/system_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MFD_ALTERA_SYSMGR</p> <p></p>"},{"location":"linux-embedded/drivers/system_manager/system_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/system_manager/system_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/system_manager/system_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/uart/uart/","title":"UART Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5, Agilex 7</p>"},{"location":"linux-embedded/drivers/uart/uart/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides two UART controllers for asynchronous serial communication.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/drivers/uart/uart/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/serial/8250/8250_dw.c.</p>"},{"location":"linux-embedded/drivers/uart/uart/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probing and resource allocation as well as memory mapping.</li> <li>It provides the support for busy detect interrupt.</li> </ul>"},{"location":"linux-embedded/drivers/uart/uart/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SERIAL_8250_DW</p> <p></p>"},{"location":"linux-embedded/drivers/uart/uart/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the uart:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/uart/uart/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/uart/uart/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/usb2_0_otg/usb_2_0_otg/","title":"USB 2.0 OTG Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5, Agilex 7</p>"},{"location":"linux-embedded/drivers/usb2_0_otg/usb_2_0_otg/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) provides a USB On-The-Go (OTG) controller that supports both device and host functions. The controller is fully compliant with the On The Go and Embedded Host Supplement to the USB Revision 1.3 and Revision 2.0 Specification. The controller can be programmed for both device and host functions to support data movement over the USB protocol</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/drivers/usb2_0_otg/usb_2_0_otg/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/dwc2</p>"},{"location":"linux-embedded/drivers/usb2_0_otg/usb_2_0_otg/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Provides basic services for accessing and managing the hardware.</li> <li>Enable support for Host and peripheral mode.</li> <li>Handle control and data transfers between the USB host and connected USB peripherals.</li> </ul>"},{"location":"linux-embedded/drivers/usb2_0_otg/usb_2_0_otg/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_USB_DWC2</p> <p></p>"},{"location":"linux-embedded/drivers/usb2_0_otg/usb_2_0_otg/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the usb2_0_otg:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/usb2_0_otg/usb_2_0_otg/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/usb2_0_otg/usb_2_0_otg/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/","title":"USB 3.1 Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex3, Agilex 5</p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#introduction","title":"Introduction","text":"<p>The HPS provides a single instance of a USB 3.1 Gen 1 controller that supports both device and host functions for high-speed applications. The general use cases of USB 3.1 are for the HPS system to support all USB devices such as:</p> <ul> <li>Portable electronic devices</li> <li>High-bandwidth applications like audio and video.</li> <li>Debug trace applications</li> </ul> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#usb-31-glue-driver","title":"USB 3.1 Glue Driver","text":"<p><code>drivers/usb/dwc3/dwc3-of-simple.c</code> is a USB glue driver for the <code>dw3-agilex-edge.c</code> component depicted in the diagram below. This glue driver is used to control dynamic mode switching.</p> <p></p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/dwc3</p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>It provides a reference to the Clock which is required by the rest of the interfaces.</li> </ul>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_USB_DWC3</p> <p></p> <p>Note:  CONFIG_USB_DWC3_HOST or CONFIG_USB_DWC3_GADGET should be enabled only if the user wants to explicitly turn on Host or Device mode. If CONFIG_USB_DWC3_DUAL_ROLE is enabled, both Host mode and Device mode drivers will be built.</p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the usb3_1:</p> <p>1. The default Device Tree configures the USB3_1 in Host Mode: (dr_mode = \"host\";)</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <pre><code>        usb31: usb1@11000000 {\n            compatible = \"intel,agilex5-dwc3\";\n            reg = &lt;0x11000000 0x100000&gt;;\n            ranges;\n            #address-cells = &lt;1&gt;;\n            #size-cells = &lt;1&gt;;\n            clocks = &lt;&amp;clkmgr AGILEX5_USB31_SUSPEND_CLK&gt;,\n                 &lt;&amp;clkmgr AGILEX5_USB31_BUS_CLK_EARLY&gt;;\n            resets = &lt;&amp;rst USB1_RESET&gt;, &lt;&amp;rst USB1_OCP_RESET&gt;;\n            reset-names = \"dwc3\", \"dwc3-ecc\";\n            status = \"disabled\";\n\n            usb@11000000{\n                compatible = \"snps,dwc3\";\n                reg = &lt;0x11000000 0x100000&gt;;\n                interrupts = &lt;GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH&gt;;\n                phys = &lt;&amp;usbphy0&gt;, &lt;&amp;usbphy0&gt;;\n                phy-names = \"usb2-phy\", \"usb3-phy\";\n                dr_mode = \"host\";\n                maximum-speed = \"super-speed-plus\";\n                snps,dis_u2_sysphy-quirk;\n                snps,dma_set_40_bit_mask_quirk;\n            };\n        };\n</code></pre> <p>2. To enable the USB3_1 in Device Mode, the \"dr_mode\" must be changed to \"peripheral\" in the Device Tree File:</p> <pre><code>        usb31: usb1@11000000 {\n            compatible = \"intel,agilex5-dwc3\";\n            reg = &lt;0x11000000 0x100000&gt;;\n            ranges;\n            #address-cells = &lt;1&gt;;\n            #size-cells = &lt;1&gt;;\n            clocks = &lt;&amp;clkmgr AGILEX5_USB31_SUSPEND_CLK&gt;,\n                 &lt;&amp;clkmgr AGILEX5_USB31_BUS_CLK_EARLY&gt;;\n            resets = &lt;&amp;rst USB1_RESET&gt;, &lt;&amp;rst USB1_OCP_RESET&gt;;\n            reset-names = \"dwc3\", \"dwc3-ecc\";\n            status = \"disabled\";\n\n            usb@11000000{\n                compatible = \"snps,dwc3\";\n                reg = &lt;0x11000000 0x100000&gt;;\n                interrupts = &lt;GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH&gt;;\n                phys = &lt;&amp;usbphy0&gt;, &lt;&amp;usbphy0&gt;;\n                phy-names = \"usb2-phy\", \"usb3-phy\";\n                dr_mode = \"peripheral\";\n                maximum-speed = \"super-speed-plus\";\n                snps,dis_u2_sysphy-quirk;\n                snps,dma_set_40_bit_mask_quirk;\n            };\n        };\n</code></pre> <p>3. To enable the USB3_1 in Dual-Role Device (DRD) Mode.</p> <p>a. The \"dr_mode\" must be changed to \"otg\" in the Device Tree File</p> <pre><code>        usb31: usb1@11000000 {\n            compatible = \"intel,agilex5-dwc3\";\n            reg = &lt;0x11000000 0x100000&gt;;\n            ranges;\n            #address-cells = &lt;1&gt;;\n            #size-cells = &lt;1&gt;;\n            clocks = &lt;&amp;clkmgr AGILEX5_USB31_SUSPEND_CLK&gt;,\n                 &lt;&amp;clkmgr AGILEX5_USB31_BUS_CLK_EARLY&gt;;\n            resets = &lt;&amp;rst USB1_RESET&gt;, &lt;&amp;rst USB1_OCP_RESET&gt;;\n            reset-names = \"dwc3\", \"dwc3-ecc\";\n            status = \"disabled\";\n\n            usb@11000000{\n                compatible = \"snps,dwc3\";\n                reg = &lt;0x11000000 0x100000&gt;;\n                interrupts = &lt;GIC_SPI 94 IRQ_TYPE_LEVEL_HIGH&gt;;\n                phys = &lt;&amp;usbphy0&gt;, &lt;&amp;usbphy0&gt;;\n                phy-names = \"usb2-phy\", \"usb3-phy\";\n                dr_mode = \"otg\";\n                maximum-speed = \"super-speed-plus\";\n                snps,dis_u2_sysphy-quirk;\n                snps,dma_set_40_bit_mask_quirk;\n            };\n        };\n</code></pre> <p>b. Two extra nodes are to be added to the Device Tree File:</p> <p>(User may add to gsrd-socfpga//meta-intel-fpga-refdes/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi)</p> <pre><code>        usb_pio: gpio@20010090 {\n                compatible = \"altr,pio-1.0\";\n                reg = &lt;0x20010090 0x10&gt;;\n                interrupts = &lt;GIC_SPI 20 IRQ_TYPE_EDGE_RISING&gt;;\n                altr,gpio-bank-width = &lt;4&gt;;\n                altr,interrupt-type = &lt;3&gt;;\n                #gpio-cells = &lt;2&gt;;\n                gpio-controller;\n        };\n\n        extcon_usb: extcon-usb {\n                compatible = \"linux,extcon-usb-gpio\";\n                id-gpio = &lt;&amp;usb_pio 0 GPIO_ACTIVE_HIGH&gt;;\n                vbus-gpio = &lt;&amp;usb_pio 1 GPIO_ACTIVE_HIGH&gt;;\n        };\n</code></pre> <p>Important Note: For the full instructions to enable USB3.1 in Device mode and Dual-Role Device mode, please refer to the Example Design tutorial https://altera-fpga.github.io/latest/embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/</p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#test-procedure","title":"Test Procedure","text":"<p>The procedure to test USB3.1 in Host mode, Device mode and Dual-Role Device mode are included in the Example Design tutorial https://altera-fpga.github.io/latest/embedded-designs/agilex-5/e-series/premium/usb3p1/ug-usb3p1-dev-drd-modes/</p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/drivers/usb3_1/usb3_1/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/","title":"Watchdog Timers Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Device Supported: Agilex 5</p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#introduction","title":"Introduction","text":"<p>The watchdog timers are peripherals you can use to recover from system lockup that might be caused by software or system related issues. The hard processor system (HPS) provides five programmable watchdog timers, which are connected to the level 4 (L4) peripheral bus.</p> <p>Each watchdog timer consists of a slave interface for control and status register (CSR) access, a register block, and a 32-bit down counter that operates on the slave interface clock (l4_sys_free_clk). A pause input, driven by the system manager, optionally pauses the counter when a CPU is being debugged.The watchdog timer drives an interrupt request to the MPU and a reset request to the reset manager.</p> <p>For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/watchdog/dw_wdt.c.</p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Allows configuration of the watchdog timer timeout period, specifying the duration after which the watchdog will trigger a system reset if not reset by the software</li> <li>Initializes the watchdog timer hardware during system boot, setting up the necessary registers and configurations to enable watchdog functionality.</li> <li>Handles interrupts generated by the watchdog timer hardware, allowing the system to respond appropriately to watchdog events, such as timer expiration.</li> </ul>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_WATCHDOG</p> <p></p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#test-procedures","title":"Test Procedures","text":"<p>This test procedure was exercised on Agilex 5 E-Series Premium Development Kit using the GSRD for HPS Enablement Board (booting from SD Card)  from 24.3.1 release which uses Linux Kernel 6.6.51.</p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#step-1-verify-that-the-watchdog-node-is-in-the-device-tree","title":"Step 1: Verify that the Watchdog Node is in the Device Tree","text":"<p>First, verify that the watchdog node is present in the device tree. You can do this by booting the system and running:</p> <pre><code>ls /proc/device-tree/soc\\@0/watchdog*\n/proc/device-tree/soc@0/watchdog@10d00200:\nclocks    compatible  interrupts  name  phandle  reg  resets  status\n\n/proc/device-tree/soc@0/watchdog@10d00300:\nclocks    compatible  interrupts  name  phandle  reg  resets  status\n\n/proc/device-tree/soc@0/watchdog@10d00400:\nclocks    compatible  interrupts  name  phandle  reg  resets  status\n\n/proc/device-tree/soc@0/watchdog@10d00500:\nclocks    compatible  interrupts  name  phandle  reg  resets  status\n\n/proc/device-tree/soc@0/watchdog@10d00600:\nclocks    compatible  disable-over-current  interrupts  name  phandle  reg  resets  status\n</code></pre> <p>Read the status of the watchdog that is present.</p> <pre><code>cat /proc/device-tree/soc\\@0/watchdog\\@10d00200/status\nokay\n</code></pre> <p>You should see output indicating the presence of the watchdog node (The printout of the following cat command should be 'okay' as shown above)</p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#step-2-check-watchdog-status","title":"Step 2: Check Watchdog Status","text":"<p>Next, check the status of the watchdog to ensure it is active. Run the following command:</p> <p><pre><code>ls /dev/watchdog*\n/dev/watchdog   /dev/watchdog1  /dev/watchdog3\n/dev/watchdog0  /dev/watchdog2  /dev/watchdog4\n</code></pre> This command will display the watchdog timers that are active. </p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#step-3-test-watchdog-reset-functionality","title":"Step 3: Test Watchdog Reset Functionality","text":"<p>To test the watchdog's ability to reset the system, you can disable the watchdog by writing to its control register. Run the following command:</p> <pre><code>cat &gt;&gt; /dev/watchdog\n</code></pre> <p>After running this command, the system should reset within a few seconds. You will see the login prompt reappear after the reset.</p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#step-4-verify-system-recovery","title":"Step 4: Verify System Recovery","text":"<p>Once the system has recovered from the reset, all the services and applications should run as expected.</p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/watchdog_timers/watchdog_timers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/","title":"Zarlink Clock Synchronizer Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#introduction","title":"Introduction","text":"<p>The Microchip\u00ae Zarlink ZL30733 3-Channel SyncE &amp; 1588 Network Synchronizer takes charge of frequency synchronization, monitors reference clock quality, manages reference clock switching, and provides holdover functionality for SyncE and PTP1588 support. It has support for multiple reference clocks and can be used to generate the outputs. The device is constantly monitoring the quality of the reference clocks and it switches to an alternative clock source when the measured period of the current reference signal is incorrect, or if it has excessive jitter.</p> <p>I2C based zl30733</p> <pre><code>graph TD;\n    A[intel_freq_control.c]--&gt;B[intel_freq_ctrl_common_i2c.c];\n    A[intel_freq_control.c]--&gt;C[intel_freq_ctrl_zl30733_i2c.c];</code></pre> <p>SPI based zl30793</p> <pre><code>graph TD;\n    A[intel_freq_control.c]--&gt;B[intel_freq_ctrl_common_spi.c];\n    A[intel_freq_control.c]--&gt;C[intel_freq_ctrl_zl30793_spi.c];</code></pre>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#zarlink-chip-information","title":"Zarlink chip information","text":"<p>For Microchip\u00ae Zarlink ZL30733 documentation please refer to https://www.microchip.com/en-us/product/zl30733 and https://www.microchip.com/en-us/product/zl30793.</p>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <ul> <li>General Frequency control driver</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_control.c</p> <ul> <li>I2C based ZL30733 support</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_zl30733_i2c.c</p> <ul> <li>I2C based common api for frequency control</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_common_i2c.c</p> <ul> <li>SPI based zl30793 support</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_zl30793_spi.c</p> <ul> <li>SPI based common api for frequency control</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_common_spi.c</p>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Support frequency synchronization, monitor reference clock quality, manage reference clock switching.</li> <li>Provides holdover functionality for SyncE and PTP1588 support.</li> </ul>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#example-designs","title":"Example Designs","text":"<p>Zarlink driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/drivers/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"sw-tools-list/host-attach-tools/","title":"Host Attach Software Tools","text":"<p>The table below provides a comprehensive list of host software tools available for Altera 7 FPGAs. These utilities are part of the  called Open Programmable Acceleration Engine (OPAE) software development kit which is part of the Open FPGA Stack (OFS) software framework.  More documentation on OPAE and OFS can be found here.</p> <p>You can use the filter fields to narrow your search.</p> Utility Supported Devices Description fpgaconf Agilex 7 FPGA Configuration fpgad Agilex 7 FPGA Diagnostics fpgainfo Agilex 7 FPGA Card Information fpgaport Agilex 7 FPGA Port Information fpgasupdate Agilex 7 FPGA Secure Update host_exerciser Agilex 7 Host Interface Exerciser hssi Agilex 7 HE-HSSI Controller hssi_ethernet Agilex 7 HSSI/Ethernet Statistics hssi_loopback Agilex 7 HSSI Loopback hssimac Agilex 7 HSSI MAC mem_tg Agilex 7 Memory Traffic Generator mmlink Agilex 7 Memory Mapped Link ofs.uio Agilex 7 OFS DFL UIO opae.io Agilex 7 OFS DFL OPAE IO opaeuio Agilex 7 OFS OPAE User IO opaevfio Agilex 7 OFS DFL Virt IO pac_hssi_config Agilex 7 Programmable Acceleration Card HSSI Configuration packager Agilex 7 AFU Packager pcie_device Agilex 7 PCIe Device rsu Agilex 7 Remote System Update (RSU) userclk Agilex 7 User Clock Control vabtool Agilex 7 Vendor Authorized Boot Tool"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/","title":"HPS Xen Hypervisor GSRD for the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit","text":""},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#introduction","title":"Introduction","text":"<p>This page presents the Xen GSRD, which is based on the Linux GSRD for the Agilex\u2122 5 E-Series Modular Development Kit. The Xen GSRD uses the SD card for storing the root filesystem.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#xen-overview","title":"Xen Overview","text":"<p>Xen is a free open-source Type-1 hypervisor which enables efficient and secure virtualization of hardware resources to run multiple operating systems on a single physical machine. </p> <p></p> <p>In Xen's architecture, there are two domains. Dom0 is the privileged management domain that runs the hypervisor and has full access to physical hardware, acting as the bridge between the hypervisor and other virtual machines. DomUs are unprivileged guest domains that run operating systems or applications, relying on Dom0 for resource allocation. Dom0 and DomUs operate independently, ensuring isolation and security.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex\u2122 5 Modular Development Kit GSRD:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex\u2122 5 Modular Development Kit GSRD binaries are located at https://releases.rocketboards.org/2025.08/xen/agilex5_mk_a5e065bb32aes1_xen/.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#exercise-xen-gsrd-prebuilt-binaries","title":"Exercise Xen GSRD Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the Xen GSRD, on the Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit.</p> <p>Running the boot from SD card section of the GSRD is a prerequisite step for running the Xen examples, as not all steps are as detailed on this page as in the GSRD page. Refer to the following links for help on getting started:</p> Link Description Board Documentation Board user guide, schematics, etc GSRD Development Kit Section Details about the development kit GSRD Board Setup Section Setting up the development kit GSRD Serial Console Section Setting up serial console GSRD Write SD Card Section Writing SD card image"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#write-binaries","title":"Write Binaries","text":"<p>This section shows presents downloading and flashing the SD card image and JIC files, and downloading the xen rootfs cpio archive to be used by DomUs VMs.</p> <p>1. Download and write to SD card the image https://releases.rocketboards.org/2025.08/xen/agilex5_mk_a5e065bb32aes1_xen/sdimage.tar.gz</p> <p>2. Download and write to QSPI flash the JIC file https://releases.rocketboards.org/2025.08/xen/agilex5_mk_a5e065bb32aes1_xen/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz</p> <p>3. Set MSEL to QSPI, and power cycle the board to boot to Linux.</p> <p>4. On the host computer, download the xen rootf cpio archive:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/xen/agilex5_mk_a5e065bb32aes1_xen/xen-image-minimal-agilex5_modular.cpio.gz\nmv xen-image-minimal-agilex5_modular.cpio.gz xen-image-minimal-agilex5.cpio.gz\n</code></pre> <p>5. On the Linux on target board, copy over the above downloaded file in 'xen' folder:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/xen-image-minimal-agilex5.cpio.gz .\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#boot-xen-gsrd","title":"Boot Xen GSRD","text":"<p>This section shows how to boot the Xen GSRD. By default, if no other operation is done, the board boots into normal, non-Xen enabled GSRD on a power cycle. In order to boot with the Xen Hypervisor, you need to stop the U-Boot countdown, and boot Linux manually using the commands shown in the below sections. This is provided for convenience, and when used in a real production system, U-Boot can be configured to boot the required Xen configuration automatically.</p> <p></p> Boot Without Passthrough <p>1. Set MSEL to QSPI, and power cycle the board</p> <p>2. Press any key during U-Boot countdown to stop it</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> Boot With Passthrough <p>The instructions are the same as without passthrough, just that the following command needs to be added befote the 'booti' command:</p> Device Passthrough Command QSPI fdt set /soc@0/spi@108d2000 xen,passthrough Ethernet fdt set /soc@0/ethernet@10830000 xen,passthrough"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#manage-vms","title":"Manage VMs","text":"<p>This section shows how to use the 'xl' Xen utility to manage VMs running on DomUs. Only a few options are used, refer to 'xl' command help for more options.</p> <p>1. Boot Xen GSRD as shown above. It can be either with or without passthrough</p> <p>2. Create VM1 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_1.cfg\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>3. Start VM1:</p> <pre><code>xl create test_vm_1.cfg\n</code></pre> <p>4. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>5. Connect to VM1 console:</p> <pre><code>xl console DomU1\n</code></pre> <p>6. Run some commands in VM1:</p> <pre><code>pwd\nls -la\n</code></pre> <p>7. Exit from VM1 console by pressing CTRL + ]. Note this works only from serial console, and not over SSH connection.</p> <p>8. Create VM2 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_2.cfg\n# Guest name\nname = \"DomU2\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>9. Start VM2:</p> <pre><code>xl create test_vm_2.cfg\n</code></pre> <p>10. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>11. Shutdown VM1:</p> <pre><code>xl shutdown DomU1\n</code></pre> <p>The above command politely asks DomU1 to shut down by using the ACPI shutdown signal and letting the OS shut down.</p> <p>Alternatively, when needed, you can also use 'destroy' commands which acts as a hard power cycle:</p> <pre><code>xl destroy DomU1\n</code></pre> <p>12. List VMs again, it will not show VM1 anymore</p> <pre><code>xl list\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#ethernet-passthrough","title":"Ethernet Passthrough","text":"<p>This section shows an example of how to assign the Ethernet IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc@0/ethernet@10830000 xen,passthrough\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Run 'ifconfig' to confirm Dom0 Linux does not have Ethernet anymore:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 2172  bytes 134772 (131.6 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 2172  bytes 134772 (131.6 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> <p>7. Go to xen folder and look at the provided Ethernet passthrough files (dtb file and VM configuration file)</p> <pre><code>root@agilex5dka5e065bb32aes1:~/# cd xen\nroot@agilex5dka5e065bb32aes1:~/xen# ls *ethernet*\nethernet@10830000.cfg  ethernet@10830000.dtb\nroot@agilex5dka5e065bb32aes1:~/xen# cat ethernet@10830000.cfg\n# SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"/home/root/xen/xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\ndevice_tree = \"ethernet@10830000.dtb\"\ndtdev = [ \"/soc@0/ethernet@10830000\" ]\niomem = [ \"0x10830,4\",\"0x10d12,1\" ]\nirqs = [ 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 267, 268, 269, 270, 271, 272 ]\n</code></pre> <p>8. Start the VM:</p> <pre><code>xl create ethernet\\@10830000.cfg\n</code></pre> <p>9. Connect to VM console </p> <pre><code>xl console DomU1\n</code></pre> <p>10. In the VM console, login with 'root' account, then do an 'ifconfig' or other commands to confirm Ethernet is working:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\neth0      Link encap:Ethernet  HWaddr 1A:CD:51:03:2A:55  inet addr:192.168.1.154  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fe80::18cd:51ff:fe03:2a55/64 Scope:Link\n          inet6 addr: 2603:8081:7700:1092::1bb7/128 Scope:Global\n          inet6 addr: 2603:8081:7700:1092:18cd:51ff:fe03:2a55/64 Scope:Global\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:12 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:20 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 RX bytes:1715 (1.6 KiB)  TX bytes:2275 (2.2 KiB)\nInterrupt:14 Base address:0xc000 lo        Link encap:Local Loopback  inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#qspi-passthrough","title":"QSPI Passthrough","text":"<p>This section shows an example of how to assign the QSPI IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p></p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc@0/spi@108d2000 xen,passthrough\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Go to xen folder and look at the provided QSPI passthrough files (dtb file and VM configuration file):</p> <pre><code>root@agilex5dka5e065bb32aes1:~/# cd xen\nroot@agilex5dka5e065bb32aes1:~/xen# ls *spi*\nspi@108d2000.cfg  spi@108d2000.dtb\nroot@agilex5dka5e065bb32aes1:~/xen# cat spi@108d2000.cfg\n#SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\n# Ramdisk\nramdisk = \"/home/root/xen/xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\ndevice_tree = \"spi@108d2000.dtb\"\niomem = [ \"0x108d2,1\", \"0x10900,100\" ]\nirqs = [ 35 ]\n</code></pre> <p>7. Start the VM, and connect to its console</p> <pre><code>xl create spi@108d2000.cfg\nxl console DomU1\n</code></pre> <p>8. In the VM console, login with 'root' account, then run a couple of commands to see QSPI is enabled:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# mtdinfo\nCount of MTD devices:           2\nPresent MTD devices:            mtd0, mtd1\nSysfs interface supported:      yes\nroot@agilex5dka5e065bb32aes1:~# cat /proc/mtd dev:    size   erasesize  name\nmtd0: 04200000 00010000 \"u-boot\"\nmtd1: 0be00000 00010000 \"root\"\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#rebuild-xen-gsrd","title":"Rebuild Xen GSRD","text":"<p>The instructions are the same as for the GSRD, except that the environment variable BUILD_HYP=1 needs to be set for building the Xen enabled GSRD version. This environment variable is only used by the Yocto GSRD script.</p> Yocto Build Prerequisites <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd_modular.xen\nmkdir agilex5_gsrd_modular.xen\ncd agilex5_gsrd_modular.xen\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-modular-devkit-som-legacy-baseline.zip\nunzip a5ed065es-modular-devkit-som-legacy-baseline.zip\nrm -f a5ed065es-modular-devkit-som-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b walnascar https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\nexport HYP_BUILD=1\n. agilex5_mk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_mk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_mk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_mk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_mk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_mk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_mk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_mk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_mk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#use-zephyr-on-domu","title":"Use Zephyr on DomU","text":"<p>This section shows how to build a simple Zephyr example and run in inside a Xen VM.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#build-zephyr-binary","title":"Build Zephyr Binary","text":"<p>For theis example the Zephyr binary was built on an Ubuntu 22.04 machine, with the required packages installed as indicated in https://docs.zephyrproject.org/latest/develop/getting_started/index.html.</p> <p>1. Create a virtual Python environment:</p> <pre><code>export TOP_FOLDER=`pwd`\npython3 -m venv $TOP_FOLDER/.zephyr_venv\nsource $TOP_FOLDER/.zephyr_venv/bin/activate\n</code></pre> <p>2. Install the Zephr project:</p> <pre><code>pip3 install wheel pip3 install west west init -m https://github.com/zephyrproject-rtos/zephyr --mr main zephyrproject cd zephyrproject\nwest update west zephyr-export\npip install -r zephyr/scripts/requirements.txt\n</code></pre> <p>3. Download the Altera\u00ae Zephyr repo and install SDK:</p> <pre><code>git clone -b socfpga_rel_24.3 https://github.com/altera-fpga/zephyr-socfpga\ncd zephyr-socfpga\nwest update\nwest zephyr-export\nwest sdk install\n</code></pre> <p>4. Work around an issue that happens at least on certain Ubuntu 22.04 installations:</p> <pre><code>pushd boards/arm64/xenvm\nrm xenvm_defconfig &amp;&amp; mv xenvm_gicv3_defconfig xenvm_defconfig\nrm xenvm_gicv3.yaml\nmv xenvm.dts xenvm_base.dts &amp;&amp; mv xenvm_gicv3.dts xenvm.dts &amp;&amp; sed -i 's/xenvm\\.dts/xenvm_base.dts/g' xenvm.dts\npopd\n</code></pre> <p>5. Build the sample application:</p> <pre><code>west build -b xenvm samples/hello_world -p\n</code></pre> <p>This will create the file $TOP_FOLDER/zephyrproject/zephyr-socfpga/build/zephyr/zephyr.bin</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#run-zephyr-vm","title":"Run Zephyr VM","text":"<p>1. Write the Xen GSRD binaries.</p> <p>2. Boot to XEN GSRD, does not matter if passthrough is enabled or not</p> <p>3. Copy the Zephyr binary to the target rootfs:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/zephyr.bin .\n</code></pre> <p>4. Still in the xen folder, create the Zephyr VM configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; zephyr.cfg\nkernel=\"zephyr.bin\"\nname=\"zephyr\"\nvcpus=1\nmemory=16\ngic_version=\"v3\"\non_crash=\"preserve\"\nEOT\n</code></pre> <p>5. Start the Zephyr VM:</p> <pre><code>xl start zephyr.cfg\n</code></pre> <p>6. Connect to VM console:</p> <pre><code>xl console zephyr\n</code></pre> <p>7. In the VM console, you will see the message output by the Zephyr:</p> <pre><code>Hello World! xenvm\n[00:00:00.000,000] &lt;inf&gt; xen_events: xen_events_init: events inited\n\n[00:00:00.000,000] &lt;inf&gt; uart_hvc_xen: Xen HVC inited successfully\n\n*** Booting Zephyr OS build v4.0.0-4569-g8cff70a95d6c ***\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-modular/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/","title":"HPS Xen Hypervisor GSRD for the Agilex\u2122 5 E-Series Premium Dev Kit","text":""},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#introduction","title":"Introduction","text":"<p>This page presents the Xen GSRD, which is based on the Linux GSRD for the Agilex\u2122 5 E-Series Premium Development Kit. The Xen GSRD uses the HPS Enablement Board, and SD card for storing the root filesystem.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#xen-overview","title":"Xen Overview","text":"<p>Xen is a free open-source Type-1 hypervisor which enables efficient and secure virtualization of hardware resources to run multiple operating systems on a single physical machine. </p> <p></p> <p>In Xen's architecture, there are two domains. Dom0 is the privileged management domain that runs the hypervisor and has full access to physical hardware, acting as the bridge between the hypervisor and other virtual machines. DomUs are unprivileged guest domains that run operating systems or applications, relying on Dom0 for resource allocation. Dom0 and DomUs operate independently, ensuring isolation and security.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Premium Development Kit GSRD:</p> <ul> <li> <p>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1, with the following included accessories:</p> <ul> <li>HPS Enablement Expansion Board. </li> <li>Mini USB Cable.</li> <li>Micro USB Cable.</li> <li>Ethernet Cable.</li> <li>Micro SD card and USB card writer.</li> </ul> </li> </ul> <ul> <li> <p>Host PC with:</p> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>SSH server installer, to enable using 'scp' command from target board to host PC</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 </li> </ul> </li> </ul> <ul> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for more information about the development kit.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex\u2122 5 Premium Development Kit Xen binaries are located at https://releases.rocketboards.org/2025.08/xen/agilex5_dk_a5e065bb32aes1_xen/.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#exercise-prebuilt-binaries","title":"Exercise Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the Xen example, on the Agilex 5 FPGA E-Series 065B Premium Development Kit, with the HPS Enablement Expansion board.</p> <p>Running the boot from SD card section of the GSRD is a prerequisite step for running the Xen examples, as not all steps are as detailed on this page as in the GSRD page. Refer to the following links for help on getting started:</p> Link Description Board Documentation Board user guide, schematics, etc GSRD Development Kit Section Details about the development kit GSRD Board Setup Section Setting up the development kit GSRD Serial Console Section Setting up serial console GSRD Write SD Card Section Writing SD card image"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#write-binaries","title":"Write Binaries","text":"<p>This section shows presents downloading and flashing the SD card image and JIC files, and downloading the xen rootfs cpio archive to be used by DomUs VMs.</p> <p>1. Download and write to SD card the image https://releases.rocketboards.org/2025.08/xen/agilex5_dk_a5e065bb32aes1_xen/sdimage.tar.gz</p> <p>2. Download and write to QSPI flash the JIC file https://releases.rocketboards.org/2025.08/xen/agilex5_dk_a5e065bb32aes1_xen/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz</p> <p>3. Set MSEL to QSPI, and power cycle the board to boot to Linux.</p> <p>4. On the host computer, download the xen rootf cpio archive:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/xen/agilex5_dk_a5e065bb32aes1_xen/xen-image-minimal-agilex5.cpio.gz\n</code></pre> <p>5. On the Linux on target board, copy over the above downloaded file in 'xen' folder:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/xen-image-minimal-agilex5.cpio.gz .\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#boot-xen-gsrd","title":"Boot Xen GSRD","text":"<p>This section shows how to boot the Xen GSRD. By default, if no other operation is done, the board boots into normal, non-Xen enabled GSRD on a power cycle. In order to boot with the Xen Hypervisor, you need to stop the U-Boot countdown, and boot Linux manually using the commands shown in the below sections. This is provided for convenience, and when used in a real production system, U-Boot can be configured to boot the required Xen configuration automatically.</p> <p></p> Boot Without Passthrough <p>1. Set MSEL to QSPI, and power cycle the board</p> <p>2. Press any key during U-Boot countdown to stop it</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> Boot With Passthrough <p>The instructions are the same as without passthrough, just that the following command needs to be added befote the 'booti' command:</p> Device Passthrough Command QSPI fdt set /soc@0/spi@108d2000 xen,passthrough Ethernet fdt set /soc@0/ethernet@10830000 xen,passthrough"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#manage-vms","title":"Manage VMs","text":"<p>This section shows how to use the 'xl' Xen utility to manage VMs running on DomUs. Only a few options are used, refer to 'xl' command help for more options.</p> <p>1. Boot Xen GSRD as shown above. It can be either with or without passthrough</p> <p>2. Create VM1 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_1.cfg\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>3. Start VM1:</p> <pre><code>xl create test_vm_1.cfg\n</code></pre> <p>4. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>5. Connect to VM1 console:</p> <pre><code>xl console DomU1\n</code></pre> <p>6. Run some commands in VM1:</p> <pre><code>pwd\nls -la\n</code></pre> <p>7. Exit from VM1 console by pressing CTRL + ]. Note this works only from serial console, and not over SSH connection.</p> <p>8. Create VM2 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_2.cfg\n# Guest name\nname = \"DomU2\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>9. Start VM2:</p> <pre><code>xl create test_vm_2.cfg\n</code></pre> <p>10. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>11. Shutdown VM1:</p> <pre><code>xl shutdown DomU1\n</code></pre> <p>The above command politely asks DomU1 to shut down by using the ACPI shutdown signal and letting the OS shut down.</p> <p>Alternatively, when needed, you can also use 'destroy' commands which acts as a hard power cycle:</p> <pre><code>xl destroy DomU1\n</code></pre> <p>12. List VMs again, it will not show VM1 anymore</p> <pre><code>xl list\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#ethernet-passthrough","title":"Ethernet Passthrough","text":"<p>This section shows an example of how to assign the Ethernet IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc@0/ethernet@10830000 xen,passthrough\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Run 'ifconfig' to confirm Dom0 Linux does not have Ethernet anymore:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 2172  bytes 134772 (131.6 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 2172  bytes 134772 (131.6 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> <p>7. Go to xen folder and look at the provided Ethernet passthrough files (dtb file and VM configuration file)</p> <pre><code>root@agilex5dka5e065bb32aes1:~/# cd xen\nroot@agilex5dka5e065bb32aes1:~/xen# ls *ethernet*\nethernet@10830000.cfg  ethernet@10830000.dtb\nroot@agilex5dka5e065bb32aes1:~/xen# cat ethernet@10830000.cfg\n# SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"/home/root/xen/xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\ndevice_tree = \"ethernet@10830000.dtb\"\ndtdev = [ \"/soc@0/ethernet@10830000\" ]\niomem = [ \"0x10830,4\",\"0x10d12,1\" ]\nirqs = [ 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 267, 268, 269, 270, 271, 272 ]\n</code></pre> <p>8. Start the VM:</p> <pre><code>xl create ethernet\\@10830000.cfg\n</code></pre> <p>9. Connect to VM console </p> <pre><code>xl console DomU1\n</code></pre> <p>10. In the VM console, login with 'root' account, then do an 'ifconfig' or other commands to confirm Ethernet is working:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\neth0      Link encap:Ethernet  HWaddr 1A:CD:51:03:2A:55  inet addr:192.168.1.154  Bcast:192.168.1.255  Mask:255.255.255.0\n          inet6 addr: fe80::18cd:51ff:fe03:2a55/64 Scope:Link\n          inet6 addr: 2603:8081:7700:1092::1bb7/128 Scope:Global\n          inet6 addr: 2603:8081:7700:1092:18cd:51ff:fe03:2a55/64 Scope:Global\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:12 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:20 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 RX bytes:1715 (1.6 KiB)  TX bytes:2275 (2.2 KiB)\nInterrupt:14 Base address:0xc000 lo        Link encap:Local Loopback  inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:65536  Metric:1\n          RX packets:0 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#qspi-passthrough","title":"QSPI Passthrough","text":"<p>This section shows an example of how to assign the QSPI IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p></p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc@0/spi@108d2000 xen,passthrough\nbooti 0x8a000000 - 0x88000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Go to xen folder and look at the provided QSPI passthrough files (dtb file and VM configuration file):</p> <pre><code>root@agilex5dka5e065bb32aes1:~/# cd xen\nroot@agilex5dka5e065bb32aes1:~/xen# ls *spi*\nspi@108d2000.cfg  spi@108d2000.dtb\nroot@agilex5dka5e065bb32aes1:~/xen# cat spi@108d2000.cfg\n#SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\n# Ramdisk\nramdisk = \"/home/root/xen/xen-image-minimal-agilex5.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\ndevice_tree = \"spi@108d2000.dtb\"\niomem = [ \"0x108d2,1\", \"0x10900,100\" ]\nirqs = [ 35 ]\n</code></pre> <p>7. Start the VM, and connect to its console</p> <pre><code>xl create spi@108d2000.cfg\nxl console DomU1\n</code></pre> <p>8. In the VM console, login with 'root' account, then run a couple of commands to see QSPI is enabled:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# mtdinfo\nCount of MTD devices:           2\nPresent MTD devices:            mtd0, mtd1\nSysfs interface supported:      yes\nroot@agilex5dka5e065bb32aes1:~# cat /proc/mtd dev:    size   erasesize  name\nmtd0: 04200000 00010000 \"u-boot\"\nmtd1: 0be00000 00010000 \"root\"\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#physical-core-assignment-to-virtual-machines","title":"Physical Core Assignment to Virtual Machines","text":"<p>When Xen creates a new virtual machine, the Xen scheduler will assign a physical core to be used by this VM depending on load and configuration. However, you can assign specific cores through CPU pinning. Here is described how you can assign a specific core to any of the VM created.</p> <p>In order to exercise this, you can use any of the test procedures described previously, but the following example will show you how to do it using the procedure described in Manage VMs (booting without passthrough).</p> <p>1.  Boot to Linux and create DomU1 and DomU2 VMs keeping both alive. You can check that both of them exist using the following command:</p> <pre><code>root@agilex5dka5e065bb32aes1:~/xen# xl list\nName                 ID   Mem VCPUs      State   Time(s)\nDomain-0              0  2048     2     r-----      45.0\nDomU1                 1  1024     1     -b----      23.7\nDomU2                 2  1024     1     r-----      15.7\n</code></pre> <p>2. Check the current core assignment for each one of the VMs created using the xl vcpu-list command:</p> <pre><code>root@agilex5dka5e065bb32aes1:~/xen# xl vcpu-list\nName             ID  VCPU   CPU State   Time(s) Affinity (Hard / Soft)\nDomain-0         0     0    0   r--      27.5    0 / all\nDomain-0         0     1    1   -b-      21.3    1 / all\nDomU1            1     0    3   -b-      30.6    all / all\nDomU2            2     0    2   -b-      30.6    all / all\n</code></pre> <p>The output of this command indicates in the CPU column whcih is the current physical core assigned to each one of the VM. In this case we can see that DomU1 is running in the physical core 3 while DomU2 is runninng in the physical core 2.  Also observe the Affinity column, in whcih for the DomU1 and Dom2, the Hard Affinity is not restricted to any specific core as it is indicated with all.</p> <p>3. You can change the core assigned to the VMs using the xl vcpu-pin command. The syntax of this command is as follow:</p> <p>xl vcpu-pin <p>The parameters of this command can been retrieved from the information provided by the xl vcpu-list command.</p> <p>4. In this exercise, let's restrict the physical core that can be assinged to the DomU1 and DomU2 inverting the core observed in the step 2. In this case we will assign the physical core 2 to DomU1 and the physical core 3 to DomU2.</p> <pre><code>root@agilex5dka5e065bb32aes1:~/xen# xl vcpu-pin 1 0 2\nroot@agilex5dka5e065bb32aes1:~/xen# xl vcpu-pin 2 0 3\nroot@agilex5dka5e065bb32aes1:~/xen#  xl vcpu-list\nName             ID  VCPU   CPU State   Time(s) Affinity (Hard / Soft)\nDomain-0         0     0    0   r--      36.1    0 / all\nDomain-0         0     1    1   -b-      30.6    1 / all\nDomU1            1     0    2   -b-      64.2    2 / all\nDomU2            2     0    3   -b-      64.2    3 / all\n</code></pre> <p>From the previous campture you can verify that now the core 2 is being assigned to DOMU1  and the core 3 is being assigned to DomU2. Also observe that in the Affinity column these cores are the only ones that can be used by these VMs.</p> <p>If you want to go beyond, you can compile the following getCore application and take it to any created VM. The output of this application tells you in which physical core this is being executed. The easier way to transfer this to a VM is by using the Ethernet Passthrough example.  You can build the application in your development computer,  and then take it to your VM created in your board through TFTP or SCP applications.</p> <p><pre><code>/* getCore.c app to get the physical core used to execute it.\n   This can be compiled with the following command after the appropiate setup of ARM Tool chain\n   gcc -g -o getCore getCore.c */\n#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\nunsigned long int read_mpidr(void)\n{\nunsigned long int value;\nasm volatile(\"mrs %[result], mpidr_el1\" : [result] \"=r\" (value));\nreturn value;\n}\nunsigned int getCore(){  unsigned long mpidr;\nunsigned int core;\nmpidr = read_mpidr();\ncore = (mpidr &gt;&gt; 8) &amp; 0xFF;    return core;\n}\nint main()\n{\nunsigned int core;    core = getCore();\nprintf(\"=== My Debug example started on Core %d ===\\n\", core); return 0;\n}\n</code></pre> In any of the VMs created, you can execute  this application before and after calling the xl vcpu-pin command to assign an exclusive core and observe that the physical core in which the application is running is changed as expected. This is shown in the following capture. In this capture only one VM is being created. You can see that initially the core 2 was assigned to the DomU1 VM and when the getCore application was run in this VM, it indicates that  this was run in that core. Then in Domain-0 , the xl vcpu-pin 1 0 3 is used to assign the core 3 to the DomU1 VM and when the getCore application is run there we can confirm that this is being executed in the core 3.</p> <pre><code>#In Domain-0\nroot@agilex5dka5e065bb32aes1:~/xen# xl vcpu-list\nName           ID  VCPU   CPU State   Time(s) Affinity (Hard / Soft)\nDomain-0       0     0    0   r--      20.5     0 / all\nDomain-0       0     1    1   -b-      16.7     1 / all\nDomU1          1     0    2   -b-      36.5     all / all\n\nroot@agilex5dka5e065bb32aes1:~/xen# xl console DomU1 &lt;Now in DomU1&gt;\nroot@agilex5dka5e065bb32aes1:~/# tftp -gr getCore 10.10.0.1\nroot@agilex5dka5e065bb32aes1:~/# chmod +x ./getCore\nroot@agilex5dka5e065bb32aes1:~/# ./getCore\n=== My Debug example started on Core 2 ===\n# Exit from DomU1 with Ctrl+] and return to Domain-0\nroot@agilex5dka5e065bb32aes1:~/xen# xl vcpu-pin 1 0 3\nroot@agilex5dka5e065bb32aes1:~/xen# xl vcpu-list\nName          ID  VCPU   CPU State   Time(s) Affinity (Hard / Soft)\nDomain-0      0     0    0   -b-      34.1  0 / all\nDomain-0      0     1    1   r--      32.7  1 / all\nDomU1         1     0    3   -b-      60.6  3 / all\n# Return to DomU1\nroot@agilex5dka5e065bb32aes1:~/# xl console DomU1\nroot@agilex5dka5e065bb32aes1:~/# ./getCore        === My Debug example started on Core 3 ===\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#memory-isolation-in-vms","title":"Memory Isolation in VMs","text":"<p>When creating a secondary virtual machine (i.e. DomUx), this runs as a guest and is given access only to the resources given by Xen. Typically, only the RAM is assigned to a VM, like in the VMs created at Manage VMs. When Xen creates this VM, it creates a virtualized memory map based on the  resources assigned to this and Xen keeps the mapping in internal tables. These resources could be RAM memory or peripheral that could be configured as passthrough. The main VM (i.e. Dom0) will show the full memory map as defined in the device Technical Refernece Manual unless any peripheral is transfer to a secondary VM also using PassThrough mechanism. Xen Hypervisor provide complete isolation between different VMs. Xen uses Guest Physical Addresses (GPAs) to represent the physical address space inside a guest OS. Each DomU is given its own GPA (Guest Physical Addresses ) space, which Xen maps to different  MFN (Machine Frame Numbers) in the host\u2019s actual memory. Even though  the VM memory map observed through /proc/iomem inside multiple DomUs may look identical, the GPAs are backed by different host memory pages, ensuring isolation between VMs (unless a shared memory region is explicitly defined as part of the VMs configuration).</p> <p>The following example demonstrates the memory isolation feature in the VMs. This is based on the Manage VMs using only Dom0 and DomU1. This example, demonstrates the memory layout for each one of these VMs using cat /proc/iomem. The exercise also access one memory location that is included in the local memory layout, using devmem2, to confirm that this is accessible from the same VM. Finally, the exercise tries to access a memory location that belongs to the other VM, verifying that this is not possible as they are isolated from each other.</p> <p>In Dom0 read the memory layout and read the 1st  memory location in GICD: <pre><code>root@agilex5dka5e065bb32aes1:~/xen/# cat /proc/iomem 00000000-0007ffff : 0.sram sram@0\n10808000-10808fff : 10808000.mmc0 mmc0@10808000\n10830000-108334ff : 10830000.ethernet ethernet@10830000\n108d2000-108d20ff : 108d2000.spi spi@108d2000\n10900000-109fffff : 108d2000.spi spi@108d2000\n10b00000-10b3ffff : 10b00000.usb usb@10b00000\n10c03200-10c032ff : 10c03200.gpio gpio@10c03200\n10c03300-10c033ff : 10c03300.gpio gpio@10C03300\n10d00200-10d002ff : 10d00200.watchdog watchdog@10d00200\n10d00300-10d003ff : 10d00300.watchdog watchdog@10d00300\n10d00400-10d004ff : 10d00400.watchdog watchdog@10d00400\n10d00500-10d005ff : 10d00500.watchdog watchdog@10d00500\n10d00600-10d006ff : 10d00600.watchdog watchdog@10d00600\n10d10000-10d10fff : 10d10000.clock-controller clock-controller@10d10000\n10d11000-10d11fff : 10d11000.rstmgr rstmgr@10d11000\n10da0000-10da0fff : 10da0000.i3c i3c@10da0000\n10da1000-10da1fff : 10da1000.i3c i3c@10da1000\n10db0000-10db04ff : 10db0000.dma-controller dma-controller@10db0000\n10dc0000-10dc04ff : 10dc0000.dma-controller dma-controller@10dc0000\n11000000-11007fff : usb1@11000000\n  11000000-11007fff : xhci-hcd.0.auto usb1@11000000\n1100c100-110fffff : 11000000.usb1 usb1@11000000\n16002000-16002fff : 16002000.pmu-tcu pmu-tcu@16002000\n16042000-16042fff : 16042000.pmu-tbu pmu-tbu@16042000\n16062000-16062fff : 16062000.pmu-tbu pmu-tbu@16062000\n16082000-16082fff : 16082000.pmu-tbu pmu-tbu@16082000\n160a2000-160a2fff : 160a2000.pmu-tbu pmu-tbu@160A2000\n160c2000-160c2fff : 160c2000.pmu-tbu pmu-tbu@160C2000\n160e2000-160e2fff : 160e2000.pmu-tbu pmu-tbu@160E2000\n1d000000-1d00ffff : GICD\n1d060000-1d15ffff : GICR\n20000000-2fffffff : System RAM\n80000000-81ffffff : reserved\n98000000-f7ffffff : System RAM\n  98010000-99e9ffff : Kernel code\n  99ea0000-9a17ffff : reserved\n  9a180000-9a71ffff : Kernel data\n  a0000000-a0006fff : reserved\n  a0200000-a81fffff : reserved\n  f2000000-f7ffffff : reserved\n9c0000000-9dfffffff : System RAM\n  9dd440000-9df9fffff : reserved\n  9dfaa8000-9dfaa8fff : reserved\n  9dfaa9000-9dfadafff : reserved\n  9dfadd000-9dfadefff : reserved\n  9dfadf000-9dfadffff : reserved\n  9dfae0000-9dfae0fff : reserved\n  9dfae1000-9dfbe4fff : reserved\n  9dfbe5000-9dfc09fff : reserved\n  9dfc0a000-9dfffffff : reserved\n\nroot@agilex5dka5e065bb32aes1:~/xen/# devmem2 0x1d000000\n/dev/mem opened.\nMemory mapped at address 0xffffa178b000.\nRead at address  0x1D000000 (0xffffa178b000): 0x00000012\n</code></pre></p> <p>In DomU1 read the memory layout and read the 1st  memory location in GICD: <pre><code>root@agilex5dka5e065bb32aes1:~# cat /proc/iomem 03001000-03010fff : GICD\n03020000-0401ffff : GICR\n40000000-7fffffff : System RAM\n  40010000-41e9ffff : Kernel code\n  41ea0000-4217ffff : reserved\n  42180000-4271ffff : Kernel data\n  48000000-4e3e4fff : reserved\n  7ca00000-7fbfffff : reserved\n  7fc65000-7fc67fff : reserved\n  7fc68000-7fce8fff : reserved\n  7fce9000-7fd01fff : reserved\n  7fd04000-7fd06fff : reserved\n  7fd07000-7fe0afff : reserved\n  7fe0b000-7fffffff : reserved\nroot@agilex5dka5e065bb32aes1:~# devmem2 0x03001000\n/dev/mem opened.\nMemory mapped at address 0xffffb8980000.\nRead at address  0x03001000 (0xffffb8980000): 0x00000012\n</code></pre></p> <p>In DomU1 read the read the 1st  memory location in GICD using the memory address indicated in Dom0  to confirm that this is not accessible: <pre><code>root@agilex5dka5e065bb32aes1:~# devmem2 0x1d000000\n/dev/mem opened.\nMemory mapped at address 0xffff87bfe000.\nKilled\n</code></pre> In Dom0 read the read the 1st  memory location in GICD using the memory address indicated in DomU1 to confirm that this is not accessible: <pre><code>root@agilex5dka5e065bb32aes1:~/xen/# devmem2 0x03001000\n/dev/mem opened.\nMemory mapped at address 0xffffb738b000.\nKilled\n</code></pre></p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#rebuild-xen-gsrd","title":"Rebuild Xen GSRD","text":"<p>This section presents how to build the Xen GSRD binaries. The instructions are the same as for the GSRD, except that the environment variable BUILD_HYP=1 needs to be set for building the Xen enabled GSRD version. This environment variable is only used by the Yocto GSRD script.</p> Yocto Build Prerequisites <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd_premium.xen\nmkdir agilex5_gsrd_premium.xen\ncd agilex5_gsrd_premium.xen\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/\\\narm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu/bin/:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf agilex5_soc_devkit_ghrd &amp;&amp; mkdir agilex5_soc_devkit_ghrd &amp;&amp; cd agilex5_soc_devkit_ghrd\nwget https://github.com/altera-fpga/agilex5e-ed-gsrd/releases/download/QPDS25.1.1_REL_GSRD_PR/a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nunzip a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nrm -f a5ed065es-premium-devkit-oobe-legacy-baseline.zip\nmake legacy_baseline-build\nmake legacy_baseline-sw-build\nquartus_pfg -c output_files/legacy_baseline.sof \\\noutput_files/legacy_baseline_hps_debug.sof \\\n-o hps_path=software/hps_debug/hps_wipe.ihex\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/legacy_baseline_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b walnascar https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\nexport HYP_BUILD=1\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/legacy_baseline.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#use-zephyr-on-domu","title":"Use Zephyr on DomU","text":"<p>This section shows how to build a simple Zephyr example and run in inside a Xen VM.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#build-zephyr-binary","title":"Build Zephyr Binary","text":"<p>For theis example the Zephyr binary was built on an Ubuntu 22.04 machine, with the required packages installed as indicated in https://docs.zephyrproject.org/latest/develop/getting_started/index.html.</p> <p>1. Create a virtual Python environment:</p> <pre><code>export TOP_FOLDER=`pwd`\npython3 -m venv $TOP_FOLDER/.zephyr_venv\nsource $TOP_FOLDER/.zephyr_venv/bin/activate\n</code></pre> <p>2. Install the Zephr project:</p> <pre><code>pip3 install wheel pip3 install west west init -m https://github.com/zephyrproject-rtos/zephyr --mr main zephyrproject cd zephyrproject\nwest update west zephyr-export\npip install -r zephyr/scripts/requirements.txt\n</code></pre> <p>3. Download the Altera\u00ae Zephyr repo and install SDK:</p> <pre><code>git clone -b socfpga_rel_24.3 https://github.com/altera-fpga/zephyr-socfpga\ncd zephyr-socfpga\nwest update\nwest zephyr-export\nwest sdk install\n</code></pre> <p>4. Work around an issue that happens at least on certain Ubuntu 22.04 installations:</p> <pre><code>pushd boards/arm64/xenvm\nrm xenvm_defconfig &amp;&amp; mv xenvm_gicv3_defconfig xenvm_defconfig\nrm xenvm_gicv3.yaml\nmv xenvm.dts xenvm_base.dts &amp;&amp; mv xenvm_gicv3.dts xenvm.dts &amp;&amp; sed -i 's/xenvm\\.dts/xenvm_base.dts/g' xenvm.dts\npopd\n</code></pre> <p>5. Build the sample application:</p> <pre><code>west build -b xenvm samples/hello_world -p\n</code></pre> <p>This will create the file $TOP_FOLDER/zephyrproject/zephyr-socfpga/build/zephyr/zephyr.bin</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#run-zephyr-vm","title":"Run Zephyr VM","text":"<p>1. Write the Xen GSRD binaries.</p> <p>2. Boot to XEN GSRD, does not matter if passthrough is enabled or not</p> <p>3. Copy the Zephyr binary to the target rootfs:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/zephyr.bin .\n</code></pre> <p>4. Still in the xen folder, create the Zephyr VM configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; zephyr.cfg\nkernel=\"zephyr.bin\"\nname=\"zephyr\"\nvcpus=1\nmemory=16\ngic_version=\"v3\"\non_crash=\"preserve\"\nEOT\n</code></pre> <p>5. Start the Zephyr VM:</p> <pre><code>xl create zephyr.cfg\n</code></pre> <p>6. Connect to VM console:</p> <pre><code>xl console zephyr\n</code></pre> <p>7. In the VM console, you will see the message output by the Zephyr:</p> <pre><code>Hello World! xenvm\n[00:00:00.000,000] &lt;inf&gt; xen_events: xen_events_init: events inited\n\n[00:00:00.000,000] &lt;inf&gt; uart_hvc_xen: Xen HVC inited successfully\n\n*** Booting Zephyr OS build v4.0.0-4569-g8cff70a95d6c ***\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/","title":"HPS Xen Hypervisor GSRD for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile)","text":""},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#overview","title":"Overview","text":"<p>This page presents the Xen GSRD, which is based on the Linux GSRD for the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile).</p> <p>The Xen GSRD uses the SD card for storing the root filesystem.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the Xen GSRD:</p> <ul> <li>Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) ordering code DK-SI-AGF014EB</li> <li>SD/MMC HPS Daughtercard<ul> <li>SDM QSPI Bootcard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel FPGA Download Cable II</li> <li>Micro SD card (4GB or greater)</li> </ul> </li> <li>Host PC with<ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Micro SD card slot or Micro SD card writer/reader</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1</li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board)</li> </ul> </li> </ul> <p>You can determine your board version by referring to the following table from https://www.intel.com/content/www/us/en/docs/programmable/683752/current/overview.html</p> Development Kit Version Ordering Code Device Part Number Starting Serial Number Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 2 P-Tiles &amp; E-Tiles) DK-SI-AGF014EB AGFB014R24B2E2V (Power Solution 2) 00205001 Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 1 P-Tiles &amp; E-Tiles) DK-SI-AGF014EA AGFB014R24B2E2V (Power Solution 1) 0001101 Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (ES P-Tiles &amp; E-Tiles) DK-SI-AGF014E3ES AGFB014E3ES (Power Solution 1) 0001001 <p>The DK-SI-AGF014E3ES and DK-SI-AGF014EA are deprecated, and not supported anymore.</p> <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#release-notes","title":"Release Notes","text":"<p>See https://github.com/altera-fpga/gsrd-socfpga/releases/tag/QPDS25.1.1_REL_GSRD_PR.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The release files are accessible at https://releases.rocketboards.org/2025.08/xen/agilex7_dk_si_agf014eb_xen/</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>:</p> File Description linux-socfpga-v6.12.19-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2025.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.12.1-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 25.1.1 and the following software component versions integrate the 25.1.1 release. </p> <p>Note: Regarding the GHRD components in the following table, only the device-specific GHRD is used in this page.</p> Component Location Branch Commit ID/Tag Agilex 3 GHRD https://github.com/altera-fpga/agilex3c-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 5 GHRD https://github.com/altera-fpga/agilex5e-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Agilex 7 GHRD https://github.com/altera-fpga/agilex7f-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Stratix 10 GHRD https://github.com/altera-fpga/stratix10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Arria 10 GHRD https://github.com/altera-fpga/arria10-ed-gsrd main QPDS25.1.1_REL_GSRD_PR Linux https://github.com/altera-fpga/linux-socfpga socfpga-6.12.19-lts QPDS25.1.1_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-fpga/arm-trusted-firmware socfpga_v2.12.1 QPDS25.1.1_REL_GSRD_PR U-Boot https://github.com/altera-fpga/u-boot-socfpga socfpga_v2025.04 QPDS25.1.1_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky walnascar latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga walnascar latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-fpga/meta-intel-fpga-refdes walnascar QPDS25.1.1_REL_GSRD_PR <p>Note: The combination of the component versions indicated in the table above has been validated through the use cases described in this page and it is strongly recommended to use these versions together. If you decided to use any component with different version than the indicated, there is not warranty that this will work.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#exercise-xen-gsrd-prebuilt-binaries","title":"Exercise Xen GSRD Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the Xen GSRD, on the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit.</p> <p>Refer to the following links for additional help on getting started:</p> Link Description Board Documentation Board user guide, schematics, etc GSRD Board Setup Section Setting up the development kit GSRD Serial Console Section Setting up serial console GSRD Write SD Card Section Writing SD card image"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#write-binaries","title":"Write Binaries","text":"<p>This section shows presents downloading and flashing the SD card image and JIC files, and downloading the xen rootfs cpio archive to be used by DomUs VMs.</p> <p>1. Download and write to SD card the image https://releases.rocketboards.org/2025.08/xen/agilex7_dk_si_agf014eb_xen/sdimage.tar.gz</p> <p>2. Download and write to QSPI flash the JIC file https://releases.rocketboards.org/2025.08/xen/agilex7_dk_si_agf014eb_xen/ghrd_agfb014r24b2e2v.hps.jic.tar.gz</p> <p>3. Set MSEL to QSPI, and power cycle the board to boot to Linux.</p> <p>4. On the host computer, download the xen rootf cpio archive:</p> <pre><code>wget https://releases.rocketboards.org/2025.08/xen/agilex7_dk_si_agf014eb_xen/xen-image-minimal-agilex7.cpio.gz\n</code></pre> <p>5. On the Linux on target board, copy over the above downloaded file in 'xen' folder:</p> <pre><code>cd xen\nscp &lt;host_user&gt;@&lt;host-ip&gt;:/&lt;host-folder&gt;/xen-image-minimal-agilex7.cpio.gz .\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#boot-xen-gsrd","title":"Boot Xen GSRD","text":"<p>This section shows how to boot the Xen GSRD. By default, if no other operation is done, the board boots into normal, non-Xen enabled GSRD on a power cycle. In order to boot with the Xen Hypervisor, you need to stop the U-Boot countdown, and boot Linux manually using the commands shown in the below sections. This is provided for convenience, and when used in a real production system, U-Boot can be configured to boot the required Xen configuration automatically.</p> <p></p> Boot Without Passthrough <p>1. Set MSEL to QSPI, and power cycle the board</p> <p>2. Press any key during U-Boot countdown to stop it</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nbooti 0x0a000000 - 0x08000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> Boot With Passthrough <p>The instructions are the same as without passthrough, just that the following command needs to be added befote the 'booti' command:</p> Device Passthrough Command QSPI fdt set /soc/spi@ff8d2000 xen,passthrough Ethernet fdt set /soc/ ethernet@ff800000 xen,passthrough USB fdt set /soc/usb@ffb00000 xen,passthrough SD/eMMC fdt set /soc/ ethernet@ff808000 xen,passthrough"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#manage-vms","title":"Manage VMs","text":"<p>This section shows how to use the 'xl' Xen utility to manage VMs running on DomUs. Only a few options are used, refer to 'xl' command help for more options.</p> <p>1. Boot Xen GSRD as shown above. It can be either with or without passthrough</p> <p>2. Create VM1 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_1.cfg\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex7.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>3. Start VM1:</p> <pre><code>xl create test_vm_1.cfg\n</code></pre> <p>4. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>5. Connect to VM1 console:</p> <pre><code>xl console DomU1\n</code></pre> <p>6. Run some commands in VM1:</p> <pre><code>pwd\nls -la\n</code></pre> <p>7. Exit from VM1 console by pressing CTRL + ]. Note this works only from serial console, and not over SSH connection.</p> <p>8. Create VM2 configuration file:</p> <pre><code>cat &lt;&lt; EOT &gt; test_vm_2.cfg\n# Guest name\nname = \"DomU2\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"xen-image-minimal-agilex7.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\nEOT\n</code></pre> <p>9. Start VM2:</p> <pre><code>xl create test_vm_2.cfg\n</code></pre> <p>10. List running VMs:</p> <pre><code>xl list\n</code></pre> <p>11. Shutdown VM1:</p> <pre><code>xl shutdown DomU1\n</code></pre> <p>The above command politely asks DomU1 to shut down by using the ACPI shutdown signal and letting the OS shut down.</p> <p>Alternatively, when needed, you can also use 'destroy' commands which acts as a hard power cycle:</p> <pre><code>xl destroy DomU1\n</code></pre> <p>12. List VMs again, it will not show VM1 anymore</p> <pre><code>xl list\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#qspi-passthrough","title":"QSPI Passthrough","text":"<p>This section shows an example of how to assign the QSPI IP to a DomU VM, instead of being used by Dom0, which is the default.</p> <p></p> <p>1. Write binaries</p> <p>2. Boot to U-Boot prompt by interrupting the U-Boot countdown</p> <p>3. Run the following U-Boot commands:</p> <pre><code>fatls mmc 0:1\nfatload mmc 0:1 $loadaddr boot.scr.xen.uimg\nsource $loadaddr\nfdt set /soc/spi@ff8d2000 xen,passthrough\nbooti 0x0a000000 - 0x08000000\n</code></pre> <p>4. Xen console messages will be shown, then regular Linux boot console messages.</p> <p>5. Log into Linux as usual with 'root' login and no passoword will be requested</p> <p>6. Go to xen folder and look at the provided QSPI passthrough files (dtb file and VM configuration file):</p> <pre><code>root@agilex7dksiagf014eb:~/# cd xen\nroot@agilex7dksiagf014eb:~/xen# ls *spi*\nspi@ff8d2000.cfg  spi@ff8d2000.dtb\nroot@agilex7dksiagf014eb:~/xen# cat spi@ff8d2000.cfg\n# SPDX-License-Identifier: MIT-0\n# Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\nramdisk = \"/home/root/xen/xen-image-minimal-agilex7.cpio.gz\"\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\n# Optional incase any passthrough or share mem\ndevice_tree = \"spi@ff8d2000.dtb\"\niomem = [ \"0xff8d2,1\", \"0xff900,100\" ]\nirqs = [ 35 ]\n</code></pre> <p>7. Start the VM, and connect to its console</p> <pre><code>xl create spi@ff8d2000.cfg\nxl console DomU1\n</code></pre> <p>8. In the VM console, login with 'root' account, then run a couple of commands to see QSPI is enabled:</p> <pre><code>root@agilex7dksiagf014eb:~# cat /proc/mtd dev:    size   erasesize  name\nmtd0: 04200000 00010000 \"u-boot\"\nmtd1: 0be00000 00010000 \"root\"\nroot@agilex7dksiagf014eb:~# mtdinfo       Count of MTD devices:           2\nPresent MTD devices:            mtd0, mtd1\nSysfs interface supported:      yes\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#rebuild-xen-gsrd","title":"Rebuild Xen GSRD","text":""},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p>The instructions are the same as for the GSRD, except that the environment variable BUILD_HYP=1 needs to be set for building the Xen enabled GSRD version. This environment variable is only used by the Yocto GSRD script.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd.xen\nmkdir agilex7f_gsrd.xen\ncd agilex7f_gsrd.xen\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/altera_pro/25.1.1/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf agilex7f-ed-gsrd\nwget https://github.com/altera-fpga/agilex7f-ed-gsrd/archive/refs/tags/QPDS25.1.1_REL_GSRD_PR.zip\nunzip QPDS25.1.1_REL_GSRD_PR.zip\nrm QPDS25.1.1_REL_GSRD_PR.zip\nmv agilex7f-ed-gsrd-QPDS25.1.1_REL_GSRD_PR agilex7f-ed-gsrd\ncd agilex7f-ed-gsrd\nmake agf014eb-si-devkit-oobe-baseline-all\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b walnascar https://github.com/altera-fpga/gsrd-socfpga\ncd gsrd-socfpga\nexport HYP_BUILD=1\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf</li> <li>agilex7_dk_si_agf014eb_nand_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona0.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona1.rbf: not applicable</li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n file://agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=xxxxxxxxx \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the file:</p> <pre><code>SRC_URI[agilex7_dk_si_agf014eb_gsrd_core.sha256sum] = \"5d633ee561d5cc8c22b51211a144654fdc0be47ee14b07ac134074cbff84eb8b\"\n</code></pre> <p>by using the following commands:</p> <pre><code>sed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014eb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014eb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-agilex-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#create-qspi-image","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex7f-ed-gsrd/install/designs/agf014eb_si_devkit_oobe_baseline.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"virtualization/hypervisors/xen/ug-xen-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122.  </p>"},{"location":"virtualization/hypervisors/xen/xen-overview/","title":"Overview","text":""},{"location":"virtualization/hypervisors/xen/xen-overview/#introduction","title":"Introduction","text":"<p>Xen is a free open-source hypervisor originally developed by the University of Cambridge, and now part of Linux Foundation's Xen Project. This page presents and overview of Xen, and details about the Altera\u00ae support for Xen on the Agilex\u2122 7 and Agilex\u2122 5 devices.</p> <p>Xen enables efficient and secure virtualization of hardware resources to run multiple operating systems on a single physical machine. As a Type-1 hypervisor, Xen operates directly on the hardware, providing high performance and low overhead by managing CPU, memory, and I/O resources for guest virtual machines. It is widely used in cloud computing, server virtualization, and embedded systems due to its scalability, robustness, and support for a variety of guest operating systems. Xen's architecture emphasizes security through isolation, making it a popular choice for environments requiring strong separation between virtual machines.</p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#architecture","title":"Architecture","text":"<p>The Xen hypervisor is the core component that runs directly on the hardware and manages CPU, memory, and interrupts. It provides a virtualized environment for guest operating systems by abstracting hardware resources.</p> <p>In Xen's architecture, there are two domains. Dom0 is the privileged management domain that runs the hypervisor and has full access to physical hardware, acting as the bridge between the hypervisor and other virtual machines. DomUs are unprivileged guest domains that run operating systems or applications, relying on Dom0 for resource allocation. Dom0 and DomUs operate independently, ensuring isolation and security. </p> <p></p> <p>On Altera\u00ae SoC FPGAs, the following OSes are currently supported:</p> Device Dom0 OS DomU OS Agilex\u2122 7 Linux Linux Agilex\u2122 5 Linux Linux, Zephyr <p>Dom0 runs Linux OS and supports xen tools(xl) to create, configure, and manage Xen VMs. Linux guest OS on the Dom0 has by default native access to IO subsystem (peripheral devices).</p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#virtualization-modes","title":"Virtualization Modes","text":"<p>Xen supports three primary virtualization modes for physical hardware: passthrough, paravirtualization, and device emulation using HVM (Hardware Virtual Machine). Passthrough enables virtual machines (VMs) to directly access physical hardware, delivering near-native performance for demanding workloads. Paravirtualization enhances VM efficiency by modifying the guest OS to collaborate with the hypervisor, minimizing overhead. HVM mode provides fully emulated devices, allowing unmodified guest operating systems to interact with hardware without direct access. </p> <p>On Altera\u00ae SoC FPGAs, only passthrough mode is supported, as shown in the table below:</p> Device Passthrough Support Agilex\u2122 7 Ethernet, QSPI, USB, SD Agilex\u2122 5 Ethernet, QSPI <p>Peripherals that are assigned as passthrough are not managed by Dom0, instead they are available to be allocated to DomUs.</p> <p>Note: peripherals like UART, I2C, SPI and GPIO which are not memory mapped at the 4KB MMU page granularity, cannot be configured for Xen passthrough.</p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#smmu-support","title":"SMMU Support","text":"<p>Xen Hypervisor owns the SMMU peripheral device entirely and setup the STE, CD and others on the SMMU. Xen Hypervisor creates the SMMU stage-2 translation table: IPA(40bits) to PA (40bits). </p> <p>For embedded use case when the system memory is in few Gigabytes(&lt;1TB), Xen Hypervisor uses fixed IPA base address 0x4000_0000 for DOMUs, and the mapping of DOMU guest IPA to PA  is managed by the Xen hypervisor.  </p> <p>Agilex\u2122 7 HPS uses ARM SMMUv2, and the Xen driver (xen/drivers/passthrough/arm/smmu.c) is responsible for managing Stage 2 translation. In this context, Stage 2 translation refers to the translation of IPA (Intermediate Physical Address) to PA (Physical Address), which is crucial for memory management in guest virtual machines. The SMMUv2 in Xen supports both stages of translation. Stage 1 handles IOVA (Input/Output Virtual Address) to IPA conversion, while Stage 2 converts IPA to PA. </p> <p>Agilex\u2122 5 HPS, however, uses ARM SMMUv3, and the corresponding Xen driver (xen/drivers/passthrough/arm/smmu-v3.c) is responsible for Stage 2 translation only. The current Xen SMMUv3 driver is in technical preview mode and only supports Stage 2 translation (IPA to PA), as opposed to the Linux SMMUv3 driver, which supports both Stage 1 and Stage 2. This limitation implies that while guest virtual machines can access memory through Stage 2 (IPA to PA) translation, Stage 1 translations (IOVA to IPA) are not supported by Xen for SMMUv3. Therefore Partial Reconfiguration (PR), and Remote System Update (RSU),  is not functional yet on Agilex\u2122 5 since Linux stratix10-svc driver is using stage 1 translation. </p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#boot-flow","title":"Boot Flow","text":"<p>The Xen Hypervisor boot flow is similar to regular GSRD boot flow, with the main difference being that instead of U-Boot loading the Linux kernel, it loads the Xen hypervisor, then the Xen hypervisor loads the Linux kernel. </p> <p>A significant amount of storage is required for the guest OS root filesystem, and that requires a large storage medium, such as SD card or eMMC device. The provided examples support SD card as storage.</p> <p>The following diagram shows the regular GSRD boot flow on the top, and the Xen Hypervisor boot flow on the bottom:</p> <p></p> <p>The boot steps are:</p> <p>1. Configuration management firmware (CMF) running on SDM loads the HPS first-stage bootloader (FSBL) into HPS OCRAM and takes the HPS boot core out of reset. </p> <p>2. U-Boot SPL loads into DDR and runs the SSBL image, composed of ATF BL31 and U-Boot proper.</p> <p>3. U-Boot Proper is responsible for booting either native Linux operating system or the Xen Hypervisor, depending on the boot configuration.  In the provided Xen GSRD examples, this is achieved by using a different boot script.</p> <p>Default GSRD boot flow uses native Linux flow and the u-boot distro autoboot runs the boot.scr.uimg script to load the Linux Kernel, dtb and/or core.rbf files. </p> <p>To boot Xen Hypervisor you need to stop at u-boot prompt by pressing enter during the countdown and instead load and run the Xen uboot script (boot.scr.xen.uimg). This is to ensure customer can use the single GSRD image to either boot native Linux or Xen Hypervisor.  </p> <p>No code change is required in U-boot or ATF to run Xen Hypervisor. </p> <p>U-boot boot script (uimg) has been added to Yocto build to boot Xen Hypervisor. </p> <p>Additional Linux kernel configuration has been enabled to use Linux kernel with Xen Hypervisor.</p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#linux-device-tree","title":"Linux Device Tree","text":"<p>Xen Hypervisor requires device tree and typically Linux device tree is used as base line and xen specific changes are updated using u-boot Flattened Device Tree (FDT) commands.</p> <p>The example below shows the Agilex\u2122 5 xen device tree changes, for reference:</p> <pre><code>fdt rm /chosen bootargs\nfdt set /chosen \\#address-cells &lt;1&gt;\nfdt set /chosen \\#size-cells &lt;1&gt;\nfdt set /chosen \\xen,xen-bootargs \"console=dtuart dtuart=serial0 $xen_bootargs bootscrub=0 maxcpus=4 hmp-unsafe=true log_level=debug Dom0_max_vcpus=2 Dom0_vcpus_pin watchdog_timeout=0 timer_slop=0 iommu=verbose iommu=debug \"\nfdt set /chosen \\xen,Dom0-bootargs \"rdinit=/bin/sh console=hvc0 earlycon=xen earlyprintk=xen root=/dev/mmcblk0p2 rw rootwait \"\nfdt mknod /chosen Dom0\nfdt set /chosen/Dom0 compatible \"multiboot,kernel\" \"multiboot,module\"\nfdt set /chosen/Dom0 reg &lt;0x83000000 0x${filesize}&gt;\nfdt mknod /chosen dom1\nfdt set /chosen/dom1 compatible \"multiboot,ramdisk\" \"multiboot,module\"\nfdt set /chosen/dom1 reg &lt;0x8b000000 0x8000000&gt;\n</code></pre> <p>To configure any device for Xen pass-through mode, use below fdt command from u-boot console: </p> <pre><code>fdt set /soc@0/&lt;device@physical_address&gt; xen,passthrough\n</code></pre> <p>For example this is how you set the QSPI as passthrough, to be used by DomUs instead of Dom0:</p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#domain-configuration","title":"Domain Configuration","text":"<p>Altera support for Xen on the Agilex\u2122 7 and Agilex\u2122 5 devices uses  Dom0 standard configuration, which allows to control and manage multiple VMs (DomUs). </p> <p>Dom0 Standard Configuration: This configuration is common in traditional Xen setups and is suitable for scenarios where a management domain (Dom0) is required to control and manage the virtualization environment. Dom0 provides the control and management of DomUs.</p> <p>Dom0-less Configuration</p> <p>Xen also offers a Dom0-less configuration, which is not currently supported for Altera Agilex\u2122 7 and Agilex\u2122 5 devices.</p> <p>In a Dom0-less (or DomU-only) configuration, Dom0 is not required, allowing guest operating systems to run DomUs without a privileged management domain. Such systems are typically configured statically, meaning the number and setup of DomUs are predefined and cannot be easily modified after boot. Additionally, if any DomU operating system crashes, the entire system, including all DomUs, must be rebooted.</p> <p>For typical embedded use cases, a Dom0-less Xen configuration is preferred. However, it slows down development since setting up and managing a Dom0-less environment is initially more complex. Additionally, it lacks support for the Xen management tool xl vcpu-pi, which optimizes CPU resource allocation for performance and workload characterization, and it does not allow dynamic creation or destruction of VMs.</p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#dom0-configuration","title":"Dom0 Configuration","text":"<p>Dom0 is responsible for creating and managing other unprivileged domains (DomUs) that can run various operating systems in parallel.</p> <p>Xen project best practices suggest initial amount of DOM0 memory should be &gt;= 1024MB and it can be increased based on the practical needs.  </p> <p>Device tree changes are required for Xen hypervisor (Agilex\u2122 5 example), xen bootargs responsible for Xen boot up and DOM0 configuration, while dom0-bootargs is for DOM0 Linux kernel.</p> <p><pre><code>    chosen {\n        stdout-path = \"serial0:115200n8\";\n        #address-cells = &lt;1&gt;;\n        #size-cells = &lt;1&gt;;\n\nxen,dom0-bootargs = \"rdinit=/bin/sh console=hvc0 earlycon=xen earlyprintk=xen root=/dev/mmcblk0p2 rw rootwait\";\n        xen,xen-bootargs = \"console=dtuart dtuart=serial0 dom0_mem=2048M  guest_loglvl=all loglvl=all maxcpus=4 hmp-unsafe=true dom0_max_vcpus=2 dom0_vcpus_pin iommu=verbose iommu=debug\"; dom0 {\n            compatible = \"multiboot,kernel\", \"multiboot,module\";\n            reg = &lt;0x82000000 [Size of Kernel Image]&gt;;\n        };\n        dom1 {\n            compatible = \"multiboot,ramdisk\", \"multiboot,module\";\n            reg = &lt;0x8b000000 [Size of Ramdisk]&gt;; };\n    };\n</code></pre> Xen Bootargs : </p> <ul> <li>console = dtuart: Xen uses the UART specified in the device tree for console messages</li> <li>dtuart=serial0: serial0 is used as device tree UART (dtuart).</li> <li>dom0_mem=2048M: Allocates 2048 MB (2 GB) of memory to DOM0.</li> <li>dom0_vcpus_pin: Pins DOM0's vCPUs to specific physical CPUs (pCPUs), ensuring that DOM0's vCPUs always run on dedicated pCPUs without being moved around by the hypervisor. This is to improve performance by reducing context-switch overhead and ensuring that DOM0 has dedicated CPU resources.</li> <li>dom0_max_vcpus=2 : Limits the maximum number of virtual CPUs (vCPUs) that DOM0 can use to 2 vCPUs. </li> <li>hmp-unsafe = true : Xen Hypervisor supports HMP (Heterogeneous Multi-Processing), commonly known as big.LITTLE architecture. Where system have mix of high-performance \u201cbig\u201d cores (e.g. A76) and power-efficient \u201cLITTLE\u201d cores(e.g. A55).</li> </ul> <p>The \"unsafe\" setting indicates that Xen will not take the necessary precautions to ensure secure scheduling between the heterogeneous cores, user need to ensure the CPU affinity is set correctly. Usually, DOM0 are pinned to big cores with higher performance and security features. This can help avoid the risk of running privileged code or security-sensitive tasks on less capable LITTLE cores. </p> <p>For Agilex\u2122 5 hmp-unsafe = true is mandatory to enable all the 4 cores otherwise only 2 cores are enabled by Xen Hypervisor.</p> <p>Dom0 Bootargs :</p> <ul> <li>root = /dev/mmcblk0p2: Specifies the location of the root filesystem on the SD card partition for the Linux kernel in DOM0. To boot using ramdiks image instead of SD card, use the following dom0-bootargs: xen,dom0-bootargs = \"initrd=0x8b000000 root=/dev/ram0 rw init=/sbin/init console=hvc0 earlycon=xen\";</li> </ul> <ul> <li>Console=hvc0: All output from the Linux kernel running in DOM0 will be directed to Hypervisor Virtual Console (hvc0). Xen manages the HVC consoles by creating a virtual console for each domain (DOM0 or DOMU). Each domain has its own independent virtual console, and Xen routes console I/O (input/output) for each domain appropriately. The HVC driver in the guest OS (DOM0 or DOMU) communicates with Xen via hypercalls, with Xen acting as an intermediary to route the data between the virtual console and the actual hardware UART port.</li> </ul> <p>DOM0 Linux guest OS have direct access to all the IO subsystem (peripheral device) like native Linux running without Xen Hypervisor, except for devices set for xen,passthrough.</p> <p>Once Xen boots the DOM0 Linux, the  xl tool is used to create a virtual machine (DOMU).</p> <p>To create a VM/DOMU, use the following command:</p> <pre><code>xl create -c &lt;domU configuration file&gt;\n</code></pre>"},{"location":"virtualization/hypervisors/xen/xen-overview/#domu-configuration","title":"DomU Configuration","text":"<p>Before creating DOMU guest VM, a ramdisk image \u201cxen-image-minimal-agilexX.cpio.gz \u201c needs to be copied to boards xen folder in DOM0 Linux. The ramkdisk image \u201cxen-image-minimal-agilexX.cpio.gz\u201d is not a part of the GSRD WIC image to reduce the size of the rootfs on SDcard/eMMC. Xen folder on SD card already contains partial device trees for the passthrough device (.dtb) and xen domu configuration file (.cfg)</p> <p>Below is the example DomU configuration file:</p> <pre><code># Guest name\nname = \"DomU1\"\n# Kernel image to boot\nkernel = \"/boot/Image\"\n# Ramdisk\nramdisk = \"xen-image-minimal-agilex5.cpio.gz\"\n# Linux boot args\nextra = \"root=/dev/ram0 init=/bin/sh console=hvc0 rdinit=/sbin/init\"\n# Initial memory allocation (MB)\nmemory = 1024\n# QSPI device passthrough example for dtb, iomem and irq parameters\ndevice_tree = \"spi@108d2000.dtb\"\niomem = [ \"0x108d2,1\", \"0x10900,100\" ]\nirqs = [ 35 ]\n</code></pre> <p>Parameters:</p> <ul> <li>iomem: IOMEM setup, assigned 1 page starting at \"0x108d20000\"  and 100 pages starting at \u201c0x10900000\u201d base address for QSPI peripheral in DOMU.</li> </ul> <ul> <li>irqs: Device specific interrupt. Xen irqs parameter is using GIC absolute interrupt numbering. In this example Shared Peripheral Interrupt number is 0x3, so additing 32 for the SPI interrupt to get the absolute interrupt used by GIC controller.   irqs = 3 + 32 = 35</li> </ul> <p>Note : To switch from DomU console to Dom0 console, use CTRL+ ] on terminal console. CTRL + ] doesn't work over the telnet, direct UART console access is required.</p> <p>To switch from Dom0 console to DomU console: <pre><code>xl console &lt;Domain Name&gt;\n</code></pre></p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#cpu-allocation","title":"CPU Allocation","text":"<p>Xen Hypervisor supports CPU core allocation at boot time (static CPU allocation) and can switch to another CPU core during runtime (dynamic CPU allocation) for Xen domains. Xen introduced the concept of vCPUs (virtual CPU) and pCPUs (physical CPU). </p> <p>Static CPU allocation : Xen parameters like \u201cmaxcpus\u201d and \u201cdom0_max_vcpus\u201d define the maximum number of CPUs available to Xen and DOM0. The \u201cdom0_vcpus_pin\u201d parameter allows vCPUs to be statically pinned to the specific pCPUs, improving performance and reducing overhead by avoiding unnecessary context switches. The \u201cvcpus\u201d parameter in the DOMU configuration file specifies the number of vCPUs per domain. </p> <p>Dynamic CPU allocation : If static configuration for vCPUs and pCPUs is not defined for Xen or domains, Xen will allocate vCPUs and pCPUs dynamically. </p> <p>To determine which physical CPU (pCPU) a Xen domain/guest is running on, you can use the <code>xl</code> command-line tool:</p> <pre><code>xl vcpu-list &lt;domain_name&gt;\n</code></pre> <p>It is also possible to switch the physical CPU (pCPU) for any Xen domain using:</p> <p><pre><code>xl vcpu-pin &lt;domain-id&gt; &lt;vcpu-id&gt; &lt;pcpu&gt; </code></pre> Parameters: *  : The ID of the domain (VM). Use xl vcpu-list to get the domain ID.  *  : The ID of the vCPU within the VM that you want to pin to a different pCPU. *  : The physical CPU to which you want to switch the vCPU. <p>The number of vCPUs and pCPUs assigned to a specific domain is highly depends on real time workload and performance characterization. </p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#gsrd-build-with-xen-hypervisor","title":"GSRD Build with Xen Hypervisor","text":"<p>Xen Hypervisor is built using Yocto \u201cmeta-virtualization\u201d layer, with recipe-extended included in \u201cmeta-intel-fpga-refdes\u201d layer to build Xen Hypervisor using altera github repository as part of GSRD.</p> <p>The \u201cbuild.sh\u201d script has been updated to include the \u201cmeta-virtualization\u201d layer for GSRD build. The environment variable BUILD_HYP needs to be set to 1, then the \u201cconf/layer.conf\u201d will include the \u201crecipes-extended\u201d that builds Xen Hypervisor. </p> <p>The Yocto changes are implemented in such a way that the same \u201cgsrd-console-image-xxxx.wic\u201d image can be used to boot either regular Linux or the Xen Hypervisor using a u-boot boot script. The first partition of the \u201cgsrd-console-image-agilexX.wic\u201d image contains the Linux kernel Image, device tree, core.rbf, boot.scr.xen.uimg and Xen binaries. </p> <p>Additional Linux kernel configuration for Xen Hypervisor is enabled \u201crecipes-kernel/linux/linux-socfpga-lts/xen.cfg\u201d and it gets included in default Linux kernel config (defconfig) for \u201chyp_build\u201d.  </p> <p>A U-boot boot script, \u201crecipes-bsp/u-boot/files/agilexX_uboot_xen.txt\u201d, has been added to update or modify Linux device tree for Xen Hypervisor boot by adding/removing required properties.</p> <p>Additionally, \u201crecipes-bsp/u-boot/files/agilexX_uboot_script_xen.its\u201d has been added, and \u201crecipes-bsp/u-boot/u-boot-socfpga-scr.bb\u201d has been updated to create the U-boot boot.scr image files using \u201cagilexX_uboot_xen.txt\u201d. The user can interrupt the U-Boot autoboot process and run the \u201cboot.scr.xen.uimg\u201d to boot the Xen Hypervisor. </p> <p>New image, \u201cxen-image-minimal\u201d, has been added to the GSRD Yocto build to use with DOM0/DOMU Linux guest OS. The file \u201crecipes-extended/images/xen-image-minimal.bbappend\u201d has been added to create a smaller image by removing unnecessary packages.</p>"},{"location":"virtualization/hypervisors/xen/xen-overview/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/","title":"Clock Manager Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) clock generation is centralized in the clock manager. The clock manager is responsible for providing software-programmable clock control to configure all clocks generated in the HPS. Clocks are organized in clock groups. A clock group is a set of clock signals that originate from the same clock source which may be synchronous to each other. The clock manager has two phase-locked loop (PLL) clock group where the clock source is a common PLL voltage-controlled oscillator (VCO). A clock group that is independent and asynchronous to other clocks may only have a single clock, also known as a clock slice. Peripheral clocks are a group of independent clock slices.</p> <p></p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/clock_control/clock_control_agilex5.c.</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supply clock to each HPS peripheral as configured in the boot loader and provide an API to retrieve the clock for each peripheral.</li> <li>Clock Manager will be initialized only one time during boot up by FSBL (ATF BL2) based on external user settings stored in HPS handoff data in bitstream.</li> </ul>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_CLOCK_CONTROL</p> <p></p> <p>CONFIG_CLOCK_CONTROL_AGILEX5</p> <p></p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p> <p>A clock manager node will be added in device tree.  Then, the peripheral can associate the clock manager in device tree so that the peripheral driver code can retrieve the clock frequency from clock manager. One such example is shown below.</p> <p></p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#known-issues","title":"Known Issues","text":"<p>None Known. </p>"},{"location":"zephyr-embedded/dma/dma/","title":"DMA Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: No</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/dma/dma/#introduction","title":"Introduction","text":"<p>DMA Controller controls the transfer of data between I/O devices and memory without CPU involvement. DMA controller can access the memory directly for reading and writing. This helps to enhance the performance of the cores to do some other operations, as the data transfers are handled by the DMA controller.</p> <p>The hard processor system (HPS) provides two DMA Controllers based on the Synopsis-Designware IP.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/dma/dma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/drivers/dma/dma_dw_axi.c.</p>"},{"location":"zephyr-embedded/dma/dma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Driver supports scatter-gather list.</li> <li>Driver can be configured for one of the possible three use cases.     * Memory to Memory Transfer     * Device to Memory Transfer     * Memory to Device Transfer</li> <li>Each DMA controller can support up to four channels for DMA transfer.</li> <li>Driver supports DMA transfer suspend.</li> <li>Driver supports DMA transfer resume.</li> <li>Driver supports to stop active DMA transfer.</li> </ul>"},{"location":"zephyr-embedded/dma/dma/#kernel-configurations","title":"Kernel Configurations","text":""},{"location":"zephyr-embedded/dma/dma/#device-tree","title":"Device Tree","text":"<p>Device Tree location to configure DMA is</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <pre><code>dma0: dma@10DB0000 {\ncompatible = \"snps,dw-axi-dma\";\n#dma-cells = &lt;2&gt;;\nreg = &lt;0x10DB0000 0x1000&gt;;\ninterrupt-parent = &lt;&amp;gic&gt;;\ninterrupts = &lt;GIC_SPI 81 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 82 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 83 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 84 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;;\ndma-channels = &lt;4&gt;;\nresets = &lt;&amp;reset RSTMGR_DMA_RSTLINE&gt;;\nstatus = \"disabled\";\n};\n</code></pre>"},{"location":"zephyr-embedded/dma/dma/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/dma/mem_to_mem/.</p> <p>The most relevant files are:</p> <ol> <li>Project yml -&gt; sample.yml:</li> </ol> <pre><code> 1 sample:\n 2   name: DMA\n 3   description: DMA Driver sample application\n 4 common:\n 5   tags:\n 6     - drivers\n 7     - dma\n 8 tests:\n 9   sample.drivers.dma.mem_to_mem:\n10     build_only: true\n11     harness: console\n12     integration_platforms:\n13       - intel_socfpga_agilex5_socdk\n14     harness_config:\n15       type: multi_line\n16       ordered: true\n17       regex:\n18         - \"Sample application for Memory to Memory transfer using dma controller\"\n19         - \"Successfully transferred\"\n20         - \"Sample application for dma transfer complete\"\n21     filter: DT_HAS_SNPS_DESIGNWARE_DMA_ENABLED\n22     depends_on: dma\n</code></pre> <ol> <li> <p>Config overlay -&gt; prj.conf: <pre><code>  1 CONFIG_DMA=y\n  2 CONFIG_LOG=y\n</code></pre></p> </li> <li> <p>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</p> </li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (c) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 &amp;dma0 {\n  8         status = \"okay\";\n  9 };\n</code></pre> 4. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/dma/mem_to_mem/src/main.c.</p>"},{"location":"zephyr-embedded/dma/dma/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/dma/mem_to_mem/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/dma/dma/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n[00:00:00.125,000] &lt;inf&gt; clock_control_agilex5: Intel Agilex5 clock driver initialized!\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nSample application for Memory to Memory transfer using dma controller\ndma@10DB0000: Successfully transferred 10 blocks of size:200 channel:1\nSample application for dma transfer complete\n</code></pre>"},{"location":"zephyr-embedded/dma/dma/#known-issues","title":"Known Issues","text":"<p>None Known. </p>"},{"location":"zephyr-embedded/gpio/gpio/","title":"General Purpose I/O Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/gpio/gpio/#introduction","title":"Introduction","text":"<p>General Purpose Input/Output (GPIO) Controller provides the low-level configuration through software or hardware to control the actual general purpose IO cells/pads present in the HPS.  The below diagram represents block diagram of the GPIO controller connected with other components in the system.</p> <p></p> <p>Two GPIO module instances present in HPS and each having support of 24 GPIO ports. Only Port A of GPIO Controller is configured. All the design contained of this document is referred from \u201cSynopsys GPIO Databook\u201d.</p> <p>Functional Modes:</p> <ul> <li>Software Control Mode: In the software control mode, the port direction is set by writing to the corresponding port control register of a GPIO pin. These port control registers are memory mapped.</li> <li>Hardware Control Mode : If a signal is configured for hardware control, an external auxiliary hardware-signal controls the direction of the port. For the SM, Auxiliary H/W support is not enabled.</li> </ul> <p>For More information please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/gpio/gpio/#features","title":"Features","text":"<ul> <li>Digital debounce</li> <li>Configurable interrupt mode</li> <li>Up to 48 dedicated I/O pins</li> </ul>"},{"location":"zephyr-embedded/gpio/gpio/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/drivers/gpio/gpio_intel_socfpga.c.</p>"},{"location":"zephyr-embedded/gpio/gpio/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>GPIO Pin configure as input or output.</li> <li>GPIO Port/Pin set value using mask.</li> <li>GPIO Port/Pin get value using mask.</li> <li>GPIO Port/Pin toggle using mask.</li> </ul>"},{"location":"zephyr-embedded/gpio/gpio/#kernel-configurations","title":"Kernel Configurations","text":"<p>No additional Kernel configurations needed to enable GPIO driver functionality.</p>"},{"location":"zephyr-embedded/gpio/gpio/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/gpio/gpio/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/basic/blinky.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: Blinky Sample\n 3 tests:\n 4   sample.basic.blinky:\n 5     tags:\n 6       - LED\n 7       - gpio\n 8     filter: dt_enabled_alias_with_parent_compat(\"led0\", \"gpio-leds\")\n 9     depends_on: gpio\n10     harness: led\n11     integration_platforms:\n12       - frdm_k64f\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code>CONFIG_GPIO=y\n</code></pre> <ol> <li>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 #include &lt;dt-bindings/gpio/gpio.h&gt;\n  8 \n  9 / {\n 10         aliases {\n 11                 led0 = &amp;myled0;\n 12         };\n 13 \n 14         leds {\n 15                 compatible = \"gpio-leds\";\n 16                 myled0: led_0 {\n 17                         gpios = &lt;&amp;gpio1 19 GPIO_ACTIVE_HIGH&gt;;\n 18                 };\n 19         };\n 20 };\n 21 \n 22 &amp;gpio1 {\n 23         status = \"okay\";\n 24 };\n</code></pre> 4. Agilex\u2122 5 specific board configuration -&gt;  intel_socfpga_agilex5_socdk.conf  <pre><code>  1 # Copyright (c) 2023, Intel Corporation.\n  2 # SPDX-License-Identifier: Apache-2.0\n  3 \n  4 CONFIG_STDOUT_CONSOLE=y\n  5 CONFIG_PRINTK=y\n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/basic/blinky.</p>"},{"location":"zephyr-embedded/gpio/gpio/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/basic/blinky  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/gpio/gpio/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nGPIO blinky application started\nGPIO toggle started for 10 times\nGPIO blinky Application completed!!!\n</code></pre>"},{"location":"zephyr-embedded/gpio/gpio/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/gpio/gpio/#other-consideration","title":"Other Consideration","text":"<p>Pinmux configuration should be in GPIO mode to use respective IO functionality.</p>"},{"location":"zephyr-embedded/psci/psci/","title":"Power State Coordination Interface (PSCI) driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/psci/psci/#introduction","title":"Introduction","text":"<p>Power State Coordination Interface (PSCI) is an Arm\u00ae standard that describes a software interface for power management between and operating system and supervisory firmware. Refer to Arm PSCI Platform Design Document for the PSCI interface specification.</p> <p>The following diagram shows the interaction between Zephyr/OS and Secure Monitor firmware ATF BL31 for PSCI interface.</p> <p></p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/psci/psci/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/pm_cpu_ops/pm_cpu_ops_psci.c</p>"},{"location":"zephyr-embedded/psci/psci/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>This driver provides the cold and warm reset functionality.</li> <li>This driver/module also provides a shell interface via which user can issue cold/warm reset commands.</li> </ul>"},{"location":"zephyr-embedded/psci/psci/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_PM_CPU_OPS</p> <p></p> <p>CONFIG_PM_CPU_OPS_PSCI</p> <p></p>"},{"location":"zephyr-embedded/psci/psci/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the PSCI:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/psci/psci/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/qspi/qspi/","title":"QSPI Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/qspi/qspi/#introduction","title":"Introduction","text":"<p>The HPS has the capability to access serial NOR Flash connected to the SDM quad serial peripheral interface (SPI). The quad SPI flash controller supports standard SPI Flash devices as well as high-performance dual and quad SPI Flash devices.</p> <p>On power up, the SDM owns the QSPI controller. For the HPS to use the QSPI controller, the HPS must request ownership from the SDM.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>QSPI driver (Polling-based mechanism - Upstreamed): https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/flash/flash_cadence_qspi_nor.c</p> <p>QSPI driver (with Interrupt-based mechanism \u2013 Not yet Upstreamed): https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/drivers/flash/flash_cadence_qspi_nor.c</p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supported Operations: Read, Write, Erase</li> </ul>"},{"location":"zephyr-embedded/qspi/qspi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_FLASH</p> <p></p> <p>CONFIG_FLASH_CAD_QSPI_NOR</p> <p></p> <p>CONFIG_FLASH_PAGE_LAYOUT</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the QSPI: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/soc_flash_qspi.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <p>```   1  sample:   2   description: Cadence QSPI Driver sample application.   3   name: cdns_qspi_nor   4 tests:   5   sample.drivers.flash.soc_flash_qspi:   6     platform_allow:   7       - intel_socfpga_agilex5_socdk   8     integration_platforms:   9       - intel_socfpga_agilex5_socdk  10     tags:  11       - flash  12       - cdns  13     harness: console  14     harness_config:  15       fixture: external_flash  16       type: multi_line  17       ordered: true</p> <p>```</p> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <p><pre><code>  1 # Copyright (c) 2023, Intel Corporation.\n  2 # SPDX-License-Identifier: Apache-2.0\n  3 \n  4 # Misc\n  5 CONFIG_HEAP_MEM_POOL_SIZE=363840\n  6 \n  7 # Enable Flash\n  8 CONFIG_FLASH=y\n  9 CONFIG_FLASH_PAGE_LAYOUT=y\n 10 CONFIG_LOG=y\n</code></pre> 4. Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay <pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  * SPDX-License-Identifier: Apache-2.0\n  4  */\n  5\n  6 /* The overlay file should be used to enable any\n  7  * dts nodes required by this application for this\n  8  * board.\n  9  */\n 10\n 11 / {\n 12         aliases {\n 13                 qspi = &amp;qspi;\n 14         };\n 15 };\n 16\n 17 &amp;qspi {\n 18         status = \"okay\";\n 19 };\n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/soc_flash_qspi/src/main.c.</p>"},{"location":"zephyr-embedded/qspi/qspi/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/soc_flash_qspi/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/qspi/qspi/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n[00:00:00.219,000] &lt;inf&gt; clock_control_agilex5: Intel Agilex5 clock driver initialized!\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: Initializing Qspi\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: QSPI Capacity: 10000000\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: Flash size: 268435456 Bytes\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nQSPI flash driver test sample\nQSPI flash device block size = 100\nQSPI flash number of pages = 100000\nQSPI flash driver block size 100\nThe Page size of 100\nQSPI flash driver data erase successful....\nQSPI flash driver write completed....\nQSPI flash driver read completed....\nQSPI flash driver read verified\nQSPI flash driver data erase successful....\nQSPI flash driver read verified after erase....\nQSPI flash driver test sample completed....\n</code></pre>"},{"location":"zephyr-embedded/qspi/qspi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/","title":"Reset Manager for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#introduction","title":"Introduction","text":"<p>The Reset Manager generates individual module reset signals. Each module takes its module reset signal from the Reset Manager and conditions it to match the reset requirements of that module. The reset controller is designed to work with the SDM, which acts as the software-controlled master reset for the HPS. </p> <p>The following diagram shows the Reset Manager connectivity with Agilex5 HPS.</p> <p></p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/commits/main/drivers/reset/reset_intel_socfpga.c.</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Reset manager provides the capability to reset (bring it out of reset state) each peripheral in the system separately.</li> <li>It provides API to assert, de-assert, and toggle the reset line of each peripheral.</li> </ul>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_RESET</p> <p></p> <p>CONFIG_RESET_INTEL_SOCFPGA</p> <p></p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the Reset manager IP:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/seu/seu/","title":"Single Event Upset (SEU)","text":"<p>Single Error Upset (SEU) Driver for Hard Processor System</p> <p>Last updated: January 22, 2026 </p> <p>Upstream Status: In Progress</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/seu/seu/#introduction","title":"Introduction","text":"<p>The SEU driver is meticulously crafted to fulfill a dual purpose within its operational framework. Its primary function lies in promptly detecting and reporting single event upsets errors to users. Additionally, this subsystem offers a streamlined mechanism for the deliberate insertion of errors.</p> <p>For more information, please refer to the Agilex5 SEU Mitigation.</p>"},{"location":"zephyr-embedded/seu/seu/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/pull/67097.</p>"},{"location":"zephyr-embedded/seu/seu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supports user register/unregister callback</li> <li>Support inject ECC error</li> <li>Support injects single/multibit errors</li> </ul>"},{"location":"zephyr-embedded/seu/seu/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SEU</p> <p></p> <p>CONFIG_SEU_INTEL_SOCFPGA</p> <p></p> <p>CONFIG_SEU_MAX_CLIENT</p> <p></p> <p>CONFIG_ MAX_TIMEOUT_MSECS</p> <p></p>"},{"location":"zephyr-embedded/seu/seu/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the SEU is at https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi.</p> <p></p>"},{"location":"zephyr-embedded/seu/seu/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"zephyr-embedded/smp/smp/","title":"SMP (Symmetric Multi-Processing) support for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/smp/smp/#introduction","title":"Introduction","text":"<p>SMP (Symmetric Multi-Processing) refers to running operating system on multiple CPU cores. Zephyr kernel supports SMP which can turn on and off the non-boot cores (aka secondary cores).</p> <p>Zephyr sends \u201cCPU_ON\u201d and \u201cCPU_OFF\u201d functions via PSCI SMC to ATF BL31 to turn on and off individual core. Zephyr supports CPU hot plug which provides public API and command line to turn on and off the individual core including both boot and non-boot cores during runtime. </p> <p>The below diagram shows HPS SMP flow (CPU_ON and CPU_OFF) supported by Zephyr:</p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/smp/smp/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/arch/arm64/core/smp.c</p>"},{"location":"zephyr-embedded/smp/smp/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Bring up secondary cores; power-on, initialize the secondary cores and make them ready to run as part of multi-core boot system.</li> </ul>"},{"location":"zephyr-embedded/smp/smp/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SMP</p> <p></p> <p>CONFIG_MP_MAX_NUM_CPUS=4</p> <p></p>"},{"location":"zephyr-embedded/smp/smp/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the smp:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/smp/smp/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/timer/timer/","title":"General Purpose Timer Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/timer/timer/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) provides four 32-bit general-purpose timers. The timer generates an interrupt when the 32-bit binary count-down timer reaches zero.</p> <p>Each timer can operate in one-shot mode (alarm mode) or periodic mode.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/counter/counter_dw_timer.c.</p>"},{"location":"zephyr-embedded/timer/timer/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>The timer can be configured to run as a one-shot timer(alarm).</li> <li>The timer can be configured to run as a periodic timer.</li> <li>Run timer in free running mode.</li> <li>Stop Timer.</li> </ul>"},{"location":"zephyr-embedded/timer/timer/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_COUNTER_SNPS_DW</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the timer:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/counter/alarm.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: Counter RTC Driver Sample\n 3 tests:\n 4   sample.drivers.counter.alarm:\n 5     tags:\n 6       - drivers\n 7       - counter\n 8     harness: console\n 9     platform_allow:\n10       - nucleo_f746zg\n       .....   \n27       - stm32h573i_dk\n28     integration_platforms:\n29       - nucleo_f746zg\n30     harness_config:\n31       type: multi_line\n32       ordered: true\n33       regex:\n34         - \"Counter alarm sample\"\n35         - \"Set alarm in 2 sec\"\n36         - \"!!! Alarm !!!\"\n37         - \"Now: [2|3]\"\n38     depends_on: counter\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code> 1 CONFIG_PRINTK=y\n 2 CONFIG_COUNTER=y                     \n</code></pre> <ol> <li>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 &amp;timer0 {\n  8         status = \"okay\";\n  9 };\n</code></pre> 4. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/counter/alarm/src/main.c.</p>"},{"location":"zephyr-embedded/timer/timer/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/counter/alarm  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/timer/timer/#output","title":"Output","text":"<pre><code>NOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nCounter alarm sample\n\nSet alarm in 2 sec (200000000 ticks)\n!!! Alarm !!!\nNow: 1\nSet alarm in 4 sec (400000000 ticks)\n</code></pre>"},{"location":"zephyr-embedded/timer/timer/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/uart/uart/","title":"UART Driver for Hard Processor System","text":"<p>Last updated: January 22, 2026 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/uart/uart/#introduction","title":"Introduction","text":"<p>Universal Asynchronous Receiver/Transmitter (UART) that is part of the hardened Hard Processor System (HPS) of the FPGA performs parallel to serial data conversion from HPS CPU to device or serial-to-parallel data conversion from device to HPS CPU. The UART controllers are based on an industry standard 16550 UART controller.</p> <p>The below diagram represents block diagram of the UART controller connected with other components in the system.</p> <p></p> <p>Functional blocks:</p> <ul> <li>Slave interface: connects to APB bus.</li> <li>Register block: responsible for the main UART functionality including control, status, and interrupt generation.</li> <li>FIFO block: responsible for FIFO control and storage.</li> <li>Baud block generator: produces the transmitter and receiver baud clock along with the output reference clock signal.</li> <li>Serial transmitter: converts the parallel data-written to the UART-into serial form and adds all additional bits, as specified by the control register, for transmission. These serial data referred to as a character.</li> <li>Serial receiver: converts the serial data character-specified by the control register-receive in the UART to parallel form. This block controls, parity, framing and line break detection errors.</li> </ul> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/uart/uart/#features","title":"Features","text":"<ul> <li>Programmable character properties, such as number of data bits per character, optional parity bits, and number of stop bits.</li> <li>Automatic hardware flow control as per the 16750 standards.</li> <li>128-byte transmit and receive FIFO buffers.</li> <li>Transmit Holding Register Empty (THRE) interrupt mode.</li> <li>DMA controller handshaking interface.</li> <li>Parity error detection, Framing error detection and, Line break detection.</li> <li>Prioritized interrupt identification with different interrupt types.</li> </ul>"},{"location":"zephyr-embedded/uart/uart/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/commits/main/drivers/serial/uart_ns16550.c.</p>"},{"location":"zephyr-embedded/uart/uart/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the asynchronous communication between HPS CPU and device, and vice versa.</li> <li>Supports Full Duplex communication and Polling/Interrupt based mechanism for data transfer. </li> <li>Supports 16 bytes FIFO with automatic hardware flow control (RTS and CTS lines).</li> </ul>"},{"location":"zephyr-embedded/uart/uart/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_UART_NS16550</p> <p></p> <p>CONFIG_UART_INTERRUPT_DRIVEN</p> <p></p> <p>CONFIG_UART_NS16550_ACCESS_WORD_ONLY</p> <p></p>"},{"location":"zephyr-embedded/uart/uart/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the uart:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/uart/uart/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/uart/echo_bot.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: UART driver sample\n 3 tests:\n 4   sample.drivers.uart:\n 5     integration_platforms:\n 6       - qemu_x86\n 7     tags:\n 8       - serial\n 9       - uart\n10     filter: CONFIG_SERIAL and\n11             CONFIG_UART_INTERRUPT_DRIVEN and\n12             dt_chosen_enabled(\"zephyr,shell-uart\")\n13     harness: keyboard\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code>  1 CONFIG_SERIAL=y\n  2 CONFIG_UART_INTERRUPT_DRIVEN=y\n</code></pre> <ol> <li>Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/uart/echo_bot/src/main.c.</li> </ol>"},{"location":"zephyr-embedded/uart/uart/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/uart/echo_bot/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/uart/uart/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nHello! I'm your echo bot.\nTell me something and press enter:\nEcho: hello there\n</code></pre>"},{"location":"zephyr-embedded/uart/uart/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"zephyr-embedded/watchdog/watchdog/","title":"Watchdog Timer Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#introduction","title":"Introduction","text":"<p>The watchdog timer is used mainly to recover from system lockup that might be caused by software or system-related issues. </p> <p>The hard processor system (HPS) provides five Watchdog Timers based on synopsis designware.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/watchdog/wdt_dw.c.</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Watchdog can be enabled/disabled in driver initialization when zephyr boots through Kconfig option.</li> <li>Enable/Disable watchdog interrupt when the timer expires.</li> <li>Watchdog Timers counts down from a preset value to zero, then performs one of the following user-configurable operations:     * Generates a system reset.     * Generates an interrupt, restarts the timer, and if the timer is not cleared before a second timeout occurs, generates a system reset Driver can be configured for one of the possible three use cases.</li> </ul>"},{"location":"zephyr-embedded/watchdog/watchdog/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ WDT_DW</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the Watchdog:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/watchdog.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <p>```   1 sample:   2   name: Watchdog Driver Sample   3 common:   4   tags:   5     - drivers   6     - watchdog   7   harness: console   8   harness_config:   9     type: multi_line  10     ordered: true  11     regex:  12       - \"Watchdog sample application\"  13       - \"Feeding watchdog...\"  14       - \"Waiting for reset...\"  15       - \"Watchdog sample application\"  16   depends_on: watchdog</p> <p>```</p> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <p><pre><code>  1 CONFIG_LOG=y\n  2 CONFIG_LOG_MODE_IMMEDIATE=y\n  3 CONFIG_WDT_LOG_LEVEL_DBG=y\n  4 CONFIG_WATCHDOG=y\n  5 CONFIG_WDT_DISABLE_AT_BOOT=n\n</code></pre> 3. Specific board config -&gt; intel_socfpga_agilex5_socdk.conf  <pre><code>  1 CONFIG_WDT_DW_RESET_MODE=2\n  2 CONFIG_WDT_DW_PAUSE_BY_DBG=y\n</code></pre> 4. Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay <pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6\n  7 / {\n  8         aliases {\n  9                 watchdog0 = &amp;watchdog0;\n 10         };\n 11 };\n 12\n 13 &amp;watchdog0 {\n 14         interrupt-parent = &lt;&amp;gic&gt;;\n 15         interrupts = &lt;GIC_SPI 117 IRQ_TYPE_LEVEL\n 16                         IRQ_DEFAULT_PRIORITY&gt;;\n 17         status = \"okay\";\n 18 };             \n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/watchdog/src/main.c.</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/watchdog/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/watchdog/watchdog/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nWatchdog sample application\nAttempting to test pre-reset callback\nFeeding watchdog 5 times\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nWaiting for reset...\nHandled things..ready to reset\nNOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nWatchdog sample application\nAttempting to test pre-reset callback\nFeeding watchdog 5 times\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nWaiting for reset...\n</code></pre>"},{"location":"zephyr-embedded/watchdog/watchdog/#known-issues","title":"Known Issues","text":"<p>None known</p>"}]}