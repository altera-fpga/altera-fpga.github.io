{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Altera FPGA Developer Site  <p>Welcome to the Altera FPGA Developer Site!</p> <p>This site provides key information for Stratix 10\u00ae,  Agilex\u2122 5 and Agilex\u2122 7 FPGAs including:</p> <ul> <li>Comprehensive driver information for Linux and software utilities.</li> </ul> <ul> <li>Documentation for how to use example designs and tutorials found on our altera-fpga GitHub site.</li> </ul> <p>   <p></p> <p>Use the table below to help you get started.</p>    Software Developer FPGA Developer Application Developer          Take advantage of our software resources to develop a full stack solution for your applications:* Linux Drivers  * Host Attach Utilities Use our design example resources as a starting point for your own custom design or peruse our demos to learn more about a specific topic: * Example Designs * Demos Review our software utilities and higher level stack offerings:* Host Attach Utilities","text":""},{"location":"baremetal-embedded/agilex-5/e-series/premium/ug-baremetal-agx5e-premium/","title":"Agilex\u2122 5 E-Series Premium Development Kit Baremetal Hello World Example","text":""},{"location":"baremetal-embedded/agilex-5/e-series/premium/ug-baremetal-agx5e-premium/#overview","title":"Overview","text":"<p>This page demonstrates how to use the baremetal drivers for a simple hello world program, running from SDRAM, and booting from QSPI, on the Agilex 5 E-Series Premium Development Kit</p> <p>ATF (Arm Trusted Firmware) is used, composed of the following two components:</p> <ul> <li>ATF bl22: First stage bootloader. Part of the bitstream. Initializes hardware, including SDRAM, and loads FIP image.</li> <li>ATF bl31: Secure Monitor Handler. Can perform services for the baremetal application for certain scenarios, such as configuring the FPGA fabric.</li> </ul> <p>The layout of the QSPI flash is as follows:</p> Address Description 0x0000_0000 Bitstream, including ATF bl2 0x03C0_0000 FIP image, including ATF bl31 and baremetal image"},{"location":"baremetal-embedded/agilex-5/e-series/premium/ug-baremetal-agx5e-premium/#build-flow","title":"Build Flow","text":"<p>The build flow is depicted in the following diagram:</p> <p></p> <p>The following inputs are used:</p> Item Link Baremetal Drivers Source baremetal-drivers Baremetal CMake Project File CMakeLists.txt Programming File Generator File flash_image.pfg Arm Trusted Firmware Source arm-trusted-firmware Precompiled GHRD SOF ghrd_a5ed065bb32ae6sr0_hps_debug.sof <p>Note that for the GHRD SOF we are using the SOF which has the debug FSBL inside as it was more convenient to download with an existing direct file link. However, the debug FSBL inside is overwritten with the ATF bl2 when the output QSPI flash JIC image is created.</p>"},{"location":"baremetal-embedded/agilex-5/e-series/premium/ug-baremetal-agx5e-premium/#build-instructions","title":"Build Instructions","text":"<p>1. Create the top folder to store this example:</p> <pre><code>rm -rf bm_example.agilex5\nmkdir bm_example.agilex5\ncd bm_example.agilex5\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Set up the toolchain required to build the example:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/13.2.rel1/binrel/arm-gnu-toolchain-13.2.rel1-x86_64-aarch64-none-elf.tar.xz\ntar xf arm-gnu-toolchain-13.2.rel1-x86_64-aarch64-none-elf.tar.xz\nrm -f arm-gnu-toolchain-13.2.rel1-x86_64-aarch64-none-elf.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-13.2.Rel1-x86_64-aarch64-none-elf/bin/:$PATH\nexport CROSS_COMPILE=aarch64-none-elf-\n</code></pre> <p>3. Add Quartus tools to the PATH - only the Quartus Programmer tools are actually used:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>4. Build ATF</p> <pre><code>cd $TOP_FOLDER\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware atf\nmake -C atf fiptool\nmake -C atf bl2 bl31 PLAT=agilex5 DEBUG=1 SOCFPGA_BOOT_SOURCE_QSPI=1 LOG_LEVEL=50\n</code></pre> <p>5. Retrieve the baremetal library sources:</p> <pre><code>cd $TOP_FOLDER\nrm -rf baremetal-drivers*\ngit clone -b 24.3 https://github.com/altera-fpga/baremetal-drivers\n</code></pre> <p>6. Create the sample application folder:</p> <pre><code>cd $TOP_FOLDER\nrm -rf baremetal-example\nmkdir baremetal-example\ncd baremetal-example\n</code></pre> <p>7. Bring in the hello world source code:</p> <pre><code>cp $TOP_FOLDER/baremetal-drivers/test/simics/hello-world/printf_hello_world.c hello_world.c\n</code></pre> <p>8. Bring in the cmake file for the project:</p> <pre><code>wget https://altera-fpga.github.io/rel-24.3/baremetal-embedded/agilex-5/e-series/premium/collateral/CMakeLists.txt\n</code></pre> <p>The file looks like this: <pre><code>cmake_minimum_required(VERSION 3.5...3.28)\n# disable building tests\nset(BUILD_TESTS OFF)\n# library dir\nget_filename_component(LIBRARY_DIR \"../baremetal-drivers\" ABSOLUTE)\n# library project\nadd_subdirectory(${LIBRARY_DIR} alterametal)\n# linker script\nset(ALTERAMETAL_LINKER_SCRIPT \"${LIBRARY_DIR}/build/aarch64/core0.ld\")\n# project\nproject(bm_hello_world C CXX ASM)\n# target\nadd_executable(hello_world.elf)\n# sources\ntarget_sources(hello_world.elf\n    PRIVATE\n        hello_world.c\n)\n# link to the baremetal library\ntarget_link_libraries(hello_world.elf PRIVATE\n    alterametal\n)\n# specify linker script\ntarget_link_options(hello_world.elf PRIVATE\n    -T${ALTERAMETAL_LINKER_SCRIPT}\n)\n</code></pre></p> <p>9. Setup the build using cmake, build the executable and create the bin file</p> <pre><code>mkdir build\ncd build\ncmake -GNinja ..\nninja hello_world.elf\n${CROSS_COMPILE}objcopy -O binary hello_world.elf hello_world.bin\n</code></pre> <p>10. Build FIP file, containing ATF bl31 and the hello application</p> <pre><code>$TOP_FOLDER/atf/tools/fiptool/fiptool create --soc-fw $TOP_FOLDER/atf/build/agilex5/debug/bl31.bin --nt-fw hello_world.bin fip.bin\n</code></pre> <p>11. Bring the Programming File Generator file, used to instruct Quartus Programmer how to create the flash image:</p> <pre><code>wget https://altera-fpga.github.io/rel-24.3/baremetal-embedded/agilex-5/e-series/premium/collateral/flash_image.pfg\n</code></pre> <p>The file looks like this:</p> <p><pre><code>&lt;pfg version=\"1\"&gt;\n&lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n&lt;output_files&gt;\n&lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n&lt;file_options/&gt;\n&lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;secondary_file type=\"SEC_RPD\" name=\"flash_image_jic\"&gt;\n&lt;file_options bitswap=\"1\"/&gt;\n&lt;/secondary_file&gt;\n&lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n&lt;/output_file&gt;\n&lt;/output_files&gt;\n&lt;bitstreams&gt;\n&lt;bitstream id=\"Bitstream_1\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"bl2.hex\"&gt;design.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;/bitstreams&gt;\n&lt;raw_files&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;fip.bin&lt;/raw_file&gt;\n&lt;/raw_files&gt;\n&lt;flash_devices&gt;\n&lt;flash_device type=\"MT25QU512\" id=\"Flash_Device_1\"&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03C00000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"fip\" size=\"0\"/&gt;\n&lt;/flash_device&gt;\n&lt;flash_loader&gt;a5ed065bb32ae5sr0&lt;/flash_loader&gt;\n&lt;/flash_devices&gt;\n&lt;assignments&gt;\n&lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n&lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"0\" partition_id=\"fip\"&gt;\n&lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;/assignments&gt;\n&lt;/pfg&gt;\n</code></pre> 12. Convert bl2 to hex format to be used by Programming File Generator:</p> <pre><code>${CROSS_COMPILE}objcopy -v -I binary -O ihex --change-addresses 0x0 $TOP_FOLDER/atf/build/agilex5/debug/bl2.bin bl2.hex\n</code></pre> <p>13. Create JIC File, using the prebuilt hardware SOF file from GSRD release:</p> <pre><code>wget -O design.sof https://releases.rocketboards.org/2024.11/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0_hps_debug.sof\nquartus_pfg -c flash_image.pfg\n</code></pre>"},{"location":"baremetal-embedded/agilex-5/e-series/premium/ug-baremetal-agx5e-premium/#run-example","title":"Run Example","text":"<p>1. Set up the board as described in the GSRD Configure Board.</p> <p>2. Power down board</p> <p>3. Set up MSEL dipswitch SW27 for JTAG boot: OFF-OFF-OFF-OFF</p> <p>4. Power up board</p> <p>5. Program the QSPI flash with the JIC file:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;$TOP_FOLDER/baremetal-example/build/flash_image.hps.jic\"\n</code></pre> <p>6. Power down board</p> <p>7. Set up MSEL dipswitch SW27 for QSPI boot:OFF-ON-ON-OFF</p> <p>8. Power up board</p> <p>9. Observe on the HPS serial console how bl31 is ran, then it loads the FIP image, and runs the baremetal application which prints the hello world message.</p>"},{"location":"baremetal-embedded/agilex-5/e-series/premium/ug-baremetal-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"common/templates/linux_driver_template/","title":"Host Attach DFL FPGA Management Engine IP Driver","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"common/templates/linux_driver_template/#introduction","title":"Introduction","text":"<p>This set of drivers is designed to support FME functionality, as implemented under FPGA Device Feature List (DFL) framework. It is used to expose FME capabilities.</p> Driver Mapping Source(s) Required for DFL dfl-fme.ko FPGA Management Engine IP drivers/fpga/ - dfl-fme.h, dfl-fme-main.c, dfl-fme-pr.c, dfl-fme-error.c, dfl-fme-perf.c Y dfl-fme-mgr.ko PR IP drivers/fpga/dfl-fme-mgr.c N dfl-fme-br.ko SW Dependency drivers/fpga/dfl-fme-br.c N dfl-fme-region.ko SW Dependency drivers/fpga/dfl-fme-region.c N <pre><code>graph TD;\n    A[dfl-fme]--&gt;B[dfl-fme-mgr];\n    A[dfl-fme]--&gt;C[dfl-fme-br];\n    A[dfl-fme]--&gt;D[dfl-fme-region]; </code></pre>"},{"location":"common/templates/linux_driver_template/#fpga-management-engine-ip","title":"FPGA Management Engine IP","text":"<p>The FPGA Management Engine IP provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA. Implementation of a PR region is optional.</p> <p>Each FME feature exposes its capability to host software drivers through a device feature header (DFH) register found at the beginning of its control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link. For more information about DFHs, refer to the Device Feature Header (DFH) structure.</p>"},{"location":"common/templates/linux_driver_template/#driver-sources","title":"Driver Sources","text":"<p>The source code for these drivers can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga, where branches labelled fpga-ofs-dev-*-lts correspond with the latest developmental versions of the DFL driver suite on that specific kernel version.</p>"},{"location":"common/templates/linux_driver_template/#driver-capabilities","title":"Driver Capabilities","text":"<p>This driver set is a DFL specific implementation of generic FPGA drivers available in the kernel. <code>dfl-fme-mgr</code> is a DFL specific instantiation of the generic FPGA manager (drivers/linux/fpga/fpga-mgr.c), <code>dfl-fme-br</code> builds on top of a generic FPGA bridge (drivers/fpga/fpga-bridge.c), and <code>dfl-fme-region</code> instantiates an FPGA region. All three supplementary DFL Drivers depend on <code>dfl-fme</code>.</p> <p>The DFL FME driver is a feature device implemented under the Device Feature List (DFL) framework. It enables the platform driver for the FME IP and implements all FPGA platform level management features. Only one FME is created per DFL based FPGA device. The DFL Bridge, Manager, and Region drivers are only required when attempting to configure a PR region in the FIM.</p>"},{"location":"common/templates/linux_driver_template/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_FME</p> <p></p> <p>FPGA_DFL_FME_MGR</p> <p></p> <p>FPGA_DFL_FME_BRIDGE</p> <p></p> <p>FPGA_DFL_FME_REGION</p> <p></p>"},{"location":"common/templates/linux_driver_template/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"common/templates/linux_driver_template/#example-designs","title":"Example Designs","text":"<p>The FPGA Management Engine IP is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"doc_modules/Notices_%26_Disclaimers/","title":"Notices & Disclaimers","text":""},{"location":"doc_modules/Notices_%26_Disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"driver-list/driver-list-all/","title":"All Drivers, Altera Driver","text":"<p>This table comprehensively lists all Altera drivers available for Agilex 5 and Agilex 7. </p> <p>You can filter your search by entering your query into any number of available columns.</p> <ul> <li>The Name column indicate the name of the IP that the driver supports.</li> <li>If a driver exists then a link to a driver page is provided for more details. N/A means driver support \"Not Available\" for the particular IP.</li> </ul> IP Name Linux Driver Zephyr Driver Altera 16550 Compatible UART Core Linux Zephyr Altera Hardware Monitor Linux N/A Clock Manager Linux Zephyr Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) N/A PSCI Device Feature List (DFL) Capability Linux N/A DFL Accelerator Functional Unit (AFU workload) Linux N/A DFL FPGA Management Engine IP Linux N/A DFL Memory Interface/Subsystem Linux N/A DFL Time of Day Clock Intel FPGA IP Linux: Host Attach TOD Linux: Embedded TOD N/A Direct Memory Access Controller (DMAC) Linux Zephyr Error Detection and Correction (EDAC) Linux N/A Ethernet Media Access Controller Linux N/A Ethernet Subsystem (HSSI SS) Linux N/A Ethernet Subsystem Intel FPGA IP (HSSI xTile) Linux N/A Ethernet 1588 PTP Time of Day Clock Linux N/A General Purpose Timers Linux N/A Generic Serial Flash Interface Intel FPGA IP Linux N/A GPIO Linux Zephyr I2C Linux N/A I3C Linux N/A Interrupt Controller (GICv3) Linux Agilex 5   Agilex 7 Microchip\u00ae Zarlink ZL30793 Network Synchronizer Linux N/A MSGDMA Linux N/A NAND Controller Linux N/A PCIe Subsystem Linux N/A QSPI Linux Zephyr QSFP Linux N/A Reset Manager Linux Zephyr Single Error Upset (SEU) N/A Zephyr SD/eMMC Controller Linux N/A SMMU Linux N/A SPI Linux N/A System Manager Linux N/A Timer N/A Zephyr UART Linux N/A USB 2.0 OTG Linux N/A Watchdog Timer Linux Zephyr"},{"location":"driver-list/driver-list-baremetal/","title":"Baremetal Drivers","text":""},{"location":"driver-list/driver-list-baremetal/#overview","title":"Overview","text":"<p>This page presents the pre-release of the Agilex 5 baremetal drivers. The purpose of the drivers is to provide developers with access to the low-level functionality of the HPS IP blocks, including the ability to access IP registers. The drivers are provided through the following git repository: https://github.com/altera-fpga/baremetal-drivers and  are released under the MIT License. </p> <p>Resources:</p> <ul> <li>Documentation</li> <li>API Construction</li> <li>Build Details</li> <li>Release Notes</li> </ul> <p>Majority of validation for this pre-release was done on the Intel Simics Simulator for Intel FPGAs.</p>"},{"location":"driver-list/driver-list-baremetal/#demo","title":"Demo","text":"<p>The following demo is provided:</p> <ul> <li>Agilex\u2122 5 E-Series Premium Development Kit Baremetal Hello World</li> </ul>"},{"location":"driver-list/driver-list-baremetal/#driver-list","title":"Driver List","text":"Name Documentation Source Clock Manager clkmgr clkmgr Combophy for SDMMC combophy combophy DMA dma dma GIC gic gic General Purpose IO gpio gpio HPS Mailbox to SDM mailbox mailbox I2C i2c i2c I3C i3c i3c MMU mmu mmu Reset Manager rstmgr rstmgr SDMMC sdmmc sdmmc SPI spi spi System Manager sysmgr sysmgr Timers timer timer UART uart uart Watchdog Timers watchdog watchdog"},{"location":"driver-list/driver-list-linux/","title":"Linux Drivers","text":"<p>The table below provides a comprehensive list of the drivers available for Agilex 5 and Agilex 7.</p> <ul> <li>IP Name column indicates what type of IP the driver targets.  </li> <li>HPS or PCIe column indicates if the driver is targeting the embedded Host Processor System found on our devices or a server host or both.</li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) HPS or PCIe Host Documentation Upstream Status Kernel Source Altera 16550 Compatible UART Core Agilex 7 PCIe UART Yes 8250_dfl Altera Hardware Monitor Agilex 5  Agilex 7 HPS Hardware Monitor No Hwmon driver Clock Manager Agilex 5 HPS Clock Manager No clk_agilex5 Device Feature List (DFL) Capability Stratix 10   Agilex 7 PCIe dfl Yes dfl DFL Accelerator Functional Unit (AFU workload) Agilex 7   Stratix 10 PCIe dfl-afu Yes dfl-afu-dma-region dfl-afu-error dfl-afu-region dfl-afu-main DFL FPGA Management Engine IP Agilex 7  Stratix 10 PCIe dfl-fme Yes dfl-fme-mgr dfl-fme-br dfl-fme-region DFL Memory Interface/Subsystem Agilex 7 Stratix 10 PCIe Memory Yes dfl-emif Direct Memory Access Controller (DMAC) Agilex 5 HPS DMAC Yes dmac Error Detection and Correction (EDAC) Agilex 5 HPS EDAC Yes altera_edac Ethernet 1588 PTP Time of Day Clock Agilex 7 HPS/PCIe PCIe Attach ToD Embedded ToD Yes ToD PCIe-Attach driver ToD Embedded driver Ethernet Media Access Controller Agilex 5 HPS EMAC No dwxgmac2_core Ethernet Subsystem Intel FPGA IP (MAC-Specific) Agilex 7 HPS HSSI No intel_fpga_hssiss Ethernet Subsystem Intel FPGA IP (Tile-Specific) Agilex 7 HPS hssi_xtile No eth_main etile_fec etile_driver etile_ethtool ftile_ethtool ftile_fec ftile_driver General Purpose Timers Agilex 7   Agilex 5 HPS GP Timers Yes dw_apb_timer Generic Serial Flash Interface Intel FPGA IP Agilex 7 Stratix 10 PCIe Generic Serial Flash Yes spi General Purpose I/O (GPIO) Agilex 7   Agilex 5 HPS gpio Yes gpio-dwapb I2C Agilex 7   Agilex 5 HPS I2C Yes I2c driver I3C Agilex 5 HPS I3C Yes I3c driver Interrupt Controller (GICv3) Agilex 5 HPS GICv3 Yes GICv3 driver Microchip\u00ae Zarlink ZL30793 Network Synchronizer Agilex 7 HPS Zarlink No Zarlink driver MSGDMA Agilex 7 HPS MSGDMA No MSGDMA driver NAND Controller Agilex 5 HPS NAND Yes cadence-nand-controller PCIe Subsystem Agilex 7 PCIe PCIe Subsystem Yes dfl-pcie QSFP Agilex 7 HPS QSFP No qsfp QSPI Agilex 5 HPS QSPI No spi-cadence-quadspi Reset Manager Agilex 5 HPS Reset Manager No Reset Manager driver SD/eMMC Controller Agilex 5 HPS SD/eMMC Yes SD/eMMC driver SPI Agilex 7  Agilex 5 HPS SPI Yes SPI driver System Manager Agilex 5 HPS System manager Yes sysmgr System Memory Management Unit Agilex 5 HPS SMMU Yes SMMU driver UART Agilex 7   Agilex 5 HPS UART Yes UART driver USB 2.0 OTG Agilex 7   Agilex 5 HPS USB2.0 Yes USB 2.0 driver Userspace I/O (UIO) Agilex 7  Stratix 10 PCIe UIO Yes UIO driver Watchdog Timer Agilex 5 HPS Watchdog Timer Yes dw_wdt"},{"location":"driver-list/driver-list-zephyr/","title":"Zephyr Drivers","text":"<p>The table below provides a comprehensive list of embedded Zephyr drivers available for the HPS and Nios V on Agilex 5 FPGA devices.</p> <ul> <li>IP Name column indicates what type of IP the driver targets. </li> <li>Target is </li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) Target Documentation Upstream Status Kernel Source Arm\u00ae Silicon Provider (SiP) Services Agilex 5 HPS SiP-SVC Yes sip_smc_intel_socfpga Clock Manager Agilex 5 HPS Clock Manager Yes clock_control_agilex5 Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS PSCI Yes pm_cpu_ops_psci DMAC Agilex 5 HPS DMAC Yes dma General Purpose Timer Agilex 5 HPS Timer Yes counter_dw_timer GPIO Agilex 5 HPS gpio No gpio_intel_socfpga Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS psci No psci QSPI Agilex 5 HPS QSPI Yes flash_cadence_qspi_nor Reset Manager Agilex 5 HPS Reset Manager Yes reset_intel_socfpga Single Event Upset (SEU) Agilex 5 HPS SEU In Progress pull/67097 SMP Agilex 5 HPS SMP Yes smp UART Agilex 5 HPS UART Yes uart_ns16550 Watchdog Timer Agilex 5 HPS Watchdog Timer Yes wdt_dw"},{"location":"driver-list_all/","title":"All Drivers, Altera Driver","text":"<p>This table comprehensively lists all Altera drivers available for Agilex 5 and Agilex 7. </p> <p>You can filter your search by entering your query into any number of available columns.</p> <ul> <li>The Name column indicate the name of the IP that the driver supports.</li> <li>If a driver exists then a link to a driver page is provided for more details. N/A means driver support \"Not Available\" for the particular IP.</li> </ul> IP Name Linux Driver Zephyr Driver Altera 16550 Compatible UART Core Linux Zephyr Altera Hardware Monitor Linux N/A Clock Manager Linux Zephyr Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) N/A PSCI Device Feature List (DFL) Capability Linux N/A DFL Accelerator Functional Unit (AFU workload) Linux N/A DFL FPGA Management Engine IP Linux N/A DFL Memory Interface/Subsystem Linux N/A DFL Time of Day Clock Intel FPGA IP Linux: Host Attach TOD Linux: Embedded TOD N/A Direct Memory Access Controller (DMAC) Linux Zephyr Error Detection and Correction (EDAC) Linux N/A Ethernet Media Access Controller Linux N/A Ethernet Subsystem (HSSI SS) Linux N/A Ethernet Subsystem Intel FPGA IP (HSSI xTile) Linux N/A Ethernet 1588 PTP Time of Day Clock Linux N/A General Purpose Timers Linux N/A Generic Serial Flash Interface Intel FPGA IP Linux N/A GPIO Linux Zephyr I2C Linux N/A I3C Linux N/A Interrupt Controller (GICv3) Linux Agilex 5   Agilex 7 Microchip\u00ae Zarlink ZL30793 Network Synchronizer Linux N/A MSGDMA Linux N/A NAND Controller Linux N/A PCIe Subsystem Linux N/A QSPI Linux Zephyr QSFP Linux N/A Reset Manager Linux Zephyr Single Error Upset (SEU) N/A Zephyr SD/eMMC Controller Linux N/A SMMU Linux N/A SPI Linux N/A System Manager Linux N/A Timer N/A Zephyr UART Linux N/A USB 2.0 OTG Linux N/A Watchdog Timer Linux Zephyr"},{"location":"driver-list_baremetal/","title":"Baremetal Drivers","text":""},{"location":"driver-list_baremetal/#overview","title":"Overview","text":"<p>This page presents the pre-release of the Agilex 5 baremetal drivers. The purpose of the drivers is to provide developers with access to the low-level functionality of the HPS IP blocks, including the ability to access IP registers. The drivers are provided through the following git repository: https://github.com/altera-fpga/baremetal-drivers and  are released under the MIT License. </p> <p>Resources:</p> <ul> <li>Documentation</li> <li>API Construction</li> <li>Build Details</li> <li>Release Notes</li> </ul> <p>Majority of validation for this pre-release was done on the Intel Simics Simulator for Intel FPGAs.</p>"},{"location":"driver-list_baremetal/#demo","title":"Demo","text":"<p>The following demo is provided:</p> <ul> <li>Agilex\u2122 5 E-Series Premium Development Kit Baremetal Hello World</li> </ul>"},{"location":"driver-list_baremetal/#driver-list","title":"Driver List","text":"Name Documentation Source Clock Manager clkmgr clkmgr Combophy for SDMMC combophy combophy DMA dma dma GIC gic gic General Purpose IO gpio gpio HPS Mailbox to SDM mailbox mailbox I2C i2c i2c I3C i3c i3c MMU mmu mmu Reset Manager rstmgr rstmgr SDMMC sdmmc sdmmc SPI spi spi System Manager sysmgr sysmgr Timers timer timer UART uart uart Watchdog Timers watchdog watchdog"},{"location":"driver-list_linux/","title":"Linux Drivers","text":"<p>The table below provides a comprehensive list of the drivers available for Agilex 5 and Agilex 7.</p> <ul> <li>IP Name column indicates what type of IP the driver targets.  </li> <li>HPS or PCIe column indicates if the driver is targeting the embedded Host Processor System found on our devices or a server host or both.</li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) HPS or PCIe Host Documentation Upstream Status Kernel Source Altera 16550 Compatible UART Core Agilex 7 PCIe UART Yes 8250_dfl Altera Hardware Monitor Agilex 5  Agilex 7 HPS Hardware Monitor No Hwmon driver Clock Manager Agilex 5 HPS Clock Manager No clk_agilex5 Device Feature List (DFL) Capability Stratix 10   Agilex 7 PCIe dfl Yes dfl DFL Accelerator Functional Unit (AFU workload) Agilex 7   Stratix 10 PCIe dfl-afu Yes dfl-afu-dma-region dfl-afu-error dfl-afu-region dfl-afu-main DFL FPGA Management Engine IP Agilex 7  Stratix 10 PCIe dfl-fme Yes dfl-fme-mgr dfl-fme-br dfl-fme-region DFL Memory Interface/Subsystem Agilex 7 Stratix 10 PCIe Memory Yes dfl-emif Direct Memory Access Controller (DMAC) Agilex 5 HPS DMAC Yes dmac Error Detection and Correction (EDAC) Agilex 5 HPS EDAC Yes altera_edac Ethernet 1588 PTP Time of Day Clock Agilex 7 HPS/PCIe PCIe Attach ToD Embedded ToD Yes ToD PCIe-Attach driver ToD Embedded driver Ethernet Media Access Controller Agilex 5 HPS EMAC No dwxgmac2_core Ethernet Subsystem Intel FPGA IP (MAC-Specific) Agilex 7 HPS HSSI No intel_fpga_hssiss Ethernet Subsystem Intel FPGA IP (Tile-Specific) Agilex 7 HPS hssi_xtile No eth_main etile_fec etile_driver etile_ethtool ftile_ethtool ftile_fec ftile_driver General Purpose Timers Agilex 7   Agilex 5 HPS GP Timers Yes dw_apb_timer Generic Serial Flash Interface Intel FPGA IP Agilex 7 Stratix 10 PCIe Generic Serial Flash Yes spi General Purpose I/O (GPIO) Agilex 7   Agilex 5 HPS gpio Yes gpio-dwapb I2C Agilex 7   Agilex 5 HPS I2C Yes I2c driver I3C Agilex 5 HPS I3C Yes I3c driver Interrupt Controller (GICv3) Agilex 5 HPS GICv3 Yes GICv3 driver Microchip\u00ae Zarlink ZL30793 Network Synchronizer Agilex 7 HPS Zarlink No Zarlink driver MSGDMA Agilex 7 HPS MSGDMA No MSGDMA driver NAND Controller Agilex 5 HPS NAND Yes cadence-nand-controller PCIe Subsystem Agilex 7 PCIe PCIe Subsystem Yes dfl-pcie QSFP Agilex 7 HPS QSFP No qsfp QSPI Agilex 5 HPS QSPI No spi-cadence-quadspi Reset Manager Agilex 5 HPS Reset Manager No Reset Manager driver SD/eMMC Controller Agilex 5 HPS SD/eMMC Yes SD/eMMC driver SPI Agilex 7  Agilex 5 HPS SPI Yes SPI driver System Manager Agilex 5 HPS System manager Yes sysmgr System Memory Management Unit Agilex 5 HPS SMMU Yes SMMU driver UART Agilex 7   Agilex 5 HPS UART Yes UART driver USB 2.0 OTG Agilex 7   Agilex 5 HPS USB2.0 Yes USB 2.0 driver Userspace I/O (UIO) Agilex 7  Stratix 10 PCIe UIO Yes UIO driver Watchdog Timer Agilex 5 HPS Watchdog Timer Yes dw_wdt"},{"location":"driver-list_zephyr/","title":"Zephyr Drivers","text":"<p>The table below provides a comprehensive list of embedded Zephyr drivers available for the HPS and Nios V on Agilex 5 FPGA devices.</p> <ul> <li>IP Name column indicates what type of IP the driver targets. </li> <li>Target is </li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) Target Documentation Upstream Status Kernel Source Arm\u00ae Silicon Provider (SiP) Services Agilex 5 HPS SiP-SVC Yes sip_smc_intel_socfpga Clock Manager Agilex 5 HPS Clock Manager Yes clock_control_agilex5 Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS PSCI Yes pm_cpu_ops_psci DMAC Agilex 5 HPS DMAC Yes dma General Purpose Timer Agilex 5 HPS Timer Yes counter_dw_timer GPIO Agilex 5 HPS gpio No gpio_intel_socfpga Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS psci No psci QSPI Agilex 5 HPS QSPI Yes flash_cadence_qspi_nor Reset Manager Agilex 5 HPS Reset Manager Yes reset_intel_socfpga Single Event Upset (SEU) Agilex 5 HPS SEU In Progress pull/67097 SMP Agilex 5 HPS SMP Yes smp UART Agilex 5 HPS UART Yes uart_ns16550 Watchdog Timer Agilex 5 HPS Watchdog Timer Yes wdt_dw"},{"location":"ed-demo-list/demo-list/","title":"Demonstrations","text":"<p>The table below provides a comprehensive list of Altera demonstrations.  Demos are self-contained RTL, software or incomplete designs that demonstrate a concept.</p> <ul> <li>Demos Repository provides direct link to repository containing hardware source code and release.</li> <li>Supported Devices column indicates the demos device targets.  A listing of \"All\" means that this demo can be run on any device family.</li> <li>Development Kit Target lists development kits on which the demonstration is tested.</li> <li>Summary provides a short description of the demonstration.</li> <li>Documentation column provides a link to corresponding user documentation.</li> </ul> <p>You can use the filter fields to narrow your search.</p> Demos Repository Supported Device(s) Development Kit Target Summary Documentation HPS-FPGA Interface Demos Agilex 5 Agilex 5 E-Series Premium Development Kit  Third Party Boards Shows how users can implement and interact with the various hardware interfaces between the Hard Processing System (SoC) and FPGA fabric on the Agilex 5 FPGA device family HPS-FPGA Interfaces Demos User Guide n/a Agilex 5 Agilex 5 E-Series Premium Development Kit Demonstrates a simple hello world message using baremetal Agilex\u2122 5 E-Series Premium Development Kit Baremetal Hello"},{"location":"ed-demo-list/ed-list/","title":"Example Designs","text":"<p>The table below provides a comprehensive list of example designs. </p> <ul> <li>Demonstration Repository provides direct link to repository containing hardware source code and release.</li> <li>Supported Devices column indicates demonstration device targets.  A listing of \"All\" means that this demo can be run on any device family.</li> <li>Development Kit Target lists development kits on which the demonstration is tested.</li> <li>Summary provides a short description of the demonstration.</li> <li>Documentation column provides a link to corresponding user documentation.</li> </ul> <p>You can use the filter fields to narrow your search.</p> Example Design Supported Device(s) Embedded/Host Attach/Hostless Development Kit Target Summary Documentation TSN SGMII XCVR System Example Design Agilex 5 Embedded Agilex 5 E-Series Premium Development Kit Provides an example of a HPS system with support for TSN feature on SGMII XCVR Agilex 5 TSN SGMII XCVR System Example Design Golden System Reference Design (GSRD) Agilex 5 Embedded * Agilex 5 E-Series Premium Development Kit * Agilex 5 E-Series Modular Development Kit Provides instructions on how to test a basic HPS example with software on the development kit * Agilex 5 E-Series Premium Development Kit GSRD User Guide* Agilex 5 E-Series Modular Development Kit GSRD User Guide Golden System Reference Design (GSRD) Agilex 5 Embedded Agilex 5 E-Series Universal Virtual Platforms Provides instructions on how to exercise several use cases in which HPS software is running on the Intel Simics simulator using virtual platforms * Agilex\u2122 5 Intel Simics Virtual Platform Example User Guide - Linux GSRD * Agilex\u2122 5 Intel Simics Virtual Platform Example User Guide - Zephyr GSRD Golden Hardware Reference Design (GHRD) Boot Examples Agilex 5 Embedded * Agilex 5 E-Series Premium Development Kit * Agilex 5 E-Series Modular Development Kit Provides instructions on how to build Linux systems from separate components * Agilex 5 E-Series Premium Development Kit GHRD Linux Boot Examples * Agilex 5 E-Series Modular Development Kit GHRD Linux Boot Examples FPGA Remote Debug Example Agilex 5 Embedded Agilex 5 E-Series Premium Development Kit Provides an example of how to use the remote FPGA debug feature Agilex 5 FPGA Remote Debug Example HPS Remote System Update Example Agilex 5 Embedded Agilex 5 E-Series Premium Development Kit Provides a complete Remote System Update example including build and execution Agilex 5 HPS Remote System Update Example TSN HPS RGMII System Example Design Agilex 5 Embedded Agilex 5 E-Series Premium Development Kit Provides an example of a HPS system with support for TSN feature on HPS IO Agilex 5 TSN HPS RGMII System Example Design Golden System Reference Design (GSRD) Agilex 7 Embedded Agilex 7 F-Series FPGA Develpopment kit  (P-Tiles &amp; E-Tile) (DK-SI-AGF014EB and DK-SI-AGF014EA) Provides instructions on how to test a basic HPS example with software on the development kit Agilex 7 F-Series SoC Development Kit GSRD User Guide Golden System Reference Design (GSRD) Agilex 7 Embedded Agilex 7 I-Series FPGA Development Kit (DK-SI-AGI027FB, DK-SI-AGI027FA, DK-SI-AGI027FC) Provides instructions on how to test a basic HPS example with software on the development kit Agilex 7 I-Series FPGA Development Kit GSRD User Guide Golden System Reference Design (GSRD) Agilex 7 Embedded Agilex\u2122 7 M-Series HBM2e Development Kit (3x F-Tile &amp; 1x R-Tile) (DK-DEV-AGM039FES) Provides instructions on how to test a basic HPS example with software on the development kit Agilex 7 M-Series HBM2e Development Kit GSRD User Guide HPS eMMC Boot Example Agilex 7 Embedded Agilex 7 Transceiver-SoC Development Kit P-Tile E-Tile (DK-SI-AGF014EB) Provides an example of how to boot HPS from eMMC Agilex 7 HPS eMMC Boot Example HPS Remote System Update Example Agilex 7 Embedded Agilex 7 Transceiver-SoC Development Kit P-Tile E-Tile Production Linear Power Solution (DK-SI-AGF014EB) Provides a complete Remote System Update example including build and execution Agilex 7 HPS Remote System Update Example HPS Multi-QSPI Remote System Update Example Agilex 7 Embedded Agilex 7 Transceiver-SoC Development Kit P-Tile E-Tile Production Linear Power Solution (DK-SI-AGF014EB) Provides a complete Multi-QSPI Remote System Update example including build and execution Agilex 7 HPS Multi-QSPI Remote System Update Example FPGA Remote Debug Example Agilex 7 Embedded Agilex 7 Transceiver-SoC Development Kit P-Tile E-Tile (DK-SI-AGF014EB) Provides an example of how to use the remote FPGA debug feature Agilex 7 FPGA Remote Debug Example Fabric Configuration from Linux Example Agilex 7 Embedded Agilex 7 Transceiver-SoC Development Kit P-Tile E-Tile (DK-SI-AGF014EB) Provides an example of how to configure FPGA fabric from Linux Agilex 7 Fabric Configuration from Linux Example Golden System Reference Design (GSRD) Stratix 10 Embedded Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) Provides instructions on how to test a basic HPS example with software on the development kit Stratix 10 SX SoC Development Kit GSRD User Guide HPS eMMC Boot Example Stratix 10 Embedded Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) Provides an example of how to boot HPS from eMMC Stratix 10 HPS eMMC Boot Example HPS Remote System Update Example Stratix 10 Embedded Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) Provides a complete Remote System Update example including build and execution Stratix 10 HPS Remote System Update Example FPGA Remote Debug Example Stratix 10 Embedded Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) Provides an example of how to use the remote FPGA debug feature Stratix 10 FPGA Remote Debug Example Fabric Configuration from Linux Example Stratix 10 Embedded Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) Provides an example of how to configure FPGA fabric from Linux Stratix 10 Fabric Configuration from Linux Example"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/","title":"Agilex\u2122 5 Intel Simics Virtual Platform Example User Guide - Linux GSRD","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#overview","title":"Overview","text":"<p>Agilex\u2122 5 E-Series and D-Series devices provide the next-generation hard processor system (HPS) after those provided with the Agilex\u2122 7 and  Stratix\u00ae 10 SoC FPGA devices. Agilex\u2122 5 E-Series devices support new features, such as TSN, USB 3.1 Gen 1, and I3C, SPI.</p> <p>The Agilex\u2122 5 HPS application processors can run Linux or an RTOS, such as Zephyr*, with a scalable performance using one to four Arm* Cortex*-A cores with variable frequencies that allow for a wide range of applications.</p> <p>The Agilex\u2122 5 Simics virtual platform models the HPS processor with two Arm Cortex-A55 cores, two Arm Cortex-A76 cores, and HPS peripherals. The Agilex\u2122 5 E-Series HPS virtual platform is released as part of the Simics\u00ae Simulator for Intel\u00ae FPGAs software, which also includes a virtual platforms where the Agilex\u2122 5 device is instantiated, emulating the concept of having different versions of a development kit or daughter cards.</p> <p>The Agilex\u2122 5 E-Series device has the following supported virtual platforms:</p> <ul> <li>Agilex\u2122 5  Universal Virtual Platform - Used to simulate E-Series and D-Series devices.</li> </ul> <p>The following sections describe the prerequisites for the Intel Simics Simulator for Intel\u00ae FPGA and the available virtual platforms, including prebuilt binaries, and instructions for building these binaries. It also covers some common use cases that you can exercise on the virtual platforms.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#prerequisites","title":"Prerequisites","text":"<p>To exercise the instructions presented on this page (build your binaries and exercise the use cases), your system must satisfy the following prerequisites:</p> <ul> <li>Host PC with Linux OS. (Note: Instructions on this page use Ubuntu 22.04 LTS.)</li> <li>The following packages are needed to deploy the Simics project:<ul> <li>GCC 6.3 compiler or higher</li> <li>g++ 9.4 or higher</li> <li>GNU make 4.1 or higher</li> </ul> </li> <li>Local Ethernet network with DHCP server (provides IP address to the board).</li> <li>Intel Simics Simulator for Intel FPGAs installed.</li> <li>Intel Agilex\u2122 5 Virtual Platform components available to be deployed.</li> </ul> <p>Notes:</p> <ul> <li>For binaries building instructions, see Build Instructions.</li> <li>For installation instructions for the Intel Simics Simulator for Intel FPGAs and the Agilex\u2122 5 E-Series virtual platforms, refer to the following documents:<ul> <li>Intel\u00ae Simics\u00ae Simulator Landing Page </li> <li>Intel\u00ae Simics\u00ae Simulator for Intel\u00ae FPGAs User Guide</li> <li>Agilex\u2122 5 E-Series Virtual Platform User Guide</li> </ul> </li> <li>U-Boot, Linux compilation, Yocto compilation, and the creation of an SD card image require a Linux host PC.   To create these binaries, the toolchain and other software required need to be downloaded. This is described as part of the instructions in each section.</li> <li>The Intel Simics Simulator for Intel\u00ae FPGAs is available only for Linux systems.</li> <li>In case any use case requires additional prerequisites, these are listed as part of the use case description.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#release-content","title":"Release Content","text":"<p>Version: 24.3</p> SW Component Repository Branch/TAG/Version U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04/QPDS24.3_REL_GSRD_PR ATF https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.11.0/QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts/QPDS24.3_REL_GSRD_PR Reference Design Sources https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap/QPDS24.3_REL_GSRD_PR GSRD https://github.com/altera-opensource/gsrd-socfpga scarthgap Yocto Project https://git.yoctoproject.org/poky scarthgap/latest Reference Design Recipes https://git.yoctoproject.org/meta-intel-fpga scarthgap/latest Arm Debugger http://fpgasoftware.intel.com/armds ARM DS 2022.2 Ashling RiscFree https://www.intel.com/content/www/us/en/software-kit/826843/ Additional Software/Stand-Alone Software tab 24.3 <p>Note: For information prior 24.2 release, please refer to Linux GSRD Intel Simics Virtual Platform for Intel Agilex\u00ae 5 E-Series. </p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>You can find the prebuilt binaries from the GSRD prebuilt at the following URL: https://releases.rocketboards.org/2024.11/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/. The files in this folder allow you to boot directly from SDCard. It also contains some of the files that are used to generate the final images used to boot from QSPI and from NAND. The following folders contain the remaining files used by the recipes to create the binaries to boot from QSPI and NAND.</p> <ul> <li>QSPI: QSPI boot complement files. Here is the link to obtain the uboot_script.its file which is also needed.</li> <li>NAND: No available since NAND is not supported in silicon yet.</li> </ul> <p>Note: The final images used to boot from QSPI and NAND are not provided, but the binaries used to generate these are provided, so you can generate the final images following the instructions in Build QSPI Boot Image and Build NAND Boot Image sections.</p> <p>Note:  Starting from 24.2 release, the binaries targeted for silicon can also be used with Simics simulator.</p> HPS Peripheral Supported eMMC/SDCard &amp; Combo Phy Controllers Yes DMA Controller Yes XGMAC Ethernet Controller Yes USB 3.1 Gen1 Controller Yes USB 2.0 Controller Yes GPIO Controller Yes I2C Controller Initiator/Target Yes SPI Controller Initiator/Target Yes I3C Controller Initiator Yes I3C Controller Target Yes NAND Controller &amp; Combo PHY Controller Yes APB Timer Yes QSPI Controller Yes GICv3 Interrupt controller Yes EDAC RAS Driver Yes Clock manager Yes Reset manager Yes UART Yes WatchDog timer Yes System manager Yes SVC SOC FPGA manager Yes SVC FPGA firmware Yes SMMU Yes SVC FCS Crypto Yes SVC HWMON Yes SVC RSU Yes CVP Yes PMU Yes"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-instructions","title":"Build Instructions","text":"<p>The following diagram illustrates the full-build flow for the binaries used with the Intel Simics simulator. The build flow utilizes the source code placed in GitHub in repositories and uses a flow based on Yocto.</p> <p></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#set-up-the-environment","title":"Set Up the Environment","text":"<pre><code>sudo rm -rf agilex5_gsrd\nmkdir agilex5_gsrd\ncd agilex5_gsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#get-sof-from-hardware-design","title":"Get SOF from Hardware Design","text":"<p>In Simics, the SOF file generated as result of the build of the hardware design is not used at all in the simulation, but this is needed to create the RPD file to exercise the QSPI boot. This is the reason why we provide the steps to build the hardware desgin here.</p> <pre><code>cd $TOP_FOLDER\nrm ghrd_a5ed065bb32ae6sr0_hps.sof\nwget https://releases.rocketboards.org/2024.11/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0_hps.sof </code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps.sof</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#set-up-the-yocto-build-system","title":"Set Up the Yocto Build System","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <ol> <li> <p>Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b scarthgap https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up the yocto build environments again, if you closed the current window (for example, when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex5_devkit-gsrd-rootfs/\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#customize-the-yocto-build","title":"Customize the Yocto Build","text":"<ol> <li> <p>(Optional) Change the following files in gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/:</p> <ul> <li>distroboot script:uboot.txt</li> <li>its file for creating FIT image fromthe above script: uboot_script.its </li> </ul> </li> <li> <p>(Optional) Change the following file in gsrd-socfpga/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts:</p> <ul> <li>its file for creating the kernel.itb image: fit_kernel_agilex5.its , which by default contains the following:<ul> <li>Kernel </li> <li>Distroboot boot script</li> <li>Device tree configurations</li> <li>Board configurations </li> </ul> </li> </ul> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package </code></pre> <p>After the build is completed successfully, the following two folders are created:</p> <ul> <li><code>agilex5_devkit-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. For the description of the build directory structure, refer to https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build.</li> <li><code>agilex5_devkit-gsrd-images</code>: the build script copies here are relevant files built by Yocto from the <code>agilex5_devkit-gsrd-rootfs/tmp/deploy/images/agilex5</code> folder. It also includes other relevant files.</li> </ul> <p>Note: If you want to build binaries creating each one of the binaries independently, you could refer to Agilex\u2122 5 E-Series GHRD Linux Boot Examples.</p> <p>The most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex5_devkit-gsrd-images</code> folder are:</p> File Description SD Card Boot QSPI Boot NAND Boot ghrd_a5ed065bb32ae6sr0_hps.sof SOF file from the hardware design * u-boot-spl-dtb.bin U-Boot SPL binary file * * * u-boot.itb U-Boot (SSBL) * * * boot.scr.uimg Distroboot boot script * * kernel.itb Linux kernel fit image * * * console-image-minimal-agilex5_nand.ubifs File system for NAND boot * console-image-minimal-agilex5_nor.ubifs File system for QSPI boot * gsrd-console-image-agilex5.wic SD Card Image * uboot.txt U-Boot Distroboot script * uboot_script.its ITS file to create FIT binary of U-Boot Distroboot script *"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-qspi-boot-image","title":"Build QSPI Boot Image","text":"<p>The next step consists of creating the QSPI image with UBIFS format that will be used by in the simulation that exercises this use case. To build this image the same binaries generated from the GSRD build are used.</p> <p>The layout of the QSPI image is shown in the following table:</p> MTD Partition UBI Volume Volume Name Type Image/Individual File Group File Start Addr Size 0 (qspi_bootinfo) N/A N/A RAW Bootinfo (Empty) N/A 0x0 2MB 1 (qspi_uboot) N/AN/A N/AN/A RAWRAW bitstream (FPGA image, SDM firmware)u-boot.itb N/A 0x002000000x04000000 ~1 MBAUTO 2 (qspi_root) 01234 envscriptkerneldtbrootfs UBIUBIUBIUBIUBIFS u-boot.envu-boot.scrkernel.itbkernel.dtbrootfs.ubifs root.ubi 0x4200000AutoAutoAutoAuto 256KB128KB24MB256KB160MB <ol> <li> <p>Gather the required files.</p> <pre><code># Gattering files\ncd $TOP_FOLDER\nrm -rf qspi-bin &amp;&amp; mkdir qspi-bin &amp;&amp; cd qspi-bin mv $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0_hps.sof agilex5_factory.sof\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb u-boot-itb.bin\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex u-boot-spl.hex\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/kernel.itb kernel-image\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nor.ubifs  rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg boot.scr.uimg\n</code></pre> </li> <li> <p>Create the PFG file that describes the format of the QSPI image: </p> <pre><code>cd $TOP_FOLDER/qspi-bin\ncat &lt;&lt; EOF &gt; agilex5_flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" directory=\".\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"flash_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"./u-boot-spl.hex\"&gt;./agilex5_factory.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot-itb.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00200000\" e_addr=\"0x0030FFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"U-Boot\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_e_addr=\"1\" e_addr=\"0xFFFFFFF\" id=\"HPS\" s_addr=\"0x4200000\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"U-Boot\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n</code></pre> </li> <li> <p>Create UBI configuration file for the rootfs partition:</p> <pre><code># Creating UBI Configuration file\ncd $TOP_FOLDER/qspi-bin\ncat &lt;&lt; EOT &gt;ubinize_nor.cfg \n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel-image     \nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOT\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/qspi-bin/ubinize_nor.cfg</li> </ul> </li> <li> <p>Generate the root.ubi file for root partition. For this, the ubinize_nor.cfg is used with the files obtained from the previous steps. This file defines the components to be included in the root.ubi file as indicated in the table above. The ubinize executable is available as part of the mtd-tools package.      The parameters for ubinize command are:</p> <p>-p: physical erase block size of the flash -m: minimum input/output unit size of the flash -s: sub-pages and sub-page size </p> <p>Once the root.ubi files is created this is renamed as hps.bin.  Required files for this step: ubinize_nor.cfg,  boot.scr.uimg,  kernel-image,  rootfs.ubifs</p> <pre><code># Generate hps.bin file with UBI format\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize_nor.cfg\nmv root.ubi hps.bin\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/qspi-bin/hps.bin</li> </ul> </li> <li> <p>Using Quartus Programming File Generator to compile an RPD file by using the configuration specified in the PFG file.</p> <p>Required files for this step: u-boot-spl.hex,  agilex5_factory.sof, u-boot-itb.bin and hps.bin   Note: Make sure the filenames are specified correctly in agilex5_flash_image.pfg</p> <p>Run the Quartus File Generator command below to generate an RPD file:</p> <pre><code># Creating QSPI image\nquartus_pfg -c agilex5_flash_image.pfg\n</code></pre> </li> </ol> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/qspi-bin/flash_image_jic.rpd</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-nand-boot-image","title":"Build NAND Boot Image","text":"<p>The next step consists of creating the NAND image that will be used by in the simulation that exercises this use case. For this, the NAND image will have the layout shown in the following figure:</p> MTD Partition UBI Volume Volume Name Type Image/Individual File Group File Flash Offset Size Size in Hex 0 (u-boot) N/A N/A RAW u-boot.itb N/A 0x00000000 2 MB 0x200000 1 (root) 01234 envscriptkerneldtbrootfs UBIUBIUBIUBIUBIFS u-boot.envu-boot.scrkernel.itbkernel.dtbrootfs.ubifs root.ubi 0x00200000 onwards 256KB128KB24MB256KB272MB 0x400000x200000xA000000x400000x11000000 <p>Based on the table above, we have 2 partitions. One contains just the U-Boot fit image located at address 0x0 and the other contains the rest of the software components in a ubi file (with UBIFS format) located at address 0x200000. Continue with the following steps to create the NAND boot image.</p> <ol> <li> <p>Bring the required files from the GSRD build directory to a NAND boot directory:</p> <pre><code># Gathering the required files\ncd $TOP_FOLDER\nrm -rf nand-bin &amp;&amp; mkdir nand-bin &amp;&amp; cd nand-bin\nln -s $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/uboot_script.its uboot_script.its cp $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/uboot.txt .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb u-boot.itb\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/kernel.itb kernel-image\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/socfpga_agilex5_socdk_nand_vanilla.dtb kernel-dtb\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nand.ubifs rootfs.ubifs\n</code></pre> </li> <li> <p>The Agilex 5 E-Series Universal virtual virtual returns by default a board_id = 0 when U-Boot reads the STRATIX_JTAG_USER_CODE parameter. The board_id is used to select the desired configuration (linux kernel image + device tree + fpga fabric design) as described in Single  Image Boot flow. Starting from 24.2 release, the configuration for board_id = 0 defines the device tree for the OOB board in the premium dev kit (SD card daughter card). Since we want to load the configuratio that works for NAND boot, we require to use the device tree specific for the NAND daughter card. In order to address this problem, one solution is to force having a board_id that defines the configuration for NAND (and also without defining a FPGA core fabric since in Simics programming the fabric is not supported). For this, we require to set in U-Boot the  board_id environment variable to 7 for which the socfpga_agilex5_socdk_nand_vanilla.dtb device tree is used (as can be seen in fit_kernel_agilex5_devkit.its). This is achieved with the following code:</p> <pre><code># Update boot script to modify board_id so we can boot from nand_vanila device tree\ncd $TOP_FOLDER/nand-bin\nsed -i '/Trying to boot Linux from device/a setenv board_id 7 ' uboot.txt\nmkimage -f uboot_script.its boot.scr.uimg\n</code></pre> </li> <li> <p>Create UBI configuration file for the root partition:</p> <pre><code># Create the UBI Configuration file\ncd $TOP_FOLDER/nand-bin\ncat &lt;&lt;EOT &gt;ubinize_nand.cfg \n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel-image     \nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nimage=kernel-dtb\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=400MiB\nvol_flag=autoresize\nEOT\n</code></pre> <p>Note: kernel-dtb is not really used since the dtb used is inside the kernel-image file.</p> </li> <li> <p>Generate root.ubi file for root partition, using the ubinize_nand.cfg file generated in previous step. This file defines the components to be included in the root.ubi file as indicated in the table above. The command used to generate the file is ubinize which is available as part of the mtd-tools package. The parameters that ubinize command received are listed next:</p> <p>-p: physical erase block size of the flash -m: minimum input/output unit size of the flash -s: sub-pages and sub-page size, ubinize will take into account and put the VID header to same NAND page as the EC header</p> <pre><code># Create the UBI file with root partition\ncd $TOP_FOLDER/nand-bin\nubinize -o root.ubi -p 1024KiB -m 8192 -s 8192 ubinize_nand.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/nand-bin/root.ubi</li> </ul> </li> <li> <p>Generate final NAND image (nand.img) using dd command. This file includes the U-Boot built from the GSRD and the root.ubi file generated in the step before. The location in the NAND image is indicated in the table above.</p> <pre><code># Creating the NAND image\nexport COMBINEDFILE=nand.img\ndd if=/dev/zero bs=1024M count=1 | tr '\\0' $'\\xFF' &gt; $COMBINEDFILE\n# Adding u-boot.itb\ndd conv=notrunc bs=1 if='u-boot.itb' of=$COMBINEDFILE seek=$((0x00000000))\n# Adding root.ubi\ndd conv=notrunc bs=1 if='root.ubi' of=$COMBINEDFILE seek=$((0x00200000))\n</code></pre> </li> </ol> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/nand-bin/nand.img </li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#known-issues-with-the-release","title":"Known Issues with the Release","text":"<p>For known issues in this release please refer to the Intel Simics Simulator for FPGA Release page.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#agilextm-5-simics-virtual-platform-universal","title":"Agilex\u2122 5  Simics Virtual Platform - Universal","text":"<p>Note: The Agilex 5 Simics Virtual Platform - Universal was initially developed to support the Agilex 5 E-Series device, but it also supports the Agilex 5 D-Series device which matches the B0 steping of the E-Series device. In this page we refer to Agilex 5 E-Series,  but it also applies for the Agilex 5 D-Series, unless other thing is indicated.</p> <p>This virtual platform is associated with the agilex5e-universal.simics target script. The following figure shows a high-level block diagram of this virtual platform. In this diagram, you can observe the main components that can be exercised during the execution of the use cases described later on this page. The implementation of this virtual platform allows all the peripherals in the HPS to be enabled at the same time, which is not possible in physical hardware implementations. The pinmux and Combo PHY impose restrictions on the physical hardware. In the case of the pinmux in the physical hardware, you can enable only a subset of peripherals simultaneously because there are not enough pins if all pins are enabled simultaneously. This limitation does not exist in the Agilex\u2122 5 E-Series Universal Virtual Platform. For the Combo PHY, the physical hardware allows only one flash controller (NAND or SDMMC) to be enabled at a time. However, the virtual platform allows both to be enabled simultaneously.</p> <p></p> <p>In this block diagram:</p> <ul> <li>The architecture of the virtual platform follows a hierarchy that goes from target script \u2192 system \u2192 board \u2192 fpga \u2192 qsys_top \u2192 hps_subsystem \u2192 agilex_hps, which is aligned with the Simics virtual platform development philosophy that tries to match with the real golden hardware reference design (GHRD) architecture.</li> <li>The target script instantiates the system component, provides the CLI run time commands, and creates the network configuration. This script also defines the parameters that configure other components.</li> <li>The system component represents the complete virtual platform system and instantiates the board component. This component is implemented in a Python file.</li> <li>The board component represents the model of a PCB (analogous to a development kit). It includes the instance of the FPGA component and all board components connected to the FPGA (for example, flash devices, ethernet PHY). The GPIO loopback connection is implemented here. This component is implemented in a Python file.</li> <li>The FPGA component represents the top-level hardware design model in the Quartus Prime software project design that targets the Agilex\u2122 5 E-Series SoC FPGA device. It matches the logical hierarchy of the fictitious GHRD that the Agilex\u2122 5 E-Series Universal Virtual Platform models. This component only instantiates the qsys_top component and is implemented as a Python script.</li> <li>The qsys_top component matches the design's top view being modeled and corresponds to the system seen from the Platform Designer under the GHRD (soc_inst instance). The HPS subsystem component and the components included as part of the FPGA fabric design are instantiated under the qsys_top component. The qsys_top component is modeled as a Python script.</li> <li>The FPGA fabric design corresponds to the logic model implemented in the FPGA fabric.</li> <li>The HPS subsystem component corresponds to the model of the module that integrates all components associated with the HPS in the Agilex\u2122 5 E-Series device. It includes the HPS models, SDM mailbox, and EMIF model.</li> <li>The Agilex\u2122 5 HPS component in the virtual platform is an Intel Simics model that corresponds to the Hard Processor System Agilex\u2122 5 FPGA IP in the  Quartus Prime software.</li> <li>The embedded software running in the HPS component is expected to be the same that can be run in the real silicon. Exercising the HPS-embedded software in this virtual platform allows you to debug the software using the Simics debug capabilities.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#main-features-supported-by-the-intel-agilextm-5-e-series-universal-virtual-platform","title":"Main Features Supported by the Intel Agilex\u2122 5 E-Series Universal Virtual Platform","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#boot-an-operative-system","title":"Boot an Operative System","text":"<p>The Agilex\u2122 5 E-Series Virtual Platform allows exercising the HPS software in all parts of the boot flow for Linux* and Zephyr* operating systems. You can exercise the boot flow from a flash device such as an SD Card, NAND flash, or QSPI flash. Booting from an SD Card is the default boot mode.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#basic-ethernet","title":"Basic Ethernet","text":"<p>The basic ethernet functionality is configured from the agilex5e-universal.simics target script. The virtual platform simulates a network switch and a router in the simulated environment using the service node component referred to as service_node_cmp0. This provides a TFTP server to transfer files from the host PC to the target system and a DHCP server to assign an IP to the target system dynamically.</p> <p>The service node acts as a simulated environment router configured with the 10.10.0.1 IP address. The DHCP service is configured to assign an IP in the range of 10.10.0.100 and 10.10.0.199. The service node is also configured to provide Network Address Port Translation (NAPT) for outgoing traffic, allowing it to interact with the host PC enabling TFTP, SCP, and SSH services.</p> <p>The target device provides ethernet functionality using the XGMAC/TSN devices, enabling an ethX ethernet link. This link connects with an ethernet switch instantiated in the target script. Only the TSN0 instance is connected to this switch using the Marvell ethernet Phy instantiated at the board level.</p> <p>Basic ethernet support in the virtual platform allows the target software to set a MAC address locally to allow communication over the network. This supports all key transport layers of a protocol, such as TCP, UDP, and ICMP. Basic ethernet allows communication over IPv4 and IP6 protocols while supporting different hardware offloading features. The virtual platform supports L2, L3, and L4 filtering and can show network statistics.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#cpu-power-on-and-boot-core-selection","title":"CPU Power-On and Boot Core Selection","text":"<p>The virtual platform supports setting the CPU power-on settings and the CPU boot core selection. This configuration is defined at the target script level (agilex5e-universal.simics) for this virtual platform. Based on the configuration, the virtual platform exposes only the appropriate number of cores available to the target software. When multiple CPUs are enabled, the virtual platform is configured to support symmetric multiprocessing (SMP).</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#reset-flow","title":"Reset Flow","text":"<p>The virtual platform is designed to support all key reset flows described in the Agilex\u2122 5 E-Series Technical Reference Manual. Reset flows initiated by the CPU are simulated through the same mechanism in which the CPU writes to the appropriate addresses (reset manager device). Resets triggered by the external hardware signaling are simulated with Simics' commands.</p> Reset Type Recipe Notes Power-on reset Not supported The power-on reset is not supported as its effect is equivalent to restarting the simulation in a virtual platform simulation. However, if this is required for some exceptional use cases, you can trigger the cold reset instead, as this resets most domains. HPS cold reset system.board.hps-cold-reset Simulates toggling the HPS_COLD_nRESET pin using the command registered in the board component. HPS warm reset system.board.fpga.soc_inst.hps_subsys.agilex_hps.hps-warm-reset Simulates a warm reset of the HPS without triggering any other event. This type of reset is not enabled through external means in hardware. The command is registered in the HPS component. Watchdog reset Software-based The watchdog timer peripheral in the HPS can be configured and enabled through software. When the watchdog expires, the HPS resets (only the trigger of warm reset is supported)."},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#gpio-loopback-connection","title":"GPIO Loopback Connection","text":"<p>The virtual platform supports the feature that allows creating a loopback connection in certain pins in GPIO0 and GPIO1 ports. This is implemented at the board component level. The loopback implementation directly connects GPIO in and out pins of the GPIO ports in both directions to reflect the same state on those pins. In each GPIO port, the pair of pins that are connected are shown in the following table:</p> Pin Source Pin Destination 0 1 5 6 18 19 20 21 <p>The Simics command to activate the GPIO loop-back connection is <code>system.board.create-gpio-loopback</code>.</p> <p>Note: The loopback connection is activated by default from the target script.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#usb-disks-hot-plug-support","title":"USB Disks Hot-Plug Support","text":"<p>The virtual platform instantiates three USB disks that support hot-plugging by using Simics CLI commands to emulate plugging and unplugging the USB disks.</p> <p>The current connection of the USB disks in this virtual platform is indicated in the following table:</p> Disk Type Slot USB Controller usb3_disk SuperSpeed (SS) usb3 USB 3.1 Gen 1 usb3_hs_disk High Speed (HS) usb2 USB 3.1 Gen 1 usbotg_disk High Speed (HS) otg USB 2.0 OTG"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#fpga-fabric-example-design","title":"FPGA Fabric Example Design","text":"<p>The FPGA Fabric example design includes one instance of a On-Chip memory design exist in the FGPA fabric model. This is located directly under the qsys_top component. This On-Chip memory instance has a size of 1 MB and is connected to the HPS2FPGA bridge. This On-Chip memory model supports reading and writing to any memory location. You can access the memory designs using direct memory access to the memory locations in which these are mapped under the HPS2FPGA bridge memory space or by accessing the memories example design as a memory space or by accessing the memories example design as a memory space.</p> <p>The mapping of the memory instance is defined as follows:</p> Example Design Name Bridge Size Start address End Address example_design hps2fpga 1 MB 0x0040000000 0x00400FFFFF <p>The memory instance in the FPGA fabric example design receives a parameter named base_addr. The description of this parameter is described as follows:</p> Parameter Description Range Default Value base_addr An offset value that indicates the mapping of the instance taking as reference the Start Address value defined in the previous table. Integer 0x00000000 <p>The FPGA fabric example design also includes a Peripheral subsystem which is integrated by 3 I/O IP components, each one to access or allow to control a set of LEDs, a Dip switch and a push button. The peripheral subsystem is mapped into the lwhps2pga bridge starting at a base address of 0x20000000. These components includes some internal registers that allow to control the state of the output (for LED component) and also to read state of the input of push button and dip-switch components. The mapping of these components and their registers are shown next:</p> Component Mapping Address Range Register Information button_pio 0x00010060 0x10 [0x0] - DATA[0:0]: Read state of the button. Read Only. [0x8] - INTERRUPTMASK[0:0]- Enable('1\u2019)/Disable('0\u2019) the interrupt trigger. When dsiable, the interrupt is cleared. Read/Write dipsw_pio 0x00010070 0x10 [0x0] - DATA[0:0]: Read state of the button. Read Only. [0x8] - INTERRUPTMASK[0:0]- Enable('1\u2019)/Disable('0\u2019) the interrupt trigger. When dsiable, the interrupt is cleared. Read/Write led_pio 0x00010080 0x10 [0x0] - DATA[31:0]: Set and read the state of the LEDs. Read/Write <p>The DIP switch and push button component can trigger an interrupt to the HPS on the assertion of the corresponding input signal.</p> Component Interrupt HPS Interrupt Connection button_pio periph_button_irq f2s_fpga_irq[0] \u2013 SIP 49 dipsw_pio periph_dipsw_irq f2s_fpga_irq[1] \u2013 SIP 50 <p></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#fpga-to-hps-bridges","title":"FPGA-to-HPS Bridges","text":"<p>The FPGA-To-HPS bridges provide a way in which the FPGA fabric IPs can interact with the HPS subsystem and the SDRAM. The bridge implementation includes two new memory spaces in the FPGA logic model that are used to send read and write transactions to the HPS or SDRAM component from the FPGA logic passing through the FPGA-to-HPS bridges.</p> <ul> <li>FPGA to HPS bridge (FPGA2HPS): Connects the FPGA2HPS memory space with the HPS component.</li> <li>FPGA to SDRAM bridge (FPGA2SDRAM): Connects the F2SDRAM memory space with the HPS component.</li> </ul> <p>You can send read and write transactions through each one of the bridges from the Intel Simics CLI.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#b0-silicon-features-selection","title":"B0 Silicon Features Selection","text":"<p>The Agilex 5 E-Series Universal Virtual Platform allows you to select the stepping silicon features that the Agilex 5 Simics model supports by stepping the target script parameter accepting the value of A0 or B0. The B0 stepping corresponds to the HPS model of the Agilex 5 D-Series.</p> <p>Note: Agilex 5 E-Series Universal Virtual Platform stepping features support is released in the 24.1 Intel Simics Simulator for Intel FPGAs release although the default stepping during the project deployment remains being A0. You can override the default stepping using the stepping parameter from the target script. In this case, the B0 features are enabled in the Agilex 5 E-Series model.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#configurable-parameters-in-the-intel-agilextm-5-e-series-universal-virtual-platform","title":"Configurable Parameters in the Intel Agilex\u2122 5 E-Series Universal Virtual Platform","text":"<p>The parameters that you can configure are shown in the following table:</p> Parameter Description Range Default Value sd_image_filename Name of the SD image to load into the SD memory model of the board component. Supported formats are <code>.img</code> and <code>.wic</code>. Filename string \"\" fsbl_image_filename First-stage boot loader file. The supported format is <code>.bin</code>. Filename string \"\" hps_boot_core The CPU to use as the boot core. Integer [0,2] 0 hps_core0_1_power_on The power-on states of CPU 0/1. Boolean True hps_core2_power_on The power-on states of CPU 2. Boolean True hps_core3_power_on The power-on states of CPU 3. Boolean True create_hps_serial0_console Choose whether to create or not a console component and connect it to the <code>serial0</code> peripheral of the HPS IP. Boolean True create_hps_eth0_network Choose whether to create or not a basic ethernet network and connect the <code>ethX</code> peripheral of the HPS IP to this. Boolean True create_hps_sd_card Create the SD card in the board component and connect it to the SD/eMMC controller. You can set either the create_hps_sd_card or create_hps_mmc parameter to true at a time. Boolean True create_hps_mmc Create the eMMC card in the board component and connect it to the SD/eMMC controller. You can set either the create_hps_sd_card or create_hps_mmc parameter to true at a time. Boolean False nand_data_image_filename Name of the NAND image to load into the NAND memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" nand_spare_image_filename Name of the NAND spare image to load into the NAND memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" qspi_image_filename Name of the QSPI image to load into the QSPI memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" usb3_image_filename Name of the USB disk image corresponding to the SuperSpeed disk in the board component connected to the USB 3.1 controller. Filename string \"\" usb3_hs_image_filename Name of the USB disk image corresponding to the high-speed disk in the board component connected to the USB 3.1 controller. Filename string \"\" usb_otg_image_filename Name of the USB disk image corresponding to the high-speed disk in the board component connected to the USB 2.0 OTG controller. Filename string \"\" hps_cpu_freq_mhz ARM cores frequency in Megahertz (MHz). Integer [400 - 1500] 400 stepping Select the silicon features that the Agilex 5 Simics model supports. A0 or B0. D-Series corresponds to B0 device. A0"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-cases-supported-by-the-agilextm-5-e-series-universal-virtual-platform","title":"Use Cases Supported by the Agilex\u2122 5 E-Series Universal Virtual Platform","text":"<p>The following sections explain some supported use cases using the Agilex\u2122 5 E-Series Universal virtual platform. The preconditions required to execute them are listed in the following section:</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#simulation-setup","title":"Simulation Setup","text":"<p>Consider that the Intel Simics Simulator for Intel FPGAs Simulator has been installed on a Linux System and the output binaries generated from Build Instructions section are already available.</p> <ol> <li> <p>Create a project directory under the Intel Simics Simulator installation directory (Assuming it is SimicsInstallDir):</p> <pre><code>$ mkdir project-1\n$ cd project-1\n</code></pre> </li> <li> <p>Under the new project directory created, deploy the agilex5e-universal virtual platform:</p> <pre><code>$&lt;Simics installation dir&gt;/simics/bin/simics_intelfpga_cli \u2013-deploy agilex5e-universal\nSimics(R) Simulator for Intel(R) FPGA CLI:\nINFO: Preparing to initialize /home/simicsUser/SimicsInstallDir/project-1 as a\nSimics workspace\nProject created successfully\n# Observe that the directory has been initialized and the simics and simics-gui\n# commands appear in the project directory. Also, the target directory is\n# created. This includes the target script corresponding to the deployed\n# platform.\n</code></pre> </li> <li> <p>Build the virtual platform components:</p> <pre><code>$ make\n=== Environment Check ===\n'/home/simicsUser/SimicsInstallDir/project-1' is up-to-date\ngcc version 9\n=== Building module agilex5e-universal-board-comp ===\n:\n=== Building module agilex5e-universal-fpga-comp ===\n:\n=== Building module agilex5e-universal-system-comp ===\n:\nCopying agilex5_icon_84x84.png\n</code></pre> </li> <li> <p>Copy the following binaries created in Build Instructions section to the Simics project directory:</p> <ul> <li>gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/gsrd-console-image-agilex5.wic</li> <li>gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.bin</li> <li>qspi-bin/flash_image_jic.rpd</li> <li>nand-bin/nand.img</li> </ul> </li> <li> <p>Customize the configuration of the Agilex\u2122 5 E-Series Universal virtual platform, according to the setup required to exercise any specific use case. Set up the fsbl_image_filename parameter with the first-stage bootloader. If the boot implies booting from an SD Card device, configure sd_image_filename and create_hps_sd_card parameters (this image should include the main bootloader and the OS and/or application images). As part of the configuration, select the core used to boot using the hps_boot_core parameter, which could be core 0 (A55) or core 2 (A76).</p> <p>You can configure the virtual platform either by updating the agilex5e-universal.simics**target script or creating a separate top-level target script (named based on the simulation purpose) that is expected to be run with this (example: **uboot-linux_sdcard.simics used to boot from U-Boot to Linux from an SD Card device). You become the owner of this new target script, in which, you can set the required parameters and call the original virtual platform target script (targets/agilex5e-universal/agilex5e-universal.simics path). An example of the setup required to run a simulation that exercises the boot flow going from U-Boot to Linux, booting from an SD Card is shown in the following:</p> <pre><code>#uboot-linux_sdcard.simics\n$sd_image_filename = \"gsrd-console-image-agilex5.wic\"\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$hps_boot_core = 0\n$create_hps_sd_card = TRUE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> <p>Note: The uboot-linux_sdcard.simics file must be created under the Intel Simics project directory.</p> <p>Tip: Any specific configuration needed for a use case is indicated under the Setup section of that use case.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-sdcard-boot-flow-from-fsbl-to-linux","title":"Use Case: Exercise SDCard Boot Flow from FSBL to Linux","text":"<p>This use case consists of booting from an SDCard device going from U-Boot to Linux prompt passing through U-Boot SPL \u2192 ATF \u2192 U-Boot \u2192 Linux.</p> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <p>To exercise this use case, follow the below steps once the Simulation setup is complete:</p> <ol> <li> <p>From the project directory, launch the simulation using the uboot-linux_sdcard.simics target script. This script launches the simulator and the current terminal becomes the Simics CLI:</p> <pre><code>$ ./simics uboot-linux_sdcard.simics </code></pre> </li> <li> <p>From the Simics CLI, start running the simulation with the run command.</p> <pre><code>simics&gt;  run\n</code></pre> </li> <li> <p>Wait to get to the Linux prompt in the target serial console. </p> </li> <li> <p>Login into the Linux prompt using the root user without a password.</p> <p><pre><code># Target Serial console\nU-Boot SPL 2024.04 (Oct 16 2024 - 02:54:45 +0000)\nReset state: Cold\nMPU           875000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nio96b_cal_status: Calibration for IO96B instance 0x18400400 done at 0 msec!\n\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\nio96b_mb_init: num_instance 1\nio96b_mb_init: get memory interface IO96B 0\n:\nDDR: size check success\nDDR: firewall init success\nDDR: init success\nQSPI: Reference clock at 400000 kHz\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 0\nNOTICE:  BL31: v2.11.0(release):QPDS24.3_REL_GSRD_PR\nNOTICE:  BL31: Built : 07:09:49, Oct 15 2024\nU-Boot 2024.04 (Oct 16 2024 - 02:54:45 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  51 devices, 26 uclasses, devicetree: separate\nWDT:   Not starting watchdog@10d00200\nWDT:   Not starting watchdog@10d00300\nWDT:   Not starting watchdog@10d00400\nWDT:   Not starting watchdog@10d00500\nWDT:   Not starting watchdog@10d00600\nNAND:  4096 MiB\nMMC:   mmc0@10808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nLoading Environment from UBI... SF: Detected mt25qu02g with page size   256 Bytes, erase size 64 KiB, total 256 MiB\n:\nScanning mmc 0:1...\nFound U-Boot script /boot.scr.uimg\n2411 bytes read in 12 ms (195.3 KiB/s)\n## Executing script at 81000000\ncrc32+ Trying to boot Linux from device mmc0\nFound kernel in mmc0\n17685575 bytes read in 33 ms (511.1 MiB/s)\n## Loading kernel from FIT Image at 82000000 ...\n:\nSF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\nEnabling QSPI at Linux DTB...\nWorking FDT set to ffad6000\nQSPI clock frequency updated\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\n\nStarting kernel ...\n\nDeasserting all peripheral resets\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.37-altera-g978b3d90f408 (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240723) #1 SMP PREEMPT Mon Oct 14 01:56:39 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n:\nPoky (Yocto Project Reference Distro) 5.0.5 dhcp0 ttyS0\n\ndhcp0 login: [   37.881580] kauditd_printk_skb: 15 callbacks suppressed\n[   37.881588] audit: type=1334 audit(1709054800.748:33): prog-id=27 op=UNLOAD\n[   37.882865] audit: type=1334 audit(1709054800.748:34): prog-id=26 op=UNLOAD\n[   37.883602] audit: type=1334 audit(1709054800.748:35): prog-id=25 op=UNLOAD\n\ndhcp0 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for testing and development purposes only. It is recommended that you create your own distribution for production use.\n\nroot@dhcp0:~# </code></pre> This finishes the main scenario of this use case, but there are some extensions that are described next.</p> <p>Note: You can speed-up the boot process by skipping the U-Boot autoboot countdown by pressing any key and then typing the boot command:</p> <pre><code>U-Boot 2024.01 (Jun 25 2024 - 09:28:56 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\n\n:\nNet:   No ethernet found.\nHit any key to stop autoboot:  0 SOCFPGA_AGILEX5 # boot\nswitch to partitions #0, OK\nmmc0 is current device\nScanning mmc 0:1...\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-hello-application","title":"Use Case: Exercise Hello Application","text":"<p>This is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes executing the hello application from the Linux prompt.</p> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Execute the hello application located in the intelFPGA directory. After executing this application, the Hello SoC FPGA! message is displayed on the command prompt:</p> <pre><code># Target Serial console \nroot@dhcp0:~#  ./intelFPGA/hello Hello SoC FPGA!\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-system-check-application-with-hps-led-turn-onoff-control","title":"Use Case: Exercise System Check Application with HPS LED Turn On/Off control","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes executing the System Check Application to observe the state of the HPS LEDs. The execution of this use case works under the assumption that the LEDs are connected to the corresponding GPIOs in the virtual platform.</p> Setup <p>Same setup as the parent use case.</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>From the target system serial console, execute the System Check application (syschk) located under the intelFPGA directory. This shows some system information, such as the target system IP address and the state of the HPS LEDs. Observe that the initial state of the three HPS LEDs is OFF.</p> <p>Note:  When using device tree targeted for OOB card, only hps_led1 is available, so the System Check application only shows this led.</p> <pre><code># Target Serial console \nroot@dhcp0:~#  ./intelFPGA/syschk # Target Serial console \nActual changes:\n                              ALTERA SYSTEM CHECK                              lo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                      usb2                  : xHCI Host Contro\nhps_led2              : OFF\nhps_led0              : OFF             serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : OFF\n</code></pre> </li> <li> <p>Change the state of any of the HPS LEDs using the /sys/class/led/hps_ledX/brightness files writing either a '1' or '0' to these. For this, you need to first close the System Check application by typing Ctrl+C in the target serial console. Change the state of the LEDs to 'ON' state as indicated next and reopen the System Check application to observe the new state of the LEDs.</p> <pre><code># Target Serial console \nroot@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led0/brightness root@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led1/brightness root@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led2/brightness root@dhcp0:~# ./intelFPGA/syschk # Target Serial console \nActual changes:\n                                    ALTERA SYSTEM CHECK\n\nlo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                        usb2                  : xHCI Host Contro\nhps_led2              : ON\nhps_led0              : ON              serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : ON\n</code></pre> </li> <li> <p>Close the System Check application with Ctrl+C and return the HPS LEDs to the OFF state. Reconfirm that the state of the LEDs was updated to the new state in the System Check application.</p> <pre><code># Target Serial console \nroot@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led0/brightness root@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led1/brightness root@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led2/brightness root@dhcp0:~# ./intelFPGA/syschk # Target Serial console \nActual changes:\n                              ALTERA SYSTEM CHECK                              lo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                      usb2                  : xHCI Host Contro\nhps_led2              : OFF\nhps_led0              : OFF             serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : OFF\n</code></pre> </li> <li> <p>Close the System Check application with Ctrl+C.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-access-the-web-server-application-from-host-pc","title":"Use Case: Access the Web Server Application from Host PC","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes accessing from the host PC a web page that is being hosted by the target system, which runs a web server application. This application is launched automatically as part of the Linux boot process.</p> Setup <p>Using the uboot-linux_sdcard.simics Simics script, create an incoming port forwarding shown in the following:</p> <pre><code>connect-real-network-port-in ethernet-link = ethernet_switch0 target-ip=10.10.0.100 target-port = 80 host-port = 4080 -tcp </code></pre> <p>The port forwarding created allows you to access the webpage from the host PC. In the configuration, use the connect-real-network-port-in command, port 4080 in the host PC, and the target port in the target system is 80 (HTTP port). You also assign as the target IP, the IP that corresponds to the target system, which is 10.10.0.100. Also, indicate that this port forwarding is related to the TCP protocol. YOu can check the new port forwarding setup using the list-port-forwarding-setup command (this setup also could be done from the Simics CLI but in this case, the simulation should be stopped to perform the network configuration).</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>From the host PC, open a web browser and access the webpage running in the target system using the address: http://localhost:4080 . Note that the host machine is referred to as localhost and the port is 4080, which is the one visible from the host PC. </p> <p></p> <p>Note: The IP address of the host PC could be used as well instead of localhost.</p> <p>Note: The webpage displays instructions to connect to the target system using SSH. These instructions are valid if you run these binaries in real hardware. If you want to establish the SSH connection with a simulated target system, create a second incoming port forwarding with the following setup:</p> <p>connect-real-network-port-in ethernet-link = ethernet_switch0 target-ip=10.10.0.100 target-port = 22 host-port = 4022 -tcp</p> <p>Then, connect to the target system using ssh -p 4022 root@localhost from the host PC or ssh -p 4022 root@ from any other PC in the same network. <p>A variation of this use case consists of accessing the web page from another PC under the same network that the host PC (both PCs in a real network). For this, use the IP address of the host PC instead of localhost and continue using the same port: http://&lt;host PC address&gt;:4080.</p> <p>Note: In the Linux Ubuntu system, you can get the IP address using the ifconfig command from a terminal. Also, ensure that the firewall in this PC is not blocking port 80.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-access-on-chip-ram-in-fpga-example-design-from-linux-prompt","title":"Use Case: Access ON-Chip RAM in FPGA Example Design from Linux Prompt","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes accessing from Linux the FPGA fabric example design for read and write operations. For this, the devmem2 Linux application is used. Also, a Simics CLI script is used to write some initial content to the memories in the example design.</p> Setup <p>Start with the setup as the parent use case. From the Simics CLI or using the uboot-linux_sdcard.simics Simics script, add the script branch that adds some content to the memories in the example design. The script branch writes 256 32-bit words in each memory.</p> <p></p> <pre><code># uboot-linux_sdcard.simics\n:\nscript-branch{\n# Wait until we see any message in the Serial Console to be sure the model has been fully initialized\nbp.console_string.wait-for system.board.fpga.soc_inst.hps_subsys.agilex_hps.console0.con \"U-Boot SPL\"\n$idx = 0\nwhile ($idx &lt; 256) {\n$addr = 4*$idx\n$valueMem1 = 0xcafe0000 | $idx\necho \"Set Values \" + (hex($valueMem1)) + \" at address \" + (hex($addr))\nsystem.board.fpga.soc_inst.example_design.design_mem.write $addr $valueMem1    $idx+=1 }\n}\n</code></pre> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Read the first and last locations written by the CLI script in the memories in the example design using the devmem2 application in Linux. This command receives the physical memory that wants to be accessed (in this case, based on the offset where the HPS2FPGA bridges are mapped to):</p> <pre><code>dhcp0 login:  root root@dhcp0:~#  devmem2 0x40000000 w /dev/mem opened.\nMemory mapped at address 0xffffa3940000.\nRead at address  0x40000000 (0xffffa3940000): 0xCAFE0000\nroot@dhcp0:~#  devmem2 0x400003fc w /dev/mem opened.\nMemory mapped at address 0xffff91ac1000.\nRead at address  0x400003FC (0xffff91ac13fc): 0xCAFE00FF\n</code></pre> <p>Observe that the values read matches the expected one shown in the figure above.</p> <p>Note: The addresses in parenthesis in the capture above correspond to the virtual address in which Linux maps the physical address corresponding to the location in the memory example design that is being accessed. This virtual address may be different than the one shown in the capture.</p> </li> <li> <p>Use the <code>devmem2</code> command to write into the memories in the example design and read back the data. For this, the following addresses are selected:</p> Bridge Address Memory Design Addr Index Value HPS2FPGA 0x40000400 0x400 256 0xcafe0200 <pre><code>root@dhcp0:~#  devmem2 0x40000400 w 0xcafe0200 /dev/mem opened.\nMemory mapped at address 0xffffbd034000.\nRead at address  0x40000400 (0xffffbd034400): 0x00000000\nWrite at address 0x40000400 (0xffffbd034400): 0xCAFE0200, readback   0xCAFE0200\n</code></pre> </li> <li> <p>Read back to the previous memory location written to confirm the operation was performed successfully.</p> <pre><code>root@dhcp0:~#  devmem2 0x40000400 w  /dev/mem opened.\nMemory mapped at address 0xffffa5ab9000.\nRead at address  0x40000400 (0xffffa5ab9400): 0xCAFE0200\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-peripheral-components-in-fpga-fabric-example-design","title":"Use Case: Exercise Peripheral Components in FPGA Fabric Example Design","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and exercising:</p> <ul> <li>LED I/O component to write/and read the state of the LED from Simics CLI and from U-Boot shell</li> <li>Dip-Swich and Push-Button I/O components to change the state of the input from Simics CLI and read the state of the input from U-Boot shell. Also configure the triggering of an nterrupts from these component to the HPS.</li> </ul> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <ol> <li>Start the simulation similar to how it is done in the main use case, but in the serial console stop the U-Boot autoboot by pressing a key on the reception of the message \"Hit any key to stop autoboot:\".</li> <li> <p>Here you are going to exercise the setting of some LEDs. Read the state of the LEDs I/O pins from the U-Boot shell through memory access using the address in which the DATA register of this component is mapped (0x20010080) and turn-on the 3 LEDs associated with the 3 less significative bits in this register. Then read-back the state of these pins to confirm these has been updated. You can confirm that the state of the LED's was updated reading directly into the DATA register of the LED I/O components from the Simics CLI.</p> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010080 1\n20010080: 00000000                             \u2026.\nSOCFPGA_AGILEX5 # mw 0x20010080 0x7 1\nSOCFPGA_AGILEX5 # md 0x20010080 1\n20010080: 00000007  </code></pre> <pre><code># Simics CLI\nrunning&gt; print-device-reg-info system.board.fpga.soc_inst.periph_subsys.led_pio.bank.regs.DATA [system.board.fpga.soc_inst.periph_subsys.led_pio.bank.regs.DATA]\nBits : 32\nOffset : 0x0\n          Value : 7\nBit Fields:\n  Data @ [31:0] : 00000000000000000000000000000111\n</code></pre> </li> <li> <p>Next you will exercise the toggling the input pin of the dip-switch component using the Simics CLI through the signal_raise() and signal_lower() and then reading back the state of the pin using the DATA register in this component using the U-Boot shell through the corresponding memory location of this register (0x20010070).</p> <pre><code># Simics CLI\nrunning&gt; @conf.system.board.fpga.soc_inst.periph_subsys.dipsw_pio.port.input_io[0].iface.signal.signal_raise() None\n</code></pre> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010070 1 \n20010070: 00000001 </code></pre> <pre><code># Simics CLI\nrunning&gt;  @conf.system.board.fpga.soc_inst.periph_subsys.dipsw_pio.port.input_io[0].iface.signal.signal_lower() None\n</code></pre> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010070 1 \n20010070: 00000000                             \u2026.\n</code></pre> </li> <li> <p>Finally you are going to exercise triggering an interrupt and clearing the interrupt generated from the rising edge of the input in the button I/O component. This will be exercised from the Simics CLI. To observe that the interrupt is triggered, the log level of the interrupt controller is increased. First the interrupt needs to be enabled using the INTERRUPT register in this component. Once the interrupt is enabled, we can assert the input signal and observe that the interrupt is triggered and the DATA register gets also updated with the set value ('1'). Finally, you will clear the interrupt using again the INTERRUPT register.</p> <pre><code># Simics CLI\nrunning&gt; log-level object = system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic level = 4 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic] Changing log level: 1 \u2192 4\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 0\nrunning&gt;  write-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.INTERRUPTMASK 1 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 already low\nrunning&gt;  @conf.system.board.fpga.soc_inst.periph_subsys.button_pio.port.input_io[0].iface.signal.signal_raise() [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 raised\nNone\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 1\nrunning&gt;  write-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.INTERRUPTMASK 0 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 lowered\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 1\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-usb-disk-hot-plug","title":"Use Case: Exercise USB Disk Hot-Plug","text":"<p>This use case is an extension of the main use case and includes attaching a USB image to one of the USB disks available in the Agilex\u2122 5-E Universal virtual platform and exercising the plug-in and plug-out actions as follows:</p> <ol> <li>Boot to the Linux prompt and plug in the USB disk (default), mount the disk and access some of the disk content, and add new content. The disk used in this use case is usb3_disk connected to the USB 3.0 Gen 1 controller.</li> <li>Unmount and plug-out the disk, and verify that this is not seen by Linux anymore.</li> <li>Plug-in and remount the disk, and verify that the content created is still available.</li> </ol> <p>All this is done as part of a single simulation session. The procedure described in the current use case does not allow to keep persistence of the content updated in the USB image after finishing the simulation.</p> <p>For this use case, we require to create an initial USB disk Image for which some information is provided in the Setup section.</p> Setup <p>Start with the setup as the parent use case an continue with next steps. 1. Create a 32 MB USB image (<code>usbImage.img</code>) following the instructions . The image has a <code>ext4</code> type file system in the partition created that includes as  initial content the <code>hello1.txt</code> file:</p> <ol> <li> <p>In your Simics project directory, create the <code>usbImage.img</code> image:  </p> <pre><code># Create a dircetory to create the image\nmkdir usbDisk &amp;&amp; cd usbDisk\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir part1 &amp;&amp;  cd part1\necho \"This is my original file in USB image\" &gt; hello1.txt cd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P part1/*,num=1,format=ext4,size=16M \\\n-s 32M \\\n-n usbImage.img\n</code></pre> </li> <li> <p>Update the target script to attach the image to the USB disk.</p> <pre><code>#uboot-linux_sdcard.simics   \n$sd_image_filename = \"gsrd-console-image-agilex5.wic\"\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$usb3_image_filename = \"usbDisk/usbImage.img\"\n$hps_boot_core = 0\n$create_hps_sd_card = TRUE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> </li> </ol> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in. By default, the USB disks in the virtual platform are plugged in. These can be detected from the Linux using the fdisk -l command and shown next:</p> <pre><code>root@dhcp0:~# fdisk -l Disk /dev/mmcblk0: 16 GB, 17179869184 bytes, 33554432 sectors 262144 cylinders, 4 heads, 32 sectors/track\nUnits: sectors of 1 * 512 = 512 bytes\n\nDevice       Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/mmcblk0p1 *  16,0,1      1023,3,32         2048    1026047    1024000  500M  b Win95 FAT32\n/dev/mmcblk0p2    1023,3,32   1023,3,32      1026048    4098047    3072000 1500M 83 Linux\nDisk /dev/sda: 32 MB, 33554432 bytes, 65536 sectors 37 cylinders, 43 heads, 41 sectors/track\nUnits: sectors of 1 * 512 = 512 bytes\n\nDevice  Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/sda1    0,32,33     2,42,41           2048      34816      32769 16.0M 83 Linux\nPartition 1 has different physical/logical start (non-Linux?):\n     phys=(0,32,33) logical=(1,6,40)\nPartition 1 has different physical/logical end:\n     phys=(2,42,41) logical=(19,32,8)\n</code></pre> </li> <li> <p>Observe that the usb3_disk corresponds to the /dev/sda device and /dev/sda1 corresponds to the partition created in this disk which size of 16 MB.</p> </li> <li> <p>Mount the partition in usb3_disk, observe the content (hello1.txt file), add new content (hello2.txt), and unmount the disk.</p> <pre><code>root@dhcp0:~# mkdir /media/usbDrive root@dhcp0:~# mount /dev/sda1 /media/usbDrive [  680.753967] EXT4-fs (sda1): mounted filesystem with ordered data mode. Quota mode: none.\nroot@dhcp0:~# ls /media/usbDrive hello1.txt root@dhcp0:~# more /media/usbDrive/hello1.txt This is my original file in USB image\nroot@dhcp0:~# echo \"This is my new file in the USB image\" &gt; /media/usbDrive/hello2.txt root@dhcp0:~# ls /media/usbDrive hello1.txt  hello2.txt root@dhcp0:~# umount /media/usbDrive/ [ 2403.043825] EXT4-fs (sda1): unmounting filesystem.\n</code></pre> </li> <li> <p>Unplug the usb3_disk from the Simics CLI and observe that Linux detects this action.</p> <p>In Simics CLI: <pre><code>running&gt; system.board.usb3_disk.unplug </code></pre></p> <p>In Linux shell: <pre><code>root@dhcp0:~# [ 1115.122439] usb 3-1: USB disconnect, device number 2\n</code></pre></p> <p>You can call fdisk -l command again to observe that /dev/sda device is no longer present.</p> </li> <li> <p>From the Simics CLI plugin, the usb3_disk again provides the usb3 port. Observe in the Linux shell that the device connection is detected. Remount the device partition and confirm that the new content created before is still present. Finally, unmount the disk.</p> <p>In Simics CLI:</p> <p><pre><code>running&gt; system.board.usb3_disk.plug port = usb1_typec\n</code></pre> In Linux shell:</p> <pre><code>root@dhcp0:~# [ 1415.994946] usb 3-1: new SuperSpeed USB device number 3 using xhci-hcd\n[ 1416.015078] usb 3-1: LPM exit latency is zeroed, disabling LPM.\n[ 1416.016520] usb-storage 3-1:1.0: USB Mass Storage device detected\n[ 1416.017476] scsi host0: usb-storage 3-1:1.0\n[ 1417.023153] scsi 0:0:0:0: Direct-Access     Vtech    Turbo_Disk(tm)   0001 PQ: 0 ANSI: 2\n[ 1417.024835] sd 0:0:0:0: [sda] 65536 512-byte logical blocks: (33.6 MB/32.0 MiB)\n[ 1417.025818] sd 0:0:0:0: [sda] Test WP failed, assume Write Enabled\n[ 1417.026685] sd 0:0:0:0: [sda] Asking for cache data failed\n[ 1417.027290] sd 0:0:0:0: [sda] Assuming drive cache: write through\n[ 1417.029785]  sda: sda1\n[ 1417.030333] sd 0:0:0:0: [sda] Attached SCSI disk\n\nroot@dhcp0:~# fdisk -l\nDisk /dev/mmcblk0: 16 GB, 17179869184 bytes, 33554432 sectors\n:\nDevice  Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/sda1    0,32,33     2,42,41           2048      34816      32769 16.0M 83 Linux\nPartition 1 has different physical/logical start (non-Linux?):\n     phys=(0,32,33) logical=(1,6,40)\nPartition 1 has different physical/logical end:\n     phys=(2,42,41) logical=(19,32,8)\nroot@dhcp0:~# mount /dev/sda1 /media/usbDrive [ 5419.362283] EXT4-fs (sda1): mounted filesystem 0fe6c96c-996c-4659-b7e2-e694076e5aef r/w with ordered data mode. Quota mode: none.\nroot@dhcp0:~# ls  /media/usbDrive hello1.txt  hello2.txt  lost+found\nroot@dhcp0:~# more  /media/usbDrive /media/usbDrive/hello2.txt\nThis is my new file in the USB image\nroot@dhcp0:~# umount /media/usbDrive/ [ 7348.324046] EXT4-fs (sda1): unmounting filesystem 0fe6c96c-996c-4659-b7e2-e694076e5aef.\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-ubifs-qspi-boot-flow-from-fsbl-to-linux","title":"Use Case: Exercise UBIFS QSPI Boot Flow from FSBL to Linux","text":"<p>This use case consists of booting from a QSPI flash device going from U-Boot to Linux prompt passing through U-Boot SPL \u2192 ATF \u2192 U-Boot \u2192 Linux using an image with UBIFS format.</p> Setup <p>Perform steps 1 to 4 described in the Simulation Setup section.</p> <ol> <li> <p>In the Intel Simics environment at the project directory, generate a compressed version of the .rpd file created (.craff) file using the craff tool provided under the Simics Base installation directory:</p> <pre><code>&lt;SimicsInstallDir&gt;/simics-6.0.202/bin/craff -o qspi_image.img.craff flash_image_jic.rpd\n</code></pre> <p>The following file is created under the Simics project directory:</p> <ul> <li>qspi_image.img.craff</li> </ul> </li> <li> <p>In the Intel Simics environment at the project directory, create a customized target script to exercise the FSBL to Linux boot flow from QSPI device with an image with UBIFS format. The file to create is called uboot-linux_qspi.simics. This file will look like this:</p> <pre><code>#uboot-linux_qspi.simics\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$qspi_image_filename  = \"qspi_image.img.craff\"\n$hps_boot_core = 0\n$create_hps_sd_card = FALSE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> </li> </ol> Procedure <p>To exercise this use case, follow the steps below once the Simulation setup is complete:</p> <ol> <li> <p>From the project directory, launch the simulation using the uboot-linux_qspi.simics target script. This script launches the simulator and the current terminal becomes the Simics CLI:</p> <pre><code>$ ./simics uboot-linux_qspi.simics </code></pre> </li> <li> <p>From the Simics CLI, start running the simulation with the <code>run</code> command.   <pre><code>simics&gt;  run\n</code></pre></p> </li> <li> <p>Wait for the simulation to get to the Linux prompt in the target serial console.</p> </li> <li> <p>Login into the Linux prompt using the root user without a password.  </p> <pre><code> U-Boot SPL 2024.04 (Oct 16 2024 - 02:54:45 +0000)\nReset state: Cold\n  MPU           875000 kHz\n  L4 Main       400000 kHz\n  L4 sys free   100000 kHz\n  L4 MP         200000 kHz\n  L4 SP         100000 kHz\n  SDMMC          50000 kHz\n  io96b_cal_status: Calibration for IO96B instance 0x18400400 done at 0 msec!\n  init_mem_cal: Initial DDR calibration IO96B_0 succeed\n  io96b_mb_init: num_instance 1\nio96b_mb_init: get memory interface IO96B 0\n:\n  ecc_enable_status: ECC enable status: 0\nDDR: size check success\n  DDR: firewall init success\n  DDR: init success\n  QSPI: Reference clock at 400000 kHz\n  Trying to boot from MMC1\n  MMC: no card present\n  spl: mmc init failed with error: -123\n  Trying to boot from SPI\n  ## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\n  NOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 0\nNOTICE:  BL31: v2.11.0(release):QPDS24.3_REL_GSRD_PR\n  NOTICE:  BL31: Built : 07:09:49, Oct 15 2024\nU-Boot 2024.04 (Oct 16 2024 - 02:54:45 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\n  DRAM:  2 GiB (effective 8 GiB)\nCore:  51 devices, 26 uclasses, devicetree: separate\n  WDT:   Not starting watchdog@10d00200\n  WDT:   Not starting watchdog@10d00300\n  WDT:   Not starting watchdog@10d00400\n  WDT:   Not starting watchdog@10d00500\n  WDT:   Not starting watchdog@10d00600\n  NAND:  4096 MiB\n  MMC:   mmc0@10808000: 0\nLoading Environment from FAT... MMC: no card present\n  :\n  Hit any key to stop autoboot:  0 MMC: no card present\n  SF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\n  Select Environment on UBI: OK\n  Saving Environment to UBI... done\nOK\n  UBI partition 'root' already selected\n  UBI partition 'root' already selected\n  No size specified -&gt; Using max size (196224)\nRead 196224 bytes from volume script to 0000000081000000\nQSPI: Running script from UBIFS\n  QSPI: Trying to boot script at 0x81000000\n  ## Executing script at 81000000\ncrc32+ Trying to boot Linux from device qspi\n\ndevice nor0 &lt;nor0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: u-boot              0x04200000      0x00000000      0\n1: root                0x0be00000      0x04200000      0\ndevice nand0 &lt;nand.0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: nand_uboot          0x00200000      0x00000000      0\n1: nand_root           0x1f400000      0x00200000      0\nactive partition: nor0,0 - (u-boot) 0x04200000 @ 0x00000000\n\ndefaults:\n  mtdids  : nand0=10b80000.nand.0\n  mtdparts: mtdparts=10b80000.nand.0:2m(u-boot),-(root)\nUBI partition 'root' already selected\n  :\n  SF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\n  Enabling QSPI at Linux DTB...\n  Working FDT set to ffae1000\n  QSPI clock frequency updated\n  RSU: Firmware or flash content not supporting RSU\n  RSU: Firmware or flash content not supporting RSU\n  RSU: Firmware or flash content not supporting RSU\n  RSU: Firmware or flash content not supporting RSU\n\nStarting kernel ...\n\nDeasserting all peripheral resets\n  [    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.37-altera-g978b3d90f408 (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240723) #1 SMP PREEMPT Mon Oct 14 01:56:39 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n  [    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n  [    0.000000] efi: UEFI not found.\n  [    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n  [    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n  [    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n  [    0.000000] earlycon: uart0 at MMIO32 0x0000000010c02000 (options '115200n8')\n[    0.000000] printk: bootconsole [uart0] enabled\n  [    0.000000] NUMA: No NUMA configuration found\n  :\n  Poky (Yocto Project Reference Distro) 5.0.5 agilex5dka5e065bb32aes1 ttyS0\n\nagilex5dka5e065bb32aes1 login: [  270.942017] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-0\n  [  270.947263] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-1\n  [  270.952619] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-2\n  :\n  [  281.452200] socfpga-dwmac 10830000.ethernet eth0: Link is Up - 1Gbps/Full - flow control rx/tx\n  [  311.541769] audit: type=1334 audit(1709054902.844:15): prog-id=18 op=UNLOAD\n  [  311.542509] audit: type=1334 audit(1709054902.844:16): prog-id=17 op=UNLOAD\n  [  311.543247] audit: type=1334 audit(1709054902.844:17): prog-id=16 op=UNLOAD\n\ndhcp0 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for testing and development purposes only. It is recommended that you create your own distribution for production use.\n\nroot@dhcp0:~#\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-nand-boot-flow-from-fsbl-to-linux","title":"Use Case: Exercise NAND Boot Flow from FSBL to Linux","text":"<p>This use case consists of booting from a NAND flash device going from U-Boot to Linux prompt passing through U-Boot SPL \u2192 ATF \u2192 U-Boot \u2192 Linux.</p> Setup <p>Perform steps 1 to 4 described in the Simulation Setup section.</p> <ol> <li> <p>In the Intel Simics environment at the project directory, create a customized target script to exercise the FSBL to Linux boot flow from NAND device. The file to create is called uboot-linux_nand.simics. This file will look like this:</p> <pre><code>#uboot-linux_nand.simics\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$nand_data_image_filename = \"nand.img\"\n$hps_boot_core = 0 $create_hps_sd_card = FALSE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> <p>Also, in order to have ethernet connectivity, you need to connect the ethernet interface defined in the NAND device tree (eth0). For this,  update the following line in the targets/agilex5e-universal/agilex5e-universal.simics file:</p> <pre><code>if $create_hps_eth0_network {    :\n    # Connect HPS eth0 instead of eth2 to Ethernet Switch\nconnect ($eth_switch.get-free-connector) $system.board.eth0\n    :    }\n</code></pre> </li> </ol> Procedure <p>To exercise this use case, follow the below steps once the Simulation setup is complete:</p> <ol> <li> <p>From the project directory, launch the simulation using the <code>uboot-linux_nand.simics</code> target script. This script launches the simulator and the current terminal becomes the Simics CLI:</p> <pre><code>$ ./simics uboot-linux_nand.simics </code></pre> </li> <li> <p>From the Simics CLI, start running the simulation with the <code>run</code> command.</p> <pre><code>simics&gt;  run\n</code></pre> </li> <li> <p>Wait for the simulation to get to the Linux prompt in the target serial console.</p> </li> <li> <p>Login into the Linux prompt using the root user without a password.  </p> <pre><code>  U-Boot SPL 2024.04 (Oct 16 2024 - 02:54:45 +0000)  Reset state: Cold\n  MPU           875000 kHz\n  L4 Main       400000 kHz\n  L4 sys free   100000 kHz\n  L4 MP         200000 kHz\n  L4 SP         100000 kHz\n  SDMMC          50000 kHz\n  io96b_cal_status: Calibration for IO96B instance 0x18400400 done at 0 msec!\n  init_mem_cal: Initial DDR calibration IO96B_0 succeed\n  :\n  ecc_enable_status: ECC enable status: 0\nDDR: size check success\n  DDR: firewall init success\n  DDR: init success\n  QSPI: Reference clock at 400000 kHz\n  Trying to boot from MMC1\n  MMC: no card present\n  spl: mmc init failed with error: -123\n  Trying to boot from SPI\n  Trying to boot from NAND\n  ## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\n  NOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 0\nNOTICE:  BL31: v2.11.0(release):QPDS24.3_REL_GSRD_PR\n  NOTICE:  BL31: Built : 07:09:49, Oct 15 2024\nU-Boot 2024.04 (Oct 16 2024 - 02:54:45 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\n  DRAM:  2 GiB (effective 8 GiB)\nCore:  51 devices, 26 uclasses, devicetree: separate\n  WDT:   Not starting watchdog@10d00200\n  WDT:   Not starting watchdog@10d00300\n  WDT:   Not starting watchdog@10d00400\n  WDT:   Not starting watchdog@10d00500\n  WDT:   Not starting watchdog@10d00600\n  NAND:  4096 MiB\n  MMC:   mmc0@10808000: 0\nLoading Environment from FAT... MMC: no card present\n  :\n  ** Cannot find mtd partition \"root\"\nIn:    serial0@10c02000\n  Out:   serial0@10c02000\n  Err:   serial0@10c02000\n  Net:   Warning: ethernet@10810000 (eth0) using random MAC address - 9a:4a:35:36:eb:71\n  eth0: ethernet@10810000\n  Warning: ethernet@10830000 (eth2) using random MAC address - 8e:87:b0:0c:94:09, eth2: ethernet@10830000\n  Hit any key to stop autoboot:  0 MMC: no card present\n  SF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\n  Select Environment on UBI: OK\nNAND: Trying to boot script at 0x81000000\n\n## Executing script at 81000000\ncrc32+ Trying to boot Linux from device nand\n  Select Environment on UBI: OK\n  Saving Environment to UBI... UBI partition 'root' already selected\n  done\nOK\n  :\n  device nor0 &lt;nor0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: u-boot              0x04200000      0x00000000      0\n1: qspi_root           0x0be00000      0x04200000      0\ndevice nand0 &lt;ffb90000.nand.0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: u-boot              0x00200000      0x00000000      0\n1: root                0xffe00000      0x00200000      0\nactive partition: nor0,0 - (u-boot) 0x04200000 @ 0x00000000\n\ndefaults:\n  mtdids  : nand0=10b80000.nand.0\n  mtdparts: mtdparts=10b80000.nand.0:2m(u-boot),-(root)\n:\n  Starting kernel ...\n\nDeasserting all peripheral resets\n  [    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.37-altera-g978b3d90f408 (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240723) #1 SMP PREEMPT Mon Oct 14 01:56:39 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n  [    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n  [    0.000000] efi: UEFI not found.\n  [    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n  [    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n  [    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n  [    0.000000] earlycon: uart0 at MMIO32 0x0000000010c02000 (options '115200n8')\n:\n  Poky (Yocto Project Reference Distro) 5.0.2 dhcp0 ttyS0\n\n[   15.586539] soc64-hwmon soc@0:firmware:svc:hwmon: Initialized 4 temperature and 6 voltage channels\n  [   15.587715] soc64-hwmon soc@0:firmware:svc:hwmon: couldn't get service channel rsu\n  [   15.594272] Stratix10 SoC FPGA manager soc@0:firmware:svc:fpga-mgr: couldn't get service channel (fpga)\n[   15.595272] platform soc@0:firmware:svc:hwmon: deferred probe pending\n  [   15.595948] platform soc@0:base_fpga_region: deferred probe pending\n  [   15.596631] platform soc@0:firmware:svc:fpga-mgr: deferred probe pending\n  [   36.588749] audit: type=1334 audit(1709054799.316:15): prog-id=18 op=UNLOAD\n  [   36.589487] audit: type=1334 audit(1709054799.316:16): prog-id=17 op=UNLOAD\n  [   36.590224] audit: type=1334 audit(1709054799.316:17): prog-id=16 op=UNLOAD\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for testing and development purposes only. It is recommended that you create your own distribution for production use.\n\nroot@dhcp0:~#\n</code></pre> <p>Note: Most of the same use cases that are exercised from the Exercise SDCard Boot Flow from FSBL to Linux use case can also be exercised from this use case. There are some exceptions due to the limitation in the size of the file system which does not support the required commands.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-debug-bare-metal-code-using-intel-simics-simulator","title":"Use Case: Debug Bare-Metal Code Using Intel Simics Simulator","text":"<p>This use case consists of performing a debug session in a bare-metal environment, which in this case corresponds to a U-Boot application example. In this use case, debugging is performed using only the Simics CLI commands allowing us to navigate on the source code of the application, advance in the execution of this, and observe and modify values of variables. The application is created in the form of a U-Boot command (helloTestApp) that should be executed from the U-Boot shell. The application starts by printing a hello message (Hello Intel SoC FPGA!) and printing the number of times the command has been executed since the last power-up. After this, the application enters into a loop in which it waits for 100 sec and increases an iteration counter by one. The content on the loop is executed as long as the iterator counter is lower than 100000 and also the value of the exitVar variable remains in 0, otherwise, it leaves the loop and continues printing the number of times the content of the loop was executed. After this, the code performs some mathematical operations involving the iterator value and other variables and finally prints the result of the final operation.</p> <p>The source code of the application is shown next. This is included in the do_helloTestApp() function, which then is referenced in the U_BOOT_CMD macro, which converts this into a U-Boot command. This source code must be included in a new file under the U-Boot repository as cmd/socFPGATrainingExamples.c. Also, to be built as part of the U-Boot binaries, update the cmd/Makefile file by adding obj-y += socFPGATrainingExamples.o.</p> <pre><code>/*\n   Training Examples called from a command from U-Boot shell\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;command.h&gt;\n#include &lt;linux/delay.h&gt;\nstatic char helloTestCmd_help_text[] =\n\"helloTestApp\\t\\n\";\nstatic unsigned int execCount = 0;\nstatic int do_helloTestApp(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])\n{\nvolatile unsigned char exitVar = 0;\nunsigned int waitIter = 0;\nvolatile unsigned int myVarA = 0;\nunsigned int temp = 0;\nunsigned int result;\nif (argc &gt; 1)\n{\nreturn CMD_RET_USAGE;\n}\nprintf(\"Hello Intel SoC FPGA! \\r\\n\");\nexecCount++;\nprintf(\"Executed %d times \\r\\n\", execCount);\nprintf(\"Relocated address of do_helloTestApp: %p and execCount: %p \\r\\n\", &amp;do_helloTestApp, &amp;execCount);\nwhile ((exitVar == 0) &amp;&amp; (waitIter &lt; 100000)){\nudelay(100);\nwaitIter++;\n}\nprintf(\"Exit from loop at iteration: %d \\r\\n\", waitIter);\ntemp = waitIter + myVarA;\nresult = temp % 1000;\nprintf(\"Final result: %d \\r\\n\", result);\nreturn CMD_RET_SUCCESS;\n}\nU_BOOT_CMD(\nhelloTestApp, 1, 1, do_helloTestApp,\n   \"Command used to launch hello application\", helloTestCmd_help_text\n);\n</code></pre> <p>Note: You can perform the build of this application by updating the Yocto recipe. This can be done by creating a patch in which you describe the files that need to be created/updated in the U-Boot repository and then deploy it. This can be done during the Yocto customization stage (Customize the Yocto Build). To create the u-boot patch (<code>myUbootExampleApp.patch</code>), do the following:</p> <pre><code>cd $TOP_FOLDER\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga u-boot-socfpga-patch\ncd u-boot-socfpga-patch/\n - Create cmd/socFPGATrainingExamples.c file with the source code provided of the example application.\n - Edit cmd/Makefile to include the build of socFPGATrainingExamples.c\n\nobj-y += help.o\n    obj-y += panic.o\n    obj-y += version.o\n    obj-y += socFPGATrainingExamples.o\n\ngit add cmd/Makefile cmd/socFPGATrainingExamples.c\ngit diff --patch --staged &gt; myUbootExampleApp.patch\n</code></pre> <p>To deploy the patch in the Yocto build flow do the following:</p> <ol> <li>Copy the <code>myUbootExampleApp.patch</code> file to the $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/ directory.</li> <li> <p>Request to deploy the path by adding a patch to the $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/u-boot-socfpga_%.bbappend file:</p> <pre><code>SRC_URI:append = \" \\ \n      file://0001-arm-Add-dwarf-4-to-compilation-flag.patch \\   \n      file://0001-arm-agilex-add-board-configuration.patch \\    \n      file://0001-arm-stratix10-add-board-configuration.patch \\ \n      file://myUbootExampleApp.patch \\ \n      \"\n</code></pre> </li> <li> <p>Continue with the rest of the Yocto build flow indicated at Build Yocto section.</p> </li> </ol> <p>After these steps, the application is included in the U-Boot binary file (uboot.itb), which is part of the SDCard image created (gsrd-console-image-agilex5.wic) and a symbol file corresponding to the U-Boot image, located at $TOP_FOLDER/gsrd-socfpga/agilex5_devkit-gsrd-images/u-boot-agilex5_devkit-socdk-gsrd-atf/u-boot. The symbol file is used later during the setup of the debug session.</p> Setup <p>Start with the setup of the main use case defined at [Simulation Setup]#simulation-setup). Modify the target script to add the created symbol file and set a breakpoint at the entry point of the  do_helloTestApp function as indicated in the following:</p> <pre><code># uboot-linux_sdcard.simics\n:\nadd-symbol-file  &lt;path of symbol file&gt;/u-boot  0x7FAF2000 -relative\nbp.source_location.break do_helloTestApp\n</code></pre> <p>Note: The symbol file is being loaded with an offset relocation of 0x7FAF2000. This is needed because in a late stage of the U-Boot execution, this relocates itself into a different SDRAM memory location and this should be indicated to the debugger, so there is a match between the addresses indicated in the symbol file and the real memory address location of the symbols. You can obtain this relocation offset by subtracting the real address of a specific function (which can be obtained from the application being executed) and the original offset from the same function in the symbols file (provided in the u-boot.sym file). This is shown in the following figure:</p> <p></p> Procedure <ol> <li> <p>Start the simulation similar to how it is done in the main use case, but in the serial console stop the U-Boot autoboot by pressing a key on the reception of the message \"Hit any key to stop autoboot:\". </p> </li> <li> <p>Start the U-Boot example application by calling the helloTestApp command from the U-Boot shell. This will make the breakpoint set in the target script trigger and the simulation will be stopped. In the Simics CLI, you will see the following message:</p> <pre><code>  [tcf] Breakpoint 1 on execution in context board.fpga.soc_inst.hps_subsys.agilex_hps.core[0] </code></pre> </li> <li> <p>From Simics CLI, start a debug session by calling the following command:   <pre><code>simics&gt; (psel).debug dbg0 (the arm-cortex-a55 system.board.fpga.soc_inst.hps_subsys.agilex_hps.core[0]) Now debugging the arm-cortex-a55 system.board.fpga.soc_inst.hps_subsys.agilex_hps.core[0] do_helloTestApp(cmdtp=(struct cmd_tbl *) 0xfffc5788, flag=0, argc=1, argv=(char * const *) 0xffb09520) at /home/tasks/gsrd/agilex5/updateUbootApp/agilex5_gsrd/gsrd-socfpga/agilex5_devkit-gsrd-rootfs/tmp/work/agilex5-poky-linux/u-boot-socfpga/1_v2022.10+gitAUTOINC+59fa161039-r0/git/cmd/socFPGATrainingExamples.c:19 19 volatile unsigned char exitVar = 0; </code></pre></p> </li> <li> <p>Following the program's logic, if the value of exitVar stays zero and the program is continued, the loop will continue until it reaches 100,000 and then the program ends with output messages in the serial console. You can check the values of the variable using the sym-type  and sym-value features:   <pre><code>simics&gt; dbg0.sym-type exitVar volatile unsigned char simics&gt; dbg0.sym-value exitVar 0 '\\x00' simics&gt; dbg0.sym-type myVarA volatile unsigned int- simics&gt; dbg0.sym-value myVarA 0\n</code></pre></p> </li> <li> <p>Control the program by using breakpoint and value modification. In this section, first insert a breakpoint at Line 34, which is in the loop (You may let the program run for a few seconds before inserting this breakpoint). With that, expect the program to pause when the breakpoint is met and modify the value of exitVar.   <pre><code>//The loop conditions are exitVar and waitIter   32| while ((exitVar == 0) &amp;&amp; (waitIter &lt; 100000)){   33|    udelay(100);   34|    waitIter++;   35| }\n</code></pre></p> <p>In the Simics Serial Console, enter the following line to insert the breakpoint at Line 34: <pre><code>running&gt; bp.source_line.break filename=socFPGATrainingExamples.c line-number=34\nBreakpoint 2: 0x2 (planted) </code></pre></p> <p>As the breakpoint is planted, continue the program by entering run. The program will stop when the breakpoint is hit. When the program stopped, modify the value of exitVar in the Serial Console by using the sym-write feature.</p> <pre><code>simics&gt; dbg0.sym-write exitVar 1 exitVar = 1 '\\x01'\nsimics&gt; run\n</code></pre> <p>Next, enter run and see the program ends immediately due to exitVar=1. <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n    Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n    Exit from loop at iteration: 9691\nFinal result: 691\nSOCFPGA_AGILEX5 #\n</code></pre></p> <p>From the output print, it shows that the program iterated for 9691 loops before hitting the Line-34 breakpoint you planted, this number would be bigger if you waited longer before planting the breakpoint. Lastly, the modification of exitVar  ended the program.</p> <p>Note:   a) You can modify the value of myVarA and exitVar at any time before the looping ends (the test program ends after 99,999 loops).   b) If the loop-ending condition (myVarA and exitVar) changed, the program should exit in the next run.   c) Using the same Simics session, you can enter helloTestApp in U-boot Shell to restart the test program again.</p> </li> <li> <p>For the first time the program is executed, the output shows \u201cExecuted 1 times\u201d, this value will increase (+1) as you run the program again without ending the Simics session. Meanwhile, in the serial console, the program has ended as soon as it just started because the controlling variable exitVar, having a value of 1, already reached the loop-ending condition. Output on a serial console:</p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n    Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n    Exit from loop at iteration: 2\nFinal result: 2\nSOCFPGA_AGILEX5 #\n</code></pre> </li> <li> <p>If the value exitVar remained zero, the loop counter is allowed to run for 99,999 loops. While the program is looping, you may change the value of myVarA to \u2018345\u2019. The Final result will be 345 when the looping ends. Final result is the modulus value where the <code>Final result = ( (waitIter + myVarA) % 1000 )</code></p> <pre><code> SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n    Executed 2 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n    Exit from loop at iteration: 100,000\n    Final result: 345\nSOCFPGA_AGILEX5 #\n</code></pre> </li> <li> <p>If both values of exitVar and myVarA remain unchanged, both being zero respectively, the looping continues until it reaches waitIter = 100,000. When the program ends, the Final result would be zero.</p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n    Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n    Exit from loop at iteration: 100,000\n    Final result: 0\nSOCFPGA_AGILEX5 #\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-debug-bare-metal-code-using-simics-riscfree","title":"Use Case: Debug Bare-metal Code Using Simics-RiscFree","text":"<p>This use case is an extension to the use case in section Use Case: Debug Bare-metal Code Using Intel Simics Simulator above but the debugging steps are performed in the Simics-RiscFree IDE. The test program used here is the same helloTestApp.c Important: The offset relocation of 0x7FAF2000 in the symbol file is still required and must be done before the symbol file is used to launch Simics-RiscFree.</p> Setup <p>This section requires the simics-riscfree script. It is included in your Intel Simics Simulator project directory.</p> <ol> <li> <p>To launch Simics-RiscFree IDE, use this command:</p> <pre><code>$  ./simics-riscfree </code></pre> </li> <li> <p>Following the command, you must set up a RiscFree  workspace. You should use a new directory as a RiscFree workspace different from the Simics project directory.     </p> </li> <li> <p>In the RiscFree IDE GUI launched, you should see the current Simics project you selected shown in the Project Explorer window. If this is not shown, you can open it from \"Window &gt; Show View &gt; Project Explorer\" menu.</p> <p></p> </li> <li> <p>From the Project Explorer window, right-click on the target script you want to launch (uboot-linux_sdcard.simics) and select \u201cDebug As &gt; Simics Session\u201d.     </p> </li> <li> <p>When prompted for Switching Perspective, select Yes. The interface switches to the RiscFree Debugger, which is more user-friendly for debugging.     </p> </li> </ol> Procedure <ol> <li>In the RiscFree Debugger window, click on the Run button  to launch the Intel Simics Simulator project.</li> <li> <p>As the project is launched, a Simics CLI window appears. When the CLI reaches the Hit any key to stop autoboot message, press any key to stop the autoboot to OS, which will then go into the U-boot Shell.</p> <p></p> </li> <li> <p>Start the test program by entering helloTestApp in the U-boot Shell.</p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nsimics&gt; [tcf] Breakpoint 1 on execution in context board.fpga.soc_inst.hps_subsys.agilex_hps.core[0]\n</code></pre> </li> <li> <p>As the first breakpoint is met, the program is halted at the entry point of the do_helloTestApp() function. Use the step into/step-over buttons  to get to the while ((exitVar == 0)  &amp;&amp;  (waitIter &lt; 100000)) line and show a capture of this with list command.</p> <p></p> </li> <li> <p>At this point, if you click on the Run button, the test program prints \u201cHello Intel SoC FPGA!\u201d and finishes looping after some time.</p> <p></p> <p>Note: If the loop already ended, relaunch the test program \"helloTestApp\" to proceed to the next step.</p> </li> <li> <p>To modify the loop conditions for debugging purposes, you can modify the value of exitVar in the Variable window. For example, changing the value of exitVar from \u2018\\377\u2019 (this is a random value assigned by the system) to \u2018\\001\u2019. As <code>exitVar</code> is no longer zero, the condition of the loop is exceeded, and thus the looping ends.</p> <p>Before modification:</p> <p></p> <p>After modification:</p> <p>[</p> </li> <li> <p>The loop exits depending on two conditions: exitVar not equals to zero OR waitIter reached 100,000. As the value of exitVar is modified to 1 in the middle of looping, the loop ends with exitVar = 1 and <code>waitIter</code> at any number less than 100,000. In this example, waitIter is 82251 when the loop ends. Following the code logic, Final result is the modulus value where Final result = ( (waitIter + myVarA) % 1000 ) = 252.</p> <p></p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-remote-debugging-of-a-linux-user-mode-program-using-arm-ds-debugger","title":"Use Case: Remote Debugging of a Linux User Mode Program Using ARM DS Debugger","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and consists of performing a debug session in a Linux user mode application using ARM Development Studio. For this, the debugging is done using the GDB server running in the target system. Also, set up the Simics network connectivity with the host PC, which is the one that runs ARM DS through TCP protocol. The application to be debugged is listed next myArmDSDebugExample.c. This application determines the core in which this run started and then enters into a loop counting the number of times the loop is executed and continue observing the execution core. It also counts the number of times the application is executed in each one of the four cores. The application exits from the loop when the iterator reaches a limit or the exitVar variable has a value of '1', which normally never should occur. After the loop, the application assigns the value in x variable to the a and b variables and then adds these variables and assigns the result value in c variable. In the end, the application prints the result of the addition, the number of times the loop was iterated and the final value of exitVar, and the number of times each core executed the application.</p> <pre><code>#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\n#define NUM_CORES 4\nunsigned int coreCount[NUM_CORES];\nunsigned long int read_mpidr(void)\n{\nunsigned long int value;\nasm volatile(\"mrs %[result], mpidr_el1\" : [result] \"=r\" (value));\nreturn value;\n}\nunsigned int getCore(){\nstatic unsigned int corePrev = (unsigned int)(-1);\nunsigned long mpidr;\nunsigned int core;\nmpidr = read_mpidr();\ncore = (mpidr &gt;&gt; 8) &amp; 0xFF;    if (core != corePrev)\n{\ncoreCount[core]++; corePrev = core;\n}\nreturn core;\n}\nint main()\n{\nint x = 1000;\nunsigned int core;    unsigned int iter = 0;\nint a;\nint b;\nint c;\nvolatile int exitVar = 0;\ncore = getCore();\nprintf(\"=== My Debug example started on Core %d ===\\n\", core); while((exitVar==0) &amp;&amp; (iter &lt; 1000000000))\n{\ncore = getCore(); iter++;\n}\na = x;\nb = x;\nc = a + b;\nprintf(\"Count:%d  iter: %d  exitVar:%d \\n\", c, iter, exitVar);\nfor (core = 0; core &lt; NUM_CORES; core++)\nprintf(\"  core[%d]: %d times\\r\\n\", core, coreCount[core]);\nreturn 0;\n}\n</code></pre> Setup <ol> <li> <p>Start with the setup as the parent use case. From the Simics CLI or from the uboot-linux_sdcard.simics Simics script, add the network configuration that allows establishing the GDB server connexion between the target system and the host PC. This configuration creates an incoming forwarding port for TCP traffic from a port in the host PC to port 9123 in the target system. The port in the host PC is shown when calling the list-port-forwarding-setup command (port 4001 will be used in this example).</p> <pre><code># uboot-linux_sdcard.simics\n:\nconnect-real-network-port-in 9123 ethernet-link = ethernet_switch0 target-ip = 10.10.0.100 -tcp list-port-forwarding-setup\nrunning&gt;  list-port-forwarding-setup NAPT enabled with gateway 10.10.0.1/24 on link ethernet_switch0.link.\nNAPT enabled with gateway fe80::2220:20ff:fe20:2000/64 on link ethernet_switch0.link.\n\nReal DNS enabled at 10.10.0.1/24 on link ethernet_switch0.link.\nReal DNS enabled at fe80::2220:20ff:fe20:2000/64 on link ethernet_switch0.link.\n\nHost TCP port 4001 \u2192 10.10.0.100:9123\n</code></pre> </li> <li> <p>The Linux example application must be compiled so you can have the executable binary available. This binary is generated with a toolchain and should be built to include debug information (i.e. symbol file). ARM DS does not support the DWARF 5.0 format in the symbols files, so the application must be built with a toolchain that creates this with DWARF 4.0 version. The instructions to build the applications are shown next. This generates the myArmDSDebugExample binary.</p> <pre><code>mkdir SymDbg &amp;&amp; cd SymDbg\nwget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.2-2020.11/binrel/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\nrm gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\n\n./gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc -g -o  myArmDSDebugExample myArmDSDebugExample.c\n</code></pre> </li> </ol> Procedure <ol> <li> <p>Execute parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Take the Linux application binary to the target system filesystem using tftp. For this, you will need to do the following. The myArmDSDebugExample binary should be located in the Simics project directory before calling tftp command.</p> <pre><code>root@dhcp0:~# ethtool -K eth1 tx off tx-checksum-ipv4: off\ntx-checksum-ipv6: off\ntx-tcp-segmentation: off [not requested]\ntx-tcp6-segmentation: off [not requested]\nroot@dhcp0:~# tftp -gr myArmDSDebugExample 10.10.0.1 root@dhcp0:~# chmod +x myArmDSDebugExample </code></pre> </li> <li> <p>Start a GDB Server debug session over the application from the Linux prompt using the port created in the target system during the port forwarding setup:</p> <pre><code>root@dhcp0:~# gdbserver 10.10.0.1:9123 myArmDSDebugExample Process /home/root/myArmDSDebugExample created; pid = 283\nListening on port 9123\n</code></pre> </li> <li> <p>In ARM Development Studio, create a new debug connection following the next steps:</p> <p>a) Create a New Debug Connection to a Linux Application Connection. Press Next.</p> <p> </p> <p>b) Give a name to the Debug connection: DebugLinuxAppSimicsGDB . Press Finish.</p> <p></p> <p>c) Edit the configuration. In the Connection tab, select:</p> <p>- Linux Application Debug \u2192 Application Debug \u2192 Connections via AArch64 gdbserver \u2192 Connect to already running application   - Address: localhost (or host PC IP if want to be accessed from a different PC in the same network)   - Port: 4001   - Select Terminate gdbserver on disconnect</p> <p></p> <p>d) Edit the configuration. In Files tab, select the application binary loaded as symbol file:  </p> <p>e) Edit the configuration. In Debugger tab, select Debug from symbol: main </p> <p></p> <p>Press Debug button to start the debug.</p> </li> <li> <p>The application debug can be performed now. ARM DS shows the source code of the test application stopped at the entry point of the main() function and we observe at the left the Debug Control panel with the options to control the execution of the code:</p> <p></p> <p>Observe that in the target serial console, the gdb server reports that the connection with the host was achieved showing the message: Remote debugging from host 10.10.0.1, port 4097</p> <p>a) Run the code and after a few seconds pause it. Observe that it stops under the while loop (or under the getCore() function which is called under the loop). You can observe the value of the variables using the Variables tab. The iter variable is increased in every iteration in the loop and the current value of exitVar variable is 0. You can also observe that the application is being executed in core 0. The loop will exit whenever the exitVar variable has a value of 1 or the iterator reaches gets greater than 1000000000. At this point, the application already printed the === My Debug example started on Core 0 === message in the serial console. </p> <p></p> <p>b) You can change the value of the exitVar variable from the Value column in the Variables tab, use the step-over button to advance in the execution of the application, and confirm that this condition makes it exit from the loop. You can continue advancing in the code execution and observe that the variables a and b gets initialized with the value of x. Observe that the c variable gets updated with the result of the addition of a and b variables.</p> <p></p> <p>c) Proceed to continue the code execution and observe that the application gets finished printing the results. Also, you can get disconnected from the gdb server session and after this, the serial console shows again the Linux prompt.</p> <p></p> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/","title":"Agilex\u2122 5 Intel Simics Virtual Platform Example User Guide - Zephyr GSRD","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#overview","title":"Overview","text":"<p>Agilex\u2122 5 E-Series devices provide the next generation HPS after those provided with the Agilex\u2122\u00ae 7 and Stratix 10\u00ae SoC FPGA devices. The Agilex\u2122 5 E-Series HPS application processors can run Zephyr RTOS and Linux with scalable performance using from one to four Arm Cortex -A cores that allow for a wide range of applications. The Agilex\u2122 5 E-Series Simics virtual platform models the HPS processor with two Arm Cortex-A55 cores and two Arm Cortex-A76 cores along with the hard processor system (HPS) peripherals. The Agilex\u2122 5 E-Series HPS virtual platform is released as part of the Simics\u00ae Simulator for Agilex\u2122 FPGAs software, which also includes several virtual platforms where the Agilex\u2122 5 E-Series device is instantiated, emulating the concept of having different versions of a development kit or daughter cards. The Agilex\u2122 5 E-Series has the following supported virtual platforms:</p> <ul> <li>Agilex\u2122 5 E-Series Virtual Platform - Universal</li> </ul> <p>The following sections describe the prerequisites for the Simics simulator for Altera FPGA and the available virtual platforms including prebuilt Zephyr binaries. Instructions about how to build these binaries and run the Software stack are provided as well. Additionally, some common use cases that you can exercise with this Zephyr release are discussed.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#prerequisites","title":"Prerequisites","text":"<p>To exercise the instructions presented on this page, the following prerequisites need to be satisfied:</p> <ul> <li>Host PC with Linux. The instructions on this page use Ubuntu 20.04 LTS.  </li> <li>The following package versions are needed to build Zephyr binaries:<ul> <li>cmake - 3.20.5</li> <li>python3 - 3.8</li> <li>dtc - 1.4.6</li> </ul> </li> <li>The following packages are needed to be able to deploy the Simics project: GCC 6.3 compiler or higher, g++ 9.4 or higher, GNU make 4.1 or higher.</li> <li>Agilex\u2122 5 Simics Virtual Platform components are available to be deployed.</li> <li>Quartus\u00ae Prime Pro Edition Programmer and Tools 23.4 or later.</li> </ul> <p>Note: For installation instructions for the Simics Simulator for Altera\u00ae FPGAs and the Agilex\u2122 5 E-Series virtual platforms, refer to the following documents:</p> <ul> <li>Intel\u00ae Simics\u00ae Simulator for Intel\u00ae FPGAs User Guide</li> <li>Agilex\u2122 5 E-Series Virtual Platform User Guide</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#source-code","title":"Source Code","text":"SW Component Repository Branch/tag ATF https://github.com/altera-opensource/arm-trusted-firmware/ socfpga_v2.9.1/QPDS23.4_REL_GSRD_PR Zephyr https://github.com/altera-opensource/zephyr-socfpga/ socfpga_rel_23.4/QPDS23.4_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>Prebuilt binaries can be found at the following URL: https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/. The prebuilt binaries consist of application programs built to run on the MPU cores in multicore configuration. There are binary files designed for boot devices such as SD cards, NAND flash, and QSPI. Additionally, files used by the recipes to create the binaries to boot from QSPI and NAND are provided in their respective folders. The sample applications provided are:</p> Directory Application Description cli Application to demonstrate Command Line Interface hello_world Application that displays a Hello World! message <p>Within each application directory, you'll find the following files: </p> <pre><code>&lt;application directory&gt; \n    \u251c\u2500\u2500 bl31.bin \n    \u251c\u2500\u2500 bl31.elf \n    \u251c\u2500\u2500 fip.bin \n    \u251c\u2500\u2500 fiptool \n    \u251c\u2500\u2500 nand_boot \n    \u2502   \u251c\u2500\u2500 0001-plat-intel-soc-agilex5-enable-NAND-boot.patch \n    \u2502   \u251c\u2500\u2500 bl2.bin \n    \u2502   \u251c\u2500\u2500 bl2.elf \n    \u2502   \u2514\u2500\u2500 nand_mem.img \n    \u251c\u2500\u2500 qspi_boot\n    \u2502   \u251c\u2500\u2500 0001-plat-intel-soc-agilex5-enable-QSPI-boot.patch\n    \u2502   \u251c\u2500\u2500 agilex5_factory.sof\n    \u2502   \u251c\u2500\u2500 bl2.bin\n    \u2502   \u251c\u2500\u2500 bl2.elf\n    \u2502   \u251c\u2500\u2500 flash_image_jic.rpd\n    \u2502   \u2514\u2500\u2500 qspi_flash_image_agilex5_boot.pfg\n    \u251c\u2500\u2500 sdmmc_boot\n    \u2502   \u251c\u2500\u2500 bl2.bin\n    \u2502   \u251c\u2500\u2500 bl2.elf\n    \u2502   \u251c\u2500\u2500 make_sdimage.sh\n    \u2502   \u2514\u2500\u2500 sdimage.img\n    \u251c\u2500\u2500 usb-msd.craff\n    \u251c\u2500\u2500 zephyr.bin\n    \u251c\u2500\u2500 zephyr.dts\n    \u251c\u2500\u2500 zephyr.elf\n    \u251c\u2500\u2500 zephyr.lst\n    \u251c\u2500\u2500 zephyr.map\n    \u2514\u2500\u2500 zephyr.stat\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#embedded-software-peripheral-zephyr-drivers-availability","title":"Embedded Software Peripheral Zephyr Drivers Availability","text":"HPS Peripheral Supported SD Card driver Yes GPIO Driver Yes I2C Driver Yes UART Driver Yes Timer Driver Yes WatchDog Driver Yes SMP Driver Yes QSPI Driver Yes NAND Driver Yes SDRAM Driver Yes Ethernet Driver Yes SPI Driver Yes SDM Mailbox Driver Yes USB 2.0 Driver Yes HPS DMA Driver Yes I3C driver Yes EDAC/RAS drivers Yes"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#boot-flow","title":"Boot Flow","text":"<p>Starting with this release the Arm Trusted Firmware will act as the FSBL and SSBL bootloader for  Zephyr as described in the following diagram: </p> <p> </p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#agilextm-5-simics-virtual-platform","title":"Agilex\u2122 5 Simics Virtual Platform","text":"<p>This virtual platform is associated with the agilex5e-universal.simics target script. The following figure shows a high-level block diagram of this virtual platform. In this diagram, we can observe the main components that can be exercised during the execution of the use cases described later on this page. The implementation of this virtual platform allows all the peripherals in the HPS to be enabled at the same time, which is not possible in physical hardware implementations. The pinmux and Combo PHY impose restrictions in physical hardware. In the case of the pinmux in physical hardware, only a subset of peripherals can be enabled at the same time because there are not enough pins if all pins are enabled simultaneously. This limitation does not exist in the Agilex 5 E-Series Universal Virtual Platform. For the Combo PHY, the physical hardware allows only one flash controller (NAND or SDMMC) to be enabled at one time. However, the virtual platform allows both to be enabled simultaneously. </p> <p> </p> <p>The architecture of the virtual platform follows a hierarchy that goes from system -&gt; board -&gt; fpga -&gt; hps, which is aligned with the Agilex\u2122 5 Simics virtual platform development philosophy that tries to match with the real hardware system architecture.</p> <p>The target script instantiates the system component, provides the CLI run time commands and creates the network configuration. This script also defines the parameters that configure other components.</p> <p>The system component represents the complete system of the virtual platform and instantiates the board component. This component is implemented in a Python file.</p> <p>The board component represents the model of a PCB (analogous to a development kit). It includes the instance of the FPGA component and all board components connected to the FPGA (for example, flash device, ethernet PHY). The GPIO loopback connection is implemented here. This component is implemented in a Python file.</p> <p>The FPGA component represents a model of the top-level FPGA design. The hierarchy matches the logical hierarchy of a hypothetical GHRD that the virtual platform models. This instantiates the HPS, the external memory interface IP, and the FPGA example design.</p> <p>The embedded software running in this virtual platform is expected to be the same that could be run in the real silicon. Additionally, the ability to exercise the HPS embedded software in this virtual platform allows you to debug the software using the Simics\u00ae Simulator debug capabilities.</p> <p>For more details about Intel Simics\u00ae Simulator please refer to: Linux Simics GSRD</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#key-points-for-zephyr","title":"Key points for Zephyr","text":"<p>The Zephyr GSRD requires a top-level target script that wraps the agilex5e-universal.simics and execute Simics commands to run Zephyr.  The example of the file contents is shown below:</p> <pre><code>#Universal Zephyr simics Script. \nlocal $board_name = \"system.board.fpga\" \n\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\n# Ensure the sdimage.img &amp; bl2.bin paths are relative to the simics executable#\n\n# Enable Console\n$create_hps_serial0_console=TRUE\n\n# Boot from SD Card\n$create_hps_sd_card=TRUE\n$create_hps_mmc=FALSE\n\n# SD Card boot Image file path\n$sd_image_filename = ../bin/sdimage.img\n\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\n\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"  \n\nrun\n</code></pre> <p>In this script, the most relevant parameters to run Zephyr  are the following:</p> Parameter Description Range Default Value $sd_image_filename Sdcard image path Filename string \"\" $fsbl_image_filename Fsbl image path Filename string \"\""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#using-prebuilt-binaries","title":"Using Prebuilt Binaries","text":"<p>The Zephyr GSRD requires a top-level target script that wraps the agilex5e-universal.simics and execute Simics commands to run Zephyr. The example of the file contents is shown below:</p> <pre><code>#Universal Zephyr simics Script. \nlocal $board_name = \"system.board.fpga\" \n\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\n# Ensure the sdimage.img &amp; bl2.bin paths are relative to the simics executable#\n\n# Enable Console\n$create_hps_serial0_console=TRUE\n\n# Boot from SD Card\n$create_hps_sd_card=TRUE\n$create_hps_mmc=FALSE\n\n# SD Card boot Image file path\n$sd_image_filename = ../bin/sdimage.img\n\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\n\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"  \n\nrun\n</code></pre> <p>In this script, the most relevant parameters to run Zephyr  are the following:</p> Parameter Description Range Default Value $sd_image_filename Sdcard image path Filename string \"\" $fsbl_image_filename Fsbl image path Filename string \"\""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#using-prebuilt-binaries_1","title":"Using Prebuilt Binaries","text":"<p>This section is a guide for you to run the prebuilt sample Zephyr applications.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#setting-up-to-use-prebuilt-binaries","title":"Setting Up to Use Prebuilt Binaries","text":"<p>You will need both the boot image as well the firmware(ATF) binaries. The links below go directly to the directory with binaries corresponding to the application and boot device:</p> <ul> <li>Hello World:<ol> <li>SD Card</li> <li>NAND Flash</li> <li>QSPI Flash</li> </ol> </li> </ul> <ul> <li>CLI:<ol> <li>SD Card </li> <li>NAND Flash</li> <li>QSPI Flash</li> </ol> </li> </ul> <p>The following are the helper instructions to download the prebuilt binaries according to the application and boot device:</p> <ol> <li> <p>This step assumes you have not created the folders as mentioned in Build Instructions or that you want to start afresh. It will remove any prior work! Skip to the next step to retain prior work. Create the !ZephyrGSRD directory. <pre><code>rm -rf agilex5_zgsrd\nmkdir agilex5_zgsrd\ncd agilex5_zgsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre></p> </li> <li> <p>Create a folder to contain the prebuilt binaries. <pre><code>cd $TOP_FOLDER mkdir prebuilt\n</code></pre></p> </li> <li> <p>Specify sample application and boot device</p> <ul> <li>App Application Environment Variable Hello World export app=hello_world CLI export app=cli </li> </ul> <ul> <li>Boot Device Boot Device Environment Variable SDMMC export bootdev=sdmmc_boot bootimg=sdimage.img NAND export bootdev=nand_boot bootimg=nand_mem.img QSPI export bootdev=qspi_boot bootimg=flash_image_jic.rpd </li> </ul> </li> <li> <p>Wget the prebuilt binaries into the prebuilt folder.</p> </li> </ol> <pre><code>cd $TOP_FOLDER/prebuilt\nwget -N https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/$app/$bootdev/$bootimg -P $app/$bootdev/ wget -N https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/$app/$bootdev/bl2.bin -P $app/$bootdev/\n</code></pre> <p>The prebuilt samples for Agilex\u2122 5 would have the following structure:    * prebuilt/hello_world    * prebuilt/cli</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#organizing-the-prebuilt-binaries","title":"Organizing the Prebuilt Binaries","text":"<p>If you've downloaded the prebuilt binaries manually, please place them in the following structure, then refer below to the step \"To boot on Simics\"...</p> <pre><code>agilex5_zgsrd\n\u2514\u2500\u2500 bin\n    \u2502   \u251c\u2500\u2500 atf\n    \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 bl2.bin\n    \u2514\u2500\u2500 sdimage.img OR nand_mem.img OR flash_image_jic.rpd \n</code></pre> <p>If you've followed the helper steps above, follow the next instructions:</p> <ol> <li>Prepare the binaries to run on Simics\u00ae Simulator.</li> </ol> <p><pre><code>cd $TOP_FOLDER rm -rf bin mkdir -p bin/atf ln -s $TOP_FOLDER/prebuilt/$app/$bootdev/$bootimg bin/ ln -s $TOP_FOLDER/prebuilt/$app/$bootdev/bl2.bin bin/atf/bl2.bin\n</code></pre> 2. For the first time run, set up the Agilex\u2122 5 virtual platform. Refer to Simulation Setup.</p> <ul> <li>To boot on Simics, based on the boot device refer to the corresponding sections :  Booting from SD Card Image binaries,  Booting from NAND binaries and Booting from QSPI binaries.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#build-instructions","title":"Build Instructions","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#setting-up-environment","title":"Setting up Environment","text":"<ul> <li>Update your system</li> </ul> <pre><code>sudo apt-get update\nsudo apt-get upgrade\n</code></pre> <ul> <li>Install all the required dependencies:</li> </ul> <pre><code>sudo apt-get install --no-install-recommends git cmake ninja-build gperf ccache dfu-util device-tree-compiler wget python3-dev python3-pip python3-setuptools python3-tk python3-wheel python3-venv xz-utils file libpython3-dev make gcc gcc-multilib g++-multilib libsdl2-dev libmagic1 libguestfs-tools  libssl-dev\n</code></pre> Package Zephyr Requirement Ubuntu 20.04 (default versions) command cmake 3.20.5 3.16.3 (below required) cmake --version python 3.8 3.8.10 python3 --version dtc 1.4.6 1.5.0 dtc --version <ul> <li>As a minimum CMake version 3.20.0 is required, if you have an older version, then execute the following commands to add a non-intrusive CMake binary:</li> </ul> <pre><code>CURR_FOLDER=$PWD\nmkdir -p $HOME/bin/cmake &amp;&amp; cd $HOME/bin/cmake\nwget https://github.com/Kitware/CMake/releases/download/v3.21.1/cmake-3.21.1-Linux-x86_64.sh\nyes | sh cmake-3.21.1-Linux-x86_64.sh | cat\necho \"export PATH=$PWD/cmake-3.21.1-linux-x86_64/bin:\\$PATH\" &gt;&gt; $HOME/.zephyrrc\ncd $CURR_FOLDER\n</code></pre> <ul> <li>Load the profile that was created to use the newer CMake (this should be done for every session when Building Zephyr:</li> </ul> <pre><code>source  $HOME/.zephyrrc\n</code></pre> <ul> <li>Create the ZephyrGSRD directories:</li> </ul> <pre><code>rm -rf agilex5_zgsrd\nmkdir agilex5_zgsrd\ncd agilex5_zgsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<ul> <li>Download the compiler toolchain. Define environment variables and append the toolchain path in the environment PATH variable. so the toolchain can be used to build the binaries:</li> </ul> <p><pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.3.rel1/binrel/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu/bin:$PATH\necho \"export PATH=`pwd`/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu/bin:\\$PATH\" &gt;&gt; $TOP_FOLDER/.zephyrrc\n</code></pre> - Clone the ATF repository from GitHub and build it</p> <pre><code>git clone -b QPDS23.4_REL_GSRD_PR  https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\ngit switch -c test\nmake realclean\nARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- make PLAT=agilex5 bl2 bl31 PRELOADED_BL33_BASE=0x80100000 -j$(nproc) </code></pre> <ul> <li>Build Fiptool to be able to create the sdimage in later steps.</li> </ul> <pre><code>make fiptool\ncp tools/fiptool/fiptool $TOP_FOLDER\ncd $TOP_FOLDER\n</code></pre> <p>The previous instructions will produce (in the $TOP_FOLDER/arm-trusted-firmware directory): - build/agilex5/release/bl2.bin - build/agilex5/release/bl31.bin - tools/fiptool/fiptool</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#zephyr-build-environment-setup","title":"Zephyr Build Environment Setup","text":"<ul> <li>Create a new virtual environment and activate it</li> </ul> <pre><code>python3 -m venv ~/.zephyrproject/.venv\n#Environment Activation\nsource ~/.zephyrproject/.venv/bin/activate\n</code></pre> <ul> <li>Install west, pull the official Zephyr repository and other Zephyr dependencies:</li> </ul> <pre><code>pip3 install wheel\npip3 install west\nwest init -m https://github.com/zephyrproject-rtos/zephyr --mr v3.4-branch zephyrproject\ncd $TOP_FOLDER/zephyrproject\nwest update\nwest zephyr-export\npip install -r $TOP_FOLDER/zephyrproject/zephyr/scripts/requirements.txt\n</code></pre> <p>Note: If you get a similar error like: <pre><code>ERROR: sphinx-tabs 3.4.1 has requirement docutils~=0.18.0, but you'll have docutils 0.19 which is incompatible.\nERROR: sphinx-rtd-theme 1.2.2 has requirement docutils&lt;0.19, but you'll have docutils 0.19 which is incompatible\n</code></pre></p> <p>Run: <pre><code>pip install sphinx-rtd-theme sphinx\n</code></pre></p> <ul> <li>Install Zephyr SDK in home folder so it can be used on many Zephyr projects:</li> </ul> <pre><code>wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.4/zephyr-sdk-0.16.4_linux-x86_64.tar.xz\nwget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.4/sha256.sum | shasum --check --ignore-missing\nwget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.1/zephyr-sdk-0.16.1_linux-x86_64.tar.xz\nwget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.1/sha256.sum | shasum --check --ignore-missing tar xf zephyr-sdk*.tar.xz -C ~/\nrm zephyr-sdk*.tar.xz\n$HOME/zephyr-sdk*/setup.sh -t aarch64-zephyr-elf -h -c\n</code></pre> <ul> <li>Substitute the official \"Zephyr\" folder for zephyr-socfpga repository:</li> </ul> <pre><code>cd $TOP_FOLDER/zephyrproject\nrm -rf zephyr git clone -b QPDS23.4_REL_GSRD_PR --single-branch https://github.com/altera-opensource/zephyr-socfpga zephyr\nwest update\nwest zephyr-export\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#building-zephyr-application","title":"Building Zephyr Application","text":"<p>Every Zephyr application is composed of several configurable key components that work together in the same executable:</p> <ul> <li>Zephyr Kernel: Manages system resources and task scheduling.</li> <li>Device Drivers: Enable interaction with hardware peripherals.</li> <li>Libraries: Provide additional functionality and utilities.</li> <li>Application Code: Written in C to define application behavior</li> </ul> <p>The following Zephyr sample applications are available to test:</p> <ul> <li>HelloWorld: samples/hello_world/</li> <li>GPIO: samples/basic/blinky/</li> <li>I2C: samples/drivers/i2c_fujitsu_fram/</li> <li>Timer/Counter: samples/drivers/counter/alarm/</li> <li>Watchdog: samples/drivers/watchdog/</li> <li>SD: samples/subsys/fs/fat_fs/</li> <li>UART: samples/drivers/uart/echo_bot/</li> <li>Ethernet: samples/net/sockets/echo_client and samples/net/sockets/ echo_server</li> <li>NAND: samples/drivers/soc_flash_nand/</li> <li>SPI: samples/drivers/jesd216/</li> <li>QSPI : samples/drivers/soc_flash_qspi/</li> <li>SDM Mailbox: sample/subsys/sip_svc/</li> <li>USB 2.0 Host: samples/subsys/fs/fat_fs/</li> <li>HPS DMA: samples/drivers/dma/mem_to_mem/</li> <li>I3C: samples/drivers/i3c_sample_app_simics/</li> </ul> <p>In this regard, we will focus on building the \"Hello World\" sample that will allow us to test our development environment and run it in Simics\u00ae Simulator.</p> <ul> <li>Build the \"Hello World\" Zephyr application binary and place the built outputs in an \"agilex5\" directory in the current active directory.</li> </ul> <pre><code>cd $TOP_FOLDER/zephyrproject/zephyr\nwest build -b intel_socfpga_agilex5_socdk samples/hello_world -d agilex5\n</code></pre> <p>Successful build console output should be similar to the following:</p> <pre><code>Zephyr version: 3.4.0 (/home/msangele/Artifacts/zephyr_samples/agilex5_zgsrd/zephyrproject/zephyr), build: f1571bf6e7e2\n[134/144] Linking C executable zephyr/zephyr_pre0.elf\n\n[138/144] Linking C executable zephyr/zephyr_pre1.elf\n\n[144/144] Linking C executable zephyr/zephyr.elf\nMemory region         Used Size  Region Size  %age Used\n           FLASH:          0 GB         0 GB\n             RAM:      134048 B         8 MB      1.60%\n        IDT_LIST:          0 GB         2 KB      0.00%\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#organizing-the-build-from-source-binaries","title":"Organizing the Build-From-Source Binaries","text":"<ul> <li>Create a folder to contain the ATF firmware and Zephyr RTOS binaries for creating boot source image, and create symlinks to the actual location. (Whenever you are switching from using prebuilt to build-from-source binaries, this step has to be performed)</li> </ul> <pre><code>cd $TOP_FOLDER\n# First, remove any obsolete bin folder(optional)\nrm -rf bin\nmkdir bin\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/ bin/atf\nln -s $TOP_FOLDER/zephyrproject/zephyr/agilex5/zephyr/  bin/zephyr\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#creating-boot-images","title":"Creating Boot Images","text":"<p>Three types of boot devices are supported:</p> <ol> <li>SD Card</li> <li>NAND Flash</li> <li>QSPI Flash</li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#sd-card-image-binaries","title":"SD Card Image binaries","text":"<ul> <li>Create FIP(Firmware Image Package) binary. This will pack the Zephyr binary and ATF BL31 binary into one single binary called FIP binary.</li> </ul> <pre><code>./fiptool create --soc-fw $TOP_FOLDER/bin/atf/bl31.bin  --nt-fw $TOP_FOLDER/bin/zephyr/zephyr.bin bin/fip.bin\n</code></pre> <p>To build the \"SDCard Image\" for simics use the following commands:</p> <ul> <li>Obtain the make_sdimage.sh script.</li> </ul> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/sdmmc_boot/make_sdimage.sh\nchmod +x make_sdimage.sh\n</code></pre> <ul> <li>Create the sdimage.img</li> </ul> <pre><code>touch dummy.tar.gz\nsudo ./make_sdimage.sh -k dummy.tar.gz -p bin/fip.bin -o bin/sdimage.img -g 2G -pg 16\n</code></pre> <p>To deactivate the environment when development is done execute:</p> <pre><code>deactivate\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#resulted-files","title":"Resulted Files","text":"<p>After the build is completed successfully the most relevant files are:</p> File Description bl2.bin The FSBL that Simics will launch first bl31.bin The ATF BL31 (similar to legacy SSBL stage) zephyr.bin Zephyr Application/Kernel fip.bin Firmware Image Package sdimage.img Application image <p>If you have not set up Simics Virtual Platform for Agilex\u2122 5, go to Simulation Setup.  For booting on Simics Virtual Platform for Agilex 5, refer Booting from SD Card Image binaries</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#nand-binaries","title":"NAND binaries","text":"<p>To build the \"NAND Image\" for simics use the following commands:</p> <ul> <li>Patch the Arm Trusted Firmware source code to enable nand boot:</li> </ul> <pre><code>cd $TOP_FOLDER/arm-trusted-firmware\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/nand_boot/0001-plat-intel-soc-agilex5-enable-NAND-boot.patch\n</code></pre> <ul> <li>Create alocal branch for nand boot, apply the patch and rebuild ATF:</li> </ul> <pre><code>git branch nand\ngit checkout nand\ngit apply 0001-plat-intel-soc-agilex5-enable-NAND-boot.patch\ngit commit -a -m \"nandboot\"\nARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- make PLAT=agilex5 bl2 bl31 PRELOADED_BL33_BASE=0x80100000 -j$(nproc)\n</code></pre> <ul> <li>Rebuild fip.bin</li> </ul> <pre><code>cd $TOP_FOLDER\n./fiptool create --soc-fw $TOP_FOLDER/bin/atf/bl31.bin  --nt-fw $TOP_FOLDER/bin/zephyr/zephyr.bin bin/fip.bin\n</code></pre> <ul> <li>Create the nand_mem.img image and write the fip.bin within:</li> </ul> <pre><code>dd if=/dev/zero count=8 bs=16MB | tr '\\0' '\\377' &gt; $TOP_FOLDER/bin/nand_mem.img dd if=bin/fip.bin of=bin/nand_mem.img conv=notrunc bs=1 seek=2097152\n</code></pre> <p>To deactivate the environment when development is done and return to the main branch execute:</p> <pre><code>deactivate\ngit checkout test\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#resulted-files_1","title":"Resulted Files","text":"<p>After the build is completed successfully the most relevant files are:</p> File Description bl2.bin The FSBL that Simics will launch first bl31.bin The ATF BL31 (similar to legacy SSBL stage) zephyr.bin Zephyr Application/Kernel fip.bin Firmware Image Package nand_mem.img NAND Application image <p>If you have not set up Simics Virtual Platform for Agilex 5, go to Simulation Setup.  For booting on Simics Virtual Platform for Agilex 5, refer Booting from NAND binaries</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#qspi-binaries","title":"QSPI binaries","text":"<p>To build the \"QSPI Image\" for simics use the following commands:</p> <ul> <li>Patch the Arm Trusted Firmware source code to enable qspi boot:</li> </ul> <pre><code>cd $TOP_FOLDER/arm-trusted-firmware\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/qspi_boot/0001-plat-intel-soc-agilex5-enable-QSPI-boot.patch\n</code></pre> <ul> <li>Create a local branch for qspi boot, apply the patch and rebuild ATF:</li> </ul> <pre><code>cd $TOP_FOLDER/arm-trusted-firmware\ngit branch qspi\ngit checkout qspi\ngit apply 0001-plat-intel-soc-agilex5-enable-QSPI-boot.patch\ngit commit -a -m \"qspiboot\"\nARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- make PLAT=agilex5 bl2 bl31 PRELOADED_BL33_BASE=0x80100000 -j$(nproc)\n</code></pre> <ul> <li>Rebuild fip.bin</li> </ul> <pre><code>cd $TOP_FOLDER\n./fiptool create --soc-fw $TOP_FOLDER/bin/atf/bl31.bin  --nt-fw $TOP_FOLDER/bin/zephyr/zephyr.bin bin/fip.bin\n</code></pre> <ul> <li>Create pfg file: <pre><code>tee qspi_flash_image_agilex5_boot.pfg  &lt;&lt; 'EOF'\n&lt;pfg version=\"1\"&gt;\n  &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n  &lt;output_files&gt;\n      &lt;output_file name=\"flash_image\" directory=\".\" type=\"JIC\"&gt;\n          &lt;file_options/&gt;\n          &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n              &lt;file_options/&gt;\n          &lt;/secondary_file&gt;\n          &lt;secondary_file type=\"SEC_RPD\" name=\"flash_image_jic\"&gt;\n              &lt;file_options bitswap=\"1\"/&gt;\n          &lt;/secondary_file&gt;\n          &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n      &lt;/output_file&gt;\n  &lt;/output_files&gt;\n  &lt;bitstreams&gt;\n      &lt;bitstream id=\"Bitstream_1\"&gt;\n          &lt;path hps_path=\"bin/atf/bl2.hex\"&gt;bin/agilex5_factory.sof&lt;/path&gt;\n      &lt;/bitstream&gt;\n  &lt;/bitstreams&gt;\n  &lt;raw_files&gt;\n      &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;bin/fip.bin&lt;/raw_file&gt;\n  &lt;/raw_files&gt;\n  &lt;flash_devices&gt;\n      &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n          &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03C00000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"fip\" size=\"0\"/&gt;\n      &lt;/flash_device&gt;\n      &lt;flash_loader&gt;AGFB014R24B2E2V&lt;/flash_loader&gt;\n  &lt;/flash_devices&gt;\n  &lt;assignments&gt;\n      &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n          &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n      &lt;/assignment&gt;\n      &lt;assignment page=\"0\" partition_id=\"fip\"&gt;\n          &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n      &lt;/assignment&gt;\n  &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n</code></pre></li> </ul> <ul> <li>Create bl2.hex from bl2.bin</li> </ul> <pre><code>aarch64-none-linux-gnu-objcopy -v -I binary -O ihex --change-addresses 0xffe00000 bin/atf/bl2.bin  bin/atf/bl2.hex\n</code></pre> <ul> <li>Create flash_image_jic.rpd qspi image from fip.bin and *bl2.hex:</li> </ul> <pre><code>wget  https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/qspi_boot/agilex5_factory.sof -O bin/agilex5_factory.sof\n# The next command assumes Quartus\u00ae Prime Pro Edition Programmer and Tools is installed in the path ~/intelFPGA_pro/ (tested version: 23.4)\n~/intelFPGA_pro/23.4/qprogrammer/quartus/bin/quartus_pfg -c qspi_flash_image_agilex5_boot.pfg\nmv flash* bin\n</code></pre> <p>To deactivate the environment when development is done and return to the main branch execute:</p> <pre><code>deactivate\ngit checkout test\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#resulted-files_2","title":"Resulted Files","text":"<p>After the build is completed successfully the most relevant files are:</p> File Description bl2.bin The FSBL that Simics will launch first bl2.hex The FSBL in hex format bl31.bin The ATF BL31 (similar to legacy SSBL stage) zephyr.bin Zephyr Application/Kernel fip.bin Firmware Image Package flash_image_jic.rpd QSPI Application image <p>If you have not set up Simics Virtual Platform for Agilex 5, go to Simulation Setup. </p> <p>For booting on Simics Virtual Platform for Agilex 5, refer Booting from QSPI binaries</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#simulation-setup","title":"Simulation Setup","text":"<p>We assume that the Simics\u00ae Simulator for Intel\u00ae FPGAs Simulator has been installed in a Linux System.</p> <ul> <li>Lets add the Simics binary to the path to make things easier:</li> </ul> <p><pre><code>export PATH=$PATH:SIMICS_INSTALLATION/simics/bin/\n</code></pre> note: default path is \"~/intelFPGA_pro/intel-fpga-ext_23.4/simics/bin\"</p> <ul> <li>Create a Simics project directory under ZephyrGSRD directory:</li> </ul> <pre><code>cd $TOP_FOLDER\nrm -r project-1\nmkdir project-1\ncd project-1\n</code></pre> <p>Under the new project directory created, deploy the agilex5e-universal virtual platform:</p> <pre><code>simics_intelfpga_cli --deploy agilex5e-universal\n</code></pre> <p>The above will produce the following: <pre><code>Simics(R) Simulator for Intel(R) FPGA CLI:\nINFO: Preparing to initialize /home/simicsUser/SimicsInstallDir/project-1 as a\nSimics workspace\nProject created successfully\n# Observe that the directory has been initialized and the simics and simics-gui\n# commands appears in the project directory. Also the target directory is\n# created. This includes the target script corresponding to the deployed\n# platform.\n</code></pre></p> <ul> <li>Build the virtual platform components:</li> </ul> <pre><code>make\n</code></pre> <p>Example of console output:</p> <pre><code>=== Environment Check ===\n'/home/simicsUser/SimicsInstallDir/project-1' is up-to date\ngcc version 9\n=== Building module agilex5e-universal-board-comp ===\n.\n:\n=== Building module agilex5e-universal-fpga-comp ===\n.\n:\n=== Building module agilex5e-universal-system-comp ===\n.\n:\n</code></pre> <p>Note: You only have to setup the Agilex 5 Virtual Platform once (or until it has been remove)</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#booting-on-simics-virtual-platform-for-agilex-5","title":"Booting On Simics Virtual Platform for Agilex 5","text":"<p>We assume that the following binaries are already available (either from the Prebuilt Binaries package or built from the steps in Build Instructions) :    * bl2.bin    * bl31.bin    * zephyr.bin    * sdimage.img /nand_mem.img / flash_image_jic.rpd</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#booting-from-sd-card-image-binaries","title":"Booting from SD Card Image binaries","text":"<ul> <li> <p>Zephyr's SMP support allow us to select the boot core within simics. Select the boot core as follows:</p> Core Selection Env-variable A55 export cputype=a55 A76 export cputype=a76 </li> </ul> <ul> <li>You will need a Simics script named zephyr.simics with the contents detailed in Key points for Zephyr. Run the following to create the script:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\ncputypestring=\"\"\nif [ $cputype = \"a76\" ]; then\ncputypestring='$hps_boot_core = 2 \n$hps_core0_1_power_on = TRUE \n$hps_core2_power_on = TRUE \n$hps_core3_power_on = TRUE'\nfi;\ntee zephyr.simics &lt;&lt; 'EOF'\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\nlocal $board_name = \"system.board.fpga\"\n# Ensure the sdimage.img &amp; bl2.bin paths are relative to the simics executable#\n# Enable Console\n$create_hps_serial0_console=TRUE\n# Boot from SD Card\n$create_hps_sd_card=TRUE\n$create_hps_mmc=FALSE\n# SD Card boot Image file path\n$sd_image_filename = ../bin/sdimage.img\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\nEOF\necho \"$cputypestring\" &gt;&gt; zephyr.simics echo 'run-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\nrun' &gt;&gt; zephyr.simics </code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#booting-from-nand-binaries","title":"Booting from NAND binaries","text":"<ul> <li> <p>Zephyr's SMP support allow us to select the boot core within simics. Select the boot core by as follows:</p> Core Selection Env-variable A55 export cputype=a55 A76 export cputype=a76 </li> </ul> <ul> <li>You will need a Simics script modified for NAND named zephyr.simics. This will take Key points for Zephyr as base. Run the following to create the script:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\ncputypestring=\"\"\nif [ $cputype = \"a76\" ]; then\ncputypestring='$hps_boot_core = 2 \n$hps_core0_1_power_on = TRUE \n$hps_core2_power_on = TRUE \n$hps_core3_power_on = TRUE '\nfi;\ntee zephyr.simics &lt;&lt; 'EOF'\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\nlocal $board_name = \"system.board.fpga\"\n# Ensure the nand_mem.img &amp; bl2.bin paths are relative to the simics executable\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\n#Boot from NAND\n$nand_data_image_filename = ../bin/nand_mem.img \n# Enable Console\n$create_hps_serial0_console=TRUE\nEOF\necho \"$cputypestring\" &gt;&gt; zephyr.simics echo 'run-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\nrun' &gt;&gt; zephyr.simics </code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#booting-from-qspi-binaries","title":"Booting from QSPI binaries","text":"<ul> <li> <p>Zephyr's SMP support allow us to select the boot core within simics. Select the boot core as follows:</p> Core Selection Env-variable A55 export cputype=a55 A76 export cputype=a76 </li> </ul> <ul> <li>You will need a Simics script modified for QSPI named zephyr.simics. This will take Key points for Zephyr as base. Run the following to create the script:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\ncputypestring=\"\"\nif [ $cputype = \"a76\" ]; then\ncputypestring='$hps_boot_core = 2 \n$hps_core0_1_power_on = TRUE \n$hps_core2_power_on = TRUE \n$hps_core3_power_on = TRUE '\nfi;\ntee zephyr.simics &lt;&lt; 'EOF'\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\nlocal $board_name = \"system.board.fpga\"\n# Ensure the nand_mem.img &amp; bl2.bin paths are relative to the simics executable\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\n#Boot from QSPI\n$qspi_image_filename = ../bin/flash_image_jic.rpd  \n# Enable Console\n$create_hps_serial0_console=TRUE \nEOF\necho \"$cputypestring\" &gt;&gt; zephyr.simics echo 'run-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\nrun' &gt;&gt; zephyr.simics </code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#running-hello-world","title":"Running Hello World!","text":"<p>To exercise this use case, follow the next steps once the Simulation setup has been completed:</p> <ul> <li>From the project directory, launch the simulation using the zephyr.simics target script. This will launch the simulator and the current terminal will become the Simics CLI:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\n./simics zephyr.simics\n</code></pre> <ol> <li>Wait to get \"Hello World!\" message in the target serial console.</li> </ol> <pre><code># Target Serial console&lt;/b&gt;\nNOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):f0d41e37d\nNOTICE:  BL2: Built : 08:55:04, Nov 17 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):f0d41e37d\nNOTICE:  BL31: Built : 08:55:08, Nov 17 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x0) is up\nSecondary CPU core 2 (MPID:0x100) is up\nSecondary CPU core 3 (MPID:0x300) is up\nHello World! intel_socfpga_agilex5_socdk\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#use-cases","title":"Use Cases","text":"<p>The following sections provide instructions on how to exercise some supported use cases through cli using the Intel Agilex\u00ae 5 E-Series Universal virtual platform. The compatible sample for Agilex\u2122 5 can be found at:</p> <ul> <li>{zephyrfolder}/samples/boards/intel_socfpga/cli</li> </ul> <p>The preconditions required to execute them are listed in the following section. To use the application built following the Build Instructions, jump to Simulation_Setup.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#running-zephyr-command-line-application","title":"Running Zephyr Command Line Application","text":"<p>To demonstrate the use of some Zephyr peripherals/zephyr subsystems it supports commands like:</p> <ul> <li>device: Device commands</li> <li>flash: Flash shell commands</li> <li>fs: File system commands</li> <li>gpio: GPIO commands</li> <li>i2c: I2C commands</li> <li>io96b: IO96B information</li> <li>mailbox: Altera SoC FPGA SDM mailbox client commands</li> <li>mdio: MDIO commands</li> <li>net: Networking commands</li> <li>psci: ARM PSCI interface commands</li> <li>sip_svc: ARM SiP services commands</li> <li>spi: spi commands</li> <li>timer: Timer commands</li> <li>i3c: I3C commands</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#cli-application-prebuilt-binaries","title":"CLI application - Prebuilt binaries","text":"<p>Note: The following steps assume you have followed the instructions in Setting Up to Use Prebuilt Binaries</p> <ul> <li>Select the sample based on app and boot device (e.g. nand):</li> </ul> <pre><code>export app=cli\nexport bootdev=sdmmc_boot bootimg=sdimage.img\n</code></pre> <ul> <li>Obtain the prebuilt binaries for the CLI sample app</li> </ul> <pre><code>cd $TOP_FOLDER/prebuilt\nwget -N https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/$app/$bootdev/$bootimg -P $app/$bootdev/ wget -N https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/$app/$bootdev/bl2.bin -P $app/$bootdev/\n</code></pre> <ul> <li>Prepare the binaries to run on Simics\u00ae Simulator</li> </ul> <pre><code>cd $TOP_FOLDER\nrm -rf bin\nmkdir -p bin/atf\nln -s $TOP_FOLDER/prebuilt/$app/$bootdev/$bootimg bin/ ln -s $TOP_FOLDER/prebuilt/$app/$bootdev/bl2.bin bin/atf/bl2.bin\n</code></pre> <p>To run the application, go to the section CLI application - Run</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#cli-application-build-from-source","title":"CLI application - Build-from-source","text":"<p>There is a sample specially made for Agilex\u2122 E-Series that can be found at samples/boards/intel_socfpga/cli/ within the Zephyr folder. The following  instructions show how to build and run:</p> <pre><code>cd $TOP_FOLDER/zephyrproject/zephyr/\nwest build -b intel_socfpga_agilex5_socdk samples/boards/intel_socfpga/cli/ -d agilex5 #If you need to overwrite a previous build you need to add the --pristine flag as follows.\n#west build -b intel_socfpga_agilex5_socdk samples/boards/intel_socfpga/cli/ -d agilex5 --pristine\ncd $TOP_FOLDER\n</code></pre> <p>A. if you were using prebuilt binaries before this, perform this step: Organizing the Build-From-Source Binaries.</p> <p>As the Zephyr application has been changed, you'll to create the bootable image according to the boot device you desire. Refer to Creating Boot Images</p> <p>Run the application following CLI_application - Run.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#cli-application-run","title":"CLI application - Run","text":"<p>Once this sample is ready, you can run it in the same way as the 'hello world' sample, as follows:</p> <pre><code>cd $TOP_FOLDER/project-1\n./simics zephyr.simics\n</code></pre> <p>The following output and agilex5$ prompt will appear:</p> <pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):f0d41e37d\nNOTICE:  BL2: Built : 08:55:04, Nov 17 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):f0d41e37d\nNOTICE:  BL31: Built : 08:55:08, Nov 17 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\n\nagilex5$ Secondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nintel_socfpga_agilex5_socdk: Starting Command Line Interface...\nEnumeration started\nUSB enumeration success\n\nagilex5$\n</code></pre> <p>At this point you can use the interactive command line and execute the following commands: - help -&gt; Show all the available commands\\ - fs -&gt; To interact with file system for storage devices - gpio -&gt; To interact with the gpio ports - i2c -&gt; To send and receive data from the i2c ports - timer -&gt; To interact with the timer interrupts.</p> <pre><code>agilex5$ help\nYou can try to call commands with &lt;-h&gt; or &lt;--help&gt; parameter for more information.\n\nAvailable commands:\n  device   :Device commands\n  edac     :EDAC information\n  flash    :Flash shell commands\n  fs       :File system commands\n  gpio     :GPIO commands\n  help     :Prints the help message.\n  i2c      :I2C commands\n  i3c      :I3C commands\n  mailbox  :Intel SoC FPGA SDM mailbox client commands\n  mdio     :MDIO commands\n  net      :Networking commands\n  psci     :ARM PSCI interface commands\n  sip_svc  :ARM SiP services commands\n  spi      :spi commands\n  timer    :Timer commands\nagilex5$\n</code></pre> <p>Let's execute blink through the gpio command to demonstrate the usage of the CLI(Command line interface):</p> <pre><code>agilex5$ gpio help\ngpio - GPIO commands\nSubcommands:\n  conf   :Configure GPIO: conf &lt;gpio_node_id&gt; &lt;pin&gt; &lt;mode(in/out)&gt;\n  get    :Get GPIO value: get &lt;gpio_node_id&gt; &lt;pin&gt;\n  set    :Set GPIO: set &lt;gpio_node_id&gt; &lt;pin&gt; &lt;value(0/1)&gt;\n  blink  :Blink GPIO: blink &lt;gpio_node_id&gt; &lt;pin&gt;\nagilex5$ gpio conf gpio@10c03300  5 out\nConfiguring gpio@10c03300 pin 5\nagilex5$ gpio blink  gpio@10c03300  5  \nBlinking port gpio@10c03300 pin 5. Hit any key to exit\nagilex5$\n</code></pre> <p>Note: GPIO port gpio@10c03200 pins 0 to 10 are used for sdcard boot and should not be used for other purposes.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#using-i3c","title":"Using I3C","text":"<p>This use case is an extension to the CLI application. The CLI prebuilt or build from source binary can be used directly for this use case.</p> <p>The Zephyr driver enabled 2 I3C devices and 1 I2C device of the modeled board components and attached to the I3C master's bus. To test the I3C read and write operation to a device, set the inverted_loopback parameter to TRUE. This may be done in the zephyr.simics script.</p> <p>Note: </p> <ol> <li>The 2 I3C device enabled have the PIDs 0xFB1122330001 and 0xFB1122330002. You'll have to enable inverted_loopback for the desired devices to read-back the write operation.<ul> <li>Device #1: system.board.i3c0_device1.target-&gt;inverted_loopback=TRUE</li> <li>Device #2: system.board.i3c0_device2.target-&gt;inverted_loopback=TRUE</li> </ul> </li> <li>The 1 I2C device has the address 0x50.</li> <li>The read-back values are inverted(by NOT bit-wise operation) at byte level. (E.g. write 0xAF -&gt; read returns 0x50).</li> <li>For the first usage, the read FIFO will contain a 1-byte value of 0xF0 due to initialization (this is not a driver issue but the device model behaviour). Reads will flush the FIFO.</li> <li>When the FIFO is empty, a read-back will have a default 1-byte value of 0xA5. Data after the 1st byte are random constant value.</li> </ol> <ul> <li>For more details, refer to Intel Agilex\u00ae 5 E-Series Virtual Platform User Guide - I3C Device</li> </ul> <p>Enable the (inverted)loopback in target simics script.</p> <pre><code>cd $TOP_FOLDER/project-1\nsed -i '/^run$/i system.board.i3c0_device1.target-&gt;inverted_loopback=TRUE \\\nsystem.board.i3c0_device2.target-&gt;inverted_loopback=TRUE' zephyr.simics\n</code></pre> <p>If everything was done correctly we can execute \"i3c\" commands after running ./simics zephyr.simics as shown below:</p> <ul> <li>Perform a dummy i3c read for the first use after boot. This is to clear the data in the RX fifo resulting from CCC operation during driver initialization. The output seen will be 0xf0.</li> </ul> <pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):f0d41e37d\nNOTICE:  BL2: Built : 08:55:04, Nov 17 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):f0d41e37d\nNOTICE:  BL31: Built : 08:55:08, Nov 17 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\n\nagilex5$ Secondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nintel_socfpga_agilex5_socdk: Starting Command Line Interface...\nEnumeration started\nUSB enumeration success\n\nagilex5$ %BLUE%i3c read i3c@10DA0000 0xfb11 0x22330001 0x1%ENDCOLOR%\n\nRead 1 bytes from i3c device with address (9)\n\n00000000: f0                                               |.                |\n</code></pre> <ul> <li>Perform i3c commands for write and read test to I3C device.</li> </ul> <pre><code>agilex5$ i3c write i3c@10DA0000 0xfb11 0x22330001 0xf0 0xca 0x14 0x52\nTo be Written data[0]: f0\nTo be Written data[1]: ca\nTo be Written data[2]: 14\nTo be Written data[3]: 52\nWrote 4 bytes: Device Dynamic address (9)\nagilex5$ i3c read i3c@10DA0000 0xfb11 0x22330001 0x4             \n\nRead 4 bytes from i3c device with address (9)\n\n00000000: 0f 35 eb ad                                      |.5..             |\n</code></pre> <ul> <li>Perform i3c commands for write and read test to I2C device.</li> </ul> <pre><code>agilex5$ i3c i2c_write i3c@10DA0000 0x50 0x08 0xb0 0x55 0xca 0xfe   \nagilex5$ i3c i2c_read i3c@10DA0000 0x50 0x08 0x4                    \n00000000: b0 55 ca fe                                      |.U..             |\nagilex5$ \n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#using-usb-20","title":"Using USB 2.0","text":"<p>To test file operations We can load the USB 2.0 device model: \"usb-msd.craff\" in Simics.</p> <ul> <li>Download the USB2.0 model:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/usb-msd.craff\n</code></pre> <p>Then we need to modify our current zephyr.simics script to provide: $usb_otg_image_filename parameter as follows:</p> <pre><code>cd $TOP_FOLDER/project-1\nsed -i '1i$usb_otg_image_filename = \"usb-msd.craff\"' zephyr.simics\n</code></pre> <p>If  everything was done correctly we can execute \"fs\" commands after running =./simics zephyr.simics= as shown below: <pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  QSPI boot\nNOTICE:  BL2: v2.9.1(release):6e6d72e35\nNOTICE:  BL2: Built : 08:50:06, Nov 17 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 800\nNOTICE:  BL31: CPU ID = 81000200\nNOTICE:  BL31: v2.9.1(release):f0d41e37d\nNOTICE:  BL31: Built : 08:55:08, Nov 17 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\n\nagilex5$ Secondary CPU core 1 (MPID:0x0) is up\nSecondary CPU core 2 (MPID:0x100) is up\nSecondary CPU core 3 (MPID:0x300) is up\nintel_socfpga_agilex5_socdk: Starting Command Line Interface...\nEnumeration started\nUSB enumeration success\n\nagilex5$ fs mount fat /USB2: \nSuccessfully mounted fat fs:/USB2:\nagilex5$ fs ls USB2:/ \nagilex5$ fs write USB2:/cafe.txt 0C 0A 0F 0F 0E\nSuccessfully written 5 bytes\nagilex5$ fs read USB2:/cafe.txt                \nFile size: 5\n00000000  0C 0A 0F 0F 0E                                   \u2026..\nSuccessfully read 5 bytes\nagilex5$ fs ls USB2:/ \n      CAFE.TXT  size: 5          bytes\nagilex5$\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#exercising-zephyr-on-a-single-core","title":"Exercising Zephyr on a single core.","text":"<p>By default, SMP is enabled in Zephyr, and all the cores will be up and running. However, the user may choose the specific core on which the Zephyr application should run on a single core. This can be accomplished as follows:</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#prebuilt-binaries-for-a55-and-a76","title":"Prebuilt Binaries for A55 and A76","text":"<p>To execute the binaries prebuilt for A76, change the \"cputype\" in the steps for Organizing the Prebuilt Binaries or CLI application - Prebuilt binaries</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#build-the-zephyr-application","title":"Build the Zephyr Application","text":"<p>The default build configuration targets the A55 core. The following steps will guide you in rebuilding the \"Hello World\" application for A76. It's assumed you have already followed the Build Instructions with default settings.</p> <ul> <li>Load the profile and activate the python virtual environment</li> </ul> <pre><code>source  $TOP_FOLDER/.zephyrrc\nsource ~/.zephyrproject/.venv/bin/activate \n</code></pre> <ul> <li>Pick either core0(a55) or core2(a76):</li> </ul> Core Selection Env-variable A55 export cputype=a55 A76 export cputype=a76 <ul> <li>For demonstration purposes, we will create a new local branch so that we can revert to the default SMP configurations:</li> </ul> <pre><code>cd $TOP_FOLDER/zephyrproject/zephyr\ngit checkout QPDS23.4_REL_GSRD_PR\ngit branch nosmp_$cputype\ngit checkout nosmp_$cputype\n</code></pre> <ul> <li>Modify the file in $TOP_FOLDER/zephyrproject/zephyr/dts/arm64/intel/intel_socfpga_agilex5.dtsi, to remove the rest of the cores:</li> </ul> <pre><code>if [ $cputype = \"a55\" ]; then\nsed -i '27,46d' dts/arm64/intel/intel_socfpga_agilex5.dtsi;\nelse\nsed -i '20,32d' dts/arm64/intel/intel_socfpga_agilex5.dtsi;\nsed -i '28,33d' dts/arm64/intel/intel_socfpga_agilex5.dtsi;\nfi;\n</code></pre> <p>For reference, the device tree should look like this:</p> <p>A55: <pre><code>13: #include &lt;zephyr/dt-bindings/gpio/gpio.h&gt;\n14: \n15: / {\n16:     cpus {\n17:         #address-cells = &lt;1&gt;;\n18:         #size-cells = &lt;0&gt;;\n19: \n20:         cpu@0 {\n21:             device_type = \"cpu\";\n22:             compatible = \"arm,cortex-a55\";\n23:             enable-method = \"psci\";\n24:             reg = &lt;0&gt;;\n25:         };\n26:     };\n};\n</code></pre></p> <p>A76: <pre><code>14: \n15: / {\n16:     cpus {\n17:         #address-cells = &lt;1&gt;;\n18:         #size-cells = &lt;0&gt;;\n19: \n20: \n21:         cpu@200 {\n22:             device_type = \"cpu\";\n23:             compatible = \"arm,cortex-a76\";\n24:             enable-method = \"psci\";\n25:             reg = &lt;0&gt;;\n26:         };\n27: \n28:     };\n};\n</code></pre> Remove CONFIG_SMP=y and CONFIG_MP_MAX_NUM_CPUS=4 within intel_socfpga_agilex5_socdk_defconfig:</p> <pre><code>sed -i '/CONFIG_SMP/d' boards/arm64/intel_socfpga_agilex5_socdk/intel_socfpga_agilex5_socdk_defconfig\nsed -i '/CONFIG_MP_MAX_NUM_CPUS/d' boards/arm64/intel_socfpga_agilex5_socdk/intel_socfpga_agilex5_socdk_defconfig\ngit commit -a -m \"smpremove_$cputype\"\n</code></pre> <ul> <li>Re-build the \"Hello World\" sample.</li> </ul> <pre><code>west build -b intel_socfpga_agilex5_socdk samples/hello_world -d agilex5 --pristine\n</code></pre> <ul> <li> <p>Prepare the binaries to run on Simics\u00ae Simulator</p> <p>a. Remove obsolete folder and create the new fip binary.</p> </li> </ul> <pre><code>cd $TOP_FOLDER\nrm -rf bin\nmkdir bin\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/ bin/atf\nln -s $TOP_FOLDER/zephyrproject/zephyr/agilex5/zephyr/  bin/zephyr\n./fiptool create --soc-fw $TOP_FOLDER/bin/atf/bl31.bin  --nt-fw $TOP_FOLDER/bin/zephyr/zephyr.bin bin/fip.bin\n</code></pre> <p>To create the boot image, we will use the creating SD Card Image binaries section as base. Refer back to Creating Boot Images to boot from other boot devices.</p> <ul> <li>Obtain the make_sdimage.sh script.</li> </ul> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/sdmmc_boot/make_sdimage.sh\nchmod +x make_sdimage.sh\n</code></pre> <ul> <li>Create the sdimage.img</li> </ul> <pre><code>touch dummy.tar.gz\nsudo ./make_sdimage.sh -k dummy.tar.gz -p bin/fip.bin -o bin/sdimage.img -g 2G -pg 16&lt;/pre&gt;\n</code></pre> <p>Note: To return to QPDS23.4_REL_GSRD_PR tag execute:</p> <pre><code>cd $TOP_FOLDER/zephyrproject/zephyr\ngit checkout QPDS23.4_REL_GSRD_PR\ncd $TOP_FOLDER\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#simulation-setup_1","title":"Simulation Setup","text":"<p>It is assumed you have executed the steps at least once in Simulation Setup with default settings.</p> <ul> <li>Lets add the Simics binary to the path to make things easier:</li> </ul> <pre><code>export PATH=$PATH:&amp;ltSimics installation dir&amp;gt/simics/bin/\n</code></pre> <ul> <li>Configure the Simics top-level target script to run on a single core by adding the following parameters before the run-command-file command:</li> </ul> <p>A55:</p> <pre><code>$hps_core0_power_on = TRUE \n$hps_core1_power_on = FALSE \n$hps_core2_power_on = FALSE \n$hps_core3_power_on = FALSE\n</code></pre> <p>A76:</p> <pre><code>$hps_boot_core = 2 \n$hps_core0_1_power_on = FALSE \n$hps_core2_power_on = TRUE \n$hps_core3_power_on = FALSE\n</code></pre> <p>This can be achieved by executing the following command:</p> <pre><code>cd $TOP_FOLDER/project-1\ncputypestring=\"\"\nif [ $cputype = \"a55\" ]; then\ncputypestring='$hps_boot_core = 0 \n$hps_core0_power_on = TRUE \n$hps_core1_power_on = FALSE \n$hps_core2_power_on = FALSE \n$hps_core3_power_on = FALSE'\nelse\ncputypestring='$hps_boot_core = 2 \n   $hps_core0_1_power_on = FALSE \n   $hps_core2_power_on = TRUE \n   $hps_core3_power_on = FALSE'\nfi;\ntee zephyr.simics &lt;&lt; 'EOF'\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\nlocal $board_name = \"system.board.fpga\"\n# Ensure the sdimage.img &amp; bl2.bin paths are relative to the simics executable#\n# Enable Console\n$create_hps_serial0_console=TRUE\n# Boot from SD Card\n$create_hps_sd_card=TRUE\n$create_hps_mmc=FALSE\n# SD Card boot Image file path\n$sd_image_filename = ../bin/sdimage.img\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\nEOF\necho \"$cputypestring\" &gt;&gt; zephyr.simics echo 'run-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\nrun' &gt;&gt; zephyr.simics\n</code></pre> <p>Note: We based our approach on the SDCard script. For NAND boot and QSPI options, refer to Booting from NAND binaries and Booting from QSPI binaries.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#running-hello-world_1","title":"Running Hello World","text":"<ul> <li>Run the hello world example:</li> </ul> <pre><code>./simics zephyr.simics\n</code></pre> <ul> <li>Wait to get \"Hello World!\" message in the target serial console.</li> </ul> <pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 19:41:32, Dec 18 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 800\nNOTICE:  BL31: CPU ID = 81000200\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 19:41:33, Dec 18 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\nHello World! intel_socfpga_agilex5_socdk\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#configuration-reference","title":"Configuration Reference","text":"<p>You may rebuild and run on Simics for the target core based on the following configuration:</p> Config file A55 A76 $TOP_FOLDER/zephyrproject/zephyr/dts/arm64/intel/intel_socfpga_agilex5.dtsi At node cpu@0 : compatible = \"arm,cortex-a75\"  reg = At node cpu@0 :  compatible = \"arm,cortex-a76\" reg = $TOP_FOLDER/project-1/zephyr.simics $hps_boot_core = 0 $hps_boot_core = 2"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/","title":"Agilex\u2122 5 E-Series Modular Development Kit GHRD Linux Boot Examples","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#overview","title":"Overview","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The following scenarios are covered:</p> <ul> <li>Boot from SD Card</li> <li>Boot from QSPI</li> </ul> <p>The instructions on this page are based on the GSRD.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Modular Development Kit GSRD:</p> <ul> <li>Altera Agilex 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 </li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 and the following software component versions are used by the instructions on this page: </p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#development-kit","title":"Development Kit","text":"<p>Refer to Development Kit for details about the board, including how to install the HPS Boards, and how to set MSEL dispswitches.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#release-notes","title":"Release Notes","text":"<p>Refer to Release Notes for release information.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from SD card.</p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_boot.modular\nmkdir agilex5_boot.modular\ncd agilex5_boot.modular\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Install Yocto Dependencies <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake BOARD_TYPE=MK-A5E065BB32AES1 DEVICE=A5ED065BB32AE6SR0 DAUGHTER_CARD=mod_som HPS_EMIF_EN=1 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=150 INITIALIZATION_FIRST=hps generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from QSPI.</p> <p>This section presents how to build the binaries and boot from QSPI with the HPS Enablement Board. While the example is based on the GSRD, it contains the following differences:</p> <ul> <li>U-Boot tries to boot only from QSPI flash, does not try SD card</li> <li>U-Boot does not use a script to boot, instead it used the <code>BOOTCMD</code> environment variable directly</li> <li>kernel.itb file contains only one set of core.rbf, kernel and device tree files, targeted for this scenario</li> </ul> <p>1. Prepare the top folder</p> <pre><code>rm -rf $TOP_FOLDER/qspi-boot\nmkdir $TOP_FOLDER/qspi-boot\n</code></pre> <p>2. Build U-Boot:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from QSPI\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# mtd info\nCONFIG_MTDIDS_DEFAULT=\"nor0=nor0\"\nCONFIG_MTDPARTS_DEFAULT=\"mtdparts=nor0:66m(u-boot),190m(root)\"\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# do not keep env on sd card\nCONFIG_ENV_IS_IN_FAT=n\n# disable NAND related settings from defconfig\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"mtdparts;ubi part root;ubi readvol \\${loadaddr} kernel;ubi detach;setenv bootargs earlycon panic=-1 ubi.mtd=1 root=ubi0:rootfs rootfstype=ubifs rw rootwait;bootm \\${loadaddr}#board-0;\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build <code>kernel.itb</code> FIT file containing kernel, device tree and fpga fabric configuration file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -f core.rbf devicetree.dtb Image.lzma kernel.its kernel.itb\nln -s ../ghrd.core.rbf core.rbf\nln -s ../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb devicetree.dtb\nxz --format=lzma --extreme -k -c ../linux-socfpga/arch/arm64/boot/Image &gt; Image.lzma\ncat &lt;&lt; EOF &gt; kernel.its\n// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2024 Intel Corporation\n *\n */\n/dts-v1/;\n/ {\n    description = \"FIT image with kernel, DTB and FPGA core binary\";\n    #address-cells = &lt;1&gt;;\n    images {\n        kernel {\n            description = \"Linux Kernel\";\n            data = /incbin/(\"./Image.lzma\");\n            type = \"kernel\";\n            arch = \"arm64\";\n            os = \"linux\";\n            compression = \"lzma\";\n            load = &lt;0x86000000&gt;;\n            entry = &lt;0x86000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fdt-0 {\n            description = \"Device Tree\";\n            data = /incbin/(\"./devicetree.dtb\");\n            type = \"flat_dt\";\n            arch = \"arm64\";\n            compression = \"none\";\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fpga-0 {\n            description = \"FPGA bitstream\";\n            data = /incbin/(\"./core.rbf\");\n            type = \"fpga\";\n            arch = \"arm64\";\n            compression = \"none\";\n            load = &lt;0x8A000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n    };\n    configurations {\n        default = \"board-0\";\n        board-0 {\n            description = \"board_0\";\n            kernel = \"kernel\";\n            fdt = \"fdt-0\";\n            fpga = \"fpga-0\";\n            signature {\n                algo = \"crc32\";\n                key-name-hint = \"dev\";\n                sign-images = \"fdt-0\", \"kernel\", \"fpga-0\";\n            };\n        };\n    };\n};\nEOF\n./u-boot-socfpga/tools/mkimage -f kernel.its kernel.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/kernel.itb</code></li> </ul> <p>4. Create U-Boot binary <code>u-boot.bin</code> with a size of exactly 2MB:</p> <pre><code>cp u-boot-socfpga/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Build the <code>rootfs.ubifs</code> file:</p> <pre><code>rm -rf rootfs rootfs.ubifs\nmkdir rootfs tar -xzvf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz -C rootfs mkfs.ubifs -r rootfs -F -e 65408 -m 1 -c 6500 -o rootfs.ubifs </code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/rootfs.ubifs</code></li> </ul> <p>6. Build the <code>root.ubi</code> file:</p> <pre><code>cat &lt;&lt; EOF &gt; ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nvol_id=1\nvol_name=script\nvol_size=128KiB \nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3    \nvol_name=dtb   \nvol_size=256KiB \nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOF\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/root.ubi</code></li> </ul> <p>7. Build the QSPI flash image:</p> <pre><code>ln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof fpga.sof\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\nln -s root.ubi hps.bin\ncat &lt;&lt; EOF &gt; flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n    &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"UBOOT\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"HPS\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"UBOOT\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash_image.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/flash_image.hps.jic</code></li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <p><pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"qspi-boot/flash_image.hps.jic\"\n</code></pre> Note: You need to wipe the micro SD card or remove it from the board before start running.</p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/","title":"Agilex\u2122 5 E-Series Modular Development Kit GSRD User Guide","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#gsrd-overview","title":"GSRD Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex\u2122 5 E-Series Modular Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Modular Development Kit GSRD:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 </li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex 5 Modular Development Kit GSRD binaries are located at https://releases.rocketboards.org/2024.11/:</p> Boot Source Link SD Card https://releases.rocketboards.org/2024.11/gsrd/agilex5_modular_gsrd/ QSPI https://releases.rocketboards.org/2024.11/qspi/agilex5_modular_qspi/"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 and the following software component versions are used to build the GSRD: </p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#release-notes","title":"Release Notes","text":"<p>See https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#development-kit","title":"Development Kit","text":"<p>This release targets the Agilex 5 FPGA E-Series 065B Modular Development Kit. It is composed of a carrier board which offers additional connectivity, and a SOM board which contains the FPGA part, HPS DDRAM and all other required circuitry. Refer to board documentation for more information about the development kit.</p> <p></p> Changing MSEL <p>MSEL signals instruct the FPGA device on which configuration scheme to use. Configuration schemes used by the scenarios presented in this guide are JTAG and ASx4 (QSPI). MSEL is changed through dipswitch S4 on the top left cornet of the SOM board. Only change the settings while the board is powered off.</p> <p>The MSEL settings are:</p> <ul> <li>JTAG: SW4[2:1]=OFF:OFF</li> <li>ASx4 (QSPI): SW4[2:1]=ON:ON</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Dual core Arm Cortex-A76 processor</li> <li>Dual core Arm Cortex-A55 processor</li> <li>HPS Peripherals<ul> <li>Micro SD Card</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>UART</li> <li>I2C    </li> <li>USB 3.1</li> </ul> </li> </ul> </li> <li>Multi-Ported Front End (MPFE) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>One user LED output</li> <li>Two user DIP switch inputs</li> <li>One user push-button input</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <p> </p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>  MPU Address Maps <p>This section presents the address maps as seen from the MPU side.  </p>  HPS-to-FPGA Address Map <p>The three FPGA windows in the MPU address map provide access to 256 GB of FPGA space. First window is 1 GB from 00_4000_0000, second window is 15 GB from 04_4000_0000, third window is 240 GB from 44_0000_0000. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU, which starts at the lightweight HPS-to-FPGA base address of 0x00_2000_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0001_0000 32 Unique system ID button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs led_pio 0x0001_0080 16 LED outputs JTAG Master Address Map <p>There are three JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface and another for FPGA fabric to SDRAM.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0001_0000 32 Unique system ID button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs led_pio 0x0001_0080 16 LED outputs  Interrupt Routing <p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[1] DIP switch input button_pio f2h_irq0[0] Push button input"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#exercising-prebuilt-binaries","title":"Exercising Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Connect micro USB cable from bottom left of the carrier board to PC. This will be used for JTAG communication.</p> <p>3. Connect micro USB cable from bottom right of the SOM board to PC. This will be used for HPS UART communication.</p> <p>4. Connect Ethernet cable from SOM board to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>Each of the USB connections listed above will enumerate 4 USB serial ports on your host computer. The HPS UART port is the 3rd one enumerated by the connection to the SOM board.</p> <p>1. Install a serial terminal emulator application on your host PC:  </p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Remove USB cables, and power down your board if powered up. Look at what USB serial ports are enumerated on your computer by default, without board being connected.</p> <p>3. Power up the board.</p> <p>4. Connect micro USB cable from bottom left of the carrier board to PC. This will be used for JTAG communication. Look at what ports are enumerated on your host computer, there should be a series of four.</p> <p>5. Connect micro USB cable from bottom right of the SOM board to PC. This will be used for HPS UART communication. Look at what ports are enumerated on your host computer, there should be a series of four. Use the 3rd one in the list as the HPS serial port.</p> Possible serial port allocation in Windows <ul> <li>COM3: already there before board was installed</li> <li>COM4-7: enumerated by the JTAG connection</li> <li>COM8-11: enumerated by the HPS connection</li> </ul> <p>In the above case, the port to use for HPS serial communication would be COM10.</p> Possible serial port allocation in Linux <ul> <li>/dev/ttyUSB0-3: enumerated by the JTAG connection</li> <li>/dev/ttyUSB4-7:enumerated by the HPS connection</li> </ul> <p>In the above case, the port to use for HPS serial communication would be /dev/ttyUSB6.</p> <p>Notes:</p> <ul> <li>On Windows, the port number may be kept between power cycles, but not always. </li> <li>On Linux, the port numbe may change depending on the order in which cables are inserted.</li> </ul> <p>6. Configure your serial terminal emulator to use the following settings:  </p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>7. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#booting-from-sd-card","title":"Booting from SD Card","text":"Write SD Card <p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2024.07/gsrd/agilex5_modular_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the gsrd-console-image-agilex5_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. For this, first rename the gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p> </p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI <pre><code>wget https://releases.rocketboards.org/2024.07/gsrd/agilex5_modular_gsrd/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\ntar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> Run Sample Applications <p>1. Boot to Linux</p> <p>2. Change current folder to <code>intelFPGA</code> folder <pre><code>cd intelFPGA\n</code></pre> 3. Run the hello world application <pre><code>./hello\n</code></pre> 4. Run the <code>syscheck</code> application <pre><code>./syscheck\n</code></pre> Press <code>q</code> to exit the <code>syscheck</code> application.</p> Control LED <p>1. Boot to Linux</p> <p>2. Control LED by using the following sysfs entries:</p> <ul> <li>/sys/class/leds/fpga_led0/brightness</li> <li>/sys/class/leds/hps_led1/brightness</li> </ul> <p>using commands such as: <pre><code>cat /sys/class/leds/fpga_led0/brightness\necho 0 &gt; /sys/class/leds/fpga_led0/brightness\necho 1 &gt; /sys/class/leds/fpga_led1/brightness\n</code></pre></p> <p>Because of how the LEDs are connected, for the above commands <code>0</code> means LED is turned on, <code>1</code> means LED is turned off.</p> Connect to Board Using SSH <p>1. Boot to Linux  </p> <p>2. Determine the board IP address using the <code>ifconfig</code> command: <pre><code>root@agilex5devkit:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 192.168.1.153  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 fe80::f0eb:c8ff:fec4:eed7  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether f2:eb:c8:c4:ee:d7  txqueuelen 1000  (Ethernet)\nRX packets 649  bytes 45132 (44.0 KiB)\nRX errors 0  dropped 226  overruns 0  frame 0\nTX packets 56  bytes 8789 (8.5 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 23  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 100  bytes 8408 (8.2 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 100  bytes 8408 (8.2 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> 3. Connect to the board over SSH using <code>root</code> username, no password will be requested: <pre><code>ssh root@192.168.1.153\n</code></pre> Note: Make sure to replace the above IP address to the one matching the output of running <code>ifconfig</code> on youir board.</p> Visit Board Web Page <p>1. Boot to Linux  </p> <p>2. Determine board IP address using <code>ifconfig</code> like in the previous scenario  </p> <p>3. Start a web browser and enter the IP address in the address bar  </p> <p>4. The web browser will display a page served by the web server running on the board.  </p> <p>Note: Current release has a limitation, in that the LEDs are not controllable from the web page. This will be resolved in the next release.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#booting-from-qspi","title":"Booting from QSPI","text":"<p>This section presents how to boot from QSPI. One notable aspect is that you need to wipe the SD card partitioning information, as otherwise U-Boot SPL could find a valid SD card image, and try to boot from that first.</p> Wipe SD Card <p>Either write 1MB of zeroes at the beginning of the SD card, or remove the SD card from the HPS Daughter Card. You can use <code>dd</code> on Linux, or <code>Win32DiskImager</code> on Windows to achieve this.</p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.07/qspi/agilex5_modular_qspi/agilex_flash_image.hps.jic.tar.gz\ntar xf agilex_flash_image.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;agilex_flash_image.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>Note: On first boot, the UBIFS rootfilesystem is initialized, and that takes a few minutes. This will not happen on next reboots. See a sample log below:</p> <pre><code>[   17.033558] UBIFS (ubi0:4): Mounting in unauthenticated mode\n[   17.039470] UBIFS (ubi0:4): background thread \"ubifs_bgt0_4\" started, PID 130\n[   17.061510] UBIFS (ubi0:4): start fixing up free space\n[   20.644496] random: crng init done\n[   27.120040] platform soc:leds: deferred probe pending\n[  243.190874] UBIFS (ubi0:4): free space fixup complete\n[  243.315909] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[  243.323290] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[  243.332653] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#rebuilding-the-gsrd","title":"Rebuilding the GSRD","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#yocto-build-prerequisites","title":"Yocto Build Prerequisites","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#build-sd-card-boot-binaries","title":"Build SD Card Boot Binaries","text":"<p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.modular\nmkdir agilex5_gsrd.modular\ncd agilex5_gsrd.modular\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake BOARD_TYPE=MK-A5E065BB32AES1 DEVICE=A5ED065BB32AE6SR0 DAUGHTER_CARD=mod_som HPS_EMIF_EN=1 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=150 INITIALIZATION_FIRST=hps generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_modular-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_modular_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_modular_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_modular_gsrd_core</code> with <code>file://agilex5_modular_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_modular_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_modular_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_modular_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_modular_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_modular_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_modular_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#build-qspi-boot-binaries","title":"Build QSPI Boot Binaries","text":"<p>The diagram below shows how booting from QSPI JIC is built. The hardware project compilation and Yocto build remain the same, and the QSPI JIC is built based on the resulted files: </p> <p>1. Create the folder to contain all the files:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf qspi_boot\nmkdir qspi_boot\ncd qspi_boot\n</code></pre> <p>2. Get the <code>ubinize.cfg</code> file which contains the details on how to build the <code>root.ubi</code> volume, and <code>agilex5_devkit_flash_image_hps.pfg</code> which contains the instructions for Programming File Generator on how to create the .jic file:</p> <pre><code>wget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/ubinize.cfg\nwget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>3. Link to the files that are needed from building the hardware design, and yocto:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/console-image-minimal-agilex5_nor.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof .\n</code></pre> <p>4. Process the u-boot.itb file to be exactly 2MB in size:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the <code>root.ubi</code> file and rename it to <code>hps.bin</code> as Programming File Generator needs the <code>.bin</code> extension:</p> <pre><code>ubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>6. Create the JIC file:</p> <pre><code>quartus_pfg -c agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi_boot/agilex_flash_image.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/","title":"Agilex\u2122 5 E-Series Premium Development Kit GHRD Linux Boot Examples","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#overview","title":"Overview","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The following scenarios are covered:</p> <ul> <li>HPS Enablement Board: boot from SD card, and boot from QSPI</li> <li>HPS NAND Board: boot from eMMC flash</li> <li>HPS Test Board: boot from SD card</li> </ul> <p>The instructions on this page are based on the GSRD.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the guides from this page:</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>HPS Enablement  Expansion Board. Included with the development kit</li> <li>HPS NAND Board. Enables eMMC storage for HPS. Orderable separately</li> <li>HPS Test Board. Supports SD card boot, and external Arm tracing. Orderable separately</li> <li>Mini USB Cable. Included with the development kit</li> <li>Micro USB Cable. Included with the development kit</li> <li>Ethernet Cable. Included with the development kit</li> <li>Micro SD card and USB card writer. Included with the development kit</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 </li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 and the following software component versions are used to build the GSRD: </p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#development-kit","title":"Development Kit","text":"<p>Refer to Development Kit for details about the board, including how to install the HPS Boards, and how to set MSEL dispswitches.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>Refer to Release Notes for release readiness information and known issues.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-enablement-board","title":"HPS Enablement Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS Enablement Board. Both booting from SD card and booting from QSPI are covered.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-sd-card","title":"Boot from SD Card","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_boot.enablement\nmkdir agilex5_boot.enablement\ncd agilex5_boot.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Install Yocto Dependencies <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section presents how to build the binaries and boot from QSPI with the HPS Enablement Board. While the example is based on the GSRD, it contains the following differences:</p> <ul> <li>U-Boot tries to boot only from QSPI flash, does not try SD card</li> <li>U-Boot does not use a script to boot, instead it used the <code>BOOTCMD</code> environment variable directly</li> <li>kernel.itb file contains only one set of core.rbf, kernel and device tree files, targeted for this scenario</li> </ul> <p>1. Prepare the top folder</p> <pre><code>rm -rf $TOP_FOLDER/qspi-boot\nmkdir $TOP_FOLDER/qspi-boot\n</code></pre> <p>2. Build U-Boot:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from QSPI\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# mtd info\nCONFIG_MTDIDS_DEFAULT=\"nor0=nor0\"\nCONFIG_MTDPARTS_DEFAULT=\"mtdparts=nor0:66m(u-boot),190m(root)\"\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# do not keep env on sd card\nCONFIG_ENV_IS_IN_FAT=n\n# disable NAND related settings from defconfig\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"mtdparts;ubi part root;ubi readvol \\${loadaddr} kernel;ubi detach;setenv bootargs earlycon panic=-1 ubi.mtd=1 root=ubi0:rootfs rootfstype=ubifs rw rootwait;bootm \\${loadaddr}#board-0;\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build <code>kernel.itb</code> FIT file containing kernel, device tree and fpga fabric configuration file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -f core.rbf devicetree.dtb Image.lzma kernel.its kernel.itb\nln -s ../ghrd.core.rbf core.rbf\nln -s ../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb devicetree.dtb\nxz --format=lzma --extreme -k -c ../linux-socfpga/arch/arm64/boot/Image &gt; Image.lzma\ncat &lt;&lt; EOF &gt; kernel.its\n// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2024 Intel Corporation\n *\n */\n/dts-v1/;\n/ {\n    description = \"FIT image with kernel, DTB and FPGA core binary\";\n    #address-cells = &lt;1&gt;;\n    images {\n        kernel {\n            description = \"Linux Kernel\";\n            data = /incbin/(\"./Image.lzma\");\n            type = \"kernel\";\n            arch = \"arm64\";\n            os = \"linux\";\n            compression = \"lzma\";\n            load = &lt;0x86000000&gt;;\n            entry = &lt;0x86000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fdt-0 {\n            description = \"Device Tree\";\n            data = /incbin/(\"./devicetree.dtb\");\n            type = \"flat_dt\";\n            arch = \"arm64\";\n            compression = \"none\";\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fpga-0 {\n            description = \"FPGA bitstream\";\n            data = /incbin/(\"./core.rbf\");\n            type = \"fpga\";\n            arch = \"arm64\";\n            compression = \"none\";\n            load = &lt;0x8A000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n    };\n    configurations {\n        default = \"board-0\";\n        board-0 {\n            description = \"board_0\";\n            kernel = \"kernel\";\n            fdt = \"fdt-0\";\n            fpga = \"fpga-0\";\n            signature {\n                algo = \"crc32\";\n                key-name-hint = \"dev\";\n                sign-images = \"fdt-0\", \"kernel\", \"fpga-0\";\n            };\n        };\n    };\n};\nEOF\n./u-boot-socfpga/tools/mkimage -f kernel.its kernel.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/kernel.itb</code></li> </ul> <p>4. Create U-Boot binary <code>u-boot.bin</code> with a size of exactly 2MB:</p> <pre><code>cp u-boot-socfpga/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Build the <code>rootfs.ubifs</code> file:</p> <pre><code>rm -rf rootfs rootfs.ubifs\nmkdir rootfs tar -xzvf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz -C rootfs mkfs.ubifs -r rootfs -F -e 65408 -m 1 -c 6500 -o rootfs.ubifs </code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/rootfs.ubifs</code></li> </ul> <p>6. Build the <code>root.ubi</code> file:</p> <pre><code>cat &lt;&lt; EOF &gt; ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nvol_id=1\nvol_name=script\nvol_size=128KiB \nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3    \nvol_name=dtb   \nvol_size=256KiB \nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOF\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/root.ubi</code></li> </ul> <p>7. Build the QSPI flash image:</p> <pre><code>ln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof fpga.sof\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\nln -s root.ubi hps.bin\ncat &lt;&lt; EOF &gt; flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n    &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"UBOOT\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"HPS\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"UBOOT\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash_image.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/flash_image.hps.jic</code></li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <p><pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"qspi-boot/flash_image.hps.jic\"\n</code></pre> Note: You need to wipe the micro SD card or remove it from the board before start running.</p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-nand-board","title":"HPS NAND Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS NAND Board. Boot source is eMMC Flash.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-emmc","title":"Boot from eMMC","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_boot.emmc\nmkdir agilex5_boot.emmc\ncd agilex5_boot.emmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 DAUGHTER_CARD=devkit_dc_emmc generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk_emmc.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk_emmc.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_emmc.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create eMMC Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_emmc.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Create Helper JIC <p>In this section we are building a helper JIC which will boot from QSPI and will allow us to program the eMMC from U-Boot.</p> <p>1. Create the jic helper folder to contain all related build artifacts:</p> <pre><code>rm -rf $TOP_FOLDER/helper-jic\nmkdir $TOP_FOLDER/helper-jic\n</code></pre> <p>2. Build a modified U-Boot, which boots from QSPI and stops at command line prompt:</p> <pre><code>cd $TOP_FOLDER/helper-jic\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"echo hello\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\n# boot from QSPI\nCONFIG_ENV_IS_IN_FAT=n\nCONFIG_ENV_IS_NOWHERE=y\nCONFIG_SYS_SPI_U_BOOT_OFFS=0x00300000\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build the helper JIC:</p> <pre><code>cd $TOP_FOLDER/helper-jic\nrm -f flash.pfg fpga.sof u-boot.bin spl.hex *.jic *.rbf\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof fpga.sof\nln -s u-boot-socfpga/u-boot.itb u-boot.bin\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\ncat &lt;&lt; EOF &gt; flash.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU128\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00300000\" e_addr=\"0x004CFFFF\" fixed_e_addr=\"1\" id=\"u-boot\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE5SR0&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"u-boot\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash.pfg\n</code></pre> <p>The following file will be created:</p> <ul> <li><code>$TOP_FOLDER/helper-jic/flash.hps.jic</code></li> </ul> Write eMMC Image <p>1. Write the helper JIC to QSPI:</p> <ul> <li>Power down board</li> <li>Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</li> <li>Power up the board</li> <li>Write JIC image to QSPI: <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;helper-jic/flash.hps.jic\"\n</code></pre> </li></ul> <p>2. Boot to U-Boot prompt with the helper JIC:</p> <ul> <li>Power down board</li> <li>Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</li> <li>Power up the board</li> <li>Wait for U-Boot to boot, press any key to get to U-Boot console</li></ul> <p>3. Use <code>ifconfig</code> on your host machine to determine the IP of your TFTP server</p> <p>4. Copy the eMMC image <code>$TOP_FOLDER/sd_card/sdcard.img</code> to your TFTP server folder</p> <p>5. Use the following U-Boot commands to download and write the eMMC image:</p> <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your_tftp_server_ip&gt;\ntftp ${loadaddr} sdcard.img\nsetexpr blkcnt ${filesize} / 0x200\nmmc write ${loadaddr} 0 ${blkcnt}\n</code></pre> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-test-board","title":"HPS Test Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS Test Board. Boot source is SD Card.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-sd-card_1","title":"Boot from SD Card","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_boot.test\nmkdir agilex5_boot.test\ncd agilex5_boot.test\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 DAUGHTER_CARD=debug2 generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk_debug.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk_debug.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_debug.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_debug.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://win32diskimager.org/. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/","title":"Agilex\u2122 5 E-Series Premium Development Kit GSRD User Guide","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#gsrd-overview","title":"GSRD Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex\u2122 5 E-Series Premium  Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Premium Development Kit GSRD:</p> <ul> <li> <p>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.</p> <ul> <li>HPS Enablement Expansion Board. Included with the development kit.</li> <li>HPS NAND Board. Enables eMMC storage for HPS. Orderable separately.</li> <li>HPS Test Board. Supports SD card boot, and external Arm tracing. Orderable separately.</li> <li>Mini USB Cable. Included with the development kit.</li> <li>Micro USB Cable. Included with the development kit.</li> <li>Ethernet Cable. Included with the development kit.</li> <li>Micro SD card and USB card writer. Included with the development kit.</li> <li>Host PC with:</li> </ul> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 </li> <li>The instructions for rebuilding the binaries use Quartus version 24.2</li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex\u2122 5 Modular Development Kit GSRD binaries are located at https://releases.rocketboards.org/2024.07/:</p> Boot Source Link SD Card https://releases.rocketboards.org/2024.11/gsrd/agilex5_modular_gsrd/ QSPI https://releases.rocketboards.org/2024.11/qspi/agilex5_modular_qspi/"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 and the following software component versions are used to build the GSRD: </p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>See https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#development-kit","title":"Development Kit","text":"<p>This release targets the Agilex 5 FPGA E-Series 065B Premium Development Kit. Refer to board documentation for more information about the development kit.</p> <p></p> Installing HPS Daughtercard <p>This section shows how to install the included HPS Enablement Daughtercard.  The installation for the other optional HPS Boards is similar.</p> <p>1. Identify the correct thumb screws and washers needed, they are in a plastic bag: </p> <p>2. Locate the area on the development board where the HPS Daughtercard needs to be installed: </p> <p>3. Place the plastic washers on top of the three hex mounting posts: </p> <p>4. Place HPS Board on top of the posts and washers: </p> <p>5. Place the hex thumb screws on the two posts, as shown below. Note the 3rd one on the bottom is best unplaced as fully screwing that in may move the board. Also note the thumb screw close to the Ethernet connector is hard to screw, recommend to use small pliers and patience to make it secure. It is important that the HPS Board is secure, and does not move: </p> <p>Note: If you need to swap HPS Boards frequently,  it is recommended to remove the hex posts, and install the plastic washers between the PCB and the posts. This way you do not need to be careful for the washers not to move when you place the HPS Board on top of the posts. Note there are also plastic washers underneath the development board PCB, make sure to leave those in place when performing this operation</p> Changing MSEL <p>MSEL signals instruct the FPGA device on which configuration scheme to use. Configuration schemes used by the scenarios presented in this guide are JTAG and QSPI. MSEL is changed through dipswitch SW27. Only change the settings while the board is powered off.</p> <p>Configuration OFF-OFF-OFF-OFF corresponds to JTAG:</p> <p></p> <p>Configuration OFF-ON-ON-OFF corresponds to JTAG:</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Dual core Arm Cortex-A76 processor</li> <li>Dual core Arm Cortex-A55 processor</li> <li>HPS Peripherals connected to HPS Enablement Expansion Board:<ul> <li>Micro SD Card</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>I3C</li> <li>UART</li> <li>USB 3.1</li> </ul> </li> </ul> </li> <li>Multi-Ported Front End (MPFE) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>Three user LED outputs</li> <li>Four user DIP switch inputs</li> <li>Four user push-button inputs</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <p> </p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>  MPU Address Maps <p>This section presents the address maps as seen from the MPU side.  </p>  HPS-to-FPGA Address Map <p>The three FPGA windows in the MPU address map provide access to 256 GB of FPGA space. First window is 1 GB from 00_4000_0000, second window is 15 GB from 04_4000_0000, third window is 240 GB from 44_0000_0000. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU, which starts at the lightweight HPS-to-FPGA base address of 0x00_2000_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0001_0000 32 Unique system ID led_pio 0x0001_0080 16 LED outputs button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs JTAG Master Address Map <p>There are three JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface and another for FPGA fabric to SDRAM.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0001_0000 32 Unique system ID led_pio 0x0001_0080 16 LED outputs button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs  Interrupt Routing <p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[0] 4 DIP switch inputs button_pio f2h_irq0[1] 4 Push button inputs"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#exercising-prebuilt-binaries","title":"Exercising Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Install the appropriate HPS Daughtercard.</p> <p>3. Connect mini USB cable from vertical connector on HPS Daughtercard to host PC. This is used for the HPS serial console.</p> <p>4. Connect micro USB cable from development board to host PC. This is used by the tools for JTAG communication.</p> <p>5. Connect Ethernet cable from HPS Board to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>1. Install a serial terminal emulator application on your host PC:  </p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Power down your board if powered up. This is important, as once powered up, with the micro USB JTAG cable connected, a couple more USB serial ports will enumerate, and you may choose the wrong port.</p> <p>3. Connect mini-USB cable from the vertical mini-USB connector on the HPS Board to the host PC</p> <p>4. On the host PC, an USB serial port will enumerate. On Windows machines it will be something like <code>COM4</code>, while on Linux machines it will be something like <code>/dev/tty/USB0</code>.</p> <p>5. Configure your serial terminal emulator to use the following settings:  </p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>6. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-enablement-board","title":"HPS Enablement Board","text":"<p>This section presents how to use HPS Enablement Board to boot from SD card, and also from QSPI.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-sd-card","title":"Booting from SD Card","text":"Write SD Card <p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2024.05/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the gsrd-console-image-agilex5_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://sourceforge.net/projects/win32diskimager. For this, first rename the gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p> </p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI <pre><code>wget https://releases.rocketboards.org/2024.05/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\ntar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> Run Sample Applications <p>1. Boot to Linux</p> <p>2. Change current folder to <code>intelFPGA</code> folder <pre><code>cd intelFPGA\n</code></pre> 3. Run the hello world application <pre><code>./hello\n</code></pre> 4. Run the <code>syscheck</code> application <pre><code>./syscheck\n</code></pre> Press <code>q</code> to exit the <code>syscheck</code> application.</p> Control LEDs <p>1. Boot to Linux</p> <p>2. Control LEDs by using the following sysfs entries:</p> <ul> <li>/sys/class/leds/fpga_led0/brightness</li> <li>/sys/class/leds/fpga_led1/brightness</li> <li>/sys/class/leds/fpga_led2/brightness</li> <li>/sys/class/leds/hps_led1/brightness</li> </ul> <p>using commands such as: <pre><code>cat /sys/class/leds/fpga_led0/brightness\necho 0 &gt; /sys/class/leds/fpga_led0/brightness\necho 1 &gt; /sys/class/leds/fpga_led1/brightness\n</code></pre></p> <p>Because of how the LEDs are connected, for the above commands <code>0</code> means LED is turned on, <code>1</code> means LED is turned off.</p> Connect to Board Using SSH <p>1. Boot to Linux  </p> <p>2. Determine the board IP address using the <code>ifconfig</code> command: <pre><code>root@agilex5devkit:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 192.168.1.153  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 fe80::f0eb:c8ff:fec4:eed7  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether f2:eb:c8:c4:ee:d7  txqueuelen 1000  (Ethernet)\nRX packets 649  bytes 45132 (44.0 KiB)\nRX errors 0  dropped 226  overruns 0  frame 0\nTX packets 56  bytes 8789 (8.5 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 23  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 100  bytes 8408 (8.2 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 100  bytes 8408 (8.2 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> 3. Connect to the board over SSH using <code>root</code> username, no password will be requested: <pre><code>ssh root@192.168.1.153\n</code></pre> Note: Make sure to replace the above IP address to the one matching the output of running <code>ifconfig</code> on youir board.</p> Visit Board Web Page <p>1. Boot to Linux  </p> <p>2. Determine board IP address using <code>ifconfig</code> like in the previous scenario  </p> <p>3. Start a web browser and enter the IP address in the address bar  </p> <p>4. The web browser will display a page served by the web server running on the board.  </p> <p></p> <ul> <li>You will able to see which LED are ON and OFF in LED Status.</li> <li>You can Start and Stop the LED from scrolling. Set the delay(ms) in the LED Lightshow box. </li> <li>You can controll each LED with ON and OFF button.</li> <li>Blink each LED by entering the delay(ms) and click on the BLINK button.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-qspi","title":"Booting from QSPI","text":"<p>This section presents how to boot from QSPI. One notable aspect is that you need to wipe the SD card partitioning information, as otherwise U-Boot SPL could find a valid SD card image, and try to boot from that first.</p> Wipe SD Card <p>Either write 1MB of zeroes at the beginning of the SD card, or remove the SD card from the HPS Daughter Card. You can use <code>dd</code> on Linux, or <code>Win32DiskImager</code> on Windows to achieve this.</p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/agilex_flash_image.hps.jic.tar.gz\ntar xf agilex_flash_image.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;agilex_flash_image.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>Note: On first boot, the UBIFS rootfilesystem is initialized, and that takes a few minutes. This will not happen on next reboots. See a sample log below:</p> <pre><code>[   17.033558] UBIFS (ubi0:4): Mounting in unauthenticated mode\n[   17.039470] UBIFS (ubi0:4): background thread \"ubifs_bgt0_4\" started, PID 130\n[   17.061510] UBIFS (ubi0:4): start fixing up free space\n[   20.644496] random: crng init done\n[   27.120040] platform soc:leds: deferred probe pending\n[  243.190874] UBIFS (ubi0:4): free space fixup complete\n[  243.315909] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[  243.323290] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[  243.332653] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-nand-board","title":"HPS NAND Board","text":"<p>This section presents how to use HPS NAND Board to boot from eMMC.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-emmc","title":"Booting from eMMC","text":"Configure Board <p>For this scenario, we are using the HPS NAND Board, which can be configured through dipswitch SW3 to enable either eMMC or NAND. Set SW3 to ON to enable eMMC.</p> Write eMMC Flash <p>We are writing the eMMC Flash by using U-Boot commands. We are getting to U-Boot prompt by booting from QSPI using a JIC image which contains U-Boot, thereby not relying on what is already in eMMC.</p> <p>1. Download, and extract the eMMC image <pre><code>wget https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc/sdimage.tar.gz\ntar xf sdimage.tar.gz\n</code></pre> 2. Split the eMMC image into 1GB chunks and copy them to your TFT folder: <pre><code>split --bytes=1G gsrd-console-image-agilex5_devkit.wic\nmv xa* &lt;your_tfp_folder&gt;\n</code></pre> This will put the two chunks called <code>xaa</code> and <code>xab</code> on your TFTP folder. 3. Power down the board. </p> <p>4. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>5. Power up the board</p> <p>6. Download the helper JIC used to write the eMMC image, extract it and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc/uboot.jic.tar.gz\ntar xf uboot.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;uboot.jic\"\n</code></pre> 7. Determine your host IP address using <code>ifconfig</code> to use it as the IP address of the TFTP server</p> <p>8. Power down the board</p> <p>9. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>10. Power up the board</p> <p>11. Stop U-Boot at the boot countdown, to drop to U-Boot console</p> <p>12. At the U-Boot console, run the following commands to write the SD card image: <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;tftp_server_ip_address&gt;\ntftp ${loadaddr} xaa\nsetexpr blkcnt1 ${filesize} / 0x200\nmmc write ${loadaddr} 0 ${blkcnt1}\ntftp ${loadaddr} xab\nsetexpr blkcnt2 ${filesize} / 0x200\nmmc write ${loadaddr} ${blkcnt1} ${blkcnt2}\n</code></pre> Note: If you already have a valid image in eMMC, the U-Boot SPL which runs from QSPI will be able to see that and load it instead of the U-Boot from QSPI. To prevent this from happening, you can wipe out the eMMC card partitioning, then issue a reset for U-Boot to reboot into the QSPI helper JIC:</p> <pre><code>mw.w ${loadaddr} 0x0 0x80000\nmmc rescan\nmmc write ${loadaddr} 0x0 0x400\nreset\n</code></pre> Write QSPI Flash <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download the JIC and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz tar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Board will boot to Linux. Enter <code>root</code> as username, no password will be requested</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-test-board","title":"HPS Test Board","text":"<p>This section presents how to use HPS Test Board to boot from SD card.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-sd-card_1","title":"Booting from SD Card","text":"Configure Board <p>For this scenario we are using the HPS Test Board. There is single dipswitch on that board called SW1, which needs to be set to the ON position.</p> Write SD Card <p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2024.05/debug/agilex5_dk_a5e065bb32aes1_debug/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the SD card image to the micro SD card using the included USB writer in the host computer, and <code>dd</code> utility on Linux, or  Win32DiskImager on Windows, available at https://sourceforge.net/projects/win32diskimager. Please refer to the Booting from SD Card section for more details about this.</p> Write QSPI Flash <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download the JIC and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.05/debug/agilex5_dk_a5e065bb32aes1_debug/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz tar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Board will boot to Linux. Enter <code>root</code> as username, no password will be requested</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#rebuilding-the-gsrd","title":"Rebuilding the GSRD","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#yocto-build-prerequisites","title":"Yocto Build Prerequisites","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-enablement-board_1","title":"HPS Enablement Board","text":"<p>This section presents how to build the binaries for HPS Enablement Board.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-sd-card-boot-binaries","title":"Build SD Card Boot Binaries","text":"<p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.enablement\nmkdir agilex5_gsrd.enablement\ncd agilex5_gsrd.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-qspi-boot-binaries","title":"Build QSPI Boot Binaries","text":"<p>The diagram below shows how booting from QSPI JIC is built. The hardware project compilation and Yocto build remain the same, and the QSPI JIC is built based on the resulted files: </p> <p>1. Create the folder to contain all the files:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf qspi_boot\nmkdir qspi_boot\ncd qspi_boot\n</code></pre> <p>2. Get the <code>ubinize.cfg</code> file which contains the details on how to build the <code>root.ubi</code> volume, and <code>agilex5_devkit_flash_image_hps.pfg</code> which contains the instructions for Programming File Generator on how to create the .jic file:</p> <pre><code>wget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/ubinize.cfg\nwget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>3. Link to the files that are needed from building the hardware design, and yocto:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nor.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof .\n</code></pre> <p>4. Process the u-boot.itb file to be exactly 2MB in size:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the <code>root.ubi</code> file and rename it to <code>hps.bin</code> as Programming File Generator needs the <code>.bin</code> extension:</p> <pre><code>ubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>6. Create the JIC file:</p> <pre><code>quartus_pfg -c agilex5_devkit_flash_image_hps.pfg\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-nand-board_1","title":"HPS NAND Board","text":"<p>This section presents how to build the binaries for HPS NAND Board, for booting from eMMC.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-emmc-binaries","title":"Build eMMC binaries","text":"<p>The following diagram shows how to build the eMMC binaries that target the HPS NAND Daughtercard: </p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.emmc\nmkdir agilex5_gsrd.emmc\ncd agilex5_gsrd.emmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 DAUGHTER_CARD=devkit_dc_emmc generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf</code> </p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_emmc_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_emmc_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_emmc_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_emmc_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_emmc_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_emmc_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul> Building QSPI Helper JIC <p>We are writing the eMMC Flash by using U-Boot commands. We are getting to U-Boot prompt by booting from QSPI using a helper JIC image which contains U-Boot, thereby not relying on what is already in eMMC. The following diagram illustrates how the helper JIC is built, base on the GHRD and Yocto compilation results: </p> <p>1. Create folder to contain the helper JIC artifacts</p> <pre><code>cd $TOP_FOLDER\nrm -rf jic-helper\nmkdir jic-helper\n</code></pre> <p>2. Retrieve the .pfg file instructing the Quartus Programming File Generator on how to create the JIC file, and tweak it a little bit to make it smaller:</p> <pre><code>cd jic-helper\nwget https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc/uboot-only.pfg\nsed -i 's/directory=/hps=\"1\" directory=/g' uboot-only.pfg\nsed -i 's/type=\"JIC\"/type=\"PERIPH_JIC\"/g' uboot-only.pfg\nsed -i 's/MT25QU02G/MT25QU01G/g' uboot-only.pfg\n</code></pre> <p>3. Bring in the files that are needed:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof .\n</code></pre> <p>4. Process <code>u-boot.itb</code> file to be exactly 2MB in size, and have a <code>.bin</code> extension as needed by Quartus Programming File Generator:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the JIC file:</p> <pre><code>quartus_pfg -c uboot-only.pfg\n</code></pre> <p>The following file will be created:</p> <ul> <li><code>$TOP_FOLDER/jic-helper/agilex_flash_image.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-test-board_1","title":"HPS Test Board","text":"<p>This section presents how to build the binaries for HPS Test Board.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-sd-card-binaries","title":"Build SD Card Binaries","text":"<p>The following diagram shows how the binaries are built for the HPS Test Daughtercard:  </p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf agilex5_gsrd.test\nmkdir agilex5_gsrd.test\ncd agilex5_gsrd.test\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 DAUGHTER_CARD=debug2 generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>Replace the file <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_debug2_ghrd.core.rbf</code> with the rebuilt core.rbf file:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_debug2_ghrd.core.rbf\nrm -f $CORE_RBF\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\n</code></pre> Build Yocto <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/","title":"Agilex\u2122 5 FPGA Remote Debug Example","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#introduction","title":"Introduction","text":"<p>Intel offers an integrated set of System Level Debug (SLD) tools, including:</p> <ul> <li>SignalTap II Logic Analyzer</li> <li>In-System Sources and Probes (ISSP),</li> <li>In-System Memory Content Editor)</li> </ul> <p>Typically, the System-Level Debugging (SLD) communication solution was interfacing with the outside world through the JTAG. Then either an USB or Ethernet Blaster could be used to interface JTAG to the host PC.</p> <p></p> <p></p> <p>Another alternative approach is also available, to interface the SLD to the outside world directly through Ethernet, without requiring either an USB or Ethernet Blaster.</p> <p></p> <p>This page presents an example on how enable this remote debug feature on top of the GSRD.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#architecture","title":"Architecture","text":"<p>In the traditional approach the SLD communication solution was based on the Altera JTAG Interface (AJI) which interfaced with the JTAG TAP controller (hard atom in Altera devices which implements the JTAG protocol). The SLD tools used the JTAG channel for communication between software and hardware.</p> <p></p> <p>The remote FPGA debugging solution consists of the following:</p> <ul> <li>JTAG-Over Protocol (JOP) Component: Platform Designer component which enables access to debug information through an Avalon\u00ae-MM slave bus</li> <li>Etherlink: HPS application exporting debug information over Ethernet, available on github: https://github.com/altera-opensource/remote-debug-for-intel-fpga</li> </ul> <p></p> <p>The JOP component requires reset and clocking and also provides an Avalon\u00ae-MM slave bus through which is configured and debug information is accessed.</p> <p>Th Etherlink application runs on HPS, accesses the JOP component slave bus to access the debug information, and provides a TCP/IP link from the host PC running the Quartus Pro debug tools to the board.</p> <p>The etherlink works with the standard UIO Linux kernel driver.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#example","title":"Example","text":"<p>This section shows an example of how to use the Remote Debug feature. Communication is established from the board to the host PC through Ethernet, so that the board appears as another JTAG device, listed by jtagconfig utility.</p> <p>The example is based on the GSRD, with the following changes:</p> <ul> <li>Adding JOP component to the GHRD</li> <li>Adding JOP to the Linux device tree</li> </ul> <p>Notes:</p> <ul> <li>UIO driver is enabled as module in the default kernel configuration file</li> <li>etherlink is already part of the rootfs, built by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Altera Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1.<ul> <li>HPS Enablement Expansion Board. Included with the development kit.</li> <li>SD/MMC HPS Daughtercard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intell\u00ae FPGA Download Cable II</li> </ul> </li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera Quartus\u00ae Prime Pro Edition Version 24.3</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for more information about the development kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex5.remote_debug\nmkdir agilex5.remote_debug\ncd agilex5.remote_debug\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#build-hardware-design","title":"Build Hardware Design","text":"<p>1. Generate the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 generate_from_tcl\n</code></pre> <p>2. Open the project in Quartus, open the <code>qsys_top.qsys</code> file in Platform Designer.</p> <p>3. In the IP Catalog search for jop and double-click the component to add it to the system:</p> <p></p> <p>4. Configure the JOP component as follows:</p> <p></p> <p>5. Connect the reset and clock to JOP component, also connect it's slave bus to the HPS LW bridge, and map it at offset 0x0002_0000:</p> <p></p> <p>6. Alternatively, steps 2-6 can be peformed from command line, using the provided tcl script:</p> <pre><code>cd $TOP_FOLDER\nrm -f agilex5-ghrd-add-jop.tcl\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-5/e-series/premium/remote-debug/collateral/agilex5-ghrd-add-jop.tcl\ncd agilex5_soc_devkit_ghrd\nqsys-script --qpf=ghrd_a5ed065bb32ae6sr0.qpf --script=../agilex5-ghrd-add-jop.tcl --system-file=qsys_top.qsys\n</code></pre> <p>7. Finish compilation of the GHRD from command line:</p> <pre><code>cd $TOP_FOLDER/agilex5_soc_devkit_ghrd\nmake sof\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#build-corerbf-file","title":"Build Core.RBF File","text":"<p>This section shows how to create the core RBF file, which is needed by the Yocto recipes:</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#build-yocto","title":"Build Yocto","text":"<p>Perform the following steps to build Yocto:</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> <p>3. Enable the JOP UIO driver in the Linux device tree, by editing the file <code>meta-intel-fpga-refdes</code> to inlcude the changes shown below:</p> <pre><code>diff --git a/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi b/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi\nindex 9e043ef..ceac3aa 100644\n--- a/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi\n+++ b/recipes-bsp/device-tree/files/socfpga_agilex5_ghrd.dtsi\n@@ -49,6 +49,11 @@\n                                resetvalue = &lt;0&gt;;\n                };\n */\n+               jop@20020000 {\n+                       compatible = \"generic-uio\";\n+                       reg = &lt;0x20020000 0x4000&gt;;\n+                       reg-names = \"jop\";\n+               };\n                soc_leds: leds {\n                        compatible = \"gpio-leds\";\n</code></pre> <p>Note that the range of memory where the JOP is located is <code>0x20020000</code> .. <code>0x20023fff</code>.</p> <p>This can be done with the provided patch file:</p> <pre><code>rm -f agilex5-dts-add-jop.patch\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-5/e-series/premium/remote-debug/collateral/agilex5-dts-add-jop.patch\npushd meta-intel-fpga-refdes\npatch -p1 &lt; ../agilex5-dts-add-jop.patch\npopd\n</code></pre> <p>4. Update your Yocto recipes to use the core RBF file you have built, similar to how the GSRD does it:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>5. Build the Yocto recipes:</p> <pre><code>bitbake_image\n</code></pre> <p>6. Gather the Yocto binaries:</p> <pre><code>package\n</code></pre> <p>The following relevant files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#build-qspi-image","title":"Build QSPI Image","text":"<p>Run the following commands to build the QSPI image:</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#run-example","title":"Run Example","text":"<p>The instructions from this section present how to run the remote debug example. Refer to the GSRD for more detailed instructions on how to set up the board, serial port, and write the binaries.</p> <p>1. Write the QSPI image <code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code> to flash.</p> <p>2. Extract and write the SD card image <code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code> to the SD card</p> <p>3. Boot board and log into Linux.</p> <p>4. Determine board IP address by running the <code>ifconfig</code> command:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 10.122.105.175  netmask 255.255.255.0  broadcast 10.122.105.255\n        inet6 fe80::7097:4bff:fe41:b7c2  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 72:97:4b:41:b7:c2  txqueuelen 1000  (Ethernet)\nRX packets 218  bytes 23619 (23.0 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 78  bytes 11072 (10.8 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 22  </code></pre> <p>5. Remove pre-existing instances of the driver, and load it again:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# rmmod uio_pdrv_genirq\nroot@agilex5dka5e065bb32aes1:~# modprobe uio_pdrv_genirq of_id=\"generic-uio\"\n</code></pre> <p>6. Start the etherlink application, specifying which port to accept connections on as shown below:</p> <pre><code>root@agilex5dka5e065bb32aes1:~# etherlink --port=33301\nINFO: Etherlink Server Configuration:\nINFO:    H2T/T2H Memory Size  : 4096\nINFO:    Listening Port       : 33301\nINFO:    IP Address           : 0.0.0.0\nINFO: UIO Platform Configuration:\nINFO:    Driver Path: /dev/uio0\nINFO:    Address Span: 16384\nINFO:    Start Address: 0x0\nINFO: Server socket is listening on port: 33301\n</code></pre> <p>7. On the host, establish the JTAG communication to the board through Ethernet, using the board IP and the selected port number:</p> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0\n</code></pre> <p>8. Also on the host, run the 'jtagconfig' command to show the newly added connection:</p> <pre><code>$ jtagconfig\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0]\n020D10DD   VTAP10\n</code></pre> <p>At this point, the connection can be used by the tools which need a JTAG connection, like SignalTap.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/remote-debug/ug-remote-debug-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/","title":"Agilex\u2122 5 SoC HPS Remote System Update Example","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on the Agilex\u2122 5 E-Series Premium Development Kit (DK-A5E065BB32AES1), including the following.</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>At the moment, the Agilex\u2122 5 Hard Processor System Remote System Update User Guide is not availabe but you can refer to the  Agilex\u2122 7 Hard Processor System Remote System Update User Guide for details about the Remote System Update. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#component-versions","title":"Component Versions","text":"<p>Note: RSU functionality is first fully enabled in U-Boot in 24.3 release, while Linux functionality is enabled starting on 24.2 release.</p> <p>This example was created with Quartus\u00ae Prime Pro Edition Version 24.3 and the following component versions.</p> Repository Branch/Tag ghrd-socfpga QPDS24.3_REL_GSRD_PR linux-socfpga socfpga-6.6.37-lts/QPDS24.3_REL_GSRD_PR arm-trusted-firmware socfpga_v2.11.0/QPDS24.3_REL_GSRD_PR u-boot-socfpga socfpga_v2024.04/QPDS24.3_REL_GSRD_PR librsu master"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus\u00ae Prime Pro Edition Version 24.3  for compiling the hardware projects, generating the flash images and writing to flash </li> <li>cmake/3.24.0  (build configuration tool) or or above to build LibRSU library.</li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li>Agilex\u2122 5 E-Series Premium Development Kit (DK-A5E065BB32AES1)  for running the example. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are these.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul> <p>Note: To build binaries for a different development kit than the one used in this page, please refer to the Building the Hardware Projects section in the corresponding  GSRD page for that development kit, which is the section that may differ from the instructions presented here.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#installing-cmake","title":"Installing cmake","text":"<p>In case that you have installed a cmake version earlier than 3.24.0, you need to unistall this and install a new version. Here are the steps to achieve that. Note that this only need to performed once in your PC:</p> <pre><code>sudo apt remove cmake\nDownload cmake-x.y.z-linux-x86_64.sh from https://cmake.org/download\nsudo cp ~/Downloads/cmake-x.y.z-linux-x86_64.sh /opt/\nsudo chmod +x /opt/cmake-x.y.z-linux-x86_64.sh\nmkdir ~/cmake_install/  &amp;&amp; cd ~/cmake_install/\nsudo bash /opt/cmake-x.y.z-linux-x86_64.sh\nsudo ln -s ~/cmake_install/cmake-x.y.z-linux-x86_64/bin/* /usr/local/bin/\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex5-rsu mkdir agilex5-rsu cd agilex5-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next.</p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below.</p> <pre><code>cd $TOP_FOLDER # compile hardware designs: 0-factory, 1,2-applications, 3-factory update \nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex5_soc_devkit_ghrd . rm -rf ghrd-socfpga for version in {0..3}\ndo\nrm -rf ghrd.$version\ncp -r agilex5_soc_devkit_ghrd ghrd.$version\ncd ghrd.$version\n# update sysid to make binaries slightly different\nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' construct_subsys_peripheral.tcl\nmake config\n# Select FPGA Boot first, Enable WDT, Configure WDT to trigger cold reset + RSU on expiration\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 INITIALIZATION_FIRST=fpga RESET_WATCHDOG_EN=1 RESET_SDM_WATCHDOG_CFG=2 generate_from_tcl\n# Set to 3 the WDT retry counter to trigger a RSU\necho \"set_global_assignment -name RSU_MAX_RETRY_COUNT 3\" &gt;&gt; ghrd_a5ed065bb32ae6sr0.qsf\nmake sof\ncd .. done rm -rf agilex5_soc_devkit_ghrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created.</p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/output_files/ghrd_a5ed065bb32ae6sr0.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/output_files/ghrd_a5ed065bb32ae6sr0.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/output_files/ghrd_a5ed065bb32ae6sr0.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/output_files/ghrd_a5ed065bb32ae6sr0.sof </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\n# checkout the branch used for this document, comment out to use default\ngit checkout -b test -t origin/socfpga_v2.11.0\nmake -j 48 PLAT=agilex5 bl31\ncd ..\n</code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga # comment out next line to use the latest default branch \ngit checkout -b test -t origin/socfpga_v2024.04 # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# use 'Image' for kernel image instead of 'kernel.itb' \nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n\n## Fix to report FSBL state to SDM HSD: 14023897270\nsed -i '/mbox_init();/d' arch/arm/mach-socfpga/spl_agilex5.c\nsed -i '/timer_init();/a\\\\tmbox_init();\\n\\tmbox_hps_stage_notify(HPS_EXECUTION_STATE_FSBL);' arch/arm/mach-socfpga/spl_agilex5.c\n\n# Need fix in arch/arm/mach-socfpga/smc_api.c from HSD:14023661564  \nsed -i '/flush_dcache_range/s/arg + len/(arg + len)/g' arch/arm/mach-socfpga/smc_api.c\nsed -i '/flush_dcache_range/s/resp_buf + \\*resp_buf_len/(resp_buf + \\*resp_buf_len)/g' arch/arm/mach-socfpga/smc_api.c\nsed -i '/flush_dcache_range/s/(u64)/(uintptr_t)/g' arch/arm/mach-socfpga/smc_api.c\nsed -i '/if (ret == INTEL_SIP_SMC_STATUS_OK &amp;&amp;/a \\\\t\\tinvalidate_dcache_range((uintptr_t)resp_buf, (uintptr_t)(resp_buf + \\*resp_buf_len));' arch/arm/mach-socfpga/smc_api.c # link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\n# Enabling Watchdog automatically if it's not done already\nCONFIG_WATCHDOG_AUTOSTART=y\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable; mmc rescan; run mmcload; run linux_qspi_enable; run rsu_status; setenv bootargs console=ttyS0,115200 root=${mmcroot} rw rootwait;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone https://github.com/altera-opensource/linux-socfpga cd linux-socfpga # checkout the branch used for this document, comment out to use default \ngit checkout -b test -t origin/socfpga-6.6.37-lts # configure the RSU driver to be built into the kernel \nmake clean &amp;&amp; make mrproper make defconfig ./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y make oldconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb cd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is being included in this page. You can see it below. </p> <pre><code>&lt;pfg version=\"1\"&gt;\n&lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n&lt;output_files&gt;\n&lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n&lt;file_options/&gt;\n&lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n&lt;/output_file&gt;\n&lt;/output_files&gt;\n&lt;bitstreams&gt;\n&lt;bitstream id=\"Bitstream_1\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.0/output_files/ghrd_a5ed065bb32ae6sr0.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;bitstream id=\"Bitstream_2\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.1/output_files/ghrd_a5ed065bb32ae6sr0.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;/bitstreams&gt;\n&lt;flash_devices&gt;\n&lt;flash_loader&gt;A5ED065BB32AR0&lt;/flash_loader&gt;\n&lt;flash_device type=\"QSPI02G\" id=\"Flash_Device_1\"&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0020FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n&lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00210000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x02000000\" e_addr=\"0x02FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03000000\" e_addr=\"0x03FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n&lt;/flash_device&gt;\n&lt;/flash_devices&gt;\n&lt;assignments&gt;\n&lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n&lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n&lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;/assignments&gt;\n&lt;/pfg&gt;\n</code></pre> <p>You can also downloaded and use it to generate the flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER # Get the .pfg file\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-5/e-series/premium/rsu/collateral/initial_image.pfg\n\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/intelFPGA_pro/24.2/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg </code></pre> <p>Here are the complete instructions on how to manually create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER qpfgw &amp; </code></pre> </li> <li> <p>Select the Device family as Agilex 5, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bitswap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file ghrd_a5ed065bb32ae6sr0.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/output_files/ghrd_a5ed065bb32ae6sr0.sof image. This is the initial application image. The tab now looks like below.</p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. This opens the window to browse for the FSBL and select authentication and encryption settings. </p> <p> </p> </li> <li> <p>Click the Bootloader  (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the QSPI02G in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (ghrd_a5ed065bb32ae6sr0.sof). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0090FFFF in order to reserve 7MB for the factory image. This end address was calculated by adding 8MB to the end of the BOOT_INFO partition. Click OK. </p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be trieed after all the application images failed. </p> </li> <li> <p>Select the QSPI02G flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(ghrd_agfb014r24b2e2v.sof). This becomes the initial application image. Select the Page as 1. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x01000000 and End Address = 0x01FFFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.   The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image</p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions) and set the start and end addresses as follows. </p> <p>* P2: Start Address = 0x02000000 and End Address = 0x02FFFFFF.    * P3: Start Address = 0x03000000 and End Address = 0x03FFFFFF. </p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER quartus_pfg -c initial_image.pfg </code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -rf images/application2.rpd\nquartus_pfg -c hw/ghrd.2/output_files/ghrd_a5ed065bb32ae6sr0.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON\n</code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/factory_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_a5ed065bb32ae6sr0.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created. </p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/decision_firmware_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_a5ed065bb32ae6sr0.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decision firmware update image is created. </p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_a5ed065bb32ae6sr0.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/output_files/ghrd_a5ed065bb32ae6sr0.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul> <p>Notes:</p> <ul> <li>The first SOF file contains the factory image, from which data is taken to fill out the new decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from this SOF file is not used.</li> <li>The app_image parameter contains the SOF that is used for the application image section of the combined image.</li> <li>The hps_path parameter is unused, and may be removed in the future.</li> <li>The app_image_hps_path parameter contains the HPS FSBL hex file to be used for the application imge section of the combined image.</li> <li>When using HPS first, the additional parameter \"-o hps=1\" needs to be added, and the following files are created combined_application.hps.rpd (combined application image)  and combined_application.core.rbf (corresponding fabric configuration file).</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b scarthgap https://git.yoctoproject.org/poky git clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga git clone -b scarthgap   https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal </code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf zlib-1.3.1 wget http://zlib.net/zlib-1.3.1.tar.gz tar xf zlib-1.3.1.tar.gz rm zlib-1.3.1.tar.gz cd zlib-1.3.1/ export CROSS_PREFIX=${CROSS_COMPILE} ./configure make export ZLIB_PATH=`pwd` cd .. </code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.3.1/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.3.1/libz.so* - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application. </p> <pre><code>cd $TOP_FOLDER rm -rf librsu git clone https://github.com/altera-opensource/librsu cd librsu # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/master \ncmake -S . -B build -G\"Ninja\" -DPLATFORM=linux-aarch64 &amp;&amp; cmake --build build\ncd .. </code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/librsu/build/lib/libuniLibRSU.so.1 - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/librsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/librsu/build/bin/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example. The rsu_client application requires to be linked with the libuniLibRSU.so.1 library. This can be performed from Linux running in the Agilex 5 device using the ldconfig command. In this example, we are accomplishing this by adding the S99linkRSULib.sh script into the /etc/rcS.d/ directoyy in the file system. This script will be executed automatically at boot time. Notice that this only needs to be done once, after the SD card gets programmed.</p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2021.04/gsrd/\\\ntools/make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n# Creating  initial script to execute it during Linux boot up so we can link rsu_client with \ncat &lt;&lt; EOF &gt; S99linkRSULib.sh\n#!/bin/sh\n# SPDX-License-Identifier: GPL-2.0-only\n### BEGIN INIT INFO\n# Provides: banner\n# Required-Start:\n# Required-Stop:\n# Default-Start:     S\n# Default-Stop:\n### END INIT INFO\necho \"Calling ldconfig to Lin rsu_client with libuniLibRSU.so.1\"\nldconfig\nEOF\n# prepare the fat contents \nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\nsudo sed -i 's/agilex5_dk_a5e065bb32aes1/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\n# This also could be copy to /usr/bin/ so it can be accessed from anywhere\nsudo cp $TOP_FOLDER/librsu/build/bin/rsu_client home/root/\nsudo cp $TOP_FOLDER/librsu/build/lib/libuniLibRSU.so.1 usr/lib/\nsudo cp $TOP_FOLDER/librsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\n# We need to link rsu_client with libuniLibRSU.so.1. So we do it during Linux bootup\nsudo cp ../S99linkRSULib.sh etc/rcS.d/\nsudo chmod +x etc/rcS.d/S99linkRSULib.sh\ncd ..\n# create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_agilex5_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_agilex5_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card. </p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Agilex SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to JTAG. </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer.</p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\" </code></pre> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to QSPI. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_agilex5_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Agilex SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <p>Note: RSU functionality in U-Boot is enabled starting on 24.3 release.</p> <ol> <li> <p>Power up the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2024.04-35102-g135e53726d-dirty (Nov 23 2024 - 13:23:54 -0600)\nReset state: Cold\nMPU           800000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nis_ddr_csr_clkgen_locked: ddr csr io96b_0 clkgenA is successfully locked\nio96b_cal_status: Calibration for IO96B instance 0x18400400 done at 0 msec!\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\n:\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 0\nNOTICE:  BL31: v2.11.0(release):QPDS24.3_REL_GSRD_PR\nNOTICE:  BL31: Built : 13:23:25, Nov 23 2024\n\nU-Boot 2024.04-35102-g135e53726d-dirty (Nov 23 2024 - 13:23:54 -0600)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  50 devices, 25 uclasses, devicetree: separate\nWDT:   Started watchdog@10d00200 with servicing every 1000ms (10s timeout)\nWDT:   Started watchdog@10d00300 with servicing every 1000ms (10s timeout)\nWDT:   Started watchdog@10d00400 with servicing every 1000ms (10s timeout)\nWDT:   Started watchdog@10d00500 with servicing every 1000ms (10s timeout)\nWDT:   Started watchdog@10d00600 with servicing every 1000ms (10s timeout)\nMMC:   mmc0@10808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@10c02000\nOut:   serial0@10c02000\nErr:   serial0@10c02000\n:\nHit any key to stop autoboot:  0 \nSOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options. </p> <pre><code>SOCFPGA # rsu \nrsu - Agilex SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name &lt;name&gt; - find slot by name and display the slot number slot_count - display the slot count slot_disable &lt;slot&gt; - remove slot from CPB slot_enable &lt;slot&gt; - make slot the highest priority slot_erase &lt;slot&gt; - erase slot slot_get_info &lt;slot&gt; - display slot information slot_load &lt;slot&gt; - load slot immediately slot_load_factory - load factory immediately slot_priority &lt;slot&gt; - display slot priority slot_program_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program buffer into slot, and make it highest priority slot_program_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program raw buffer into slot slot_program_factory_update_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program factory update buffer into slot, and make it highest priority slot_rename &lt;slot&gt; &lt;name&gt; - rename slot slot_delete &lt;slot&gt; - delete slot slot_create &lt;name&gt; &lt;address&gt; &lt;size&gt; - create slot slot_size &lt;slot&gt; - display slot size slot_verify_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against buffer slot_verify_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against raw buffer status_log - display RSU status update &lt;flash_offset&gt; - Initiate firmware to load bitstream as specified by flash_offset notify &lt;value&gt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt &lt;address&gt; - restore SPT from an address save_spt &lt;address&gt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb &lt;address&gt; - restore CPB from an address save_cpb &lt;address&gt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00920000 RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00210000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000210000 Length: 0x00700000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code> SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 24.3.0 DCMF1 version = 24.3.0  DCMF2 version = 24.3.0  DCMF3 version = 24.3.0  SOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 16777216. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 16777216. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 16777216. </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased. SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n2248704 bytes read in 103 ms (20.8 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Power cycle the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting the specific image to be loaded, in this case using the following command.</p> <pre><code>SOCFPGA # rsu slot_load 1 \n</code></pre> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands. </p> <pre><code>SOCFPGA # rsu update 0x01000000 \nRSU: RSU update to 0x0000000001000000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log to confirm it.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202:  both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report.</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code>SOCFPGA # mw.l 10D00204 0 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value. </p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf0061234 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it. </p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n2478080 bytes read in 113 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nSlot 2 was programmed with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2. </p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x02000000 0x10000 \nSF: 16384 bytes @ 0x2000000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf004d003 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status. </p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 512 KB). </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x10000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d00f Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot. </p> <p><pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> 6. Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image : 0x01000000 Last Fail Image : 0x00100000 State : 0xf004d010 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre>   The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted Current Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d011 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre>   The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected. </p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created. </p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <p><pre><code>SOCFPGA # rsu clear_error_status \n</code></pre>   Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds. </p> <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. </p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x918000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF Bad SPT0 magic number 0xFFFFFFFF no valid SPT0 and SPT1 found Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the highest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails. </p> <pre><code>SOCFPGA # rsu slot_count \ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#using-the-combined-application-image","title":"Using the Combined Application Image","text":"<p>This section shows an example of using a combined application image, from U-Boot. Similar commands can be used from Linux.</p> <p>The combined application images are used the exact same way as regular application images, just that they first update the decision firmware and decision firmware data if necessary, before the device is configured with the functionality from the application SOF.</p> <p>Note: The combined application images do not have absolute pointers inside like the regular application images, the factory update images, or the decision firmware update images. Because of this, they can be written to flash with any of the U-Boot and LibRSU APIs that write to slots.</p> <ol> <li> <p>Program the RSU initial image created with the previous version ($TOP_FOLDER/initial_image_prev.jic).</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_prev.jic\"\n</code></pre> </li> <li> <p>Power cyle the board, stop to U-Boot prompt and query the decision firmware information from U-Boot, this should be a previous version.</p> <pre><code>SOCFPGA # rsu display_dcmf_version\nDCMF0 version = 24.2.0 DCMF1 version = 24.2.0 DCMF2 version = 24.2.0 DCMF3 version = 24.2.0 </code></pre> </li> <li> <p>Find an unused slot (slot 1, P2), erase it, write the combined application image to it, verify that it was programmed successfully  and check it is now the highest priority.</p> <pre><code>SOCFPGA # rsu slot_erase 1\nSlot 1 erased.\nSOCFPGA # fatload mmc 0:1 ${loadaddr} combined_application.rpd\n151552 bytes read in 9 ms (16.1 MiB/s)\nSOCFPGA # rsu slot_program_buf 1 ${loadaddr} ${filesize}\nSlot 1 was programmed with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_verify_buf 1 ${loadaddr} ${filesize}\nSlot 1 was verified with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_get_info 1\nNAME: P2\nOFFSET: 0x0000000002000000\nSIZE: 0x01000000\nPRIORITY: 1\n</code></pre> </li> <li> <p>Pass control to the combined application update image.</p> <pre><code>SOCFPGA # rsu slot_load 1\n</code></pre> </li> <li> <p>The combined application image checks the currently used decision firmware copy, it sees that it is older, then it updates the decision firmware and decision firmware data, then it loads the actual application image section. Everything takes a few seconds.</p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware is updated, and the application image is running fine.</p> <pre><code>SOCFPGA # rsu status_log\nCurrent Image : 0x02000000\nLast Fail Image : 0x00000000\nState : 0x00000000\nVersion : 0x00000202\nError location : 0x00000000\nError details : 0x00000000\nRetry counter : 0x00000000\nSOCFPGA # rsu display_dcmf_version\nDCMF0 version = 24.3.0 DCMF1 version = 24.3.0 DCMF2 version = 24.3.0 DCMF3 version = 24.3.0\n</code></pre> </li> <li> <p>Power cycle the board, the same combined application image is loaded, as it is the highest priority. But it takes a couple of seconds less, as the decision firmware does not need to be updated.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <p>Note: RSU functionality in Linux is enabled starting on 24.2 release.</p> <ol> <li> <p>Power up the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message. </p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 24.3.0 DCMF1 version = 24.3.0\nDCMF2 version = 24.3.0\nDCMF3 version = 24.3.0\nOperation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status.  It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting a specific image to be loaded, using the following commands.</p> <pre><code>./rsu_client --request 1 reboot </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202:both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report .</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux.</p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number. </p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux and display the status:  It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB. </p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot.</p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB. </p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is required to have the status available in Linux. </p> <ol> <li> <p>Power up the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions. </p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --    slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is not rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status: </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash.</p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status. </p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> </li> </ol> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.  Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> <ol> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails. </p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created. </p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine. </p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/rsu/ug-rsu-agx5e-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/","title":"Agilex\u2122 5 E-Series Premium Development Kit Time Sensitive Network (TSN) - HPS RGMII System Example Design","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#introduction","title":"Introduction","text":"<p>IEEE Ethernet is a core technology which is a backbone for IT operations and was designed to provide best effort communication suitable for IT operations. Operational Technology vendors have innovatively used Core IEEE Ethernet technology with proprietary solutions for enabling time-bounded communication. To address the need for precision timing, traffic shaping, and time-bounded communication over networks, IEEE introduced a suite of standards known as Time Sensitive Networking (TSN).</p> <p>Agilex\u2122 5 E-Series is designed as an end point for Industrial automation application with support for the following TSN protocols:</p> <ul> <li>Time Synchronization Protocols:<ul> <li>IEEE 1588-2008 Advanced Timestamp (Precision Time Protocol - PTP):<ul> <li>Function: Provides sub-microsecond accuracy for time synchronization between computing systems over a local area network.</li> <li>Key Features: 2-step synchronization, PTP offload, and timestamping.</li> <li>Use Case: Synchronizing industrial devices to operate in unison, ensuring coordinated actions across factory or plant operations.</li> </ul> </li> <li>IEEE 802.1AS (Timing and Synchronization):<ul> <li>Function: A profile of PTP (version 2) that ensures precise time synchronization in a hierarchical master-slave architecture.</li> <li>Key Features: Prioritizes accuracy and variability of timing, crucial for industrial and automotive systems.</li> <li>Use Case: Synchronizing devices to a common time for optimal operation and collaboration.</li> </ul> </li> </ul> </li> </ul> <ul> <li>Credit Based Shaper Protocol:<ul> <li>IEEE 802.1Qav (Time-Sensitive Streams Forwarding and Queuing):<ul> <li>Function: Provides low-latency, time-synchronized delivery of audio and video streams over Ethernet networks.</li> <li>Key Features: Credit-based shaper ensuring end-to-end guaranteed bandwidth with fairness to best-effort traffic.</li> <li>Use Case: Ensuring dedicated bandwidth for audio-video bridging (AVB) streams with minimal latency.</li> </ul> </li> </ul> </li> </ul> <ul> <li>Traffic Scheduling Protocols:<ul> <li>IEEE 802.1Qbv (Time-Scheduled Traffic Enhancements):<ul> <li>Function: Enables the transmission of frames at specific scheduled times within microsecond ranges.</li> <li>Key Features: Critical for time-sensitive scheduled traffic in industrial applications.</li> <li>Use Case: Facilitating precise, time-critical communication for industrial devices like PLCs and drives.</li> </ul> </li> <li>IEEE 802.1Qbu (Frame Preemption):<ul> <li>Function: Allows high-priority frames to preempt lower-priority frames, reducing latency and jitter.</li> <li>Key Features: Utilizes Express Media Access Control (eMAC) and Preemptable Media Access Control (pMAC).</li> <li>Use Case: Ensuring high-priority frames arrive with fixed latency, crucial for applications requiring consistent timing.</li> </ul> </li> </ul> </li> </ul> <p>These TSN standards collectively enable precise timing, traffic shaping, and time-bounded communication, making them indispensable for applications requiring high reliability and determinism. </p> <p>The details of TSN is not in the scope of this document. Here are some reference to the TSN specifications</p> <ul> <li>IEEE Std 802.1AS\u2122-2011 \"Timing and Synchronization for Time-Sensitive Applications in Bridged Local Area Networks\"</li> <li>IEEE Std 802.1Qav\u2122-2009 \u201cForwarding and Queuing Enhancements for Time-Sensitive Streams\u201d</li> <li>IEEE Std 802.1Qbv\u2122-2015 \u201cEnhancements for Scheduled Traffic\u201d</li> <li>IEEE Std 802.1Qbu\u2122-2016 \u201cFrame Preemption\u201d</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#tsn-hps-rgmii-system-example-design-overview","title":"TSN HPS RGMII System Example Design Overview","text":"<p>The Time Sensitive Network (TSN) through Hard Processor System (HPS) IO System Example Design (SED) is a reference design running on the Agilex\u2122 5 E-Series 065B Premium Development Kit. This System Example Design comprises the following components:</p> <ul> <li>Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:</li> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> <p>TSN Solution Architecture for this SED is illustrated as:</p> <p></p> <p>[Note:] This is a pre-production release of Agilex\u2122 5 TSN HPS RGMII System Example Design, on Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit with speed grade -6S. This corresponds to Engineering Samples Silicon quality.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>This system example design is based on the Agilex 5 E-Series Premium Development Kit GSRD. It is recommended that you familiarize yourself with the GSRD development flow before proceeding with this design. The TSN through HPS IO System Example Design will be implemented on the HPS Enablement Expansion Board (also referred as HPS Daughter Card), which is included with the development kit.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#development-kit","title":"Development Kit","text":"<p>This Example Design targets the Agilex 5 FPGA E-Series 065B Premium Development Kit, utilizing the HPS.  Refer to GSRD#Development Kit for details about the board, including how to install the HPS Daughter Card.</p> <ul> <li>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit</li> <li>HPS Enablement Expansion Board. Included with the development kit.</li> <li>Mini USB Cable</li> <li>Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> <p>Altera\u00ae Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit:</p> <p></p> <p>HPS Enablement Expandsion Board Card:</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#development-environment","title":"Development Environment","text":"<p>Host PC with:</p> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too.</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition version. Used to recompile the hardware design. If only writing binaries is required, then the smaller Altera\u00ae Quartus\u00ae Prime Pro Edition Programmer is sufficient.</li> <li>The prebuilt binaries were built using Quartus version 24.3</li> <li>The instructions for rebuilding the binaries use Quartus version 24.3</li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#release-contents","title":"Release Contents","text":"<p>This page documents the following:</p> <ul> <li>Binary Release - see Programming the Binaries section for release content details</li> <li>Source Code Release - see Programming Software Image section for release content details</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>The Agilex 5 Premium Development Kit 24.3 Example Design binaries are located at https://releases.rocketboards.org/2024.11/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/.</p> HPS Daughter Card Boot Source Link Enablement Board SD Card https://releases.rocketboards.org/2024.11/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#sources","title":"Sources","text":"<p>Quartus Prime Pro v24.3 and the following software component versions were used to build the provided prebuilt binaries:</p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project: poky https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR GSRD Build Script: gsrd-socfpga https://github.com/altera-opensource/gsrd-socfpga scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>See https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#tsn-rgmii-architecture","title":"TSN RGMII Architecture","text":"<p>This system example design showcases Ethernet design through the HPS IO on the HPS Enablement Expansion Board,  with support for TSN features including IEEE 802.1AS, IEEE 802.1Qav, IEEE 802.1Qbv, IEEE 802.1Qbu.</p> <p></p> <ul> <li> <p>HPS Peripherals connected to HPS Enablement Expansion Board:</p> <ul> <li>Micro SD Card</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>UART</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on use case.     </p> <ul> <li>User Flow 1: Testing with Prebuilt Binaries.<p></p> </li> </ul> <ul> <li>User Flow 2: Testing Complete Flow.</li> </ul> User Flow Description Required for Userflow#1 Required for Userflow#2 Environment Setup Tools Download and Installation Yes Yes Install dependencies for SW compilation No Yes Compilation Simulation No No Hardware Compilation No Yes Software Compilation No Yes Programming Programming the binaries Yes Yes Linux boot Yes Yes Testing Run Ping Test Yes Yes Testing Run Test Application Yes Yes"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#tools-download-and-installation","title":"Tools Download and Installation","text":"<ol> <li> <p>Quartus Prime Pro      - Please download and install the Quartus\u00ae Prime Pro Edition version 24.3 version software. </p> </li> <li> <p>Win32 Disk Imager     - Please download and install the latest Win32 Disk Imager, available at https://win32diskimager.org/</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#download-and-setup-the-build-toolchain","title":"Download and setup the build toolchain","text":"<p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf gsrd.enablement\nmkdir gsrd.enablement\ncd gsrd.enablement\nexport TOP_FOLDER=`pwd` # The $TOP_FOLDER must be defined for every fresh terminal session.\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <p>Note that this is installed in the <code>TOP_FOLDER</code>. You may installed this is in other location, but note the path and export it accordingly</p> <p><pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\n</code></pre> <pre><code>export PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu- </code></pre></p> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path Note: The following must be re-done for fresh terminal session</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#install-dependencies-for-sw-compilation","title":"Install dependencies for SW compilation","text":"<p>Make sure you have Yocto system requirements met: Yocto Requirements.</p> <p>The command to install the required packages on Ubuntu 22.04-LTS is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to <code>/bin/dash</code>:</p> <pre><code>sudo ln -sf /bin/bash /bin/sh\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#compilation-flow","title":"Compilation Flow","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#hardware-compilation-flow","title":"Hardware Compilation Flow","text":"<pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 generate_from_tcl\nmake sof\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#build-core-rbf","title":"Build Core RBF","text":"<pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#software-compilation-flow","title":"Software Compilation Flow","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#customize-yocto","title":"Customize Yocto","text":"<p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:</p> <p>* Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</p> <p>* Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code>     The above are achieved by the following instructions:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#building-hps-bootable-configuration-files","title":"Building HPS Bootable Configuration Files","text":"<p>Ensure you have completed the Hardware Compilation Flow and Software Compilation Flow successfully before continuing below.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#build-qspi-image","title":"Build QSPI Image","text":"<pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#build-hps-rbf","title":"Build HPS RBF","text":"<p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#programming-the-binaries","title":"Programming the Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the System Example Design release.</p> <p>Note: Please download Prebuilt Binaries from here, if you are leveraging userflow#1.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Install the appropriate HPS Daughtercard.</p> <p>3. Connect mini USB cable from vertical connector on HPS Daughtercard to host PC. This is used for the HPS serial console.</p> <p>4. Connect micro USB cable from development board to host PC. This is used by the tools for JTAG communication.</p> <p>5. Connect Ethernet cable from HPS Daughter Card to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>1. Install a serial terminal emulator application on your host PC:</p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Power down your board if powered up. This is important, as once powered up, with the micro USB JTAG cable connected, a couple more USB serial ports will enumerate, and you may choose the wrong port.</p> <p>3. Connect mini-USB cable from the vertical mini-USB connector on the HPS Daughter Card to the host PC</p> <p>4. On the host PC, an USB serial port will enumerate. On Windows machines it will be something like <code>COM4</code>, while on Linux machines it will be something like <code>/dev/tty/USB0</code>.</p> <p>5. Configure your serial terminal emulator to use the following settings:</p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>6. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#write-qspi-flash","title":"Write QSPI Flash","text":"<p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write QSPI Flash:</p>  Using pre-built image  <ul> <li>Download and extract the JIC image, then write it to QSPI</li> </ul> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2024.11/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\ntar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre>  Using compiled image  <ul> <li>Write JIC image to QSPI:</li> </ul> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#programming-software-image","title":"Programming Software Image","text":"For Prebuilt: <ul> <li>Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2024.11/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</li> </ul> For compiled image: <ul> <li>Extract sdcard image from the archive located at <code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#write-sd-card","title":"Write SD Card","text":"<p>1. Write the gsrd-console-image-agilex5_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next:</li> </ul> <pre><code># Determine the device associated with the SD card on the host computer.\ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre> <ul> <li>On Windows, use the Win32DiskImager program. For this, first rename the extension of gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#linux-boot","title":"Linux Boot","text":"<p>1. Power down board    2. Set MSEL dipswitch SW27 to ASX4 (QSPI): OFF-ON-ON-OFF    3. Power up the board    4. Wait for Linux to boot, use <code>root</code> as user name, and no password will be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#testing","title":"Testing","text":"<p>For the purpose of demonstration, 2 development kits (refer to GSRD) will be required with Ethernet connected back to back from one board to another. </p> <p>Note: Ethernet port is on the HPS Enablement Expansion Board attached.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#ping-test","title":"Ping Test","text":"<p>Use ifconfig to configure the IP address on both the Devkit DUT and start testing.</p> <p>Example:-</p> <p>Devkit #1 : $ ifconfig eth0 192.168.1.100</p> <p>Devkit #2 : $ ifconfig eth0 192.168.1.200</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#running-iperf-test","title":"Running iperf Test:","text":"<ol> <li> <p>Execute below command on Devkit #1 DUT.</p> <p><code>iperf3 -s eth0</code></p> </li> <li> <p>Execute below command on Devkit #2 DUT.</p> <p><code>iperf3 eth0 -c 192.168.1.100 -b 0 -l 1500</code></p> <p>Note : Update the Devkit #1 DUT IP address in above command.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#run-tsn-application","title":"Run TSN Application","text":"<p>The following examples are demonstrated using 2 units of the Agilex 5 platform.  Please take note of the notation \"[Board A or B]\". The following steps assumes both platforms are connected to each other via an Ethernet connection.</p> <p>1. Boot to Linux</p> <p>2. Navigate to the <code>tsn</code> directory</p> <pre><code>cd tsn\n</code></pre> Configuration for Both Boards Step I: Setup Environment Path on Both Boards <p>3. Board A</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> <p>4. Board B</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> TXRX-TSN App Step II: Run Configuration Script <p>5. Board A: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up TAPRIO qdisc.</p> <pre><code>./run.sh agilex5 eth0 vs1a setup\n</code></pre> <p>6. Board B: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up ingress qdiscs.</p> <pre><code>./run.sh agilex5 eth0 vs1b setup\n</code></pre> Step III: Start the Application <p>7. Board B: Run the application.</p> <pre><code>./run.sh agilex5 eth0 vs1b run\n</code></pre> <p>8. Board A: Immediately after starting the application on Board B, run the application on Board A.</p> <pre><code>./run.sh agilex5 eth0 vs1a run\n</code></pre> Post-Test Procedure <p>Once the test is completed, copy the following files from Board B (listener) to the host machine:</p> <ul> <li>afpkt-rxtstamps.txt</li> <li>afxdp-rxtstamps.txt</li> </ul> Generating Latency Plot Using Excel <p>Import 'afpkt-rxtstamps.txt' and 'afxdp-rxtstamps.txt' to excel in 2 seperate sheets.</p> <p></p> <p>Plot Column 1 for each sheets using Scatter chart,</p> <p></p> <p>This will generate plot for AFPKT and AFXDP with latency(on Y-axis) against packet count (on X-axis).</p> <p>The latency for this design example can be seen as below: </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#run-time-synchronization-commands","title":"Run Time Synchronization commands","text":"<p>You may use the following command guide to perform time synchronization on the Agilex\u2122 5 system using PTP4L and PHC2SYS, and to obtain delay values</p> <p>End-to-End PTP master and slave synchronization</p> <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -E -2 -m\n</code></pre> <pre><code>-i  eth0: This option specifies the `eth0` as the network interface to use for PTP.\n-s  This option enables the slave-only mode. \n-H  This option enables hardware time stamping. \n-E  This option selects the end-to-end (E2E) delay measurement mechanism. This is the default.The E2E mechanism is also referred to as the delay \u201crequest-response\u201d mechanism.\n-2  Use Ethernet Layer (L2)\n-m  This option enables printing of messages to the standard output.\n</code></pre> </li> </ul> <ul> <li>Boards A (as master):<pre><code>ptp4l -i eth0  -H -E -2 -m\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul> <p>Peer-to-Peer PTP synchronization:</p> <ul> <li>Board B (as slave):     <pre><code>slave: ptp4l -i eth0  -s -H -P -2 -m\n</code></pre><p>-P: This option enables the use of the Peer Delay Mechanism.</p> </li> </ul> <ul> <li>Board A (as master):     <pre><code>master: ptp4l -i eth0  -H -P -2 -m\n</code></pre></li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul> <p>gPTP synchronization:</p> <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>Board A (as master): <pre><code>ptp4l -i eth0  -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m --transportSpecific 1 -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/rgmii-hps/ug-tsncfg1-agx5e-premium/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/","title":"Agilex\u2122 5 E-Series Premium Development Kit Time Sensitive Network (TSN) - SGMII XCVR System Example Design","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#introduction","title":"Introduction","text":"<p>The IEEE Ethernet is a core technology which is a backbone for IT operations and was designed to provide best effort communication suitable for IT operations. Operational Technology vendors have innovatively used Core IEEE Ethernet technology with proprietary solutions for enabling time-bounded communication. To address the need for precision timing, traffic shaping, and time-bounded communication over networks, IEEE introduced a suite of standards known as Time Sensitive Networking (TSN).</p> <p>Agilex\u2122 5 E-Series is designed as an end point for Industrial automation application with support for the following TSN protocols:</p>  Time Synchronization Protocols:  <ul> <li>IEEE 1588-2008 Advanced Timestamp (Precision Time Protocol - PTP):<ul> <li>Function: Provides sub-microsecond accuracy for time synchronization between computing systems over a local area network.<ul> <li>Key Features: 2-step synchronization, PTP offload, and timestamping.</li> <li>Use Case: Synchronizing industrial devices to operate in unison, ensuring coordinated actions across factory or plant operations.</li> </ul> </li> <li>IEEE 802.1AS (Timing and Synchronization):<ul> <li>Function: A profile of PTP (version 2) that ensures precise time synchronization in a hierarchical master-slave architecture.</li> <li>Key Features: Prioritizes accuracy and variability of timing, crucial for industrial and automotive systems.</li> <li>Use Case: Synchronizing devices to a common time for optimal operation and collaboration.</li> </ul> </li> </ul> </li> </ul>  Credit Based Shaper Protocol:  <ul> <li>IEEE 802.1Qav (Time-Sensitive Streams Forwarding and Queuing):<ul> <li>Function: Provides low-latency, time-synchronized delivery of audio and video streams over Ethernet networks.<ul> <li>Key Features: Credit-based shaper ensuring end-to-end guaranteed bandwidth with fairness to best-effort traffic.</li> <li>Use Case: Ensuring dedicated bandwidth for audio-video bridging (AVB) streams with minimal latency.</li> </ul> </li> </ul> </li> </ul>  Traffic Scheduling Protocols:  <ul> <li>IEEE 802.1Qbv (Time-Scheduled Traffic Enhancements):<ul> <li>Function: Enables the transmission of frames at specific scheduled times within microsecond ranges.<ul> <li>Key Features: Critical for time-sensitive scheduled traffic in industrial applications.</li> <li>Use Case: Facilitating precise, time-critical communication for industrial devices like PLCs and drives.</li> </ul> </li> <li>IEEE 802.1Qbu (Frame Preemption):<ul> <li>Function: Allows high-priority frames to preempt lower-priority frames, reducing latency and jitter.</li> <li>Key Features: Utilizes Express Media Access Control (eMAC) and Preemptable Media Access Control (pMAC).</li> <li>Use Case: Ensuring high-priority frames arrive with fixed latency, crucial for applications requiring consistent timing.</li> </ul> </li> </ul> </li> </ul> <p>These TSN standards collectively enable precise timing, traffic shaping, and time-bounded communication, making them indispensable for applications requiring high reliability and determinism.</p> <p>The details of TSN is not in the scope of this document. Here are some reference to the TSN specifications:</p> <ul> <li>The IEEE Std 802.1AS\u2122-2011 \"Timing and Synchronization for Time-Sensitive Applications in Bridged Local Area Networks\"</li> <li>The IEEE Std 802.1Qav\u2122-2009 \u201cForwarding and Queuing Enhancements for Time-Sensitive Streams\u201d</li> <li>The IEEE Std 802.1Qbv\u2122-2015 \u201cEnhancements for Scheduled Traffic\u201d</li> <li>The IEEE Std 802.1Qbu\u2122-2016 \u201cFrame Preemption\u201d</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#tsn-sgmii-xcvr-25g-overview","title":"TSN SGMII+ XCVR 2.5G Overview","text":"<p>The TSN SGMII+ XCVR  is a Reference design, enable datapath between HPS, EMAC Controller, Multirate Ethernet PHY IP and Marvell PHY 88E2110 running at 2.5G rate on the Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit.</p> <pre><code>Note:              1. This is the pre-production release of the Agilex\u2122 5 TSN SGMII XCVR System Example Design, on Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit with -6S\u202fspeed grade. This corresponds to Engineering Samples Silicon quality.\n 2.  A single PHY is enabled with 2.5G fixed rate in this release.\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#prerequisites","title":"Prerequisites","text":"<ul> <li>Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1. Refer to the board documentation for more information about the development kit.</li> </ul> <ul> <li>HPS Enablement Expansion Board. Included with the development kit.</li> </ul> <ul> <li>Mini and Micro USB Cable. Included with the development kit.</li> </ul> <ul> <li>CAT6A Ethernet Cable. Included with the development kit.</li> </ul> <ul> <li>Micro SD card and USB card writer. Included with the development kit.</li> </ul> <ul> <li>Host PC with 64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> </ul> <ul> <li>Linux OS installed on host PC, preferably Ubuntu 22.04LTS , while other versions and distributions may work too.</li> </ul> <ul> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> </ul> <ul> <li>Quartus\u00ae Prime Pro Edition software version 24.3 is used to recompile the hardware design. If only writing binaries is required, then the Quartus\u00ae Prime Pro Edition Programmer version 24.3 is sufficient.</li> </ul> <ul> <li>Local Ethernet network, with DHCP server Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#binaries","title":"Binaries","text":"<ul> <li>Prebuilt binaries are located here.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#sources","title":"Sources","text":"Component Location Branch Commit ID/Tag GHRD https://github.com/altera-fpga/agilex5-ed-tsn-sgmii/tree/rel/24.3/src/hw rel/24.3 24.3-1 Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project: poky https://git.yoctoproject.org/poky/ scarthgap Latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga/ scarthgap QPDS24.3_REL_GSRD_PR Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR GSRD Build Script: gsrd-socfpga https://github.com/altera-fpga/agilex5-ed-tsn-sgmii/tree/rel/24.3/src/sw rel/24.3 24.3-1"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#release-notes","title":"Release Notes","text":"<ul> <li>Refer this link for Known Issues.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#tsn-xcvr-sgmii-25g-architecture","title":"TSN XCVR SGMII+ 2.5G Architecture","text":"<p>Agilex\u2122  FPGAs provide a powerful platform for showcasing 2.5G Ethernet with TSN-enabled applications with all the TSN features including IEEE 802.1AS, IEEE802.1Qbv, IEEE802.1Qbu, IEEE802.1Qav in HPS subsystem by enabling the EMAC Controller.  To support the 2.5G rate, you must enable the 8-bit GMII interface to the FPGA fabric, from where it gets connected to a Marvell PHY 88E2110  (through the FPGA transceivers) device to drive the RJ45 CAT6A copper media.</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#hps-subsystem","title":"HPS Subsystem","text":"<p>The Hard Processor System (HPS) in this design is a critical component that interfaces with various subsystems and peripherals to ensure efficient and high-performance operation. The following are the key connections of the HPS to other design components;</p> <ul> <li>Light Weight HPS to FPGA Manager (H2F) interface to access control and status registers of TSN Subsystem and Peripheral Subsystem </li> </ul> <ul> <li>8-bit EMAC GMII interface to connect to 1G/2.5G/5G/10G Multirate Ethernet PHY IP for TSN-enabled ethernet data transfers </li> </ul> <ul> <li>EMAC MDIO PHY Management Interface (through FPGA HVIO pins) to manage external Marvell 88E2110 Ethernet Transceiver </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#tsn-subsystem","title":"TSN Subsystem","text":"<p>The main components of the TSN Subsystem are Multirate Ethernet PHY IP, GTS System PLL Clocks IP, Reset Release IP and IOPLL IP. </p> <ul> <li>The Multirate Ethernet PHY IP transmits outgoing traffic (from HPS GMII interface) and receives incoming traffic through GTS Transceiver PHY. </li> </ul> <ul> <li>The GMII adapter is enabled to convert the 8-bit GMII data from HPS to the 16-bit data inside the Multirate Ethernet PHY IP</li> </ul> <ul> <li>The IEEE 1588 Precision Time Protocol feature is enabled to accurately measure internal data path delay, ensuring high accuracy of TSN applications. </li> </ul> <ul> <li>The GTS System PLL Clocks IP provides a system PLL clock input to Multirate Ethernet PHY IP, while the IOPLL IP generates a clock source for latency_sclk and latency_measurement_clk of Multirate Ethernet PHY IP. </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#hardware-setup","title":"Hardware Setup","text":"<p>The Board-to-Board hardware setup connection details are captured in the image below.</p> <p> Note:</p> <p>1. Refer to the base GSRD Installing HPS Daughtercard section to perform 1a and 1b.</p> <p>2. This is the reference hardware setup  and user can leverage with their own hardware setup(Ex: Board to Third party device). </p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#address-map-details","title":"Address Map Details","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#hps-lw-h2f-register-map","title":"HPS LW H2F Register Map","text":"Address Offset Size (Bytes) Peripheral Description GHRD-aligned address space 0x2001_0000 8 System ID Hardware configuration system ID (0xacd5cafe) 0x2001_0060 16 Button PIO Push Button 0x2001_0070 16 DIPSW PIO DIP Switch 0x2001_0080 16 LED PIO LED connections on board Application-specific address space 0x3002_0100 64 Multirate Ethernet PHY Multirate Ethernet PHY IP CSR 0x2002_0300 128 User space CSR Sideband status and control signals of various modules"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#user-space-csr","title":"User Space CSR","text":"<p>The User Space CSR contains registers specific to system-level status (e.g. PLL locked, RX ready) and control (e.g., reset).</p> Access Definition RO Read only RW Read and write  Multirate Ethernet PHY Status Register (Offset 0x00) Name Bit Access Default Description Reserved [31:7] RO 0 Reserved op_speed [6:4] RO 3\u2019b100 Operating speed of Multirate Ethernet PHY IP:  3\u2019b000: 10G (Only valid for NBASE-T)  3\u2019b001: 1G  3\u2019b010: 100M  3\u2019b011: 10M  3\u2019b100: 2.5G  3\u2019b101: 5G (Only valid for NBASE-T)  3\u2019b110: Unused  3\u2019b111: Unused rx_block_lock [3] RO 0 Asserted when the 66b block alignment is finished on all PCS virtual lanes tx_ready [2] RO 0 When asserted, it indicates that the Multirate Ethernet PHY TX data path is ready for transmission. rx_ready [1] RO 0 When asserted, it indicates that the Multirate Ethernet PHY RX data path is ready to receive data. mrphy_pll_lock [0] RO 0 When asserted, it indicates that the PLLs in Multirate Ethernet PHY soft logic are locked. Multirate Ethernet PHY Reset Control Register (Offset 0x04) Name Bit Access Default Description Reserved [31:3] RO 0 Reserved i_rx_rst_n [2] RW 1 Resets Multirate Ethernet PHY IP RX path. Self-clearing bit based on o_rx_rst_ack_n. i_tx_rst_n [1] RW 1 Resets Multirate Ethernet PHY IP TX path. Self-clearing bit based on o_tx_rst_ack_n. i_rst_n [0] RW 1 Multirate Ethernet PHY IP global reset. Self-clearing bit based on o_rst_ack_n. TX Delay Register (Offset 0x08) Name Bit Access Default Description Reserved [31:4] RO 0 Reserved TX delay [3:0] RO 0 Additional GMII data path delay to be added. In number of gmii8b_tx_clkout clock cycles. RX Delay Register (Offset 0x0C) Name Bit Access Default Description Reserved [31:4] RO 0 Reserved RX delay [3:0] RO 0 Additional GMII data path delay to be added. In number of gmii8b_rx_clkout clock cycles. Error Status Register (Offset 0x10) Name Bit Access Default Description Reserved [31:1] RO 0 Reserved Unsupported speed error [0] RW 0 Assert this bit when EMAC Controller published unsupported speeds. Software clears this bit once addressed."},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#user-flow","title":"User Flow","text":"<p>There are two ways to test the design based on user flow.</p>  User Flow 1: Testing with Prebuild Binaries.   User Flow 2: Testing Complete Flow.  User Flow Description Required for User flow 1 Required for User flow 2 Environment Setup Tools Download and Installation Yes Yes Installing Dependency Packages for SW Compilation No Yes Package Download No Yes Compilation Simulation No No Hardware Compilation No Yes Software Compilation No Yes Programing Programing Hardware binary Yes Yes Programing Software Image Yes Yes Linux boot Yes Yes Testing Run Ping Test Yes Yes Run TSN Reference Application Yes Yes"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#environment-setup","title":"Environment Setup","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#tools-download-and-installation","title":"Tools Download and Installation","text":"<p>1. Quartus Prime Pro</p> <ul> <li>Download the Quartus\u00ae Prime Pro Edition software version 24.3 from the FPGA Software Download Center webpage of the Intel website. Follow the on-screen instructions to complete the installation process. Choose an installation directory that is relative to the Quartus\u00ae Prime Pro Edition software installation directory.</li> </ul> <ul> <li>Set up the Quartus tools in the PATH, so they are accessible without full path.</li> </ul> <pre><code>    export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\n    export PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Win32 Disk Imager</p> <ul> <li>Download and install the latest Win32 Disk Imager.</li> </ul> <p>3. Agile\u2122  5 FPGA E-Series 065B Premium Development Kit Board Test System (BTS)</p> <ul> <li> <p>Go to the Agilex\u2122 5 FPGA E-Series 065B Premium Development Kit webpage, download and extract the installer package, which includes BTS.</p> <p>Note: If you are using User Flow 1, after the BTS installation, go to Programming stage directly.</p> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#installing-dependency-packages-for-sw-compilation","title":"Installing Dependency Packages for SW Compilation","text":"<p>Follow the instructions in the Base GSRD Yocto Build Prerequisites section.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#package-download","title":"Package Download","text":"<pre><code># Create the top folder to store all the build artifacts:\nsudo rm -rf artifacts.enablement\nmkdir artifacts.enablement\ncd artifacts.enablement\nexport TOP_FOLDER=`pwd`\ncd $TOP_FOLDER\nrm -rf agilex5-ed-tsn-sgmii\ngit clone https://github.com/altera-fpga/agilex5-ed-tsn-sgmii.git\ncd agilex5-ed-tsn-sgmii/src/sw\ngit submodule update --init -r\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#compilation","title":"Compilation","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#hardware-compilation","title":"Hardware Compilation","text":"<p><pre><code>cd $TOP_FOLDER/agilex5-ed-tsn-sgmii/src/hw\nmake config\nmake H2F_WIDTH=0 F2SDRAM_DATA_WIDTH=0 all\n</code></pre> The following file will be generated:</p> <p><code>$TOP_FOLDER/agilex5-ed-tsn-sgmii/src/hw/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></p> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5-ed-tsn-sgmii/src/hw/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> Build QSPI Image <p><pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\n\n# Note : If user doing compilation first time, download the prebuilt u-boot-spl-dtb.hex  file and create the following path $TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/ and copy the u boot file here.\nquartus_pfg \\\n-c agilex5-ed-tsn-sgmii/src/hw/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=agilex5-ed-tsn-sgmii/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> The following file will be created:</p> <p><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></p> Build RBF <p><pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.*.rbf\n\n# Note : If user doing compilation first time, download the prebuilt u-boot-spl-dtb.hex  file and create the following path $TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/ and copy the u boot file here.\nquartus_pfg \\\n-c agilex5-ed-tsn-sgmii/src/hw/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=agilex5-ed-tsn-sgmii/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> The following file will be generated:</p> <p><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code> <code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#software-compilation","title":"Software Compilation","text":"Set Up Yocto <pre><code>   cd $TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw\n   # Run the `agilex5_dk_a5e065bb32aes1-gsrd-build.sh` script to sync the submodules.\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\n   # Run the `build_setup` script to set up the build environment.\nbuild_setup\n</code></pre>  Optional: Follow these steps, if you have a custom GHRD   <p>Follow the below procedure to add the generated <code>agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code> file.</p> <ul> <li>Update the recipe <code>$WORKSPACE/meta-sm-tsn-cfg3/recipes-bsp/ghrd/hw-ref-design.bbappend</code> as follows:</li> </ul> <pre><code>cd $TOP_FOLDER\nCORE_RBF=$WORKSPACE/meta-sm-tsn-cfg3/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nrm -rf $CORE_RBF\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nFILE=\"$WORKSPACE/meta-sm-tsn-cfg3/recipes-bsp/ghrd/hw-ref-design.bbappend\"\nOLD_URI='SRC_URI\\[agilex5_dk_a5e065bb32aes1_gsrd_core_cfg3.sha256sum\\] += \"[^\"]*\"'\nNEW_URI=\"SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core_cfg3.sha256sum] += \\\"$CORE_SHA\\\"\"\nsed -i \"s|$OLD_URI|$NEW_URI|\" \"$FILE\"\n</code></pre>  Build Yocto  <p>Build Yocto: <pre><code>    # Run the `bitbake_image` command to generate the binaries.\nbitbake_image\n</code></pre> Gather Files:</p> <p><pre><code>   #  Package the binaries into the build folder.\npackage\n</code></pre> The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> </ul> <ul> <li><code>$TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb</code></li> </ul> <ul> <li><code>$TOP_FOLDER/agilex5-ed-tsn-sgmii/src/sw/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#programing","title":"Programing","text":"<p>Note:</p> <ul> <li>Download the Prebuild Binaries, if you are leveraging on User Flow 1.</li> <li>Leave all jumpers and switches in their default configuration.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#clock-configuration","title":"Clock Configuration","text":"<ol> <li>Switch ON the FIRST board and switch OFF the SECOND board.</li> <li>Open the BTS application and set the clock frequency of OUT0 to 156.25 MHz (click Set after changing the value to 156.25 MHz) under Si5332 U412 tab. Click the Read button to verify that the OUT0 value remains 156.25 MHz itself.</li> <li>On the FIRST board, press the push button SW15 and hold for 5 seconds to save the settings to EEPROM. The LED D11 blinks one time, which confirms the save state. The board is now always power up with the user setting (OUT0 = 156.25 MHz).</li> <li>Switch ON the SECOND board and switch OFF the FIRST board.</li> <li>Close and open the BTS application and set the clock frequency of OUT0 to 156.25 MHz (click Set after changing the value to 156.25 MHz) under Si5332 U412 tab. Click the Read button to verify that the OUT0 value remains 156.25 MHz itself.</li> <li>Now on the SECOND board, press the push button SW15 and hold for 5s to save settings to EEPROM. The LED D11 blinks one time, which confirms the save state. The board is now always power up with the user setting (OUT0 = 156.25 MHz).</li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#programing-software-image","title":"Programing Software Image","text":"Write SD Card  <ol> <li> <p>Extract the SD card image(sdimage.tar.gz) archive and obtain the file <code>gsrd-console-image-agilex5.wic</code>.</p> </li> <li> <p>Write the extracted SD card image (gsrd-console-image-agilex5_devkit.wic) to the micro-SD card using the included USB writer in the host computer:</p> </li> </ol> <p>On Linux, use the dd utility as shown below:</p> <p><pre><code>    # Determine the device associated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5.wic of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre> On Windows, use the Win32DiskImager program. First, rename the gsrd-console-image-agilex5.wic to an .img file (sdcard.img, for example) and write the image as shown in the following figure:</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#programing-hardware-binary","title":"Programing Hardware binary","text":"Write QSPI Flash <ol> <li>Identify the FPGA device position in the JTAG chain by using <code>jtagconfig</code>.</li> </ol> <pre><code>jtagconfig\n\n1) Agilex 5E065B Premium DK [1-1.1.1]\n4BA06477   ARM_CORESIGHT_SOC_600\n  0364F0DD   A5E(C065BB32AR0|D065BB32AR0)\n020D10DD   VTAP10\n# Here, FPGA device in position #2\ncd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic@2\" #  If FPGA device in position #1 no need to mention the position number, by default it will take position #1.\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#linux-boot","title":"Linux Boot","text":"<ol> <li> <p>Open the serial port of Board A and Board B by using serial communication utility.</p> <p>Note: Follow the instructions in the Base GSRD configure-serial-console section, to configure and setup serial connection. </p> </li> <li> <p>Power cycle the board.</p> </li> <li> <p>Monitor the serial communication windows and wait for Linux to boot, use root as user name, and no password is required.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#testing","title":"Testing","text":"<p>Once booted to OS, run the prgm_mrphy_delay_app <code>(./prgm_mrphy_delay_app)</code> present at <code>/home/root/</code> from both DUTs. Do this on both DUTs to configure the egress and ingress delay in the EMAC Controller register, which is based on the MRPHY ip delays read. Note that this application needs to be executed only once at every reboot before running the tests. This is required only when you are running the TSN/PTP test cases.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#running-ping-test","title":"Running Ping Test","text":"<p>Use ifconfig to configure the IP address on both the Board DUT and start testing.</p> <p>Example:- </p> <pre><code>ifconfig\n\neth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\ninet 169.254.154.69  netmask 255.255.0.0  broadcast 169.254.255.255\n        inet6 fe80::c8fc:35ff:feae:8333  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether ca:fc:35:ae:83:33  txqueuelen 1000  (Ethernet)\nRX packets 2394  bytes 874355 (853.8 KiB)\nRX errors 0  dropped 7  overruns 0  frame 0\nTX packets 3870  bytes 970927 (948.1 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 22\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 96573  bytes 5893245 (5.6 MiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 96573  bytes 5893245 (5.6 MiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n# Execute this command on Board #A DUT: \nifconfig eth0 192.168.1.100\n\n# Execute this command on Board #B DUT: \nifconfig eth0 192.168.1.200\n\n# Do ping to Board #A from Board #B\nping 192.168.1.100\nPING 192.168.1.100 (192.168.1.100): 56 data bytes\n64 bytes from 192.168.1.100: seq=0 ttl=64 time=1.411 ms\n64 bytes from 192.168.1.100: seq=1 ttl=64 time=0.473 ms\n64 bytes from 192.168.1.100: seq=2 ttl=64 time=0.487 ms\n64 bytes from 192.168.1.100: seq=3 ttl=64 time=0.418 ms\n64 bytes from 192.168.1.100: seq=4 ttl=64 time=0.513 ms\n64 bytes from 192.168.1.100: seq=5 ttl=64 time=0.453 ms\n\n--- 192.168.1.100 ping statistics ---\n6 packets transmitted, 6 packets received, 0% packet loss\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#running-iperf-test","title":"Running iperf Test:","text":"<ol> <li> <p>Execute below command on Board #A DUT.</p> <p><code>iperf3 -s eth0</code></p> </li> <li> <p>Execute below command on Board #B DUT.</p> <p><code>iperf3 eth0 -c 192.168.1.100 -b 0 -l 1500</code></p> <p>Note : Update the Board #A DUT IP address using the above command.</p> </li> </ol>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#run-time-synchronization","title":"Run Time Synchronization","text":"<p>Synchronize Agilex\u2122 5 system through PTP4L and PHC2SYS and obtain delay values.</p>  End-to-End PTP master and slave synchronization  <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -E -2 -m\n# Description \n-i  eth0: This option specifies the `eth0` as the network interface to use for PTP.\n-s  This option enables the slave-only mode. -H  This option enables hardware time stamping. -E  This option selects the end-to-end (E2E) delay measurement mechanism. This is the default.The E2E mechanism is also referred to as the delay \u201crequest-response\u201d mechanism.\n-2  Use Ethernet Layer (L2)\n-m  This option enables printing of messages to the standard output.\n</code></pre> </li> </ul> <ul> <li>Board  A (as master):<pre><code>ptp4l -i eth0  -H -E -2 -m\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul>  Peer-to-Peer PTP synchronization:  <ul> <li>Board B (as slave):     <pre><code>slave: ptp4l -i eth0  -s -H -P -2 -m\n</code></pre><p>-P: This option enables the use of the Peer Delay Mechanism.</p> </li> </ul> <ul> <li>Board A (as master):     <pre><code>master: ptp4l -i eth0  -H -P -2 -m\n</code></pre></li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul>  gPTP synchronization:  <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>Board A (as master): <pre><code>ptp4l -i eth0  -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m --transportSpecific 1 -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/tsn/sgmii_xcvr/ug-tsn-sgmii-xcvr-agilex5/#running-tsn-reference-appilication-test","title":"Running TSN Reference Appilication Test","text":"<p>The following examples are demonstrated using 2 units of the Agilex 5 platform.  Please take note of the notation \"[Board A or B]\". The following steps assumes both platforms are connected to each other via an Ethernet connection.</p> <p>1. Boot to Linux</p> <p>2. Navigate to the <code>tsn</code> directory</p> <pre><code>cd tsn\n</code></pre> Configuration for Both Boards Step I: Setup Environment Path on Both Boards <p>3. Board A</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> <p>4. Board B</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> TXRX-TSN App Step II: Run Configuration Script <p>5. Board A: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up TAPRIO qdisc.</p> <pre><code>./run.sh agilex5 eth0 vs1a setup\n</code></pre> <p>6. Board B: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up ingress qdiscs.</p> <pre><code>./run.sh agilex5 eth0 vs1b setup\n</code></pre> Step III: Start the Application <p>7. Board B: Run the application.</p> <pre><code>./run.sh agilex5 eth0 vs1b run\n</code></pre> <p>8. Board A: Immediately after starting the application on Board B, run the application on Board A.</p> <pre><code>./run.sh agilex5 eth0 vs1a run\n</code></pre> Post-Test Procedure <p>Once the test is completed, copy the following files from Board B (listener) to the host machine:</p> <ul> <li>afpkt-rxtstamps.txt</li> <li>afxdp-rxtstamps.txt</li> </ul> Generating Latency Plot Using Excel <p>Import 'afpkt-rxtstamps.txt' and 'afxdp-rxtstamps.txt' to excel in 2 seperate sheets.</p> <p></p> <p>Plot Column 1 for each sheets using Scatter chart,</p> <p></p> <p>This will generate plot for AFPKT and AFXDP with latency(on Y-axis) against packet count (on X-axis).</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/","title":"Agilex\u2122 7 HPS eMMC Boot Example","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#overview","title":"Overview","text":"<p>This project demonstrates how to boot to Linux on the Agilex\u2122 SoC HPS using eMMC instead of the standard SD card. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<ul> <li>Altera\u00ae Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit P-Tile E-Tile ordering code DK-SI-AGF014EB:  <ul> <li>NAND/eMMC HPS Daughtercard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel\u00ae FPGA Download Cable II</li> <li>SDM QSPI Bootcard with MT25QU02G flash device </li> </ul> </li> <li>Host PC with:  <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for details about the board.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#nandemmc-hps-daughtercard","title":"NAND/eMMC HPS Daughtercard","text":"<p>The NAND/eMMC HPS daughtercard that comes with the development kit supports both NAND and eMMC. </p> <p>To configure the card for eMMC operation, set the jumpers as shown below: </p> Jumper Setting J2 unpopulated J9 unpopulated J10 populated 1-2 J11 populated 2-3 <p>For reference, the NAND/eMMC schematic is available at https://www.intel.com/content/dam/altera-www/global/en_US/support/boards-kits/arria10/soc/hps_io48_nand_dc.pdf. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#deliverables","title":"Deliverables","text":"<p>The following files are available as part of this example: </p> File Description agilex7-u-boot-emmc.patch U-Boot DTS patch to use eMMC - device tree changes only agilex7-linux-emmc.patch Linux DTS patch to use eMMC - device tree changes only"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#build-instructions","title":"Build Instructions","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#build-flow","title":"Build Flow","text":"<p>The main changes vs the standard SD card flow are:  </p> <ul> <li>Hardware project is modified to target the eMMC daughtercard </li> <li>U-Boot device tree is patched to match the eMMC daughtercard </li> <li>Linux device tree is patched to match the eMMC daughtercard </li> <li>eMMC image is downloaded over TFTP and written by U-Boot which is ran by the debugger </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#set-up-environment","title":"Set Up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf agilex7.emmc_boot\nmkdir agilex7.emmc_boot\ncd agilex7.emmc_boot\nexport set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>The hardware design is downloaded from Github, then it's configured to enable the eMMC HPS card, then it's compiled: </p> <pre><code>cd $TOP_FOLDER rm -rf ghrd-socfpga agilex_soc_devkit_ghrd git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd . rm -rf ghrd-socfpga cd agilex_soc_devkit_ghrd # select the emmc hps daughtercard \nexport DAUGHTER_CARD=devkit_dc_emmc # use fpga configuration first instead of hps boot first \nexport BOOTS_FIRST=fpga # target the DK-SI-AGF014EB board\nexport BOARD_PWRMGT=linear\nmake scrub_clean_all make generate_from_tcl make all unset BOARD_PWRMGT\nunset BOOTS_FIRST\nunset DAUGHTER_CARD\ncd .. </code></pre> <p>The following relevant files are created: </p> <ul> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof</code> - FPGA configuration file, without HPS FSBL </li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex</code> - HPS Debug FSBL </li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#build-arm-trusted-firmware","title":"Build Arm* Trusted Firmware","text":"<pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware make -j 64 bl31 PLAT=agilex DEPRECATED=1 cd .. </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#build-u-boot","title":"Build U-Boot","text":"<pre><code>cd $TOP_FOLDER rm -f agilex7-u-boot-emmc.patch\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-7/f-series/soc/emmc/collateral/agilex7-u-boot-emmc.patch\nrm -rf u-boot-socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga # change device tree to account for board differences \npatch -p 1 &lt; ../u-boot-socfpga-emmc.patch # use 'Image' for kernel image instead of 'kernel.itb' \nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk # only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi  # Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n \nCONFIG_SPL_NAND_SUPPORT=n \nCONFIG_CMD_NAND_TRIMFFS=n \nCONFIG_CMD_NAND_LOCK_UNLOCK=n \nCONFIG_NAND_DENALI_DT=n \nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n \nCONFIG_SPL_NAND_FRAMEWORK=n \nCONFIG_CMD_NAND=n \nCONFIG_MTD_RAW_NAND=n \nCONFIG_CMD_UBI=n \nCONFIG_CMD_UBIFS=n \nCONFIG_MTD_UBI=n \nCONFIG_ENV_IS_IN_UBI=n \nCONFIG_UBI_SILENCE_MSG=n \nCONFIG_UBIFS_SILENCE_MSG=n \n# Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"bridge enable;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_SPL_DOS_PARTITION=y \nCONFIG_CMD_PART=y \nCONFIG_SPL_CRC32=y \nCONFIG_LZO=y \nCONFIG_CMD_DHCP=y \n# Enable more QSPI flash manufacturers \nCONFIG_SPI_FLASH_MACRONIX=y \nCONFIG_SPI_FLASH_GIGADEVICE=y \nCONFIG_SPI_FLASH_WINBOND=y \nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper make socfpga_agilex_defconfig # merge custom configuration with the default configuration from .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment # link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin . # build\nmake -j 64 cd .. </code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code> - FSBL/SPL hex file </li> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code> - U-Boot and ATF combined image file </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#build-qspi-image","title":"Build QSPI Image","text":"<pre><code>cd $TOP_FOLDER quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\ \nflash_image.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=AGFB014R24B2E2V \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 </code></pre> <p>The following file will be created: </p> <ul> <li><code>$TOP_FOLDER/flash_image.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#build-linux","title":"Build Linux","text":"<p>The following instructions are used to build Linux: </p> <pre><code>cd $TOP_FOLDER wget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-7/f-series/soc/emmc/collateral/agilex7-linux-emmc.patch\nrm -rf linux-socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga cd linux-socfpga patch -p 1 &lt; ../agilex7-linux-emmc.patch\nmake clean &amp;&amp; make mrproper make defconfig make -j 64 Image dtbs cd .. </code></pre> <p>The following relevant files are created: </p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code> - Linux kernel image </li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb</code> - Linux Device Tree Blob </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#build-rootfs","title":"Build Rootfs","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system: </p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b scarthgap http://git.yoctoproject.org/poky\ngit clone -b scarthgap http://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap http://git.openembedded.org/meta-openembedded\nsource poky/oe-init-build-env ./build echo 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf echo 'CORE_IMAGE_EXTRA_INSTALL += \" fio\"' &gt;&gt; conf/local.conf bitbake core-image-minimal </code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive will be created: </p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#create-emmc-image","title":"Create eMMC Image","text":"<p>The eMMC image is created with the same procedure used for creating SD card images: </p> <pre><code>cd $TOP_FOLDER rm -rf sd_card mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/2021.04/gsrd/tools/make_sdimage_p3.py # remove mkfs.fat parameter which has some issues on Ubuntu 22.04 \nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py chmod +x make_sdimage_p3.py mkdir fat &amp;&amp; cd fat cp $TOP_FOLDER/u-boot-socfpga/u-boot.itb . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb . cd .. mkdir rootfs &amp;&amp; cd rootfs sudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz sudo rm -rf lib/modules/* cd .. sudo python3 make_sdimage_p3.py -f \\ \n-P rootfs/*,num=2,format=ext3,size=64M \\ \n-P fat/*,num=1,format=fat32,size=48M \\ \n-s 128M \\ \n-n emmc.img cd .. </code></pre> <p>The following image file will be created: </p> <ul> <li>$TOP_FOLDER/sd_card/emmc.img </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#flash-instructions","title":"Flash Instructions","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#write-qspi-image","title":"Write QSPI Image","text":"<p>1. Set the MSEL to JTAG &amp; power cycle the board </p> <p>2. Use Quartus Programmer to program the QSPI flash: </p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;flash_image.jic\" </code></pre> <p>3. Set MSEL back to QSPI </p> <p>Note: If there was no previous design running, or if the previous design has been running fine, the MSEL does not need to be set to JTAG. It can remain set to QSPI, and you can still program QSPI flash succesfully. In case there was a previous design running, run \"jtagconfig\" to determine if the Agilex device is first or second in the JTAG scan chain. If it is second, change the above command to: </p> <pre><code>cd $TOP_FOLDER quartus_pgm -m jtag -o \"pvi;./flash_image.jic@2\" </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#write-emmc-image","title":"Write eMMC Image","text":"<p>The flow for writing the eMMC image is: </p> <ul> <li>Configure the FPGA over JTAG with an image containing a dummy HPS SPL, which just stays in an infinite loop </li> <li>Load and run SPL and U-Boot to HPS over JTAG </li> <li>From U-Boot command prompt, transfer the eMMC image to HPS SDRAM over TFTP </li> <li>From U-Boot command prompt, write the eMMC image from SDRAM to eMMC </li> </ul> <p>1. Run U-Boot from the debugger, as shown here</p> <p>2. The above will cause the U-Boot to start running on HPS. Stop U-Boot counter by pressing any key on the serial console. </p> <p>3. Copy the eMMC image to the TFTP folder on your host: </p> <pre><code>cd your_tftp_folder cp $TOP_FOLDER/sd_card/emmc.img . </code></pre> <p>4. Determine the IP of your host computer running TFPT, by running 'ifconfig' command. </p> <p>5. In U-Boot connect to the local network, and set the server ip parameter, where the tftp commands will connect to: </p> <pre><code>setenv autoload no dhcp setenv serverip your_host_ip_address </code></pre> <p>6. In U-Boot, download the eMMC image and write it to flash: </p> <pre><code>tftp ${loadaddr} emmc.img setexpr blkcnt ${filesize} / 0x200 mmc write ${loadaddr} 0 ${blkcnt} </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#boot-linux","title":"Boot Linux","text":"<p>1. Set the MSEL to JTAG </p> <p>2. Power cycle the board. </p> <p>3. Linux will boot up, requesting a login. Use 'root' as username, a password will not be required.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/emmc/ug-emmc-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/","title":"Agilex\u2122 7 SoC Fabric Configuration from Linux Example","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#introduction","title":"Introduction","text":"<p>When using HPS Boot First method, the FPGA device is first configured with a small Phase 1 bitstream, which configures the periphery, and brings up HPS. Then, at a later time, HPS configures the FPGA fabric using a larger Phase 2 bitstream. </p> <p>The HPS can configure the fabric either from U-Boot or Linux. The Golden System Reference Design (GSRD) configures the fabric from U-Boot. The examples in this page demonstrate how to configure the FPGA fabric from Linux, using device tree overlays. </p> <p>Two different examples are provided: </p> <ul> <li>Example building components separately </li> <li>based on the Building Bootloader for Agilex\u2122 7 example. </li> <li>Manages overlays directly. </li> <li>Example building everything with Yocto </li> <li>Based on the GSRD for Agilex\u2122 7 F-Series Transceiver-SoC DevKit (P-Tile and E-Tile). </li> <li>Manages overlays with the dtbt utility </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<ul> <li>Altera\u2122 Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit P-Tile E-Tile ordering code DK-SI-AGF014EB:  <ul> <li>OOBE/SD HPS Daughtercard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel\u00ae FPGA Download Cable II</li> <li>SDM QSPI Bootcard with MT25QU02G flash device </li> </ul> </li> <li>Host PC with:  <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera\u2122 Quartus\u00ae Prime Pro Edition Version 24.3</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for details about the board.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#example-building-components-separately","title":"Example Building Components Separately","text":"<p>This example is build on top of the Building Bootloader for Agilex\u2122 7 example, with the modification that the fabric is not configured from U-Boot anymore, but from Linux, with a device tree overlay. </p> <p>The device tree overlay and the Phase 2 configuration bitstream core.rbf are stored in the Linux rootfs folder /lib/firmware, where the Linux overlay framework expects them to be by default. </p> <p>Full instructions for building and running the example are provided. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#build-example","title":"Build Example","text":"<p>1. Set Up Environment: </p> <pre><code>sudo rm -rf agilex7.fabric_config.separate mkdir agilex7.fabric_config.separate cd agilex7.fabric_config.separate export TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Build Hardware Design: </p> <pre><code>cd $TOP_FOLDER rm -rf ghrd-socfpga agilex_soc_devkit_ghrd git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd . rm -rf ghrd-socfpga cd agilex_soc_devkit_ghrd # target the DK-SI-AGF014EB board\nexport BOARD_PWRMGT=linear\n# disable SGMII to build faster \nexport HPS_ENABLE_SGMII=0 make scrub_clean_all make generate_from_tcl make all unset BOARD_PWRMGT unset HPS_ENABLE_SGMII\ncd ..\n</code></pre> <p>3. Build Arm* Trusted Firmware: </p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware make bl31 PLAT=agilex DEPRECATED=1 cd .. </code></pre> <p>4. Build U-Boot: </p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk # use 'Image' for kernel image instead of 'kernel.itb'\nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb \nCONFIG_BOOTFILE=\"Image\" \n# - Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n \nCONFIG_SPL_NAND_SUPPORT=n \nCONFIG_CMD_NAND_TRIMFFS=n \nCONFIG_CMD_NAND_LOCK_UNLOCK=n \nCONFIG_NAND_DENALI_DT=n \nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n \nCONFIG_SPL_NAND_FRAMEWORK=n \nCONFIG_CMD_NAND=n \nCONFIG_MTD_RAW_NAND=n \nCONFIG_CMD_UBI=n \nCONFIG_CMD_UBIFS=n \nCONFIG_MTD_UBI=n \nCONFIG_ENV_IS_IN_UBI=n \nCONFIG_UBI_SILENCE_MSG=n \nCONFIG_UBIFS_SILENCE_MSG=n \n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; bridge disable;fpga load 0 \\${loadaddr} \\${filesize};bridge enable; setenv bootfile Image; run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_SPL_DOS_PARTITION=y \nCONFIG_CMD_PART=y \nCONFIG_SPL_CRC32=y \nCONFIG_LZO=y \nCONFIG_CMD_DHCP=y \n# Enable more QSPI flash manufacturers \nCONFIG_SPI_FLASH_MACRONIX=y \nCONFIG_SPI_FLASH_GIGADEVICE=y \nCONFIG_SPI_FLASH_WINBOND=y \nCONFIG_SPI_FLASH_ISSI=y \nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper make socfpga_agilex_defconfig # Use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin . # build\nmake -j 64 cd .. </code></pre> <p>5. Build JIC and Core RBF Files: </p> <pre><code>cd $TOP_FOLDER rm -f ghrd.hps.jic ghrd.core.rbf quartus_pfg -c \\ \nagilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\ \nghrd.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=AGFB014R24B2E2V \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o hps=1 </code></pre> <p>6. Build Linux: </p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone https://github.com/altera-opensource/linux-socfpga linux-socfpga cd linux-socfpga # comment out next line to use the latest Linux kernel branch \ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga linux-socfpga make clean &amp;&amp; make mrproper make defconfig # enable device tree overlays and fpga bridges \n./scripts/config --set-val CONFIG_OF_RESOLVE y ./scripts/config --set-val CONFIG_OF_OVERLAY y ./scripts/config --set-val CONFIG_OF_CONFIGFS y ./scripts/config --set-val CONFIG_FPGA_MGR_STRATIX10_SOC y ./scripts/config --set-val CONFIG_FPGA_BRIDGE y ./scripts/config --set-val CONFIG_FPGA_REGION y ./scripts/config --set-val CONFIG_OF_FPGA_REGION y ./scripts/config --set-val CONFIG_OVERLAY_FS y # enable SYSID driver \n./scripts/config --set-val CONFIG_ALTERA_SYSID y make oldconfig make -j 64 Image dtbs </code></pre> <p>7. Create Device Treee Overlay: </p> <pre><code>cd $TOP_FOLDER rm -f overlay.dtb overlay.dts cat &lt;&lt; EOF &gt; overlay.dts \n/dts-v1/; \n/plugin/; \n/ { \n fragment@0 { \n   target-path = \"/soc/base_fpga_region\"; \n   #address-cells = &lt;0x1&gt;; \n   #size-cells = &lt;0x1&gt;; \n   __overlay__ { \n     #address-cells = &lt;0x2&gt;; \n     #size-cells = &lt;0x2&gt;; \n     ranges = &lt; 0x0 0x0 0xF9000000 0x0 0x00200000&gt;; \n     firmware-name = \"overlay.rbf\"; \n     config-complete-timeout-us = &lt;30000000&gt;; \n     sysid_qsys_0: sysid@0 { \n       compatible = \"altr,sysid-24.2\", \"altr,sysid-1.0\"; \n       reg = &lt; 0x0 0x0 0x0 0x00000010&gt;; \n       id = &lt;3405707982&gt;; \n       timestamp = &lt;0&gt;; \n     }; \n   }; \n }; \n}; \nEOF\ndtc -I dts -O dtb -o overlay.dtb overlay.dts </code></pre> <p>Explanation: </p> <ul> <li><code>Fragment@0</code>: Node Name of the Overlay. </li> <li><code>target-path</code>: This refers to base_fpga_region located in arch/arm64/boot/dts/intel/socfpga_agilex.dtsi. This will invoke the following driver: drivers/fpga/of-fpga-region.c </li> <li>Fragment@0 <code>#address-cells/#size-cells</code>: This specifies the number of cells (32-bit size) to be used for the child's address map. For overlays, we need to set this value to avoid \"default_addr_size\" errors. </li> <li>overlay <code>#address-cells/#size-cells</code>: These fields should match those in arch/arm64/boot/dts/intel/socfpga_agilex.dtsi. </li> <li><code>Ranges</code>: According to the device tree standard, this allows mapping child addresses to parent addresses. In this case: <ul> <li>The first number <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> represents the child's address. </li> <li>The second pair <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> represents the parent's address. </li> <li>The third pair <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> specifies the memory region's size. </li> </ul> </li> <li><code>firmware-name = \"overlay.rbf\"</code>: This should contain the fabric's file name. </li> <li><code>sysid_qsys_0: sysid@0</code>: This specifies the device name as well as its alias. </li> <li><code>reg = &lt;0x0 0x0 0x0 0x00000010&gt;</code>: This refers to the addresses specified in the parent range field. <ul> <li><code>&lt;0x0 0x0 0x0 0x00000010&gt;</code>: This represents the child's address. </li> <li><code>&lt;0x0 0x0 0x0 0x00000010&gt;</code>: This is the size of the memory region. </li> </ul> </li> </ul> <p>8. Build Root Filesystem: </p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b scarthgap https://git.yoctoproject.org/poky git clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga git clone -b scarthgap https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf bitbake core-image-minimal </code></pre> <p>9. Build SD Card Image: </p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py sed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py chmod +x make_sdimage_p3.py mkdir fat &amp;&amp; cd fat cp $TOP_FOLDER/u-boot-socfpga/u-boot.itb . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb . cd .. mkdir rootfs &amp;&amp; cd rootfs sudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz sudo rm -rf lib/modules/* sudo mkdir -p lib/firmware sudo cp $TOP_FOLDER/ghrd.core.rbf lib/firmware/overlay.rbf sudo cp $TOP_FOLDER/overlay.dtb lib/firmware/overlay.dtb cd .. sudo python3 make_sdimage_p3.py -f \\ \n-P fat/*,num=1,format=fat32,size=48M \\ \n-P rootfs/*,num=2,format=ext3,size=32M \\ \n-s 100M \\ \n-n sdcard.img cd .. </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#run-example","title":"Run Example","text":"<p>1. Write QSPI image <code>$TOP_FOLDER/ghrd.hps.jic</code> </p> <p>2. Write SD card image <code>$TOP_FOLDER/sd_card/sdcard.img</code> </p> <p>3. Power up board </p> <p>4. Log into Linux using 'root' as username, no password will be required. </p> <p>5. Create the overlay folder </p> <pre><code>root@agilex7_dk_si_agf014eb:~# mkdir /sys/kernel/config/device-tree/overlays/0 </code></pre> <p>6. Configure the overlay: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# echo overlay.dtb &gt; /sys/kernel/config/device-tree/overlays/0/path [ 35.750389] fpga_manager fpga0: writing overlay.rbf to Stratix10 SOC FPGA Manager [ 36.170960] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges [ 36.181456] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/firmware-name [ 36.192486] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/config-complete-timeout-us </code></pre> <p>7. Locate the sysid in the sysfs: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# find / -name sysid /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid </code></pre> <p>8. Display the sysid id information: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# cat /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid/id | xargs printf \"0x%08x\\n\" 0xacd5cafe </code></pre> <p>9. Remove the overlay: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# rmdir /sys/kernel/config/device-tree/overlays/0 </code></pre> <p>10. Confirm that the overlay was removed: </p> <pre><code>root@agilex7_dk_si_agf014eb:~# find / -name sysid </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#example-building-everything-with-yocto","title":"Example Building Everything with Yocto","text":"<p>This example is build on top of the GSRD for Agilex 7 F-Series Transceiver-SoC DevKit (P-Tile and E-Tile), with the modification that the fabric is not configured from U-Boot anymore, instead through a device tree overlay. </p> <p>Full instructions for building and running the example are provided. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#build-example_1","title":"Build Example","text":"<p>1. Set up environment: </p> <pre><code>sudo rm -rf agilex7.fabric_config.yocto mkdir agilex7.fabric_config.yocto cd agilex7.fabric_config.yocto export TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Compile the hardware design: </p> <pre><code>cd $TOP_FOLDER rm -rf ghrd-socfpga agilex_soc_devkit_ghrd git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd . rm -rf ghrd-socfpga cd agilex_soc_devkit_ghrd # target the DK-SI-AGF014EB board\nexport BOARD_PWRMGT=linear\n# disable SGMII to build faster \nexport HPS_ENABLE_SGMII=0 make scrub_clean_all make generate_from_tcl make all unset BOARD_PWRMGT unset HPS_ENABLE_SGMII\ncd ..\n</code></pre> <p>3. Build the core.rbf </p> <pre><code>cd $TOP_FOLDER rm -f ghrd.hps.jic ghrd.core.rbf quartus_pfg -c \\ \nagilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof \\ \nghrd.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=AGFB014R24B2E2V \\ \n-o mode=ASX4 \\ \n-o hps=1 rm ghrd.hps.jic </code></pre> <p>4. Clone Yocto script and start the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd_socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga cd gsrd_socfpga . agilex7_dk_si_agf014eb-gsrd-build.sh build_setup </code></pre> <p>5. Get and apply the patch, containing the following changes: </p> <ul> <li>U-Boot boot script is changed to load configuration 0 from the kernel.itb, which does not configure the fabric at boot time </li> <li>Overlay file agilex_fabric_config_overlay.dts was added, pointing to core.rbf file for fabric configuration, and adding the sysid driver </li> <li>core.rbf file is also copied into the /lib/firmware folder where the Linux device tree framwork expects it </li> </ul> <pre><code>rm -f agilex7-fabric-config-yocto.patch\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-7/f-series/soc/fabric-config/collateral/agilex7-fabric-config-yocto.patch patch -d meta-intel-fpga-refdes -p1 &lt; agilex7-fabric-config-yocto.patch\n</code></pre> <p>For reference, the patch looks like this:</p> <pre><code>diff --git a/recipes-bsp/device-tree/device-tree.bb b/recipes-bsp/device-tree/device-tree.bb\nindex 94e5a17..4ccd039 100644\n--- a/recipes-bsp/device-tree/device-tree.bb\n+++ b/recipes-bsp/device-tree/device-tree.bb\n@@ -24,6 +24,7 @@ SRC_URI:append:agilex7_dk_si_agf014ea = \" \\\n                   file://agilex7_pr_persona0.dts \\\n                    file://agilex7_pr_persona1.dts \\\n                    file://socfpga_ilc.dtsi \\\n+                   file://fabric_config_overlay.dts \\\n                   \"\n\nSRC_URI:append:agilex7_dk_si_agf014eb = \" \\\n@@ -32,6 +33,7 @@ SRC_URI:append:agilex7_dk_si_agf014eb = \" \\\n                   file://agilex7_pr_persona0.dts \\\n                    file://agilex7_pr_persona1.dts \\\n                    file://socfpga_ilc.dtsi \\\n+                   file://fabric_config_overlay.dts \\\n                   \"\n\nSRC_URI:append:agilex7_dk_si_agi027fb = \" \\\ndiff --git a/recipes-bsp/device-tree/files/fabric_config_overlay.dts b/recipes-bsp/device-tree/files/fabric_config_overlay.dts\nnew file mode 100644\nindex 0000000..75ea080\n--- /dev/null\n+++ b/recipes-bsp/device-tree/files/fabric_config_overlay.dts\n@@ -0,0 +1,23 @@\n+/dts-v1/;\n+/plugin/;\n+/ {\n+                fragment@0 {\n+                                target-path = \"/soc/base_fpga_region\";\n+                                #address-cells = &lt;0x1&gt;;\n+                                #size-cells = &lt;0x1&gt;;\n+                                __overlay__ {\n+                                                #address-cells = &lt;0x2&gt;;\n+                                                #size-cells = &lt;0x2&gt;;\n+                                                ranges =&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;;\n+                                                firmware-name = \"ghrd.core.rbf\";\n+                                                config-complete-timeout-us = &lt;30000000&gt;;\n+\n+                                                sysid_qsys_0: sysid@0 {\n+                                                    compatible = \"altr,sysid-23.4\", \"altr,sysid-1.0\";\n+                                                    reg = &lt;0x0 0x0 0x0 0x00000010&gt;;\n+                                                    id = &lt;3405707982&gt;;\n+                                                    timestamp = &lt;0&gt;;\n+                                                };\n+                                };\n+                };\n+};\n\\ No newline at end of file\ndiff --git a/recipes-bsp/ghrd/hw-ref-design.bb b/recipes-bsp/ghrd/hw-ref-design.bb\nindex 36cb532..f8d0ecb 100644\n--- a/recipes-bsp/ghrd/hw-ref-design.bb\n+++ b/recipes-bsp/ghrd/hw-ref-design.bb\n@@ -195,6 +195,7 @@ do_install () {\n           install -D -m 0644 ${WORKDIR}/${MACHINE}_pr_${ARM64_GHRD_CORE_RBF} ${D}/boot/ghrd_pr.core.rbf\n            install -D -m 0644 ${WORKDIR}/${MACHINE}_pr_persona0.rbf ${D}${base_libdir}/firmware/persona0.rbf\n            install -D -m 0644 ${WORKDIR}/${MACHINE}_pr_persona1.rbf ${D}${base_libdir}/firmware/persona1.rbf\n+           install -D -m 0644 ${WORKDIR}/${MACHINE}_gsrd_${ARM64_GHRD_CORE_RBF} ${D}${base_libdir}/firmware/${ARM64_GHRD_CORE_RBF}\n       else\n            install -D -m 0644 ${WORKDIR}/${MACHINE}_gsrd_${ARM64_GHRD_CORE_RBF} ${D}/boot/${ARM64_GHRD_CORE_RBF}\n        fi\ndiff --git a/recipes-bsp/u-boot/files/uboot.txt b/recipes-bsp/u-boot/files/uboot.txt\nindex 8577186..3a0288f 100644\n--- a/recipes-bsp/u-boot/files/uboot.txt\n+++ b/recipes-bsp/u-boot/files/uboot.txt\n@@ -6,7 +6,7 @@ if test ${target} = \"mmc0\"; then\n       mmc rescan;\n        fatload ${devtype} ${devnum}:${distro_bootpart} ${loadaddr} ${bootfile};\n        setenv bootargs \"earlycon panic=-1 root=${mmcroot} rw rootwait\";        \n-       bootm ${loadaddr}#board-${board_id};\n+       bootm ${loadaddr}#board-0;\n       exit;\n    fi\n fi\n</code></pre> <p>6. Customize Yocto Build </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd.core.rbf $CORE_RBF OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\" CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") NEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb sed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>7. Build Yocto: </p> <pre><code>bitbake_image package </code></pre> <p>8. Build JIC file: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\ \nghrd.jic \\ \n-o hps_path=gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\ \n-o device=MT25QU128 \\ \n-o flash_loader=AGFB014R24B2E2V \\ \n-o mode=ASX4 \\ \n-o hps=1 </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#run-example_1","title":"Run Example","text":"<p>1. Write QSPI image <code>$TOP_FOLDER/ghrd.hps.jic</code> </p> <p>2. Write SD card image <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/gsrd-console-image-agilex7.wic</code> </p> <p>3. Power up board </p> <p>4. Log into Linux using 'root' as username, no password will be required. </p> <p>5. Apply the overlay: </p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -a agilex_fabric_config_overlay.dtbo -p /boot/devicetree Set dtbo search path to /boot/devicetree Applying dtbo: agilex_fabric_config_overlay.dtbo [ 36.789770] fpga_manager fpga0: writing ghrd.core.rbf to Stratix10 SOC FPGA Manager [ 36.915647] dw_mmc ff808000.mmc: Unexpected interrupt latency [ 37.220846] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges [ 37.231343] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/firmware-name [ 37.242381] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/config-complete-timeout-us [ 37.254582] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/sysid_qsys_0 </code></pre> <p>6. List the applied overlays: </p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -l 1 fabric_config_overlay.dtbo applied /sys/kernel/config/device-tree/overlays/1-fabric_config_overlay.dtbo\n</code></pre> <p>7. Locate the sysid in the sysfs: </p> <pre><code>root@agilex7dksiagf014eb:~# find / -name sysid /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid </code></pre> <p>8. Display the sysid id information: </p> <pre><code>root@agilex7dksiagf014eb:~# cat /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid/id | xargs printf \"0x%08x\\n\" 0xacd5cafe </code></pre> <p>9. Remove the overlay: </p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -r fabric_config_overlay.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\nRemoving dtbo: 1-fabric_config_overlay.dtbo\n</code></pre> <p>10. Confirm that the overlay was removed: </p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -l </code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/fabric-config/ug-linux-fabric-config-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/","title":"Agilex\u2122 7 F-Series SoC Development Kit GSRD User Guide","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#overview","title":"Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile).</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the GSRD:</p> <ul> <li>Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (P-Tiles &amp; E-Tile) ordering code DK-SI-AGF014EB</li> <li>SD/MMC HPS Daughtercard<ul> <li>SDM QSPI Bootcard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel FPGA Download Cable II</li> <li>Micro SD card (4GB or greater)</li> </ul> </li> <li>Host PC with<ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Micro SD card slot or Micro SD card writer/reader</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3</li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board)</li> </ul> </li> </ul> <p>You can determine your board version by referring to the following table from https://www.intel.com/content/www/us/en/docs/programmable/683752/current/overview.html</p> Development Kit Version Ordering Code Device Part Number Starting Serial Number Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 2 P-Tiles &amp; E-Tiles) DK-SI-AGF014EB AGFB014R24B2E2V (Power Solution 2) 00205001 Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 1 P-Tiles &amp; E-Tiles) DK-SI-AGF014EA AGFB014R24B2E2V (Power Solution 1) 0001101 Intel Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (ES P-Tiles &amp; E-Tiles) DK-SI-AGF014E3ES AGFB014E3ES (Power Solution 1) 0001001 <p>The DK-SI-AGF014E3ES and DK-SI-AGF014EA are deprecated, and not supported anymore. Instructions on how to build the binaries for the DK-SI-AGF014EA are provided in the Boot from SD Card on the DK-SI-AGF014EA section.</p> <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#prebuilt-binaries","title":"Prebuilt Binaries","text":"SD Card Boot <p>The release files are accessible at https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agf014eb_gsrd/</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>:</p> File Description linux-socfpga-v6.6.37-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2024.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.11.0-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p> NAND Boot <p>The release files are accessible at https://releases.rocketboards.org/2024.11/nand/agilex7_dk_si_agf014eb_nand/</p> <p>To load the binaries in the development kit see Write NAND Binaries.</p> QSPI Boot <p>The release files are accessible at https://releases.rocketboards.org/2024.11/qspi/agilex7_dk_si_agf014eb_qspi/.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 and the following software component versions are used to build the GSRD: </p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Quad Arm Cortex-A53 MPCore Processor</li> <li>HPS Peripherals connected to Out-of-Box Experience (OOBE) Daughter Card:</li> <li>Micro SD for HPS storage</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>I2C</li> <li>USB UART</li> <li>USB 2.0 OTG</li> <li>Two Push buttons and Three LEDs</li> </ul> </li> <li>Hard Memory Controller (HMC) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>Three user LED outputs</li> <li>Four user DIP switch inputs</li> <li>Four user push-button inputs</li> <li>Interrupt Latency Counter</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> <li>JTAG to Avalon Master Bridges connected to:<ul> <li>FPGA-to-SDRAM 0/\u00bd Interfaces</li> <li>FPGA-to-HPS AXI Bridge</li> </ul> </li> </ul> <p></p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#mpu-address-maps","title":"MPU Address Maps","text":"<p>This section presents the address maps as seen from the MPU (Cortex-A53) side.</p> HPS-to-FPGA Address Map <p>The MPU region provide windows of 4 GB into the FPGA slave address space. The lower 1.5 GB of this space is mapped to two separate addresses - firstly from 0x8000_0000 to 0xDFFF_FFFF and secondly from 0x20_0000_0000 to 0x20_5FFF_FFFF. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU (Cortex-A53), which starts at the lightweight HPS-to-FPGA base address of 0xF900_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0000_0000 8 Unique system ID led_pio 0x0000_1080 16 LED outputs button_pio 0x0000_1060 16 Push button inputs dipsw_pio 0x0000_1070 16 DIP switch inputs ILC 0x0000_1100 256 Interrupt latency counter (ILC)"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#jtag-master-address-map","title":"JTAG Master Address Map","text":"<p>There are two JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0000_0000 256K On-chip RAM sysid 0x0004_0000 8 Unique system ID led_pio 0x0004_0080 16 LED outputs button_pio 0x0004_0060 16 Push button inputs dipsw_pio 0x0004_0070 16 DIP switch inputs ILC 0x0004_0100 256 Interrupt latency counter (ILC)"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#interrupt-routing","title":"Interrupt Routing","text":"<p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[0] 4 DIP switch inputs button_pio f2h_irq0[1] 4 Push button inputs <p>The interrupt sources are also connected to an interrupt latency counter (ILC) module in the system, which enables System Console to be aware of the interrupt status of each peripheral in the FPGA portion of the SoC.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#typical-hps-boot-flow","title":"Typical HPS Boot Flow","text":"<p>The GSRD boot flow includes the following stages:</p> <p>1. SDM</p> <p>2. U-Boot SPL</p> <p>3. ATF</p> <p>4. U-Boot</p> <p>5. Linux</p> <p>6. Application</p> <p></p> <p>The following table presents a short description of the different boot stages:</p> Stage Description SDM Secure Device Manager boots first U-Boot SPL Configures IO, FPGA, brings up SDRAM ATF Arm Trusted Firmware, provides SMC handler U-Boot Loads Linux kernel Linux Operating system Application User application <p>For more information, please refer to Intel Agilex\u2122 Hard Processor System Technical Reference Manual (Booting and Configuration chapter).</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#exercise-prebuilt-gsrd","title":"Exercise Prebuilt GSRD","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#configure-board","title":"Configure Board","text":"<p>This section presents the necessary board settings in order to run the GSRD on the development board.</p> <p>First, confirm the following:</p> <ul> <li>SD Card/OOBE Daughter card is installed on HPS Daughter card socket</li> </ul> <p>Then the board switches need to be configured as follows:</p> <ul> <li>SW1: ON-OFF-OFF-ON</li> <li>SW2: all OFF</li> <li>SW3: OFF-OFF-ON-ON-ON-ON</li> <li>SW4: OFF-OFF-OFF-ON</li> <li>SW5: all OFF</li> <li>SW6: OFF-OFF-OFF-ON</li> <li>SW9: OFF-OFF</li> <li>SW10: OFF-ON</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#configure-serial-connection","title":"Configure Serial Connection","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, the SoC EDS Pro installer automatically installs the required drivers if necessary.</p> <p>The serial communication parameters are:</p> <ul> <li>Baud-rate: 115,200</li> <li>Parity: none</li> <li>Flow control: none</li> <li>Stop bits: 1</li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus.</p> <p>On Linux, the minicom utility can be used. Here is how to configure it:</p> <p>The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following:</p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB*</li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet.</li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared.</li> <li>Install minicom application on host PC, if not installed.</li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom</li> <li>Configure minicom.</li> </ul> <pre><code>$ sudo minicom -s\n</code></pre> <p>Under Serial Port Setup choose the following:</p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary)</li> <li>Bps/Par/Bits: 115200 8N1</li> <li>Hardware Flow Control: No</li> <li>Software Flow Control: No</li> <li>Hit [ESC] to return to the main configuration menu</li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>This section presents how to write the QSPI Falsh and SD Card image files, configure the board and boot Linux.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-qspi-image","title":"Write QSPI Image","text":"<p>The QSPI JIC image contains the FPGA configuration bitstream, and the U-Boot SPL.</p> <p>1. Download and extract the image file:</p> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agf014eb_gsrd/ghrd_agfb014r24b2e2v.jic.tar.gz\ntar xf ghrd_agfb014r24b2e2v.jic.tar.gz\n</code></pre> <p>2. Configure MSEL to JTAG:</p> <ul> <li>SW1: ON-ON-ON-ON</li> </ul> <p>3. Power cycle the board</p> <p>4. Write the image using the following commands:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agfb014r24b2e2v.jic\"\n</code></pre> <p>5. Configure MSEL back to QSPI:</p> <ul> <li>SW1: ON-OFF-OFF-ON</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-sd-card-image","title":"Write SD Card Image","text":"<p>This section explains how to create the SD card necessary to boot Linux, using the SD card image available with the pre-built Linux binaries package. Once the SD card has been created, insert the card into the SD slot of the Micro SD daughter card.</p> Write SD Card on Linux <p>1. Download the SD card image and extract it:</p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agf014eb_gsrd/sdimage.tar.gz\ntar xf sdimage.tar.gz\n</code></pre> <p>The extacted file is named <code>gsrd-console-image-agilex7.wic</code>.</p> <p>2. Determine the device associated with the SD card on the host by running the following command before and after inserting the card.</p> <pre><code>$ cat /proc/partitions\n</code></pre> <p>Let's assume it is /dev/sdx.</p> <p>3. Use dd utility to write the SD image to the SD card.</p> <pre><code>$ sudo dd if=gsrd-console-image-agilex7.wic of=/dev/sdx bs=1M\n</code></pre> <p>Note we are using sudo to be able to write to the card.</p> <p>4. Use sync utility to flush the changes to the SD card.</p> <pre><code>$ sudo sync\n</code></pre>  Write SD Card on Windows <p>1. Download the SD card image and extract it: https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agf014eb_gsrd/sdimage.tar.gz</p> <p>The extacted file is named <code>gsrd-console-image-agilex7.wic</code>.</p> <p>2. Rename the wic file as <code>sdcard.img</code></p> <p>3. Use Win32DiskImager to write the image to the SD card. The tool can be downloaded from https://sourceforge.net/projects/win32diskimager/files/latest/download</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-linux","title":"Boot Linux","text":"<p>This section presents how to boot Linux on the board. The required steps are:</p> <p>1. Start serial terminal (when using Minicom it will connect using the selected settings, for others connect manually).</p> <p>2. Power up the board.</p> <p>3. U-Boot SPL is ran</p> <p>4. U-Boot is ran</p> <p>5. Linux boots.</p> <p>6. Login using 'root' and no password.</p> <p>7. Run 'ifconfig' command to determine the IP of the board</p> <pre><code>root@agilex7dksiagf014eb:~# ifconfig\neth0: flags=4163 mtu 1500\ninet 192.168.1.163 netmask 255.255.255.0 broadcast 192.168.1.255\n inet6 fe80::20cd:5eff:fe36:dbaf prefixlen 64 scopeid 0x20\n ether 22:cd:5e:36:db:af txqueuelen 1000 (Ethernet)\nRX packets 14 bytes 2126 (2.0 KiB)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 43 bytes 7513 (7.3 KiB)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 21 base 0x2000\n\neth1: flags=4099 mtu 1500\nether 5a:4d:ca:de:cd:f6 txqueuelen 1000 (Ethernet)\nRX packets 0 bytes 0 (0.0 B)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 0 bytes 0 (0.0 B)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 22 base 0xc000\n\nlo: flags=73 mtu 65536\ninet 127.0.0.1 netmask 255.0.0.0\n inet6 ::1 prefixlen 128 scopeid 0x10\n loop txqueuelen 1000 (Local Loopback)\nRX packets 100 bytes 8468 (8.2 KiB)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 100 bytes 8468 (8.2 KiB)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\n</code></pre> <p>Note: there are two IP addresses, one coming from the Ethernet port on the HPS Daughtercard, and one from the Ethernet port on the DevKit, which is connected throgh SGMII.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#run-sample-applications","title":"Run Sample Applications","text":"<p>The GSRD includes a number of sample Linux applications that help demonstrate some of the features of the platform:</p> <ul> <li>Display Hello World message</li> <li>Control LEDs</li> <li>Detect interrupts from push buttons and DIP switches</li> </ul> <p>The sample applications can be used as a starting point for users to write their own applications that interact with software IP through Linux drivers.</p> Prerequisites  <p>1. Boot Linux on the target board as described in Boot Linux. You will not need to use the serial terminal if you plan on using ssh connection.</p> <p>2. Connect to the board using one of the following options:</p> <ul> <li>Connect using serial console, as described in Boot Linux</li> <li>Connect using ssh, as described in Connect With SSH</li> </ul> <p>3. In serial console, or ssh client console, change current folder to be /home/root/intelFPGA. This is where the application binaries are stored.</p> <pre><code>root@agilex7dksiagf014eb:~# cd /home/root/intelFPGA/\nroot@agilex7dksiagf014eb:~/intelFPGA#\n</code></pre> Display Hello World Message <p>Run the following command to display the Hello World message on the console:</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# ./hello\nHello SoC FPGA!\n</code></pre> Exercise Soft PIO Driver for LED Control <p>The following LEDs are exercised:</p> User FPGA LED Number Corresponding Board LED 0 D21 1 D23 2 D25 <p>Note: User FPGA LED #3 / D27 is quickly blinking, and cannot be controlled from software.</p> <p>1. In order to blink an LED in a loop, with a specific delay in ms, run the following command:</p> <pre><code>./blink &lt;led_number&gt; &lt;delay_ms&gt;\n</code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The delay_ms is a number that specifies the desired delay in ms between turning the LED on and off.</li> </ul> <p>2. In order to turn an individual LED on or off, run the following command:</p> <pre><code>./toggle &lt;led_number&gt; &lt;state&gt;\n</code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The state needs to be 0 to turn the LED off, and 1 to turn the LED on.</li> </ul> <p>3. In order to scroll the FPGA LEDs with a specific delay, please run the following command:</p> <pre><code>./scroll_client &lt;delay&gt;\n</code></pre> <p>The delay specifies the desired scrolling behavior:</p> <ul> <li>delay &gt; 0 - specify new scrolling delay in ms, and start scrolling</li> <li>delay &lt; 0 - stop scrolling</li> <li>delay = 0 - display current scroll delay</li> </ul> System Check Application <p>System check application provides a glance of system status of basic peripherals such as:</p> <ul> <li>USB: USB device driver</li> <li>Network IP (IPv4): Network IP address</li> <li>HPS LEDs: HPS LED state</li> <li>FPGA LEDs: FPGA LED state</li> </ul> <p>Run the application by issuing the following command:</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# ./syschk\n</code></pre> <p>The application will look as follows, press 'q' to exit:</p> <pre><code> ALTERA SYSTEM CHECK\n\nlo : 127.0.0.1 usb1 : DWC OTG Controller\neth0 : 192.168.1.163\n serial@ffc02100 : disabled\nfpga_led2 : OFF serial@ffc02000 : okay\nhps_led2 : OFF\nfpga_led0 : OFF\nhps_led0 : OFF\nfpga_led3 : OFF\nfpga_led1 : OFF\nhps_led1 : OFF\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#register-interrupts","title":"Register Interrupts","text":"<p>The following are exercised:</p> <ul> <li>User FPGA DIP switches</li> <li>SW2.SW0</li> <li>SW2.SW1</li> <li>SW2.SW2</li> <li>SW2.SW3</li> <li>User FPGA push buttons</li> <li>0: S1</li> <li>1: S2</li> <li>2: S3</li> <li>3: S4</li> </ul> <p>In order to register an interrupt handler to a specific GPIO, you will first need to determine the GPIO number used.</p> <p>1. Open the Linux Device Tree socfpga_agilex7_ghrd.dtsi file and look up the labels for the DIP switches and Push button GPIOs:</p> <pre><code> button_pio: gpio@f9001060 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0xf9001060 0x10&gt;;\ninterrupt-parent = &lt;&amp;intc&gt;;\ninterrupts = &lt;0 18 4&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;2&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\ndipsw_pio: gpio@f9001070 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0xf9001070 0x10&gt;;\ninterrupt-parent = &lt;&amp;intc&gt;;\ninterrupts = &lt;0 17 4&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;3&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\n</code></pre> <p>2. Run the following to determine the GPIO numbers for the DIP switches</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# grep -r \"gpio@f9001070\" /sys/class/gpio/gpiochip*/label\n/sys/class/gpio/gpiochip1928/label:/soc/gpio@f9001070\n</code></pre> <p>This means that the GPIOs 1928 .. 1931 are allocated to the DIP switches (there are 4 of them).</p> <p>3. Run the followinig to determine the GPIO numbers for the pushbuttons</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# grep -r \"gpio@f9001060\" /sys/class/gpio/gpiochip*/label\n/sys/class/gpio/gpiochip1960/label:/soc/gpio@f9001060\n</code></pre> <p>This means that the GPIOs 1960 \u2026 1963 are allocated to the push buttons (there are 4 of them).</p> <p>4. Register interrupt for one of the dipswiches, using the appropriate GPIO number, as determined in a previous step:</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# modprobe gpio_interrupt gpio_number=1928 intr_type=3\n[ 893.594901] gpio_interrupt: loading out-of-tree module taints kernel.\n[ 893.602212] Interrupt for GPIO:1928\n[ 893.602212] registered\n</code></pre> <p>5. Toggle the dipswitch a few times, you will see messages from the interrupt handler</p> <pre><code>[ 933.872016] Interrupt happened at gpio:1028\n[ 936.630233] Interrupt happened at gpio:1928\n[ 938.737038] Interrupt happened at gpio:1928\n[ 939.951513] Interrupt happened at gpio:1928\n</code></pre> <p>6. Remove the driver</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# rmmod gpio_interrupt\n</code></pre> <p>7. Register the pushbutton interrupt, using the appropriate GPIO number as determine on a previous step</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# modprobe gpio_interrupt gpio_number=1960 intr_type=2\n[ 1138.025297] Interrupt for GPIO:1960\n[ 1138.025297] registered\n</code></pre> <p>8. Push the pusbutton a few times, you will see interrupt handler messages</p> <pre><code>[ 1141.672192] Interrupt happened at gpio:1960\n[ 1142.110673] Interrupt happened at gpio:1960\n[ 1142.499468] Interrupt happened at gpio:1960\n[ 1142.884199] Interrupt happened at gpio:1960\n</code></pre> <p>9. Once done, remove the handler</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# rmmod gpio_interrupt\n</code></pre> <p>Note: If you are on the ssh console, you will need to run the program dmesg after pressing the button in order to see the messages:</p> <pre><code>root@agilex7dksiagf014eb:~/intelFPGA# dmesg\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#connect-to-web-server","title":"Connect to Web Server","text":"<p>The GSRD includes a web server running on the target board that can be used to exercise some of the board features:</p> <ul> <li>Turning LEDs ON and OFF</li> <li>Scrolling LEDs in a sequence</li> <li>Displaying the current status of the LEDs</li> </ul> <p>The web page served by the web server also contains links to some relevant information on the Intel website.</p> <p>Perform the following steps to connect to the web server running on the board:</p> <p>1. Boot Linux as described in Booting Linux.</p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be network interfaces of them, either can be used.</p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter.</p> <p></p> <p>4. Scroll the webpage down to the section named Interacting with Agilex\u2122 SoC Development Kit.</p> <p></p> <p>You will be able to perform the following actions:</p> <ul> <li>See which LEDs are ON and which are off in the LED Status. Note that if the LEDs are setup to be scrolling, the displayed scrolling speed will not match the actual scrolling speed on the board.</li> <li>Stop LEDs from scrolling, by clicking START and STOP buttons. The delay between LEDs turning ON and OFF is set in the LED Lightshow box.</li> <li>Turn individual LEDs ON and OFF with the ON and OFF buttons. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> <li>Blink individual LEDs by typing a delay value in ms then clicking the corresponding BLINK button. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#connect-with-ssh","title":"Connect With SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection.</p> <p></p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS:</p> <pre><code>$ sudo yum install openssh-clients\n</code></pre> <p>or the following command on Ubuntu:</p> <pre><code>$ sudo apt-get install openssh-client\n</code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-qspi","title":"Boot from QSPI","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-qspi-image_1","title":"Write QSPI Image","text":"<p>1. Configure MSEL to JTAG:</p> <p>2. Power cycle the board</p> <p>3. Write the image using the following commands:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;flash_image.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-linux_1","title":"Boot Linux","text":"<p>1. Configure MSEL back to QSPI</p> <p>2. Important: Remove SD card (or write zero to first few MBs) to confirm Linux is booting without it.</p> <p>3. Power cycle. Board will boot up to Linux prompt, where you can login as 'root' without a password.</p> <p>Note: First time Linux is booted, the UBIFS rootfs will be initialized, the step taking approximately 3 minutes, as shown in the log below: <pre><code>[   12.272151] platform soc:leds: deferred probe pending\n&lt;-- ... 3 minute 'gap' here\n[  216.905453] UBIFS (ubi0:4): free space fixup complete\n[  217.035839] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[  217.043228] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[  217.052599] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size 8650240 bytes (8 MiB, 133 LEBs)\n[  217.064650] UBIFS (ubi0:4): reserved for root: 0 bytes (0 KiB)\n[  217.070469] UBIFS (ubi0:4): media format: w4/r0 (latest is w5/r0), UUID 4A5F6BFC-BA49-47C9-A17A-425E35F3A52F, small LPT model\n[  217.271031] VFS: Mounted root (ubifs filesystem) on device 0:20\n</code></pre></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-nand","title":"Boot from NAND","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-nand-binaries","title":"Write NAND Binaries","text":"<p>1. Copy files to your TFTP server folder:</p> <pre><code>cp -f $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot.itb&lt;your-tftp-server-folder&gt;\ncp -f $TOP_FOLDER/nand-bin/root.ubi &lt;your-tftp-server-folder&gt;\n</code></pre> <p>2. Run U-Boot with the debugger, similar to how it is described at Run U-Boot from Debugger just change the script to use the binaries directly from <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/</code> and use the new name for the sof: <code>agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof</code>.</p> <p>3. Stop at U-Boot prompt, and run the following instructions to download and write NAND binaries to flash:</p> <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your-tftp-server-ip&gt;\n\ntftp $loadaddr u-boot.itb\nnand erase.part u-boot\nnand write $loadaddr u-boot $filesize\ntftp $loadaddr root.ubi\nnand erase.part clean root\nnand write.trimffs $loadaddr root $filesize\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#write-qspi-image_2","title":"Write QSPI Image","text":"<p>1. Power off board</p> <p>2. Set MSEL to JTAG</p> <p>3. Power on board</p> <p>4. Write jic image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agfb014r24b2e2v.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-linux_2","title":"Boot Linux","text":"<p>1. Make sure board is powered off.</p> <p>2. Set MSEL to QSPI</p> <p>3. Power up the board.</p> <p>4. Linux will boot, enter 'root' as user name to log in.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#partial-reconfiguration","title":"Partial Reconfiguration","text":"<p>Partial reconfiguration (PR) allows you to reconfigure a portion of the FPGA dynamically, while the rest of the FPGA design continues to function.  This section presents how to run the PR scenarios included with the GSRD.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#reference-information","title":"Reference Information","text":"<p>Refer to the following fore more details about Partial Reconfiguration</p> <ul> <li>User Guide<ul> <li>Intel Quartus Prime Pro Edition User Guide: Partial Reconfiguration</li> </ul> </li> <li>Partial Reconfiguration for Intel FPGA Devices YouTube videos:<ul> <li>Part1: Introduction &amp; Project Assignments</li> <li>Part2: Design Guidelines &amp; Host Requirements</li> <li>Part3: PR Host IP &amp; Implementations</li> <li>Part4: Output Files &amp; Demonstration</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#hardware-design","title":"Hardware Design","text":"<p>The updated GHRD contains the following components which enable PR:</p> <ul> <li>A PR region was created in the FPGA fabric, with the following associated IP<ul> <li>PR Freeze Controller - to help control the PR</li> <li>Avalon-MM PR Freeze Bridge - to help isolate the IP in the PR region during the PR process</li> </ul> </li> <li>The base revision of the project has the following in the PR region:<ul> <li>SysID located at 0xF900_0800: with id=0xfacecafe</li> <li>OCRAM located at 0xF900_0900</li> </ul> </li> <li>An alternate revision of the project contains the following in the PR region:<ul> <li>SysID located at 0xF900_0900: with id=0xcafeface</li> <li>OCRAM located at 0xF900_0800</li> </ul> </li> </ul> <p>The following diagram presents an overview of the PR region and associated IP and how it is connected to HPS:</p> <p></p> <p>Throughout this page, the content of the PR region for the base revision is called \"persona0\" while the content of the PR region for the other revision is called \"persona1\". The diagram below illustrates the differences between the two personas:</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#pr-files","title":"PR Files","text":"<p>The files on the Linux rootfs used for running the PR scenarios are shown below:</p> File Description /sbin/dtbt Tool used for managing the overlays. Available at https://github.com/altera-opensource/dtbt /boot/devicetree/agilex7_pr_fpga_static_region.dtbo overlay for the static region, needs to be applied before persona overlays /boot/devicetree/agilex7_pr_persona0.dtbo overlay for persona0 /boot/devicetree/agilex7_pr_persona0.dtbo overlay for persona1 /lib/firmware/persona0.rbf bitstream used by persona0 overlay /lib/firmware/persona1.rbf bitstream used by persona1 overlay <p>The DTS files for the overlays are available at https://github.com/altera-opensource/meta-intel-fpga-refdes/blob/scarthgap/recipes-bsp/device-tree/files/:</p> <ul> <li>agilex7_pr_fpga_static_region.dts</li> <li>agilex7_pr_persona0.dts</li> <li>agilex7_pr_persona1.dts</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#run-pr-scenarios","title":"Run PR Scenarios","text":"<p>1. Boot Linux</p> <p>2. Add the overlay for the static region:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -a agilex7_pr_fpga_static_region.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\n[ 292.932872] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges\nApplying dtbo: agilex_pr_fpga_static_region.dtbo\n[ 292.944184] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/external-fpga-config\n[ 292.960109] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/clocks\n[ 292.970529] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/clock-names\n[ 292.981470] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/clk_0\n[ 292.991034] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/freeze_controller_0\n[ 293.007735] of-fpga-region soc:base_fpga_region:fpga_pr_region0: FPGA Region probed\n[ 293.028076] altera_freeze_br f9000450.freeze_controller: fpga bridge [freeze] registered\n</code></pre> <p>3. Add the overlay for persona0:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -a agilex7_pr_persona0.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\n[ 398.171799] fpga_manager fpga0: writing persona0.rbf to Stratix10 SOC FPGA Manager\nApplying dtbo: agilex_pr_persona0.dtbo\n[ 398.321356] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_clk_100\n[ 398.332459] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_sysid_qsys_0\n</code></pre> <p>4. Locate the sysid and display the associated id:</p> <pre><code>root@agilex7dksiagf014eb:~# find / -name sysid\n/sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000800.sysid/sysid\nroot@agilex7dksiagf014eb:~# cat /sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000800.sysid/sysid/id | xargs printf \"0x%08x\\n\"\n0xcafeface\n</code></pre> <p>5. List the applied overlays:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -l\n2 agilex_pr_persona0.dtbo applied /sys/kernel/config/device-tree/overlays/2-agilex_pr_persona0.dtbo\n1 agilex_pr_fpga_static_region.dtbo applied /sys/kernel/config/device-tree/overlays/1-agilex_pr_fpga_static_region.dtbo\n</code></pre> <p>6. Remove persona0 overlay:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -r agilex7_pr_persona0.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\nRemoving dtbo: 2-agilex_pr_persona0.dtbo\n</code></pre> <p>7. Add the persona1 overlay:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -a agilex7_pr_persona1.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\n[ 531.975623] fpga_manager fpga0: writing persona1.rbf to Stratix10 SOC FPGA Manager\nApplying dtbo: agilex_pr_persona1.dtbo\n[ 532.124433] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_clk_100\n[ 532.135530] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_sysid_qsys_0\n</code></pre> <p>8. Locate the sysid and display the associated id:</p> <pre><code>root@agilex7dksiagf014eb:~# find / -name sysid\n/sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000900.sysid/sysid\nroot@agilex7dksiagf014eb:~# cat /sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000900.sysid/sysid/id | xargs printf \"0x%08x\\n\"\n0xfacecafe\n</code></pre> <p>9. Remove persona1:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -r agilex7_pr_persona1.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\nRemoving dtbo: 2-agilex_pr_persona1.dtbo\n</code></pre> <p>10. List the applied overlays:</p> <pre><code>root@agilex7dksiagf014eb:~# dtbt -l\n1 agilex_pr_fpga_static_region.dtbo applied /sys/kernel/config/device-tree/overlays/1-agilex_pr_fpga_static_region.dtbo\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#rebuild-the-gsrd","title":"Rebuild the GSRD","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-sd-card_1","title":"Boot from SD Card","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd\nmkdir agilex7f_gsrd\ncd agilex7f_gsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex_soc_devkit_ghrd\nexport BOARD_PWRMGT=linear\nexport HPS_ENABLE_SGMII=0\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\nunset BOARD_PWRMGT\nunset HPS_ENABLE_SGMII\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof - FPGA configuration file, without HPS FSBL</li> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex - HPS Debug FSBL</li> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf</li> <li>agilex7_dk_si_agf014eb_nand_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona0.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona1.rbf: not applicable</li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n file://agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=xxxxxxxxx \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the file:</p> <pre><code>SRC_URI[agilex7_dk_si_agf014eb_gsrd_core.sha256sum] = \"5d633ee561d5cc8c22b51211a144654fdc0be47ee14b07ac134074cbff84eb8b\"\n</code></pre> <p>by using the following commands:</p> <pre><code>sed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014eb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014eb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-agilex-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-qspi_1","title":"Boot from QSPI","text":"<p>This section presents how to boot from QSPI.</p> <p>Much of the same binaries as when booting from SD card can be used to boot from QSPI, because:</p> <ul> <li>The QSPI resides on the DevKit board, and not on the HPS daughtercard, so there are no board changes:</li> <li>The same GHRD configuration can be used</li> <li>The same U-Boot devce tree can be used</li> <li>The same Linux device tree can be used</li> <li>U-Boot uses distroboot, which will try first booting from SD/MMC, then from QSPI, then from NAND, so the same U-Boot can be used.</li> </ul> <p>As the QSPI has a much smaller size than the SD card (256MB vs 2GB) the rootfs is smaller, and less functionality is provided. The purpose of this section is just to show Linux booting.</p> <p>Note: The HPS speed for accessing SDM QSPI is limited to ~8MB/s. It is up to you to decide whether this level of performance is sufficient for your application. If not, it is recommended you use an SD card or eMMC device to store the HPS components such as the rootfs. Note that the QSPI speed limitation does not apply when SDM accesses the QSPI, it is just for HPS accessing SDM QSPI.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#qspi-flash-layout","title":"QSPI Flash Layout","text":"MTD Partition UBI Volume Volume Name Type Image/File Size 0 (qspi_uboot) N/A N/A RAW bitstream (FPGA image, SDM firmware) 64MB N/A N/A RAW u-boot.itb 2MB 1 (qspi_root) 0 env UBI u-boot.env root.ubi 256KB 1 script UBI u-boot.scr 128KB 2 kernel UBI kernel.itb 24MB 3 dtb UBI kernel.dtb 256KB 4 rootfs UBIFS rootfs.ubifs 160MB"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image_1","title":"Create QSPI Image","text":"<p>1. Create a folder to contain all the qspi binaries, and create symlinks to actual location for all files:</p> <pre><code>cd $TOP_FOLDER\nrm -rf qspi-boot &amp;&amp; mkdir qspi-boot &amp;&amp; cd qspi-boot\nln -s $TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof fpga.sof\nln -s $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex spl.hex\nln -s $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/console-image-minimal-agilex7_nor.ubifs rootfs.ubifs\n</code></pre> <p>2. Create U-Boot image:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncp $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>3. Create hps.ubi file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncat &lt;&lt;EOT &gt;ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOT\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>4. Create the QSPI image using the provided Quartus Programming File Generator (PFG) file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-7/f-series/soc/gsrd/collateral/agilex7f_gsrd.pfg\nquartus_pfg -c agilex7f_gsrd.pfg\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-fpg-file","title":"Create FPG File","text":"<p>This section presents how to manually re-create the Programming File Generator file provided at https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-7/f-series/soc/gsrd/collateral/agilex7f_gsrd.pfg</p> <p>1. Start Quartus Programming File Generator GUI:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nqpfgw &amp;\n</code></pre> <p>2. In PFG Output Files tab:</p> <ul> <li>Select Device Family as \"Agillex\"</li> <li>Select Configuration Mode as \"Active Serial x4\"</li> <li>Edit Name as \"flash_image\"</li> <li>Check JTAG Indirect Configuration File (.jic)</li> <li>Check Memory Map File (.map)</li> </ul> <p></p> <p>3. In PFG Input Files tab:</p> <ul> <li>Click Add Bitstream\", then browse to \"fpga.sof\" link, and add click *Open to add it.</li> <li>Click Bitstream_1&gt;fpga.sof then click Properties the click HPS Bootloader, browse to \"spl.hex\" then click Open to add it.  Note: By the time the fpga.sof file is read the following error is displayed, this was addressed by adding the spl.hex file to the Bitstream: File fpga.sof is incomplete- HPS is present but bootloader information is missing.</li> <li>Click Add Raw Data then change the extension filter to .bin then browse to \"u-boot.bin\" and click Open to add it.</li> <li>Click on the \"u-boot.bin\" then click \"Prpperties\" then select Bit swap option to \"On\"</li> <li>Repeat the above 2 steps for the following files:</li> <li>hps.bin</li> </ul> <p>The Input Files tab will now look something like this:</p> <p></p> <p>4. In the PFG Configuration Device tab:</p> <ul> <li>Click Add Device, select the Micron MT25QU02G device then click Add</li> <li>Click the MT25QU02G device, then click Add Partition, select the options as following then click OK:</li> </ul> <p></p> <ul> <li>Click the MT25QU02G device, then click Add Partition, select the options as following then click OK:</li> </ul> <p> ting</p> <ul> <li>Repeat the above step for the rest of binary files, choosing the following offsets:</li> <li>hps: 0x04200000</li> <li>Click Flash Loader &gt; Select then browse to the device used on the devkit then click OK:</li> </ul> <p></p> <p>The Configuration Device tab will now look something like this:</p> <p></p> <p>5. Go to File &gt; Save As and save the configuration file as \"flash_image_qspi.pfg\".</p> <p>6. [Optional] Open the file \"flash_image_qspi.pfg\" with a text editor and change absolute paths to relative paths.</p> <p>The file will look like this:</p> <pre><code>&lt;pfg version=\"1\"&gt;\n&lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n&lt;output_files&gt;\n&lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n&lt;file_options/&gt;\n&lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n&lt;/output_file&gt;\n&lt;/output_files&gt;\n&lt;bitstreams&gt;\n&lt;bitstream id=\"Bitstream_1\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;/bitstreams&gt;\n&lt;raw_files&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n&lt;/raw_files&gt;\n&lt;flash_devices&gt;\n&lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"u-boot\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"hps\" size=\"0\"/&gt;\n&lt;/flash_device&gt;\n&lt;flash_loader&gt;AGFB014R24B&lt;/flash_loader&gt;\n&lt;/flash_devices&gt;\n&lt;assignments&gt;\n&lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n&lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;assignment partition_id=\"u-boot\"&gt;\n&lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"0\" partition_id=\"hps\"&gt;\n&lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;/assignments&gt;\n&lt;/pfg&gt;\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-nand_1","title":"Boot From NAND","text":"<p>This section presents how to boot from NAND, including how to build all binaries.</p> <p>Build instructions are the same as for standard SD or QSPI boot. The U-Boot, ATF and Linux binaries are all the same. The only difference is that the GHRD is configured for the NAND HPS Daughtercard, then recompiled.</p> <p>Note: As the NAND used on the devkit has a smaller size than the SD card (1GB vs 2GB) the rootfs is smaller, and less functionality is provided. The purpose of this section is just to show Linux booting.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#nand-flash-layout","title":"NAND Flash Layout","text":"MTD Partition UBI Volume Volume Name Type Image/File Flash Offset Size Size in Hex 0 (u-boot) N/A N/A RAW u-boot.itb 0x00000000 2MB 0x00200000 1 (root) 0 env UBI u-boot.env root.ubi 0x00200000 onwards 256KB 0x40000 1 script UBI u-boot.scr 128KB 0x00020000 2 kernel UBI kernel.itb 64MB 0x04000000 3 dtb UBI kernel.dtb 256KB 0x00040000 4 rootfs UBIFS rootfs.ubifs &lt;957MB &lt;0x3BD70000"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-environment_1","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd.nand\nmkdir agilex7f_gsrd.nand\ncd agilex7f_gsrd.nand\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-hardware-design_1","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex_soc_devkit_ghrd\nexport BOARD_PWRMGT=linear\nexport HPS_ENABLE_SGMII=0\nexport DAUGHTER_CARD=devkit_dc_nand\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\nunset BOARD_PWRMGT\nunset HPS_ENABLE_SGMII\nunset DAUGHTER_CARD\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex</code> - HPS Debug FSBL</li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-core-rbf_1","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-yocto_1","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#customize-yocto_1","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_nand_ghrd.core.rbf</li> <li>agilex7_dk_si_agf014eb_pr_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona0.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_persona1.rbf: not applicable</li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_nand_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n file://agilex7_dk_si_agf014eb_nand_ghrd.core.rbf;sha256sum=xxxxxxxxxxxxx \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_nand_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_nand_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the file:</p> <pre><code>SRC_URI[agilex7_dk_si_agf014eb_nand_core.sha256sum] = \"f7a9a7f60f6c1c1c0197292573c844be625d9cd3e96c1c1105e1a6057aad699c\"\n</code></pre> <p>by using the following command:</p> <pre><code>sed -i \"/agilex7_dk_si_agf014eb_nand_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-yocto_1","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014eb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014eb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images</code> folder are:</p> File Description gsrd-console-image-agilex7_nand.ubifs UBI root partition image u-boot-agilex-socdk-gsrd-atf/u-boot.itb U-Boot FIT image u-boot-agilex-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image_2","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic</code> - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li><code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-nand-binaries","title":"Build NAND Binaries","text":"<p>1. Gather the files into a single folder, using symlinks:</p> <pre><code>cd $TOP_FOLDER\nrm -rf nand-bin &amp;&amp; mkdir nand-bin &amp;&amp; cd nand-bin\nln -s $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/gsrd-console-image-agilex7_nand.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/socfpga_agilex7_socdk_nand.dtb .\n</code></pre> <p>2. Install <code>mtd-tools</code> if not already installed. On Ubuntu the command is:</p> <pre><code>sudo apt-get install mtd-tools\n</code></pre> <p>3. Create UBI configuration file for the root partition:</p> <pre><code>cat &lt;&lt;EOT &gt;ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=64MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nimage=socfpga_agilex7_socdk_nand.dtb\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=400MiB\nvol_flag=autoresize\nEOT\n</code></pre> <p>4. Create the <code>root.ubi</code> file:</p> <pre><code>ubinize -o root.ubi -p 128KiB -m 2048 -s 2048 ubinize.cfg\n</code></pre> <p>This is what the above parameters mean:</p> <ul> <li>-p: physical eraseblock size of the flash</li> <li>-m: minimum input/output unit size of the flash</li> <li>-s: sub-pages and sub-page size, ubinize will take into account and put the VID header to same NAND page as the EC header</li> </ul> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/nand-bin/root.ubi</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#partial-reconfiguration_1","title":"Partial Reconfiguration","text":"<p>Partial reconfiguration (PR) allows you to reconfigure a portion of the FPGA dynamically, while the rest of the FPGA design continues to function.</p> <p>This section shows how to build everything needed to demonstrate the PR scenarios. Note that most of the binaries are the same as for the other boot scenarios (SD card, QSPI, NAND) just the following files are changed:</p> <ul> <li>New GHRD variant, creating different configuration bitstreams</li> <li>Updated core.rbf, persona0.rbf, persona1.rbf compared to prebuilt default files used by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-environment_2","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd.pr\nmkdir agilex7f_gsrd.pr\ncd agilex7f_gsrd.pr\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-hardware-design_2","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex_soc_devkit_ghrd\nexport BOARD_PWRMGT=linear\nexport HPS_ENABLE_SGMII=0\nexport ENABLE_PARTIAL_RECONFIGURATION=1\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\nunset BOARD_PWRMGT\nunset HPS_ENABLE_SGMII\nunset ENABLE_PARTIAL_RECONFIGURATION\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex</code> - HPS Debug FSBL</li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-core-rbf_2","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-yocto_2","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#customize-yocto_2","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_nand_ghrd.core.rbf: not applicable</li> <li>agilex7_dk_si_agf014eb_pr_ghrd.core.rbf</li> <li>agilex7_dk_si_agf014eb_pr_persona0.rbf</li> <li>agilex7_dk_si_agf014eb_pr_persona1.rbf</li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_pr_ghrd.core.rbf\nPER0_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_pr_persona0.rbf\nPER1_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_pr_persona1.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\nln -s $TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.pr_partition_0.rbf $PER0_RBF\nln -s $TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/alternate_persona.pr_partition_0.rbf $PER1_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0 \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1 \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core \\\n${GHRD_REPO}/agilex7_dk_si_agf014eb_nand_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_nand_core \\\n file://agilex7_dk_si_agf014eb_pr_ghrd.core.rbf;sha256sum=xxxxxxxxxxx \\\n file://agilex7_dk_si_agf014eb_pr_persona0.rbf;sha256sum=xxxxxxxxxxx \\\n file://agilex7_dk_si_agf014eb_pr_persona1.rbf;sha256sum=xxxxxxxxxxx\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nPER0_SHA=$(sha256sum $PER0_RBF | cut -f1 -d\" \")\nPER1_SHA=$(sha256sum $PER1_RBF | cut -f1 -d\" \")\nOLD_CORE_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_pr_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_pr_core\"\nNEW_CORE_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_pr_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nOLD_PER0_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_pr_persona0.rbf;name=agilex7_dk_si_agf014eb_pr_persona0\"\nNEW_PER0_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_pr_persona0.rbf;sha256sum=$PER0_SHA\"\nOLD_PER1_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_pr_persona1.rbf;name=agilex7_dk_si_agf014eb_pr_persona1\"\nNEW_PER1_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_pr_persona1.rbf;sha256sum=$PER1_SHA\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\nsed -i \"s/$OLD_PER0_URI/$NEW_PER0_URI/g\" $RECIPE\nsed -i \"s/$OLD_PER1_URI/$NEW_PER1_URI/g\" $RECIPE\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the files:</p> <pre><code>SRC_URI[name=agilex7_dk_si_agf014eb_pr_core.sha256sum] = \"69245470a36274f1f002cb275748664902d9262f577cae4bba92813cb48fdeaf\"\nSRC_URI[agilex7_dk_si_agf014eb_pr_persona0.sha256sum] = \"6556cc83a8e8a38fb1e52945d91bd651466e9553f8e60c04df5e71ee36dc45f2\"\nSRC_URI[agilex7_dk_si_agf014eb_pr_persona1.sha256sum] = \"8a0cdcb38aead468a62eb0cba68af05a4e242bd79a617f49176647d766b70b28\"\n</code></pre> <p>by using the following commands:</p> <pre><code>sed -i '/agilex7_dk_si_agf014eb_pr_core\\.sha256sum/d' $RECIPE\nsed -i '/agilex7_dk_si_agf014eb_pr_persona0\\.sha256sum/d' $RECIPE\nsed -i '/agilex7_dk_si_agf014eb_pr_persona1\\.sha256sum/d' $RECIPE\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-yocto_2","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014eb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014eb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-agilex-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image_3","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#boot-from-sd-card-on-the-dk-si-agf014ea","title":"Boot from SD Card on the DK-SI-AGF014EA","text":"<p>The DK-SI-AGF014EA has been discontinued. This release of the GSRD only supports the DK-SI-AGF014EB board.</p> <p>The DK-SI-AGF014EA version of the board differs from the DK-SI-AGF014EB version in that it uses Enpirion power regulators instead of Linear. Apart from this, the functionality is the same for both versions of the board.</p> <p>Binaries for the DK-SI-AGF014EB can be build by updating the DK-SI-AGF014EB instructions as follows:</p> <ul> <li>Update the hardware design to use the Enpirion power management ICs. This can be done by running the command 'export BOARD_PWRMGT=enpirion' before building the GHRD.</li> <li>Use the 'agilex7_dk_si_agf014ea' configuration for the GSRD Yocto instructions, instead of the 'agilex7_dk_si_agf014eb', where applicable.</li> </ul> <p>This section presents how build the SD card boot binaries for the DK-SI-AGF014EA, as an example. The other scenarios can be ported similarily.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-flow_1","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-environment_3","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7f_gsrd.enpirion\nmkdir agilex7f_gsrd.enpirion\ncd agilex7f_gsrd.enpirion\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#update-and-build-hardware-design","title":"Update and Build Hardware Design","text":"<p>Use the following commands to build the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex_soc_devkit_ghrd\nmake scrub_clean_all\nexport BOARD_PWRMGT=enpirion\nexport HPS_ENABLE_SGMII=0\nmake generate_from_tcl\nmake all\nunset BOARD_PWRMGT\nunset HPS_ENABLE_SGMII\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex</code> - HPS Debug FSBL</li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-core-rbf","title":"Create Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#set-up-yocto_3","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. agilex7_dk_si_agf014ea-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga\n. ./poky/oe-init-build-env agilex-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#customize-yocto_3","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf</li> </ul> <p>We copy the core.ghrd file in the Yocto recipe location:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014ea_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\n</code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agf014ea_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014ea_gsrd_core \\\n \"\n</code></pre> <p>to look like this:</p> <pre><code>SRC_URI:agilex7_dk_si_agf014eb ?= \"\\\n file://agilex7_dk_si_agf014ea_gsrd_ghrd.core.rbf;sha256sum=xxxxxxxxx \\\n \"\n</code></pre> <p>using the following commands:</p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014ea_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014ea_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014ea_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>3. In the same Yocto recipe delete the old SHA256 checksum for the file:</p> <pre><code>SRC_URI[agilex7_dk_si_agf014ea_gsrd_core.sha256sum] = \"5d633ee561d5cc8c22b51211a144654fdc0be47ee14b07ac134074cbff84eb8b\"\n</code></pre> <p>by using the following commands:</p> <pre><code>sed -i \"/agilex7_dk_si_agf014ea_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li>fit_kernel_agilex.its</li> </ul> <p>- its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD, NAND and PR board configurations</li> <li>Core RBF files for SD, NAND and PR board configurations</li> <li>Board configurations for SD, NAND and PR cases</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#build-yocto_3","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>agilex7_dk_si_agf014ea-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>agilex7_dk_si_agf014ea-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agf014eb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agf014ea-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#create-qspi-image_4","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd_socfpga/agilex7_dk_si_agf014ea-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/gsrd/ug-gsrd-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/","title":"Agilex\u2122 7 SoC FPGA Remote Debug Example","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#introduction","title":"Introduction","text":"<p>Intel offers an integrated set of System Level Debug (SLD) tools, including:</p> <ul> <li>SignalTap II Logic Analyzer</li> <li>In-System Sources and Probes (ISSP),</li> <li>In-System Memory Content Editor)</li> </ul> <p>Typically, the System-Level Debugging (SLD) communication solution was interfacing with the outside world through the JTAG. Then either an USB or Ethernet Blaster could be used to interface JTAG to the host PC.</p> <p></p> <p></p> <p>Another alternative approach is also available, to interface the SLD to the outside world directly through Ethernet on board, without requiring either an USB or Ethernet Blaster.</p> <p></p> <p>This page presents an example on how enable this remote debug feature on top of the GSRD.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#architecture","title":"Architecture","text":"<p>In the traditional approach the SLD communication solution was based on the Altera JTAG Interface (AJI) which interfaced with the JTAG TAP controller (hard atom in Altera devices which implements the JTAG protocol). The SLD tools used the JTAG channel for communication between software and hardware.</p> <p></p> <p>The remote FPGA debugging solution consists of the following:</p> <ul> <li>JTAG-Over Protocol (JOP) Component: Platform Designer component which enables access to debug information through an Avalon\u00ae-MM slave bus</li> <li>Etherlink: HPS application exporting debug information over Ethernet, available on github: https://github.com/altera-opensource/remote-debug-for-intel-fpga</li> </ul> <p></p> <p>The JOP component requires reset and clocking and also provides an Avalon\u00ae-MM slave bus through which is configured and debug information is accessed.</p> <p>Th Etherlink application runs on HPS, accesses the JOP component slave bus to access the debug information, and provides a TCP/IP link from the host PC running the Quartus Pro debug tools to the board.</p> <p>The etherlink works with the standard UIO Linux kernel driver.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#example","title":"Example","text":"<p>This section shows an example of how to use the Remote Debug feature. Communication is established from the board to the host PC through Ethernet, so that the board appears as another JTAG device, listed by jtagconfig utility.</p> <p>The example is based on the GSRD, with the following changes:</p> <ul> <li>Adding JOP component to the GHRD</li> <li>Adding JOP to the Linux device tree</li> </ul> <p>Notes:</p> <ul> <li>UIO driver is enabled as module in the default kernel configuration file</li> <li>etherlink is already part of the rootfs, built by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Altera Agilex\u2122 7 FPGA F-Series Transceiver-SoC Development Kit (Production 1 P-Tiles &amp; E-Tiles) ordering code DK-SI-AGF014EB.<ul> <li>SD/MMC HPS Daughtercard</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel\u00ae FPGA Download Cable II</li> <li>Micro SD card</li> </ul> </li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera Quartus\u00ae Prime Pro Edition Version 24.3</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for more details about the devkit.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf agilex7.remote_debug\nmkdir agilex7.remote_debug\ncd agilex7.remote_debug\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>The hardware design is based on the GSRD, just that the JOP component is added, and connected to clock, reset and the LWH2F bridge. The following instructions are used:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex_soc_devkit_ghrd\nexport BOARD_PWRMGT=linear\nexport ENABLE_JOP=1\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\nunset ENABLE_JOP unset BOARD_PWRMGT\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex</code> - HPS Debug FSBL</li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul> <p>For reference, the JOP component can be added manually to a Platform Designer system as follows:</p> <p>1. In the IP Catalog search for jop and double-click the component to add it to the system:</p> <p></p> <p>2. Configure the JOP component as follows:</p> <p></p> <p>3. Connect the reset and clock to JOP component, also connect it's slave bus to the HPS LW bridge, and map it to the desired offset:</p> <p></p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#build-corerbf-file","title":"Build Core.RBF File","text":"<p>This section shows how to create the core RBF file, which is needed by the Yocto recipes:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v_hps_debug.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agfb014r24b2e2v.hps.jic\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#build-yocto","title":"Build Yocto","text":"<p>Perform the following steps to build Yocto:</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. agilex7_dk_si_agf014eb-gsrd-build.sh\nbuild_setup\n</code></pre> <p>3. Enable the JOP UIO driver in the Linux device tree, by editing the file <code>meta-intel-fpga-refdes</code> to inlcude the changes shown below:</p> <pre><code>diff --git a/recipes-bsp/device-tree/files/socfpga_ilc.dtsi b/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\nindex 387d8bd..156dbb8 100644\n--- a/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\n+++ b/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\n@@ -14,5 +14,10 @@\n            status = \"disabled\";\n            altr,sw-fifo-depth = &lt;32&gt;;\n        };\n+        jop@f9008000{\n+                                compatible = \"generic-uio\";\n+                                reg = &lt;0xf9008000 0x5000&gt;;\n+                                reg-names = \"jop\";\n+                };\n    };\n };\n</code></pre> <p>Note that the range of memory where the JOP is located is <code>0xf9008000</code> .. <code>0xf900dfff</code>.</p> <p>This can be done with the provided patch file:</p> <pre><code>rm -f agilex7-dts-add-jop.patch\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-7/f-series/soc/remote-debug/collateral/agilex7-dts-add-jop.patch\npushd meta-intel-fpga-refdes\npatch -p1 &lt; ../agilex7-dts-add-jop.patch\npopd\n</code></pre> <p>4. Update your Yocto recipes to use the core RBF file you have built, similar to how the GSRD does it:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_agfb014r24b2e2v.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agf014eb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agf014eb_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex7_dk_si_agf014eb_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex7_dk_si_agf014eb_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> <p>5. Build the Yocto recipes:</p> <pre><code>bitbake_image\n</code></pre> <p>6. Gather the Yocto binaries:</p> <pre><code>package\n</code></pre> <p>The following relevant files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#build-qspi-image","title":"Build QSPI Image","text":"<p>Run the following commands to build the QSPI image:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agfb014r24b2e2v.sof \\\nghrd_agfb014r24b2e2v.jic \\\n-o hps_path=gsrd_socfpga/agilex7_dk_si_agf014eb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGFB014R24B2E2V \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#run-example","title":"Run Example","text":"<p>The instructions from this section present how to run the remote debug example. Refer to the GSRD for more detailed instructions on how to set up the board, serial port, and write the binaries.</p> <p>1. Write the QSPI image <code>$TOP_FOLDER/ghrd_agfb014r24b2e2v.hps.jic</code> to flash.</p> <p>2. Extract and write the SD card image <code>$TOP_FOLDER/gsrd-socfpga/agilex7_dk_si_agf014eb-gsrd-images/sdimage.tar.gz</code> to the SD card</p> <p>3. Boot board and log into Linux.</p> <p>4. Determine board IP address by running the <code>ifconfig</code> command:</p> <pre><code>root@agilex7dksiagf014eb:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 10.122.105.175  netmask 255.255.255.0  broadcast 10.122.105.255\n        inet6 fe80::7097:4bff:fe41:b7c2  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 72:97:4b:41:b7:c2  txqueuelen 1000  (Ethernet)\nRX packets 218  bytes 23619 (23.0 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 78  bytes 11072 (10.8 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 22  </code></pre> <p>5. Remove pre-existing instances of the driver, and load it again:</p> <pre><code>root@agilex7dksiagf014eb:~# rmmod uio_pdrv_genirq\nroot@agilex7dksiagf014eb:~# modprobe uio_pdrv_genirq of_id=\"generic-uio\"\ns```\n6\\. Start the etherlink application, specifying which port to accept connections on as shown below:\n\n```bash\n\nroot@agilex7dksiagf014eb:~# etherlink --port=33301\nINFO: Etherlink Server Configuration:\nINFO:    H2T/T2H Memory Size  : 4096\nINFO:    Listening Port       : 33301\nINFO:    IP Address           : 0.0.0.0\nINFO: UIO Platform Configuration:\nINFO:    Driver Path: /dev/uio0\nINFO:    Address Span: 20480\nINFO:    Start Address: 0x0\nINFO: Server socket is listening on port: 33301\n</code></pre> <p>7. On the host, establish the JTAG communication to the board through Ethernet, using the board IP and the selected port number:</p> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0\n</code></pre> <p>8. Also on the host, run the 'jtagconfig' command to show the newly added connection:</p> <pre><code>$ jtagconfig\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0]\n020D10DD   VTAP10\n</code></pre> <p>At this point, the connection can be used by the tools which need a JTAG connection, like SignalTap.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/remote-debug/ug-remote-debug-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/","title":"Agilex\u2122 7 SoC HPS Remote System Update Example","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on the Agilex\u2122 7 Transceiver-SoC Development kit P-Tile E-Tile production Linear power solution (DK-SI-AGF014EB), including the following.</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> </ul> <ul> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>f22Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> </ul> <ul> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>Refer to Agilex\u2122 7 Hard Processor System Remote System Update User Guide for details about the Remote System Update. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#component-versions","title":"Component Versions","text":"<p>This example was created with Quartus\u00ae Prime Pro Edition Version 24.3 and the following component versions.</p> Repository Branch/Tag ghrd-socfpga QPDS24.3_REL_GSRD_PR linux-socfpga socfpga-6.6.37-lts/QPDS24.3_REL_GSRD_PR arm-trusted-firmware socfpga_v2.11.0/QPDS24.3_REL_GSRD_PR u-boot-socfpga socfpga_v2024.04/QPDS24.3_REL_GSRD_PR intel-rsu master <p>For RSU example previous 24.2 version, please refer to Agilex 7 SoC HPS Remote System Update.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus\u00ae Prime Pro Edition Version 24.3  for compiling the hardware projects, generating the flash images and writing to flash </li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li>Agilex 7 Transceiver-SoC Development kit P-Tile E-Tile Production Linear power solution(DK-SI-AGF014EB)  for running the example. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are these.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul> <p>Note: To build binaries for a different development kit than the one used in this page, please refer to the Building the Hardware Projects section in the corresponding  GSRD page for that development kit, which is the section that may differ from the instructions presented here.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex-rsu mkdir agilex-rsu cd agilex-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next.</p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below.</p> <pre><code>cd $TOP_FOLDER # compile hardware designs: 0-factory, 1,2-applications, 3-factory update \nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd . rm -rf ghrd-socfpga # boot from FPGA \nexport BOOTS_FIRST=fpga # enable watchdog \nexport ENABLE_WATCHDOG_RST=1 # treat watchdog timeout as configuration failure to trigger RSU \nexport WATCHDOG_RST_ACTION=remote_update\n# Select Linear regulator\nexport BOARD_PWRMGT=linear\n# disable SGMII to build faster \nexport HPS_ENABLE_SGMII=0 # disable PR to build faster \nexport ENABLE_PARTIAL_RECONFIGURATION=0 for version in {0..3} do rm -rf ghrd.$version cp -r agilex_soc_devkit_ghrd ghrd.$version cd ghrd.$version # update sysid to make binaries slightly different \nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' create_ghrd_qsys.tcl make scrub_clean_all\nmake generate_from_tcl echo \"set_global_assignment -name RSU_MAX_RETRY_COUNT 3\" &gt;&gt; ghrd_agfb014r24b2e2v.qsf # Change the board id to be zero - the one used when booting from SD card \nsed -i 's/set_global_assignment -name STRATIX_JTAG_USER_CODE .*/set_global_assignment -name STRATIX_JTAG_USER_CODE 4/g' ghrd_agfb014r24b2e2v.qsf make all\ncd .. done rm -rf agilex_soc_devkit_ghrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created.</p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/socfpga_v2.11.0 \nmake bl31 PLAT=agilex DEPRECATED=1 cd .. </code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga\n# comment out next line to use the latest default branch \n# git checkout -b test -t origin/socfpga_v2024.04 \n# enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# use 'Image' for kernel image instead of 'kernel.itb' \nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin .\n# Create configuration custom file.\ncat &lt;&lt; EOF &gt; config-fragment-agilex\n# - Disable NAND/UBI related settings from defconfig.\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# - Disable distroboot and use specific boot command.\nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex_defconfig\n# Use created custom configuration file to merge with the default configuration obtained in .config file.\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex\nmake -j 48\ncd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga\ngit clone https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\n# checkout the branch used for this document, comment out to use default\n# git checkout -b test -t origin/socfpga-6.6.37-lts \n# configure the RSU driver to be built into the kernel\nmake clean &amp;&amp; make mrproper\nmake defconfig\n./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y\nmake oldconfig\nmake -j 48 Image dtbs\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is provided below so and you can easily create the initial flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER # Create automatically the .pfg file\ncat &lt;&lt; EOF &gt; initial_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.0/output_files/ghrd_agfb014r24b2e2v.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n        &lt;bitstream id=\"Bitstream_2\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.1/output_files/ghrd_agfb014r24b2e2v.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0020FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00210000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x02000000\" e_addr=\"0x02FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03000000\" e_addr=\"0x03FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;AGFB014R24B&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/intelFPGA_pro/24.2/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg\n</code></pre> <p>Here are the complete instructions on how to manually create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER\nqpfgw &amp;\n</code></pre> </li> <li> <p>Select the Device family as Agilex 7, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bitswap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file ghrd_agfb014r24b2e2v.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/output_files/ghrd_agfb014r24b2e2v.sof image. This is the initial application image. The tab now looks like below.</p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. This opens the window to browse for the FSBL and select authentication and encryption settings. </p> <p> </p> </li> <li> <p>Click the Bootloader  (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the MT25QU02G in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (ghrd_agfb014r24b2e2v.sof). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0090FFFF in order to reserve 7MB for the factory image. This end address was calculated by adding 8MB to the end of the BOOT_INFO partition. Click OK. </p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be trieed after all the application images failed. </p> </li> <li> <p>Select the MT25QU02G flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(ghrd_agfb014r24b2e2v.sof). This becomes the initial application image. Select the Page as 1. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x01000000 and End Address = 0x01FFFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.   The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image</p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions) and set the start and end addresses as follows. </p> <p>* P2: Start Address = 0x02000000 and End Address = 0x02FFFFFF.    * P3: Start Address = 0x03000000 and End Address = 0x03FFFFFF. </p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c initial_image.pfg\n</code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -rf images/application2.rpd\nquartus_pfg -c hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON\n</code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/factory_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created. </p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/decision_firmware_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decision firmware update image is created. </p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul> <p>Notes:</p> <ul> <li>The first SOF file contains the factory image, from which data is taken to fill out the new decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from this SOF file is not used.</li> <li>The app_image parameter contains the SOF that is used for the application image section of the combined image.</li> <li>The hps_path parameter is unused, and may be removed in the future.</li> <li>The app_image_hps_path parameter contains the HPS FSBL hex file to be used for the application imge section of the combined image.</li> <li>When using HPS first, the additional parameter \"-o hps=1\" needs to be added, and the following files are created combined_application.hps.rpd (combined application image)  and combined_application.core.rbf (corresponding fabric configuration file).</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap   https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf zlib-1.3.1\nwget http://zlib.net/zlib-1.3.1.tar.gz\ntar xf zlib-1.3.1.tar.gz\nrm zlib-1.3.1.tar.gz\ncd zlib-1.3.1/\nexport CROSS_PREFIX=${CROSS_COMPILE}\n./configure\nmake\nexport ZLIB_PATH=`pwd`\ncd ..\n</code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.3.1/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.3.1/libz.so* - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application. </p> <pre><code>cd $TOP_FOLDER rm -rf intel-rsu\ngit clone https://github.com/altera-opensource/intel-rsu\ncd intel-rsu\n# checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/master\ncd lib\n# add -I$(ZLIB_PATH) to CFLAGS\nsed -i 's/\\(CFLAGS := .*\\)$/\\1 -I\\$\\(ZLIB_PATH\\)/g' makefile\nmake\ncd ..\ncd example\n# add -L$(ZLIB_PATH) to LDFLAGS\nsed -i 's/\\(LDFLAGS := .*\\)$/\\1 -L\\$\\(ZLIB_PATH\\)/g' makefile\nmake\ncd ..\ncd ..\n</code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/intel-rsu/lib/librsu.so - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/intel-rsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/intel-rsu/example/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example.</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2021.04/gsrd/tools/make_sdimage_p3.py chmod +x make_sdimage_p3.py\n# prepare the fat contents \nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents \nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\nsudo sed -i 's/agilex7_dk_si_agf014eb/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\nsudo cp $TOP_FOLDER/intel-rsu/example/rsu_client home/root/\nsudo cp $TOP_FOLDER/intel-rsu/lib/librsu.so lib/\nsudo cp $TOP_FOLDER/intel-rsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\ncd ..\n# create sd card image\nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card. </p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Agilex SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to JTAG. </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer.</p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\"\n</code></pre> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to QSPI. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Agilex SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <ol> <li> <p>Power up the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2024.01-33547-g098abd8f13-dirty (Aug 19 2024 - 12:15:42 -0500)\nReset state: Cold\nMPU          1200000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nDDR: 8192 MiB\nSDRAM-ECC: Initialized success with 1722 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nNOTICE:  BL31: v2.10.1  (release):QPDS24.2_REL_GSRD_PR\nNOTICE:  BL31: Built : 12:14:02, Aug 19 2024\nU-Boot 2024.01-33547-g098abd8f13-dirty (Aug 19 2024 - 12:15:42 -0500)socfpga_agilex\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Agilex SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  28 devices, 23 uclasses, devicetree: separate\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:   Warning: ethernet@ff800000 (eth0) using random MAC address - 86:c6:bd:7c:4f:7d\neth0: ethernet@ff800000\nHit any key to stop autoboot:  0 SOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options. </p> <pre><code>SOCFPGA # rsu \nrsu - Agilex SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name &lt;name&gt; - find slot by name and display the slot number slot_count - display the slot count slot_disable &lt;slot&gt; - remove slot from CPB slot_enable &lt;slot&gt; - make slot the highest priority slot_erase &lt;slot&gt; - erase slot slot_get_info &lt;slot&gt; - display slot information slot_load &lt;slot&gt; - load slot immediately slot_load_factory - load factory immediately slot_priority &lt;slot&gt; - display slot priority slot_program_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program buffer into slot, and make it highest priority slot_program_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program raw buffer into slot slot_program_factory_update_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program factory update buffer into slot, and make it highest priority slot_rename &lt;slot&gt; &lt;name&gt; - rename slot slot_delete &lt;slot&gt; - delete slot slot_create &lt;name&gt; &lt;address&gt; &lt;size&gt; - create slot slot_size &lt;slot&gt; - display slot size slot_verify_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against buffer slot_verify_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against raw buffer status_log - display RSU status update &lt;flash_offset&gt; - Initiate firmware to load bitstream as specified by flash_offset notify &lt;value&gt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt &lt;address&gt; - restore SPT from an address save_spt &lt;address&gt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb &lt;address&gt; - restore CPB from an address save_cpb &lt;address&gt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00920000 RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00210000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000210000 Length: 0x00700000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code> SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 24.3.0 DCMF1 version = 24.3.0  DCMF2 version = 24.3.0  DCMF3 version = 24.3.0  SOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 16777216. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 16777216. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 16777216. </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased. SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n2248704 bytes read in 103 ms (20.8 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Power cycle the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting the specific image to be loaded, in this case using the following command.</p> <pre><code>rsu slot_load 1 </code></pre> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands. </p> <pre><code>SOCFPGA # rsu update 0x01000000 \nRSU: RSU update to 0x0000000001000000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log to confirm it.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202:  both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report.</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code>SOCFPGA # mw.l 0xffd00204 0 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value. </p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf0061234 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it. </p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n2478080 bytes read in 113 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nSlot 2 was programmed with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2. </p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x02000000 0x10000 \nSF: 16384 bytes @ 0x2000000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf004d003 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status. </p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 512 KB). </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x10000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d00f Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot. </p> <p><pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> 6. Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <p><pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK </code></pre> 4. Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image : 0x01000000 Last Fail Image : 0x00100000 State : 0xf004d010 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre>   The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <p><pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> 6. Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted Current Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d011 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected. </p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created. </p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <p><pre><code>SOCFPGA # rsu clear_error_status \n</code></pre>   Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds. </p> <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. </p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x918000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF Bad SPT0 magic number 0xFFFFFFFF no valid SPT0 and SPT1 found Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the highest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails. </p> <pre><code>SOCFPGA # rsu slot_count \ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#using-the-combined-application-image","title":"Using the Combined Application Image","text":"<p>This section shows an example of using a combined application image, from U-Boot. Similar commands can be used from Linux.</p> <p>The combined application images are used the exact same way as regular application images, just that they first update the decision firmware and decision firmware data if necessary, before the device is configured with the functionality from the application SOF.</p> <p>Note: The combined application images do not have absolute pointers inside like the regular application images, the factory update images, or the decision firmware update images. Because of this, they can be written to flash with any of the U-Boot and LibRSU APIs that write to slots.</p> <ol> <li> <p>Program the RSU initial image created with the previous version ($TOP_FOLDER/initial_image_prev.jic).</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_prev.jic\"\n</code></pre> </li> <li> <p>Power cyle the board, stop to U-Boot prompt and query the decision firmware information from U-Boot, this should be a previous version.</p> <pre><code>SOCFPGA # rsu display_dcmf_version\nDCMF0 version = 24.2.0 DCMF1 version = 24.2.0 DCMF2 version = 24.2.0 DCMF3 version = 24.2.0 </code></pre> </li> <li> <p>Find an unused slot (slot 1, P2), erase it, write the combined application image to it, verify that it was programmed successfully  and check it is now the highest priority.</p> <pre><code>SOCFPGA # rsu slot_erase 1\nSlot 1 erased.\nSOCFPGA # fatload mmc 0:1 ${loadaddr} combined_application.rpd\n151552 bytes read in 9 ms (16.1 MiB/s)\nSOCFPGA # rsu slot_program_buf 1 ${loadaddr} ${filesize}\nSlot 1 was programmed with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_verify_buf 1 ${loadaddr} ${filesize}\nSlot 1 was verified with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_get_info 1\nNAME: P2\nOFFSET: 0x0000000002000000\nSIZE: 0x01000000\nPRIORITY: 1\n</code></pre> </li> <li> <p>Pass control to the combined application update image.</p> <pre><code>SOCFPGA # rsu slot_load 1\n</code></pre> </li> <li> <p>The combined application image checks the currently used decision firmware copy, it sees that it is older, then it updates the decision firmware and decision firmware data, then it loads the actual application image section. Everything takes a few seconds.</p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware is updated, and the application image is running fine.</p> <pre><code>SOCFPGA # rsu status_log\nCurrent Image : 0x02000000\nLast Fail Image : 0x00000000\nState : 0x00000000\nVersion : 0x00000202\nError location : 0x00000000\nError details : 0x00000000\nRetry counter : 0x00000000\nSOCFPGA # rsu display_dcmf_version\nDCMF0 version = 24.3.0 DCMF1 version = 24.3.0 DCMF2 version = 24.3.0 DCMF3 version = 24.3.0\n</code></pre> </li> <li> <p>Power cycle the board, the same combined application image is loaded, as it is the highest priority. But it takes a couple of seconds less, as the decision firmware does not need to be updated.</p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <ol> <li> <p>Power up the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message. </p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 24.3.0\nDCMF1 version = 24.3.0\nDCMF2 version = 24.3.0\nDCMF3 version = 24.3.0\nOperation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status.  It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting a specific image to be loaded, using the following commands.</p> <pre><code>./rsu_client --request 1 reboot </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202:both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report .</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux.</p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number. </p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux and display the status:  It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB. </p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot.</p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB. </p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is required to have the status available in Linux. </p> <ol> <li> <p>Power up the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions. </p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --    slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is not rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status: </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash.</p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status. </p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> </li> </ol> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.  Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> <ol> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails. </p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created. </p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine. </p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/","title":"Agilex\u2122 7 SoC HPS Multi-QSPI Remote System Update Example","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#intro","title":"Intro","text":"<p>This page is an extension of the  Agilex 7 SoC HPS Remote System Update Example and will show you how to build RSU images with multi QSPI support. This feature allows you to extend the flash space available to store the RSU applications so the size of these could be increased. This feature allows you to support up to 4 QSPI flash devices of the same model (i.e. same size). </p> <p>Note: This feature is first enabled in 24.3 release.</p> <p>When exercising multi-QSPI feature, there are few conditions that need to be satisfied:</p> <ul> <li>The Boot info, including the decision firmware and decision firmware data must be stored in the flash 0.</li> <li>The factory image also must be stored in the flash 0.</li> <li>The SPTs and CPBs also must be stored in in flash 0.</li> <li>The starting location of any component and partition in the QSPI flash devices should be aligned to the erase granularity defined in the devices.</li> <li>An application could be located in the cross boundary of 2 chips (i.e. located in more than one chip), but the previous condition still must be satisfied.</li> </ul> <p> </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#build-instructions","title":"Build Instructions","text":"<p>The binaries build instructions presented here are targeted for the Agilex\u2122 7 Transceiver-SoC Development kit P-Tile E-Tile production Linear power solution (DK-SI-AGF014EB). This provides the full recipes to build the binaries that you will need to exercise RSU functionality. The example provided here used only 2 flash devices (MT25QU02G) so the total memory size available is 512 MB. In the flash device layout, there is 1 partition defined in chip 0 and 2 partitions in chip 1. This QSPI layout can be seen in the following table:</p> Component Start Address Size Chip BOOT_INFO 0x0000_0000 0x0020_FFFF 0 FACTORY IMAGE 0x0021_0000 0x0070_0000 0 SPT0 0x0091_0000 0x0001_0000 0 SPT1 0x0092_0000 0x0001_0000 0 CPB0 0x0093_0000 0x0001_0000 0 CPB1 0x0094_0000 0x0001_0000 0 P1 0x0100_0000 0x0100_0000 0 P2 0x1000_0000 0x0100_0000 1 P3 0x1100_0000 0x0100_0000 1 <p>The end results of the build flow are described next.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex-multiQSPI-rsu\nmkdir agilex-multiQSPI-rsu\ncd agilex-multiQSPI-rsu\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes.</p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below.</p> <pre><code>cd $TOP_FOLDER\n# compile hardware designs: 0-factory, 1,2-applications, 3-factory update\nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\n# boot from FPGA\nexport BOOTS_FIRST=fpga\n# enable watchdog\nexport ENABLE_WATCHDOG_RST=1\n# treat watchdog timeout as configuration failure to trigger RSU\nexport WATCHDOG_RST_ACTION=remote_update\n# Select Linal regulator\nexport BOARD_PWRMGT=linear\n# disable SGMII to build faster\nexport HPS_ENABLE_SGMII=0\n# disable PR to build faster\nexport ENABLE_PARTIAL_RECONFIGURATION=0\nfor version in {0..3}\ndo\nrm -rf ghrd.$version\ncp -r agilex_soc_devkit_ghrd ghrd.$version\ncd ghrd.$version\n# update sysid to make binaries slightly different\nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' create_ghrd_qsys.tcl\nmake scrub_clean_all\nmake generate_from_tcl\n# Set retry count to 3\necho \"set_global_assignment -name RSU_MAX_RETRY_COUNT 3\" &gt;&gt; ghrd_agfb014r24b2e2v.qsf\n# Set QSPI clock to 25 Mhz (needed for multi-qspi support)\necho \"set_global_assignment -name ACTIVE_SERIAL_CLOCK AS_FREQ_25MHZ\" &gt;&gt; ghrd_agfb014r24b2e2v.qsf\n# Change the board id to be 4 - the one used when booting from SD card (OOB)\nsed -i 's/set_global_assignment -name STRATIX_JTAG_USER_CODE .*/set_global_assignment -name STRATIX_JTAG_USER_CODE 4/g' ghrd_agfb014r24b2e2v.qsf\nmake all\ncd ..\ndone\nunset BOARD_PWRMGT\nunset HPS_ENABLE_SGMII\n</code></pre> <p>After completing the above steps, the following SOF files are created.</p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\n# checkout the branch used for this document, comment out to use default\n# git checkout -b test -t origin/socfpga_v2.11.0\nmake bl31 PLAT=agilex DEPRECATED=1\ncd ..\n</code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it. To enable multi-qspi support in U-Boot RSU functionality, set CONFIG_SOCFPGA_RSU_MULTIFLASH to y in the build configuration file. Also make sure that CONFIG_SF_DEFAULT_CS is set to 0 to indicate that the SPTs and CPBs are located in chip 0. There are some required changes in the device tree that allow you to enable multi-QSPI in U-Boot. These changes are the following.</p> <ul> <li>Add the number of QSPI flash devices in the system in the qspi node in socfpga_agilex.dtsi. This parameter will allow u-boot to know the number of flash devices. You can manually probe each device from U-Boot shell using sf probe 0:&lt;flash device&gt;. This command also is used to select the QSPI chip for which the sf read, sf write and sf erase will operate over.</li> <li>Create the flash1 node in socfpga_agilex_socdk-u-boot.dtsi, so it exist a node for each one of the flash devices in the system.</li> <li>For each one of the flash nodes is necessary to  reduce the maximum SPI clock frequency to 25 MHz. This is done through the spi-max-frequency field. You also need to assign the corresponding chip select number to each one of the QSPI devices using the reg field. You also need to define any partitions that you want to create in each of the flash devices. In this case a single partition is created in each of the chips. The partition size corresponds to the size of each chip. These updates are done in the socfpga_agilex_socdk.dts file.</li> <li>You can also add QSPI flash0 as the 1st device from which SPL will try to boot from. This is done by updating the u-boot,spl-boot-order field in the socfpga_agilex_socdk-u-boot.dtsi. </li> </ul> <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga\n# comment out next line to use the latest default branch \n# git checkout -b test -t origin/socfpga_v2024.04\n# enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# use 'Image' for kernel image instead of 'kernel.itb'\nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n\n# Update device tree to enable multi-qspi\n# Adding the number of QSPI devices\nsed -i '/clocks = &lt;&amp;qspi_clk&gt;;/a \\\\t\\t\\tnum-cs = &lt;2&gt;;'  arch/arm/dts/socfpga_agilex.dtsi\n\n# Starting booting from QSPI to probe QSPI devices. Removing atempt to boot from NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0,\\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n\n# Rename the flash0 to flash1 (later will recreate the node for flash0)\n# This is done to have a QSPI flash reference to add the new node just above the reference one.\nsed -i 's/\\&amp;flash0 {/\\&amp;flash1 {/' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\nsed -i '/\\&amp;flash1 {/i \\&amp;flash0 {\\n\\tcompatible = \\\"jedec,spi-nor\\\";\\n\\tspi-tx-bus-width = &lt;4&gt;;\\n\\tspi-rx-bus-width = &lt;4&gt;;\\n\\tbootph-all;\\n\\t/delete-property/ cdns,read-delay; \\n};\\n' \\\narch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n# remove the NAND configuration from device tree\nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n\n# Change max clk frequency of SPI flash0\nsed -i 's/spi-max-frequency = &lt;100000000&gt;;/spi-max-frequency = &lt;25000000&gt;;/g' arch/arm/dts/socfpga_agilex_socdk.dts\n# Change the partition size for flash0\nsed -i 's/reg = &lt;0x0 0x04200000&gt;;/reg = &lt;0x0 0x10000000&gt;;/g' arch/arm/dts/socfpga_agilex_socdk.dts\n# Delete 2nd partition\nsed -i '/root/,/};/d' arch/arm/dts/socfpga_agilex_socdk.dts\n\n# make this one flash1 (later will recreate node for flash0 using flash1 location as reference )\nsed -i 's/flash0: flash@0 {/flash1: flash@1 {/' arch/arm/dts/socfpga_agilex_socdk.dts\nsed -i '/flash1: flash@1 {/!b;n;n;n;n;c\\\\t\\treg = &lt;1&gt;;' arch/arm/dts/socfpga_agilex_socdk.dts\nsed -i 's/qspi_boot:/flash1_boot:/g' arch/arm/dts/socfpga_agilex_socdk.dts\n# Re-create the original node for flash0\nsed -i '/flash1: flash@1 {/i \\\\tflash0: flash@0 {\\n\\t\\t#address-cells = &lt;1&gt;;\\n\\t\\t#size-cells = &lt;1&gt;;\\\n\\t\\tcompatible = \"mt25qu02g\";\\n\\t\\treg = &lt;0&gt;;\\n\\t\\tspi-max-frequency = &lt;25000000&gt;;\\n\\n\\t\\tm25p,fast-read;\\\n\\t\\tcdns,page-size = &lt;256&gt;;\\n\\t\\tcdns,block-size = &lt;16&gt;;\\n\\t\\tcdns,read-delay = &lt;1&gt;;\\n\\t\\tcdns,tshsl-ns = &lt;50&gt;;\\\n\\t\\tcdns,tsd2d-ns = &lt;50&gt;;\\n\\t\\tcdns,tchsh-ns = &lt;4&gt;;\\n\\t\\tcdns,tslch-ns = &lt;4&gt;;\\n\\n\\t\\tpartitions {\\\n\\t\\t\\tcompatible = \"fixed-partitions\";\\n\\t\\t\\t#address-cells = &lt;1&gt;;\\n\\t\\t\\t#size-cells = &lt;1&gt;;\\\n\\t\\t\\tqspi_boot: partition@0 {\\n\\t\\t\\t\\tlabel = \"u-boot\";\\n\\t\\t\\t\\treg = &lt;0x0 0x10000000&gt;;\\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\t};\\n' arch/arm/dts/socfpga_agilex_socdk.dts\n\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin .\n# Create configuration custom file.\ncat &lt;&lt; EOF &gt; config-fragment-agilex\n# ENABLE MULTIFLASH\nCONFIG_SOCFPGA_RSU_MULTIFLASH=y\nCONFIG_SF_DEFAULT_CS=0\n# - Disable NAND/UBI related settings from defconfig.\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# - Disable distroboot and use specific boot command.\nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable; setenv fdtimage socfpga_agilex7f_socdk_multiqspi.dtb; run mmcload; run linux_qspi_enable; run rsu_status; run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\n# Enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex_defconfig\n# Use created custom configuration file to merge with the default configuration obtained in .config file.\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex\nmake -j 48\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-linux","title":"Building Linux","text":"<p>In Linux, the socfpga_agilex7f_socdk_multiqspi.dts device tree is used which includes the updates needed to support the multi-QSPI feature. The required changes are shown next.</p> <ul> <li>The definition of the flash nodes (up to 4). In each of these nodes the qspi_bootx partition is created. For each one of the flashes nodes defined Linux will create a MTD device for each partition if it detects that a flash device asociated with this node actually exists.</li> <li>In each one of the flash devices reducing the maximum SPI clock frequency to 25 MHz.</li> <li>In each one of the flash devices assigning to the reg field the corresponding chips select: 0, 1, 2 or 3.</li> <li>Define the rsu_handle field to point to the qspi_boot0 partition. Although this is done for all the flash node, this is needed only for the flash0. The limits of this partition is patched by U-Boot (rsu_dtb() function) to restric this partition in flash 0 to the area  that goes from the starting location of the SPT0 table to the end of the chip. This makes that Linux could only access this region in chip 0 using the mtd0 device.</li> </ul> <p> </p> <p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone https://github.com/altera-opensource/linux-socfpga cd linux-socfpga # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/socfpga-6.6.37-lts \n# configure the RSU driver to be built into the kernel \nmake clean &amp;&amp; make mrproper make defconfig ./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y\n# enable kernel debugging with RiscFree\n./scripts/config --set-val CONFIG_DEBUG_INFO  y\n./scripts/config --set-val CONFIG_GDB_SCRIPTS y\nmake oldconfig make -j 48 Image dtbs cd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex7f_socdk_multiqspi.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is provided below so and you can easily create the initial flash image by passing it to the Programming File Generator as shown below. The layout described in this .pfg file matches the layout described earlier in this page.</p> <pre><code>cd $TOP_FOLDER # Create automatically the .pfg file\ncat &lt;&lt; EOF &gt; initial_image_multiQSPI.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"initial_image_multiQSPI\" directory=\"./\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"initial_image_multiQSPI_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_multiQSPI_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.0/output_files/ghrd_agfb014r24b2e2v.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n        &lt;bitstream id=\"Bitstream_2\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.1/output_files/ghrd_agfb014r24b2e2v.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"QSPI04G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" multiple_flash_cs=\"2\" factory_fallback=\"0\" e_addr=\"0x0020FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00210000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x10000000\" e_addr=\"0x10FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x11000000\" e_addr=\"0x11FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;AGFB014R24B&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# Create Initial Image for previous release (in case needed to test  combined application). Not supported in 24.2 release so this can't be done in 24.3\n#~/intelFPGA_pro/24.2/quartus/bin/quartus_pfg -c initial_image_multiQSPI.pfg\n#mv initial_image_multiQSPI.jic initial_image_multiQSPI_prev.jic\n#mv initial_image_multiQSPI_jic_2Gb_cs0.rpd #initial_image_multiQSPI_jic_2Gb_cs0_prev.rpd\n#mv initial_image_multiQSPI_jic_2Gb_cs1.rpd initial_image_multiQSPI_jic_2Gb_cs1_prev.rpd\n#mv initial_image_multiQSPI_jic.map initial_image_multiQSPI_jic_prev.map\n# Create Initial Image for this release\ncd $TOP_FOLDER\nquartus_pfg -c initial_image_multiQSPI.pfg\n</code></pre> <p>After completion of this stage you should see the following files created. These are the images QSPI images.</p> <ul> <li>$TOP_FOLDER/initial_image_multiQSPI.jic - Initial QSPI image used for regular RSU use cases.</li> <li>$TOP_FOLDER/initial_image_multiQSPI_prev.jic - Initial QSPI image used to exercise combined application use case. - Not available in 24.3 release.</li> </ul> <p>For detailed instructions on how to create the .pfg, please refer to the Creating the initial flash-image in main RSU page. For a multi-QSPI initial image there are some variations that need to be obserrved and these are described next.</p> <ul> <li> <p>When selecting the flash device in Configuration Device tab and clicking Add Device you need to select as device any of the QSPI0xG devices depending on the total size of the multi-QSPI system (in bits). In the figure below are shown the possible options. These options gets available when building an RSU image. In this figure, the QSPI04G is being selected for a 4 Gbit system (512 MB) integrated by 2 flash devices of 2Gbit each one.</p> <p> </p> </li> </ul> <ul> <li>When configuring the memory locations for each one of the components make sure that the BOOT_INFO, FACTORY_IMAGE, STPs and CPBs fall into the memory area corresponding to the chip 0. </li> <li>Also, when configuring the memory locations for the partitions, the memory ranges are defined based on having a single memory space that comprises the total memory available in all the QSPI flash devices. It is supported that a partition covers areas in more than one chip but the starting location of the partition should still be aligned to the erase granularity defined.</li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -rf images/application2.rpd quartus_pfg -c hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON </code></pre> <p>The following application image is created: </p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/factory_update.rpd quartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created.</p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/decision_firmware_update.rpd quartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decistion firmware update image is created.</p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system.</p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b scarthgap https://git.yoctoproject.org/poky git clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga git clone -b scarthgap https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal </code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf zlib-1.3.1 wget http://zlib.net/zlib-1.3.1.tar.gz tar xf zlib-1.3.1.tar.gz rm zlib-1.3.1.tar.gz cd zlib-1.3.1/ export CROSS_PREFIX=${CROSS_COMPILE} ./configure make export ZLIB_PATH=`pwd` cd .. </code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.3.1/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.3.1/libz.so* - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application. Notice that you will need to modify the qspi.rc file (file used by librsu to retreive some of the RSU configuration) to provide  the mtd partitions in QSPI to be used for RSU, in this case it will be mtd0 and mtd1.</p> <pre><code>cd $TOP_FOLDER rm -rf intel-rsu git clone https://github.com/altera-opensource/intel-rsu cd intel-rsu # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/master \n# Replace single mtd device with the the mtd devices created \n# from each one of the QSPI partitions\nsed  -i 's/root qspi \\/dev\\/mtd0/root qspi \\/dev\\/mtd0,\\/dev\\/mtd1/g'  etc/qspi.rc cd lib # add -I$(ZLIB_PATH) to CFLAGS \nsed -i 's/\\(CFLAGS := .*\\)$/\\1 -I\\$\\(ZLIB_PATH\\)/g' makefile make cd .. cd example # add -L$(ZLIB_PATH) to LDFLAGS \nsed -i 's/\\(LDFLAGS := .*\\)$/\\1 -L\\$\\(ZLIB_PATH\\)/g' makefile make cd .. cd .. </code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/intel-rsu/lib/librsu.so - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/intel-rsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/intel-rsu/example/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example.</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2021.04/gsrd/\\\ntools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n# prepare the fat contents\nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex7f_socdk_multiqspi.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\nsudo sed -i 's/agilex7_dk_si_agf014eb/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\nsudo cp $TOP_FOLDER/intel-rsu/example/rsu_client home/root/\nsudo cp $TOP_FOLDER/intel-rsu/lib/librsu.so lib/\nsudo cp $TOP_FOLDER/intel-rsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\ncd .. # create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as indicated next.</p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card.</p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#writing-initial-multi-qspi-rsu-image-to-qspi","title":"Writing Initial multi-QSPI RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM boot card on the Agilex 7 SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Agilex 7 SoC Development Kit switches to have MSEL set to JTAG. </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer: </p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_multiQSPI.jic\" </code></pre> </li> <li> <p>Configure the Agilex 7 SoC Development Kit switches to have MSEL set to QSPI. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Agilex 7 SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#exercise-rsu-binaries","title":"Exercise RSU Binaries","text":"<p>The same RSU exercises for U-Boot and Linux described at Agilex 7 SoC HPS Remote System Update Example are supported for multi-QSPI. You can exercise all of them, but in the command responses just consider the new layout used in here (i.e. the location of the partitions will be different ). </p> <p>In the scenario in which an application is being corrupted using a U-Boot command, you also will need to use the correct location of the application. Also remember that in multi-QSPI the sf probe U-Boot command is used to select the appropriate flash device before performing any read, write or erase operation. The sf erase, sf write and sd read U-Boot commands use as memory address the relative address in the chip selected.</p> Action Command Select chip 0 sf probe 0:0  or sf probe Select chip 1 sf probe 0:1 Write to chip selected sf write &lt;address in SRAM&gt; &lt;offset in chip&gt; &lt;data size&gt; Read from chip selected sf read &lt;address in SRAM&gt; &lt;offset in chip&gt; &lt;data size&gt; Erase data in chip sf erase &lt;offset in chip&gt; &lt;data size&gt; <p>Note: When the combined application is used to upgrade the decision firmware, it is required to start with an initial image created with an older version than the one used to create this application. When exercising this use case in a multi-QSPI board, the decision firmware in the initial image also requires to support the multi-QSPI feature which is supported by Quartus Prime starting on 24.2 release.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-multiqspi-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/","title":"Agilex\u2122 7 I-Series FPGA Development Kit GSRD User Guide","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#overview","title":"Overview","text":"<p>This page presents the Golden System Reference Design for the Intel\u00ae Agilex\u2122 I-Series Transceiver-SoC Development Kit (4x F-Tile). The GSRD demonstrates the following: </p> <ul> <li>FPGA side <ul> <li>LEDs connected to GPIO soft IP modules </li> <li>DIP switches and push buttons connected to GPIO soft IP modules </li> </ul> </li> <li>HPS side <ul> <li>Linux, booted by U-Boot and ATF </li> <li>Board web server </li> <li>Sample driver </li> <li>Reacting to FPGA DIP switches and push buttons </li> <li>Sample applications </li> <li>Hello world </li> <li>Controlling FPGA LEDs: blink, scroll, toggle </li> <li>System check application </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the GSRD:</p> <ul> <li>Intel\u00ae Agilex\u2122 I-Series Transceiver-SoC Development Kit (4x F-Tile).<ul> <li>SD/MMC HPS Daughtercard </li> <li>Mini USB cable for serial output </li> <li>USB Type B cable for on-board Intel FPGA Download Cable II </li> <li>Micro SD card (4GB or greater)  </li> </ul> </li> <li>Host PC with:<ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too </li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows) </li> <li>Micro SD card slot or Micro SD card writer/reader </li> <li>Intel Quartus Prime Pro Edition </li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 </li> </ul> </li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board) </li> </ul> <p>You can identify your board by reviewing the the table in Intel Agilex\u2122 I-Series Transceiver-SoC Development Kit User Guide: </p> Development Kit Version Ordering Code Device Part Number Serial Number Identifier Suppported by GSRD Intel Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (Production 1 4x F-Tile) DK-SI-AGI027FA (Power Solution 2) AGIB027R31B1E1V 2000001 Yes Intel Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (Production 2) DK-SI-AGI027FC (Power Solution 2) AGIB027R31B1E1VB 3000001 Yes Intel Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (ES1 4x F-Tile) DK-SI-AGI027FB (Power Solution 1) AGIB027R31B1E1VAA 0001001 Yes Intel Agilex\u2122 7 FPGA I-Series Transceiver-SoC Development Kit (ES) DK-SI-AGI027FES (Power Solution 1) AGIB027R31B1E2VR0 0000001 No <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#binaries","title":"Binaries","text":"Board Binaries AGI027FB https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fb_gsrd/ AGI027FA https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fa_gsrd/ AGI027FC https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fc_gsrd/ <p>The source code is included on the SD card in the Linux rootfs path <code>/home/root</code>: </p> File Description linux-socfpga-v6.6.37-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2024.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.11.0-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html .</p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 and the following software component versions are used to build the GSRD: </p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#running-the-gsrd","title":"Running the GSRD","text":"<p>Note: The instructions provided here are using the prebuilt binaries, but the same procedure applies for the rebuilt binaries. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#boot-linux","title":"Boot Linux","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#configure-board","title":"Configure Board","text":"<p>Set up the board default settings, as listed by the the Intel Agilex\u2122 I-Series Transceiver-SoC Development Kit User Guide, \"Default Settings\" section: </p> Switch Default Position S19 [1:4] OFF/OFF/ON/ON S20 [1:4] ON/ON/ON/ON S9 [1:4] ON/OFF/OFF/X S10 [1:4] ON/ON/ON/ON S15 [1:4] ON/ON/ON/OFF S1 [1:4] OFF/OFF/OFF/OFF S6 [1:4] OFF/OFF/OFF/OFF S22 [1:4] ON/ON/ON/ON S23 [1:4] ON/ ON / ON / ON S4 [1:4] ON/ ON / ON / ON"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#write-sd-card","title":"Write SD Card","text":"<p>This section explains how to create the SD card necessary to boot Linux, using the SD card image available with the pre-built Linux binaries package. Once the SD card has been created, insert the card into the SD slot of the Micro SD daughter card. </p>  Write SD Card on Linux  <p>1. Download the SD card image and extract it: </p> <p>For DK-SI-AGI027FB board: </p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fb_gsrd/sdimage.tar.gz tar xf sdimage.tar.gz </code></pre> <p>For DK-SI-AGI027FA board: </p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fa_gsrd/sdimage.tar.gz tar xf sdimage.tar.gz </code></pre> <p>For DK-SI-AGI027FC board: </p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fc_gsrd/sdimage.tar.gz tar xf sdimage.tar.gz </code></pre> <p>The extracted file is named <code>gsrd-console-image-agilex.wic</code>. </p> <p>2. Determine the device associated with the SD card on the host by running the following command before and after inserting the card. </p> <pre><code>$ cat /proc/partitions </code></pre> <p>Let's assume it is /dev/sdx. </p> <p>3. Use dd utility to write the SD image to the SD card. </p> <pre><code>$ sudo dd if=gsrd-console-image-agilex.wic of=/dev/sdx bs=1M </code></pre> <p>Note we are using sudo to be able to write to the card. </p> <p>4. Use sync utility to flush the changes to the SD card. </p> <pre><code>$ sudo sync </code></pre>  Write SD Card on Windows  <p>1. Download the SD card and extract it: </p> <ul> <li>For DK-SI-AGI027FB board: https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fb_gsrd/sdimage.tar.gz</li> <li>For DK-SI-AGI027FA board: https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fa_gsrd/sdimage.tar.gz</li> <li>For DK-SI-AGI027FC board: https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fc_gsrd/sdimage.tar.gz</li> </ul> <p>The extracted file is named <code>gsrd-console-image-agilex.wic</code>. </p> <p>2. Rename the wic file as <code>sdcard.img</code> </p> <p>3. Use Win32DiskImager to write the image to the SD card. The tool can be downloaded from https://sourceforge.net/projects/win32diskimager/files/latest/download</p> <p></p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#configure-serial-connection","title":"Configure Serial Connection","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, you need to install thhe FTDI drivers from  https://ftdichip.com/drivers/ </p> <p>The serial communication parameters are: </p> <ul> <li>Baud-rate: 115,200 </li> <li>Parity: none </li> <li>Flow control: none </li> <li>Stop bits: 1 </li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus. </p> <p>On Linux, the minicom utility can be used. Here is how to configure it: </p> <p>1. The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following: </p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB* </li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet. </li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared. </li> <li>Install minicom application on host PC, if not installed. </li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom </li> <li>Configure minicom. </li> </ul> <pre><code>$ sudo minicom -s </code></pre> <p>Under Serial Port Setup choose the following: </p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary) </li> <li>Bps/Par/Bits: 115200 8N1 </li> <li>Hardware Flow Control: No </li> <li>Software Flow Control: No </li> <li>Hit [ESC] to return to the main configuration menu </li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#write-jic-image-to-qspi","title":"Write JIC Image to QSPI","text":"<p>The QSPI JIC image contains the FPGA configuration bitstream, and the U-Boot SPL. </p> <p>1. Download and extract the image file: </p> <p>For DK-SI-AGI027FB board: </p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fb_gsrd/ghrd_agib027r31b1e1vaa.jic.tar.gz tar xf ghrd_agib027r31b1e1vaa.jic.tar.gz </code></pre> <p>For DK-SI-AGI027FA board: </p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fa_gsrd/ghrd_agib027r31b1e1v.jic.tar.gz tar xf ghrd_agib027r31b1e1v.jic.tar.gz </code></pre> <p>For DK-SI-AGI027FC board: </p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_si_agi027fc_gsrd/ghrd_agib027r31b1e1vb.jic.tar.gz tar xf ghrd_agib027r31b1e1vb.jic.tar.gz </code></pre> <p>2. Configure MSEL to JTAG: </p> Switch Setting S9 [1:4] ON/ON/ON/X <p>3. Power cycle the board </p> <p>4. Connect the Type B USB cable from the development kit to the host for JTAG access. Write the image using the following commands: </p> <p>For DK-SI-AGI027FB board: </p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agib027r31b1e1vaa.jic\" </code></pre> <p>For DK-SI-AGI027FA board: </p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agib027r31b1e1v.jic\" </code></pre> <p>For DK-SI-AGI027FC board: </p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_agib027r31b1e1vb.jic\" </code></pre> <p>5. Configure MSEL back to QSPI: </p> Switch Setting S9 [1:4] ON/OFF/OFF/X"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#boot-linux_1","title":"Boot Linux","text":"<p>1. Make sure to have the SD card inserted in the board slot. </p> <p>2. Start serial terminal (when using Minicom it will connect using the selected settings, for others connect manually). </p> <p>3. Power up the board </p> <p>4. The device will be configured from QSPI, HPS will be loaded with the U-Boot SPL, which will then load ATF and U-Boot proper, then Linux will be booted. Login using 'root' and no password. </p> <p>5. Run 'ifconfig' command to determine the IP of the board: </p> <pre><code>root@agilexfm87:~# ifconfig eth0: flags=4163 mtu 1500 inet 192.168.1.172 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::54c0:6cff:fe8e:fbac prefixlen 64 scopeid 0x20 ether 56:c0:6c:8e:fb:ac txqueuelen 1000 (Ethernet) RX packets 100 bytes 7640 (7.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 52 bytes 7830 (7.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device interrupt 21 base 0x2000 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 100 bytes 8468 (8.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 100 bytes 8468 (8.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#running-sample-applications","title":"Running Sample Applications","text":"<p>The GSRD includes a number of sample Linux applications that help demonstrate some of the features of the platform: </p> <ul> <li>Display Hello World message </li> <li>Control LEDs </li> <li>Detect interrupts from push buttons and DIP switches </li> </ul> <p>The sample applications can be used as a starting point for users to write their own applications that interact with software IP through Linux drivers. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#prerequisites_1","title":"Prerequisites","text":"<p>1. Boot Linux on the target board as described in Boot Linux. You will not need to use the serial terminal if you plan on using ssh connection. </p> <p>2. Connect to the board using one of the following options: </p> <ul> <li>Connect using serial console, as described in Boot Linux </li> <li>Connect using SSH</li> </ul> <p>3. In serial console, or ssh client console, change current folder to be /home/root/intelFPGA. This is where the application binaries are stored. </p> <pre><code>root@agilexfm87:~# cd /home/root/intelFPGA/ </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#display-hello-world-message","title":"Display Hello World Message","text":"<p>Run the following command to display the Hello World message on the console: </p> <pre><code>root@agilexfm87:~/intelFPGA# ./hello Hello SoC FPGA!%ENDCOLOR </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#exercise-soft-pio-driver-for-led-control","title":"Exercise Soft PIO Driver for LED Control","text":"<p>The following green LEDs are exercised: </p> <ul> <li>USER LED0 </li> <li>USER LED1 </li> <li>USER LED2 </li> <li>USER LED4 </li> </ul> <p>Note: USER LED3 is always on, red colored, and cannot be controlled from software. </p> <p>1. In order to blink an LED in a loop, with a specific delay in ms, run the following command: </p> <pre><code>./blink &lt;led_number&gt; &lt;delay_ms&gt; </code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3. </li> <li>The delay_ms is a number that specifies the desired delay in ms between turning the LED on and off. </li> </ul> <p>2. In order to turn an individual LED on or off, run the following command: </p> <pre><code>./toggle &lt;led_number&gt; &lt;state&gt; </code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3. </li> <li>The state needs to be 0 to turn the LED off, and 1 to turn the LED on. </li> </ul> <p>3. In order to scroll the FPGA LEDs with a specific delay, please run the following command: </p> <pre><code>./scroll_client &lt;delay&gt; </code></pre> <p>The delay specifies the desired scrolling behavior: </p> <ul> <li>delay &gt; 0 - specify new scrolling delay in ms, and start scrolling </li> <li>delay &lt; 0 - stop scrolling </li> <li>delay = 0 - display current scroll delay </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#register-interrupts-and-call-interrupt-service-routine","title":"Register Interrupts and Call Interrupt Service Routine","text":"<p>The following are exercised: </p> <ul> <li>User FPGA DIP switches </li> <li>USER_SW0 </li> <li>USER_SW1 </li> <li>USER_SW2 </li> <li>USER_SW3 </li> <li>User FPGA push buttons </li> <li>USER_PB0 </li> <li>USER_PB1 </li> </ul> <p>In order to register an interrupt handler to a specific GPIO, you will first need to determine the GPIO number used. </p> <p>1. Open the Linux Device Tree socfpga_agilex7_ghrd.dtsi file and look up the labels for the DIP switches and Push button GPIOs: </p> <pre><code> button_pio: gpio@f9001060 { compatible = \"altr,pio-1.0\"; reg = &lt;0xf9001060 0x10&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 18 4&gt;; altr,gpio-bank-width = &lt;4&gt;; altr,interrupt-type = &lt;2&gt;; #gpio-cells = &lt;2&gt;; \ngpio-controller; }; dipsw_pio: gpio@f9001070 { compatible = \"altr,pio-1.0\"; reg = &lt;0xf9001070 0x10&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 17 4&gt;; altr,gpio-bank-width = &lt;4&gt;; altr,interrupt-type = &lt;3&gt;; #gpio-cells = &lt;2&gt;; \ngpio-controller; }; </code></pre> <p>2. Run the following to determine the GPIO numbers for the DIP switches </p> <pre><code>root@agilexfm87:~/intelFPGA# grep -r \"gpio@f9001070\" /sys/class/gpio/gpiochip*/label /sys/class/gpio/gpiochip1928/label:/soc/gpio@f9001070 </code></pre> <p>This means that the GPIOs 1928 .. 1931 are allocated to the DIP switches (there are 4 of them). </p> <p>3. Run the followinig to determine the GPIO numbers for the pushbuttons </p> <pre><code>root@agilexfm87:~/intelFPGA# grep -r \"gpio@f9001060\" /sys/class/gpio/gpiochip*/label /sys/class/gpio/gpiochip1960/label:/soc/gpio@f9001060 </code></pre> <p>This means that the GPIOs 1960, 1961 are allocated to the push buttons (there are 2 of them). </p> <p>4. Register interrupt for one of the dipswiches, using the appropriate GPIO number, as determined in a previous step: </p> <pre><code>root@agilexfm87:~/intelFPGA# modprobe gpio_interrupt gpio_number=1928 intr_type=3 [ 893.594901] gpio_interrupt: loading out-of-tree module taints kernel. [ 893.602212] Interrupt for GPIO:1928 [ 893.602212] registered </code></pre> <p>5. Toggle the USER_SW0/SW1.1 dipswitch a few times, you will see messages from the interrupt handler </p> <pre><code>[ 933.872016] Interrupt happened at gpio:1928 [ 936.630233] Interrupt happened at gpio:1928 [ 938.737038] Interrupt happened at gpio:1928 [ 939.951513] Interrupt happened at gpio:1928 </code></pre> <p>6. Remove the driver </p> <pre><code>root@agilexfm87:~/intelFPGA# rmmod gpio_interrupt </code></pre> <p>7. Register the pushbutton interrupt, using the appropriate GPIO number as determine on a previous step </p> <pre><code>root@agilexfm87:~/intelFPGA# modprobe gpio_interrupt gpio_number=1960 intr_type=2 [ 1138.025297] Interrupt for GPIO:1960 [ 1138.025297] registered </code></pre> <p>8. Push the pusbutton USER_PB0/S2 a few times, you will see interrupt handler messages </p> <pre><code>[ 1141.672192] Interrupt happened at gpio:1960 [ 1142.110673] Interrupt happened at gpio:1960 [ 1142.499468] Interrupt happened at gpio:1960 [ 1142.884199] Interrupt happened at gpio:1960 </code></pre> <p>9. Once done, remove the handler </p> <pre><code>root@agilexfm87:~/intelFPGA# rmmod gpio_interrupt </code></pre> <p>Note: If you are on the ssh console, you will need to run the program dmesg after pressing the button in order to see the messages: </p> <pre><code>root@stratix10:~/intelFPGA# dmesg </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#system-check-application","title":"System Check Application","text":"<p>System check application provides a glance of system status of basic peripherals such as: </p> <ul> <li>USB: USB device driver </li> <li>Network IP (IPv4): Network IP address </li> <li>HPS LEDs: HPS LED state </li> <li>FPGA LEDs: FPGA LED state </li> </ul> <p>Run the application by issuing the following command: </p> <pre><code>root@agilexfm87:~/intelFPGA# ./syschk </code></pre> <p>The window will look as shown below - press 'q' to exit: </p> <pre><code> ALTERA SYSTEM CHECK lo : 127.0.0.1 usb1 : DWC OTG Controller eth0 : 192.168.1.172 serial@ffc02100 : disabled fpga_led2 : ON serial@ffc02000 : okay hps_led2 : OFF fpga_led0 : OFF hps_led0 : OFF fpga_led3 : OFF fpga_led1 : OFF hps_led1 : OFF </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#connect-to-board-web-server-and-ssh-client","title":"Connect to Board Web Server and SSH Client","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#connect-to-web-server","title":"Connect to Web Server","text":"<p>1. Boot Linux as described in Boot Linux. </p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be network interfaces of them, either can be used. </p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter. </p> <p> </p> <p>4. In the section named Interacting with Agilex\u2122 SoC Development Kit you can perform the following actions: </p> <ul> <li>See which LEDs are ON and which are off in the LED Status. Note that if the LEDs are setup to be scrolling, the displayed scrolling speed will not match the actual scrolling speed on the board. </li> <li>Stop LEDs from scrolling, by clicking START and STOP buttons. The delay between LEDs turning ON and OFF is set in the LED Lightshow box. </li> <li>Turn individual LEDs ON and OFF with the ON and OFF buttons. Note that this action is only available when the LED scrolling/lightshow is stopped. </li> <li>Blink individual LEDs by typing a delay value in ms then clicking the corresponding BLINK button. Note that this action is only available when the LED scrolling/lightshow is stopped. </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#connect-using-ssh","title":"Connect Using SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection. </p> <p> </p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS: </p> <pre><code>$ sudo yum install openssh-clients </code></pre> <p>or the following command on Ubuntu: </p> <pre><code>$ sudo apt-get install openssh-client </code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action: </p> <p> </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-gsrd-for-dk-si-agi027fb","title":"Build GSRD for DK-SI-AGI027FB","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub. </p> <p> </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf gsrd.dk_si_agi027fb mkdir gsrd.dk_si_agi027fb cd gsrd.dk_si_agi027fb export TOP_FOLDER=$(pwd) </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design: </p> <pre><code>cd $TOP_FOLDER rm -rf ghrd-socfpga agilex_soc_devkit_ghrd git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd . rm -rf ghrd-socfpga cd agilex_soc_devkit_ghrd export BOARD_TYPE=devkit_fm87 make scrub_clean_all make generate_from_tcl make all unset BOARD_TYPE cd .. </code></pre> <p>The following files are created: </p> <ul> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1vaa_hps_debug.sof - FPGA configuration file, without HPS FSBL </li> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex - HPS Debug FSBL </li> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1vaa_hps_debug.sof - FPGA configuration file, with HPS Debug FSBL </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1vaa_hps_debug.sof \\\nghrd_agib027r31b1e1vaa.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1VAA \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agib027r31b1e1vaa.hps.jic </code></pre> <p>The following files will be created: </p> <ul> <li>$TOP_FOLDER/ghrd_agib027r31b1e1vaa.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric </li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd_socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga cd gsrd_socfpga . agilex7_dk_si_agi027fb-gsrd-build.sh build_setup </code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps: </p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga . ./poky/oe-init-build-env agilex7_dk_si_agi027fb-gsrd-rootfs/ </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#customize-yocto-build","title":"Customize Yocto Build","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes: </p> <ul> <li>agilex7_dk_si_agi027fb_gsrd_ghrd.core.rbf - core rbf file for configuring the fabric </li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location: </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agi027fb_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd_agib027r31b1e1vaa.core.rbf $CORE_RBF </code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location: </p> <pre><code>SRC_URI:agilex7_dk_si_agi027fb ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agi027fb_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agi027fb_gsrd_core \\\n \" </code></pre> <p>to look like this: </p> <pre><code>SRC_URI:agilex7_dk_si_agi027fb ?= \"\\\n file://agilex7_dk_si_agi027fb_gsrd_ghrd.core.rbf \\\n \" </code></pre> <p>using the following commands: </p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agi027fb_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agi027fb_gsrd_core\" NEW_URI=\"file:\\/\\/agilex7_dk_si_agi027fb_gsrd_ghrd.core.rbf\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>3. In the same Yocto recipe update the SHA256 checksum for the file: </p> <pre><code>SRC_URI[agilex7_dk_si_agi027fb_gsrd_core.sha256sum] = \"225869090fe181cb3968eeaee8422fc409c11115a9f3b366a31e3219b9615267\" </code></pre> <p>by using the following commands: </p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_SHA=\"SRC_URI\\[agilex7_dk_si_agi027fb_gsrd_core\\.sha256sum\\] = .*\" NEW_SHA=\"SRC_URI[agilex7_dk_si_agi027fb_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_SHA/$NEW_SHA/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>: </p> <ul> <li>uboot.txt - distroboot script </li> <li>uboot_script.its - its file for creating FIT image from the above script </li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>: </p> <ul> <li>fit_kernel_agilex7_dk_si_agf014eb.its - its file for creating the kernel.itb image </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto: </p> <pre><code>bitbake_image </code></pre> <p>Gather files: </p> <pre><code>package </code></pre> <p>Once the build is completed successfully, you will see the following two folders are created: </p> <ul> <li><code>agilex7_dk_si_agi027fb-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build </li> <li><code>agilex7_dk_si_agi027fb-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agi027fb-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files. </li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_si_agi027fb-gsrd-images</code> folder are: </p> File Description sdimage.tar.gz SD Card Image, to be written on SD card u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file, to be used for generating the bootable SOF file"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-qspi-image","title":"Build QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1vaa.sof \\\nghrd_agib027r31b1e1vaa.jic \\\n-o hps_path=gsrd_socfpga/agilex7_dk_si_agi027fb-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1VAA \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created: </p> <ul> <li>$TOP_FOLDER/ghrd_agib027r31b1e1vaa.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR </li> <li>$TOP_FOLDER/ghrd_agib027r31b1e1vaa.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-gsrd-for-dk-si-agi027fa","title":"Build GSRD for DK-SI-AGI027FA","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-flow_1","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub. </p> <p> </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#setting-up-environment","title":"Setting up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf gsrd.dk_si_agi027fa mkdir gsrd.dk_si_agi027fa cd gsrd.dk_si_agi027fa export TOP_FOLDER=$(pwd) </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-hardware-design_1","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design: </p> <pre><code>cd $TOP_FOLDER rm -rf ghrd-socfpga agilex_soc_devkit_ghrd git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd agilex_soc_devkit_ghrd rm -rf ghrd-socfpga cd agilex_soc_devkit_ghrd export BOARD_TYPE=devkit_fm87 export BOARD_PWRMGT=linear export QUARTUS_DEVICE=AGIB027R31B1E1V make scrub_clean_all make generate_from_tcl make all unset BOARD_TYPE unset BOARD_PWRMGT unset QUARTUS_DEVICE cd .. </code></pre> <p>The following files are created: </p> <ul> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1v.sof - FPGA configuration file, without HPS FSBL </li> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex - HPS Debug FSBL </li> <li>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1v_hps_debug.sof - FPGA configuration file, with HPS Debug FSBL </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-core-rbf_1","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1v_hps_debug.sof \\\nghrd_agib027r31b1e1v.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1V \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agib027r31b1e1v.hps.jic\n</code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/ghrd_agib027r31b1e1v.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric </li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#set-up-yocto_1","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd_socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga cd gsrd_socfpga . agilex7_dk_si_agi027fa-gsrd-build.sh build_setup </code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps: </p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga . ./poky/oe-init-build-env agilex7_dk_si_agi027fa-gsrd-rootfs/ </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes: </p> <ul> <li><code>agilex7_dk_si_agi027fa_gsrd_ghrd.core.rbf</code> - core rbf file for configuring the fabric </li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location: </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agi027fa_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd_agib027r31b1e1v.core.rbf $CORE_RBF </code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location: </p> <pre><code>SRC_URI:agilex7_dk_si_agi027fa ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agi027fa_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agi027fa_gsrd_core \\\n \" </code></pre> <p>to look like this: </p> <pre><code>SRC_URI:agilex7_dk_si_agi027fa ?= \"\\\n file://agilex7_dk_si_agi027fa_gsrd_ghrd.core.rbf \\\n \" </code></pre> <p>using the following commands: </p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agi027fa_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agi027fa_gsrd_core\" NEW_URI=\"file:\\/\\/agilex7_dk_si_agi027fa_gsrd_ghrd.core.rbf\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>3. In the same Yocto recipe update the SHA256 checksum for the file: </p> <pre><code>SRC_URI[agilex7_dk_si_agi027fa_gsrd_core.sha256sum] = \"225869090fe181cb3968eeaee8422fc409c11115a9f3b366a31e3219b9615267\" </code></pre> <p>by using the following commands: </p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_SHA=\"SRC_URI\\[agilex7_dk_si_agi027fa_gsrd_core\\.sha256sum\\] = .*\" NEW_SHA=\"SRC_URI[agilex7_dk_si_agi027fa_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_SHA/$NEW_SHA/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>: </p> <ul> <li>uboot.txt - distroboot script </li> <li>uboot_script.its - its file for creating FIT image from the above script </li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>: </p> <ul> <li>fit_kernel_agilex7_dk_si_agi027fa.its - its file for creating the kernel.itb image </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-yocto_1","title":"Build Yocto","text":"<p>Build Yocto: </p> <pre><code>bitbake_image </code></pre> <p>Gather files: </p> <pre><code>package </code></pre> <p>Once the build is completed successfully, you will see the following two folders are created: </p> <ul> <li><code>agilex7_dk_si_agi027fa-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build </li> <li><code>agilex7_dk_si_agi027fa-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agi027fa-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files. </li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex-gsrd-images</code> folder are: </p> File Description sdimage.tar.gz SD Card Image, to be written on SD card u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file, to be used for generating the bootable SOF file"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-qspi-image_1","title":"Build QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1v.sof \\\nghrd_agib027r31b1e1v.jic \\\n-o hps_path=gsrd_socfpga/agilex7_dk_si_agi027fa-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1V \\\n-o mode=ASX4 \\\n-o hps=1 </code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/ghrd_agib027r31b1e1v.hps.jic</code> - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR </li> <li><code>$TOP_FOLDER/ghrd_agib027r31b1e1v.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-gsrd-for-dk-si-agi027fc","title":"Build GSRD for DK-SI-AGI027FC","text":""},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-flow_2","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub. </p> <p> </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#set-up-environment_1","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf gsrd.dk_si_agi027fc mkdir gsrd.dk_si_agi027fc cd gsrd.dk_si_agi027fc export TOP_FOLDER=$(pwd) </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-hardware-design_2","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design: </p> <pre><code>cd $TOP_FOLDER rm -rf ghrd-socfpga agilex_soc_devkit_ghrd git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd agilex_soc_devkit_ghrd rm -rf ghrd-socfpga cd agilex_soc_devkit_ghrd export BOARD_TYPE=devkit_fm87 export BOARD_PWRMGT=linear export QUARTUS_DEVICE=AGIB027R31B1E1VB make scrub_clean_all make generate_from_tcl make all unset BOARD_TYPE unset BOARD_PWRMGT unset QUARTUS_DEVICE cd .. </code></pre> <p>The following files are created: </p> <ul> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1vb.sof</code> - FPGA configuration file, without HPS FSBL </li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex</code> - HPS Debug FSBL </li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1vb_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-core-rbf_2","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1vb_hps_debug.sof \\\nghrd_agib027r31b1e1vb.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1VB \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_agib027r31b1e1vb.hps.jic\n</code></pre> <p>The following files will be created: </p> <ul> <li>$TOP_FOLDER/ghrd_agib027r31b1e1vb.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric </li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes. </p>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#set-up-yocto_2","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd_socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga cd gsrd_socfpga . agilex7_dk_si_agi027fc-gsrd-build.sh build_setup </code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps: </p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga . ./poky/oe-init-build-env agilex7_dk_si_agi027fc-gsrd-rootfs/ </code></pre>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#customize-yocto_1","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes: </p> <ul> <li><code>agilex7_dk_si_agi027fc_gsrd_ghrd.core.rbf</code> - core rbf file for configuring the fabric </li> </ul> <p>In our case we just copy the core.ghrd file in the Yocto recipe location: </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_si_agi027fc_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd_agib027r31b1e1vb.core.rbf $CORE_RBF </code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location: </p> <pre><code>SRC_URI:agilex7_dk_si_agi027fc ?= \"\\\n${GHRD_REPO}/agilex7_dk_si_agi027fc_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agi027fc_gsrd_core \\\n \" </code></pre> <p>to look like this: </p> <pre><code>SRC_URI:agilex7_dk_si_agi027fc ?= \"\\\n file://agilex7_dk_si_agi027fc_gsrd_ghrd.core.rbf \\\n \" </code></pre> <p>using the following commands: </p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_si_agi027fc_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_si_agi027fc_gsrd_core\" NEW_URI=\"file:\\/\\/agilex7_dk_si_agi027fc_gsrd_ghrd.core.rbf\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>3. In the same Yocto recipe update the SHA256 checksum for the file: </p> <pre><code>SRC_URI[agilex7_dk_si_agi027fc_gsrd_core.sha256sum] = \"225869090fe181cb3968eeaee8422fc409c11115a9f3b366a31e3219b9615267\" </code></pre> <p>by using the following commands: </p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_SHA=\"SRC_URI\\[agilex7_dk_si_agi027fc_gsrd_core\\.sha256sum\\] = .*\" NEW_SHA=\"SRC_URI[agilex7_dk_si_agi027fc_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_SHA/$NEW_SHA/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb </code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>: </p> <ul> <li>uboot.txt - distroboot script </li> <li>uboot_script.its - its file for creating FIT image from the above script </li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>: </p> <ul> <li>fit_kernel_agilex7_dk_si_agi027fc.its - its file for creating the kernel.itb image </li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-yocto_2","title":"Build Yocto","text":"<p>Build Yocto: </p> <pre><code>bitbake_image </code></pre> <p>Gather files: </p> <pre><code>package </code></pre> <p>Once the build is completed successfully, you will see the following two folders are created: </p> <ul> <li><code>agilex7_dk_si_agi027fc-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build </li> <li><code>agilex7_dk_si_agi027fc-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_si_agi027fc-gsrd-rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files. </li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex-gsrd-images</code> folder are: </p> File Description sdimage.tar.gz SD Card Image, to be written on SD card u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file, to be used for generating the bootable SOF file"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#build-qspi-image_2","title":"Build QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agib027r31b1e1vb.sof \\\nghrd_agib027r31b1e1vb.jic \\\n-o hps_path=gsrd_socfpga/agilex7_dk_si_agi027fc-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o device=MT25QU02G \\\n-o flash_loader=AGIB027R31B1E1VB \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/ghrd_agib027r31b1e1vb.hps.jic</code> - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR </li> <li><code>$TOP_FOLDER/ghrd_agib027r31b1e1vb.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric, discarded, as we already have it on the SD card</li> </ul>"},{"location":"embedded-designs/agilex-7/i-series/soc/gsrd/ug-gsrd-agx7i-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/","title":"Agilex\u2122 7 M-Series HBM2e Development Kit GSRD User Guide","text":""},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#overview","title":"Overview","text":"<p>This page presents the Golden System Reference Design for the Intel Agilex\u2122 7 FPGA M-Series Development Kit - HBM2e Edition (3x F-Tile &amp; 1x R-Tile). The GSRD demonstrates the following: </p> <ul> <li>HPS side <ul> <li>Linux, booted by U-Boot and ATF </li> <li>Board web server </li> <li>Sample applications </li> <li>Hello world </li> <li>System check application </li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the GSRD: </p> <ul> <li>Intel Agilex\u2122 7 FPGA M-Series Development Kit - HBM2e Edition (3x F-Tile &amp; 1x R-Tile), ordering code DK-DEV-AGM039FES <ul> <li>SD/MMC HPS Daughtercard </li> <li>Mini USB cable for serial output </li> <li>Micro USB cable for on-board Intel FPGA Download Cable II </li> <li>Micro SD card (4GB or greater) </li> </ul> </li> <li>Host PC with <ul> <li>Linux - Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too </li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows) </li> <li>Micro SD card slot or Micro SD card writer/reader </li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3</li> </ul> </li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board) </li> </ul> <p>The U-Boot and Linux compilation, Yocto compilation and creating the SD card image require a Linux host PC. The rest of the operations can be performed on either a Windows or Linux host PC. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#binary-release-contents","title":"Binary Release Contents","text":"<p>The binary release files are accessible at https://releases.rocketboards.org/2024.04/gsrd/agilex7_dk_dev_agm039fes_gsrd/.</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>: </p> File Description linux-socfpga-v6.6.37-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2024.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.11.0-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 and the following software component versions are used to build the GSRD: </p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#development-kit","title":"Development Kit","text":"<p>The Agilex\u2122 7 M-Series HBM Development Kit is shown below: </p> <p> </p> <p>Refer to the following for more information about the Development Kit: </p> <ul> <li>Installer Package </li> <li>Board User Guide </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#running-gsrd-with-pre-built-binaries","title":"Running GSRD with Pre-Built Binaries","text":""},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#booting-linux","title":"Booting Linux","text":"<p>1. Connect the following cables to the board: </p> <ul> <li>Power: from board to power supply </li> <li>HPS UART Console: from vertical mini USB connector on the HPS daughtercard to host PC </li> <li>JTAG: from micro USB cable on edge of the board to host PC </li> </ul> <p>2. Download, extract and write to SD card the following SD card image: https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_dev_agm039fes_gsrd/sdimage.tar.gz. Then insert SD card into the HPS OOBE Daughtercard socket. </p> <p>3. Configure board to the default settings, making sure set S24 dipswitch to OFF-OFF-OFF-ON, to select MSEL=JTAG, so that board does not configure on power up. </p> <p>4. Power up the board </p> <p>5. Download the HPS RBF file and configure the HPS RBF file over JTAG: </p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/agilex7_dk_dev_agm039fes_gsrd/ghrd.hps.rbf quartus_pgm -c 1 -m jtag -o \"p;ghrd_agmf039r47a1e2vr0.hps.rbf\" </code></pre> <p>6. Linux will boot, use 'root' as username to log in, no password will be required. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#run-hello-world-application","title":"Run Hello World Application","text":"<p>Change to IntelFPGA folder, and run the hello application, which will display a meesage as shown below: </p> <pre><code>root@agilex7dkdevagm039fes:~# cd intelFPGA/ root@agilex7dkdevagm039fes:~/intelFPGA# ./hello Hello SoC FPGA! </code></pre>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#run-syscheck-application","title":"Run SysCheck Application","text":"<p>Run the SysCheck application: </p> <pre><code>root@agilex7dkdevagm039fes:~/intelFPGA# ./syschk </code></pre> <p>It will display some system information: </p> <pre><code> ALTERA SYSTEM CHECK lo : 127.0.0.1 usb1 : DWC OTG Controller eth0 : 192.168.1.52 serial@ffc02100 : disabled hps_led2 : OFF serial@ffc02000 : okay hps_led0 : OFF hps_led1 : OFF </code></pre> <p>Press Q to exit the appplication. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#connect-to-web-server","title":"Connect to Web Server","text":"<p>1. Boot Linux as described in previous section. </p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be network interfaces of them, either can be used. </p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter. </p> <p> </p> <p>Caution: The web server is intended to allow users to control FPGA connected LEDs on the board. Due to an issue in this release, this functionality is not yet enabled. It will be enabled in the next release. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#connect-over-ssh","title":"Connect over SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection. </p> <p> </p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS: </p> <pre><code>$ sudo yum install openssh-clients </code></pre> <p>or the following command on Ubuntu: </p> <pre><code>$ sudo apt-get install openssh-client </code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action: </p> <pre><code>ssh root@192.168.1.106 </code></pre> <p> </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#build-the-gsrd","title":"Build the GSRD","text":""},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf agilex7m.gsrd mkdir agilex7m.gsrd cd agilex7m.gsrd export TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#build-hardware-design","title":"Build Hardware Design","text":"<p>Use the following commands to build the hardware design: </p> <pre><code>cd $TOP_FOLDER rm -rf ghrd-socfpga agilex_soc_devkit_ghrd git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd . rm -rf ghrd-socfpga cd agilex_soc_devkit_ghrd # configure GHRD for the board \nsed -i 's,^\\(BOARD_TYPE[ \\t]*[:?]=\\).*,\\1 devkit_fp82,g' Makefile sed -i 's,^\\(set[ \\t]CONFIG_SCHEME[ \\t]\\).*,\\1\"AVST X8\",g' design_config.tcl sed -i 's,^\\(set[ \\t]BOARD[ \\t]\\).*,\\1\"devkit_fp82\",g' design_config.tcl sed -i 's,^\\(BOARD_PWRMGT[ \\t]*[:?]=\\).*,\\1 linear,g' Makefile\nmake scrub_clean_all make generate_from_tcl make all cd .. </code></pre> <p>The following files are created: </p> <ul> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agmf039r47a1e2vr0.sof</code> - FPGA configuration file, without HPS FSBL </li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/software/hps_debug/hps_debug.ihex</code> - HPS Debug FSBL </li> <li><code>$TOP_FOLDER/agilex_soc_devkit_ghrd/output_files/ghrd_agmf039r47a1e2vr0_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-core-rbf","title":"Create Core RBF","text":"<pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agmf039r47a1e2vr0_hps_debug.sof \\ \nghrd_agmf039r47a1e2vr0.rbf \\ \n-o hps=1 rm ghrd_agmf039r47a1e2vr0.hps.rbf </code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/ghrd_agmf039r47a1e2vr0.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric </li> </ul> <p>Note we are also creating an HPS RBF file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>Then clone the Yocto script and prepare the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd_socfpga git clone -b QPDS24.3_REL_GSRD_PR  https://github.com/altera-opensource/gsrd_socfpga cd gsrd_socfpga . agilex7_dk_dev_agm039fes-gsrd-build.sh build_setup </code></pre>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> the name <code>agilex7_dk_dev_agm039fes_gsrd_ghrd.core.rbf</code> as expected by the recipes using the following command: </p> <pre><code>RECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex7_dk_dev_agm039fes_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd_agmf039r47a1e2vr0.core.rbf $CORE_RBF </code></pre> <p>2. In the Yocto recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> modify the agilex_gsrd_code file location to point to the local file: </p> <pre><code>OLD_URI=\"\\${GHRD_REPO}\\/agilex7_dk_dev_agm039fes_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex7_dk_dev_agm039fes_gsrd_core\" NEW_URI=\"file:\\/\\/agilex7_dk_dev_agm039fes_gsrd_ghrd.core.rbf\" sed -i \"s/$OLD_URI/$NEW_URI/g\" $RECIPE </code></pre> <p>3. In the same Yocto recipe update the SHA256 checksum for the file: </p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_SHA=\"SRC_URI\\[agilex7_dk_dev_agm039fes_gsrd_core\\.sha256sum\\] = .*\" NEW_SHA=\"SRC_URI[agilex7_dk_dev_agm039fes_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_SHA/$NEW_SHA/g\" $RECIPE </code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>: </p> <ul> <li>uboot.txt - distroboot script </li> <li>uboot_script.its - its file for creating FIT image from the above script </li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>: </p> <ul> <li>fit_kernel_agilex7_dk_dev_agm039fes.its - its file for creating the kernel.itb image </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto: </p> <pre><code>bitbake_image </code></pre> <p>Gather files: </p> <pre><code>package </code></pre> <p>Once the build is completed successfully, you will see the following two folders are created: </p> <ul> <li><code>agilex7_dk_dev_agm039fes-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build </li> <li><code>agilex7_dk_dev_agm039fes-gsrd-images</code>: the build script copies here relevant files built by Yocto from the <code>agilex7_dk_dev_agf027f1es-gsrd-rootfs/tmp/deploy/images/agilex7_dk_dev_agm039fes/</code> folder, but also other relevant files. </li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/agilex7_dk_dev_agm039fes-gsrd-images</code> folder are: </p> File Description sdimage.tar.gz SD Card Image, to be written on SD card u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file, to be used for generating the bootable SOF file"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-bootable-hps-rbf-file","title":"Create Bootable HPS RBF File","text":"<pre><code>cd $TOP_FOLDER rm -f *rbf* quartus_pfg -c agilex_soc_devkit_ghrd/output_files/ghrd_agmf039r47a1e2vr0.sof \\ \nghrd_agmf039r47a1e2vr0.rbf \\ \n-o hps_path=gsrd_socfpga/agilex7_dk_dev_agm039fes-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex \\ \n-o hps=1 </code></pre> <p>The following files will be created: </p> <ul> <li>$TOP_FOLDER/ghrd_agmf039r47a1e2vr0.hps.rbf - RBF file to configure the device for HPS first, phase 1 </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#configure-through-avstx8","title":"Configure Through AVSTx8","text":"<p>This section presents the details on how the GSRD can be configured automatically at power up through AVSTx8, instead of using JTAG. </p> <p>The required steps are: </p> <p>1. Create the PFG file (optional, PFG file already provided here: ghrd_agmf039r47a1e2vr0.pfg)  2. Create the POF file, using the above PFG file  3. Create the CDF file, used by Quartus Programmer to know how to write the POF file  4. Write the the POF file to MAX10 board controller flash, using the Quartus Programmer  5. Configure board through AVSTx8 </p> <p>Warning: When using the AVSTx8 configuration method on the DevKit, the 'reboot' command from U-Boot and Linux will not work. This is because the 'reboot' command issues a Cold Reset to HPS, resulting in SDM wiping HPS and waiting for the configuration bitstream to be re-sent through AVSTx8 which is not implemented on this board. In order to make this work you need to inform the external configuration agent to re-send the configuration bitstream once the Cold Reset happens. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-programmer-generator-configuration-for-avstx8","title":"Create Programmer Generator Configuration for AVSTx8","text":"<p>The PFG file contains information needed by the Quartus Programming File Generator to create the POF file to be stored on the QSPI flash attached to the MAX 10 board controller. The MAX 10 board controller reads the information from that QSPI file and configures the FPGA device over AVST. </p> <p>This section provides the details on how the PFG file is created. A copy of the file is also attached to this page: ghrd_agmf039r47a1e2vr0.pfg. </p> <p>The steps required to create the file are: </p> <p>1. Start Programmer File Generator GUI: </p> <pre><code>qpfgw &amp; </code></pre> <p>2. In the Output Files tab: </p> <ul> <li>Select Device family: Agilex\u2122 7 </li> <li>Select Configuration mode: AVSTx8 </li> <li>Edit Name: ghrd_agmf039r47a1e2vr0 </li> <li>Check Programmer Object File (.pof) </li> <li>Check Memory Map File (.map) </li> </ul> <p>The window will look similar to this: </p> <p> </p> <p>3. Click on the Input Files tab, then click on Add Bitstream... , then select Files of type to be \"Raw Binary File (.rbf)\" then browse to the <code>ghrd_agmf039r47a1e2vr0.hps.rbf</code> file and click **Open*. </p> <p> </p> <p>The window will look similar to this: </p> <p> </p> <p>4. Go to Configuration Device tab, click Add Device, select the CFI_2Gb option and click OK. </p> <p>5. Click on the OPTIONS partition to select it, then click the Edit button: </p> <p> </p> <p>6. In the Edit Partition window, select the following: </p> <ul> <li>Address Mode: Start </li> <li>Start Address: 0x00002000 </li> </ul> <p> </p> <p>Press OK. </p> <p>7. Click on CFI_2Gb then click Add Partition and select the following: </p> <ul> <li>Name: P1 </li> <li>Input file: Bitstream_1 </li> <li>Address mode: Start </li> <li>Start address: 0x00004000 </li> </ul> <p> </p> <p>Press OK. </p> <p>8. Go to File &gt; Save menu and save the configuration file as \"ghrd_agmf039r47a1e2vr0.pfg\" </p> <p> </p> <p> </p> <p>Note: The created PFG file contains absolute paths. The attached PFG file was manually edited to use relative paths instead, so it can be used even when moving files in other folders on the host PC. </p> <p>9. At this point you can generate the POF directly by clicking the Generate button. </p> <p> </p> <p>Caution: Please use the addresses 0x00002000 for OPTIONS and 0x00004000 for P1, as they are required by the MAX10 board controller. </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-pof-avstx8-configuration-file","title":"Create POF AVSTx8 Configuration File","text":"<p>The POF file is created by using the PFG file and running the following command: </p> <pre><code>cd $TOP_FOLDER wget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-7/m-series/hbm2e/collateral/ghrd_agmf039r47a1e2vr0.pfg\nquartus_pfg -c ghrd_agmf039r47a1e2vr0.pfg </code></pre> <p>The following file is created: </p> <ul> <li>$TOP_FOLDER/ghrd_agmf039r47a1e2vr0.pof - contains the MAX 10 flash image required to configure the Agilex\u2122 7 device over AVST </li> </ul>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#create-cdf-programmer-configuration-file","title":"Create CDF Programmer Configuration File","text":"<p>The provided ghrd_agmf039r47a1e2vr0.cdf) file contains the configuration required for the Quartus Programmer to be able to write the POF file to the QSPI attached to the MAX 10 Board Controller. </p> <p>This section provides instructions on how this CDF file was created, for reference purposes. </p> <p>1. Set dipswitch S24 to OFF-OFF-OFF-ON so that board configures through JTAG. </p> <p>2. Power up the board </p> <p>3. Start Programmer GUI: </p> <pre><code>cd $TOP_FOLDER quartus_pgmw &amp; </code></pre> <p> </p> <p>4. In the Programmer window, click on Hardware Setup and select the following: </p> <ul> <li>Currently selected hardware: Intel Agilex\u2122 M-Series Development Kit - HBM2e Edition </li> <li>Hardware Frequency: 16000000 </li> </ul> <p> </p> <p>Then click Close. </p> <p>5. In the Programmer window click Autodetect, then select either option from the Select Device window as shown below: </p> <p> </p> <p>6. In the Programmer window, select the VTAP10 device, then right-click it, and select Edit &gt; Change Device </p> <p> </p> <p>Select the MAX 10 &gt; 10M50DAF256 device then click OK. </p> <p> </p> <p>7. Right click the MAX10 device, and select Edit &gt; Attach Flash Device </p> <p> </p> <p>Select Quad SPI Flash Memory &gt; QSPI_2Gb option and click OK </p> <p> </p> <p>8. Right click the QSPI_2Gb entry on the top panel, then click Change File </p> <p> </p> <p>Browse to \"ghrd_agmf039r47a1e2vr0.pof\" and click Open. </p> <p>9. In the Programmer window, select the Program/Configure and Verify checkboxes for both \"P1\" and \"OPTION_BITS\" partitions </p> <p> </p> <p>10. Go to File &gt; Save and save the configuration file as \"board.cdf\" </p> <p>Note: The output file \"ghrd_agmf039r47a1e2vr0.cdf\" has an absolute path to the \"ghrd_agmf039r47a1e2vr0.pof\" file. The provided file was hand edited to use a relative path instead, so files could be located anywhere on the host PC file system. </p> <p>11. At this stage you can also click the Start button, for the Programmer to write the file to flash. A progress bar will be shown: </p> <p> </p> <p>12. On successfull completion, the Programmer will show 100% completed: </p> <p> </p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#write-pof-file-using-the-cdf-file","title":"Write POF File Using the CDF File","text":"<p>1. Connect the following cables to the board: </p> <ul> <li>Power: from board to power supply </li> <li>JTAG: from micro USB cable on edge of the board to host PC </li> </ul> <p>2. Configure board to the default settings, except set S24 dipswitch to OFF-OFF-OFF-ON, to select MSEL=JTAG, so that board does not configure on power up. </p> <p>3. Power up the board </p> <p>4. Make sure you have the following files in the current folder: </p> <ul> <li>ghrd_agmf039r47a1e2vr0.cdf </li> <li>ghrd_agmf039r47a1e2vr0.pof </li> </ul> <p>5. Run the following command to flash the POF file: </p> <pre><code>cd $TOP_FOLDER wget https://altera-fpga.github.io/rel-24.3/embedded-designs/agilex-7/m-series/hbm2e/collateral/ghrd_agmf039r47a1e2vr0.cdf\nquartus_pgm ghrd_agmf039r47a1e2vr0.cdf </code></pre>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#boot-linux","title":"Boot Linux","text":"<p>1. Power down the board </p> <p>2. Set S24 to ON-OFF-OFF-ON to set MSEL=AVSTx8, so that the FPGA device gets configured with the POF on the next power cycle. </p> <p>3. Power up the board </p> <p>4. FPGA device will get configured, the U-Boot SPL will be ran, then U-Boot and then Linux. Log in with 'root' when prompted, no passowrd will be required, just like when configuring board with the RBF file.</p>"},{"location":"embedded-designs/agilex-7/m-series/hbm2e/ug-gsrd-agx7m-hbm2e/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/doc_modules/setup-console/","title":"Setup console","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, the SoC EDS Pro installer automatically installs the required drivers if necessary.</p> <p>The serial communication parameters are:</p> <ul> <li>Baud-rate: 115,200</li> <li>Parity: none</li> <li>Flow control: none</li> <li>Stop bits: 1</li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus.</p> <p>On Linux, the minicom utility can be used. Here is how to configure it:</p> <p>The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following:</p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB*</li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet.</li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared.</li> <li>Install minicom application on host PC, if not installed.</li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom</li> <li>Configure minicom.</li> </ul> <pre><code>$ sudo minicom -s\n</code></pre> <p>Under Serial Port Setup choose the following:</p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary)</li> <li>Bps/Par/Bits: 115200 8N1</li> <li>Hardware Flow Control: No</li> <li>Software Flow Control: No</li> <li>Hit [ESC] to return to the main configuration menu</li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit.</p>"},{"location":"embedded-designs/doc_modules/setup-quartus/","title":"Setup quartus","text":"<p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/doc_modules/setup-toolchain/","title":"Setup toolchain","text":"<p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre>"},{"location":"embedded-designs/doc_modules/setup-yocto/","title":"Setup yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/","title":"Rsu separate ssbl","text":""},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/doc_modules/tsn/test-tsn-app_txrx/","title":"Test tsn app txrx","text":"<p>The following examples are demonstrated using 2 units of the Agilex 5 platform.  Please take note of the notation \"[Board A or B]\". The following steps assumes both platforms are connected to each other via an Ethernet connection.</p> <p>1. Boot to Linux</p> <p>2. Navigate to the <code>tsn</code> directory</p> <pre><code>cd tsn\n</code></pre> Configuration for Both Boards Step I: Setup Environment Path on Both Boards <p>3. Board A</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> <p>4. Board B</p> <pre><code>export LIBXDP_OBJECT_PATH=/usr/lib/bpf\nexport LD_LIBRARY_PATH=/usr/lib/custom_bpf/lib </code></pre> TXRX-TSN App Step II: Run Configuration Script <p>5. Board A: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up TAPRIO qdisc.</p> <pre><code>./run.sh agilex5 eth0 vs1a setup\n</code></pre> <p>6. Board B: Run the configuration script and wait for it to configure the IP and MAC address, start clock synchronization, and set up ingress qdiscs.</p> <pre><code>./run.sh agilex5 eth0 vs1b setup\n</code></pre> Step III: Start the Application <p>7. Board B: Run the application.</p> <pre><code>./run.sh agilex5 eth0 vs1b run\n</code></pre> <p>8. Board A: Immediately after starting the application on Board B, run the application on Board A.</p> <pre><code>./run.sh agilex5 eth0 vs1a run\n</code></pre> Post-Test Procedure <p>Once the test is completed, copy the following files from Board B (listener) to the host machine:</p> <ul> <li>afpkt-rxtstamps.txt</li> <li>afxdp-rxtstamps.txt</li> </ul> Generating Latency Plot Using Excel <p>Import 'afpkt-rxtstamps.txt' and 'afxdp-rxtstamps.txt' to excel in 2 seperate sheets.</p> <p></p> <p>Plot Column 1 for each sheets using Scatter chart,</p> <p></p> <p>This will generate plot for AFPKT and AFXDP with latency(on Y-axis) against packet count (on X-axis).</p>"},{"location":"embedded-designs/doc_modules/tsn/test-tsn-timesync/","title":"Test tsn timesync","text":"<p>You may use the following command guide to perform time synchronization on the Agilex\u2122 5 system using PTP4L and PHC2SYS, and to obtain delay values</p> <p>End-to-End PTP master and slave synchronization</p> <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -E -2 -m\n</code></pre> <pre><code>-i  eth0: This option specifies the `eth0` as the network interface to use for PTP.\n-s  This option enables the slave-only mode. \n-H  This option enables hardware time stamping. \n-E  This option selects the end-to-end (E2E) delay measurement mechanism. This is the default.The E2E mechanism is also referred to as the delay \u201crequest-response\u201d mechanism.\n-2  Use Ethernet Layer (L2)\n-m  This option enables printing of messages to the standard output.\n</code></pre> </li> </ul> <ul> <li>Boards A (as master):<pre><code>ptp4l -i eth0  -H -E -2 -m\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul> <p>Peer-to-Peer PTP synchronization:</p> <ul> <li>Board B (as slave):     <pre><code>slave: ptp4l -i eth0  -s -H -P -2 -m\n</code></pre><p>-P: This option enables the use of the Peer Delay Mechanism.</p> </li> </ul> <ul> <li>Board A (as master):     <pre><code>master: ptp4l -i eth0  -H -P -2 -m\n</code></pre></li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul> <p>gPTP synchronization:</p> <ul> <li>Board B (as slave):<pre><code>ptp4l -i eth0  -s -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>Board A (as master): <pre><code>ptp4l -i eth0  -H -P -2 -m --transportSpecific=1\n</code></pre> </li> </ul> <ul> <li>At Board B (as slave), perform sync on local System Clock with EMAC Hardwware Clock.<pre><code>phc2sys -s eth0 -w -m --transportSpecific 1 -c CLOCK_REALTIME -O 0 -n 0\n</code></pre> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/","title":"Stratix\u00ae 10 HPS eMMC Boot Example","text":""},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#overview","title":"Overview","text":"<p>This project demonstrates how to boot to Linux on the Stratix\u00ae SoC HPS using eMMC instead of the standard SD card. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>You will need the following items: </p> <ul> <li>Stratix\u00ae 10 SX SoC Development Kit, production version, H-Tile (ordering code DK-SOC-1SSX-H-D):<ul> <li>NAND/eMMC HPS Daughtercard </li> <li>SDM QSPI Bootcard with MT25QU02G flash device </li> </ul> </li> <li>Linux host PC (Ubuntu 22.04LTS was used for developing this project, but other versions may work too) </li> <li>Internet access (for downloading files attached to this page, and cloning git trees from github) </li> <li>TFTP server running on host computer (or other accessible computer on the local network) </li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3</li> </ul> <p>Refer to board documentation for more details about the development kit.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#nandemmc-daughtercard","title":"NAND/eMMC Daughtercard","text":"<p>The NAND/eMMC HPS daughtercard that comes with the S10 SoC DevKit supports both NAND and eMMC. </p> <p>To configure the card for eMMC operation, please set the jumpers as shown below: </p> Jumper Setting J2 unpopulated J9 unpopulated J10 populated 1-2 J11 populated 2-3 <p>For reference, the NAND/eMMC schematic is available at https://www.intel.com/content/dam/altera-www/global/en_US/support/boards-kits/arria10/soc/hps_io48_nand_dc.pdf. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#deliverables","title":"Deliverables","text":"<p>The following files are available as part of this example: </p> File Description stratix10-u-boot-emmc.patch U-Boot DTS patch to use eMMC - device tree changes only stratix10-linux-emmc.patch Linux DTS patch to use eMMC - device tree changes only"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#build-instructions","title":"Build Instructions","text":""},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#build-flow","title":"Build Flow","text":"<p>The main changes vs. the standard SD card flow are: </p> <ul> <li>Hardware project is modified to target the eMMC daughtercard </li> <li>U-Boot device tree is patched to match the eMMC daughtercard </li> <li>Linux device tree is patched to match the eMMC daughtercard </li> <li>eMMC image is downloaded over TFTP and written by U-Boot which is ran by the debugger </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#set-up-environment","title":"Set Up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location: </p> <pre><code>sudo rm -rf stratix10.emmc_boot\nmkdir stratix10.emmc_boot\ncd stratix10.emmc_boot\nexport set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>The hardware design is downloaded from Github, then it's configured to enable the eMMC HPS card, then it's compiled: </p> <pre><code>cd $TOP_FOLDER rm -rf ghrd-socfpga s10_soc_devkit_ghrd git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd . rm -rf ghrd-socfpga cd s10_soc_devkit_ghrd # target the h-tile board\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\n# use fpga configuration first instead of hps boot first \nexport BOOTS_FIRST=fpga # select the emmc hps daughtercard \nexport DAUGHTER_CARD=devkit_dc_emmc # disable sgmii and partial reconfiguration - to decrease build time \nexport HPS_ENABLE_SGMII=0 export ENABLE_PARTIAL_RECONFIGURATION=0 make scrub_clean_all make generate_from_tcl make all\nunset BOOTS_FIRST\nunset DAUGHTER_CARD\ncd .. </code></pre> <p>The following relevant files are created in $TOP_FOLDER/s10_soc_devkit_ghrd/output_files/: </p> <ul> <li><code>ghrd_1sx280hu2f50e1vgas.sof</code> - FPGA configuration file, without HPS FSBL </li> <li><code>ghrd_1sx280hu2f50e1vgas_hps_debug.sof</code> - FPGA configuration file, with dummy HPS FSBL used for debugging </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#build-arm-trusted-firmware","title":"Build Arm* Trusted Firmware","text":"<pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware\nmake bl31 PLAT=stratix10 DEPRECATED=1 cd .. </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#build-u-boot","title":"Build U-Boot","text":"<pre><code>cd $TOP_FOLDER wget https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/emmc/collateral/stratix10-u-boot-emmc.patch\nrm -rf u-boot-socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga # change device tree to account for board differences \npatch -p 1 &lt; ../stratix10-u-boot-emmc.patch\n# enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk # use 'Image' for kernel image instead of 'kernel.itb'\nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# - Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n \nCONFIG_SPL_NAND_SUPPORT=n \nCONFIG_CMD_NAND_TRIMFFS=n \nCONFIG_CMD_NAND_LOCK_UNLOCK=n \nCONFIG_NAND_DENALI_DT=n \nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n \nCONFIG_SPL_NAND_FRAMEWORK=n \nCONFIG_CMD_NAND=n \nCONFIG_MTD_RAW_NAND=n \nCONFIG_CMD_UBI=n \nCONFIG_CMD_UBIFS=n \nCONFIG_MTD_UBI=n \nCONFIG_ENV_IS_IN_UBI=n \nCONFIG_UBI_SILENCE_MSG=n \nCONFIG_UBIFS_SILENCE_MSG=n \n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"bridge enable;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_SPL_DOS_PARTITION=y \nCONFIG_CMD_PART=y \nCONFIG_SPL_CRC32=y \nCONFIG_LZO=y \nCONFIG_CMD_DHCP=y \n# Enable more QSPI flash manufacturers \nCONFIG_SPI_FLASH_MACRONIX=y \nCONFIG_SPI_FLASH_GIGADEVICE=y \nCONFIG_SPI_FLASH_WINBOND=y \nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper make socfpga_stratix10_defconfig # Use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin . make -j 64 cd .. </code></pre> <p>The following files will be created: </p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code> - SSBL/SPL hex file </li> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code> - U-Boot and ATF combined image file </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#create-qspi-image","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command: </p> <pre><code>cd $TOP_FOLDER quartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof flash_image.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=1SX280HU2 \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 </code></pre> <p>The following image file will be created: </p> <ul> <li><code>$TOP_FOLDER/flash_image.jic</code> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#build-linux","title":"Build Linux","text":"<p>The following instructions are used to build Linux: </p> <pre><code>cd $TOP_FOLDER wget https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/emmc/collateral/stratix10-linux-emmc.patch\nrm -rf linux-socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga cd linux-socfpga patch -p1 &lt; ../stratix10-linux-emmc.patch\nmake clean &amp;&amp; make mrproper make defconfig make -j 64 Image dtbs cd .. </code></pre> <p>The following relevant files are created: </p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code> - Linux kernel image </li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb</code> - Linux Device Tree Blob </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#build-rootfs","title":"Build Rootfs","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system: </p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b scarthgap http://git.yoctoproject.org/poky\ngit clone -b scarthgap http://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap http://git.openembedded.org/meta-openembedded\nsource poky/oe-init-build-env ./build echo 'MACHINE = \"stratix10\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf echo 'CORE_IMAGE_EXTRA_INSTALL += \" fio\"' &gt;&gt; conf/local.conf bitbake core-image-minimal </code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive will be created: </p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz</code></li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#create-emmc-image","title":"Create eMMC Image","text":"<p>The eMMC image is created with the same procedure used for creating SD card images: </p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card mkdir sd_card cd sd_card wget https://releases.rocketboards.org/2021.04/gsrd/tools/make_sdimage_p3.py chmod +x make_sdimage_p3.py # remove mkfs.fat parameter which has some issues on Ubuntu 22.04 \nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py mkdir fat &amp;&amp; cd fat cp $TOP_FOLDER/u-boot-socfpga/u-boot.itb . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb . cd .. mkdir rootfs &amp;&amp; cd rootfs sudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz sudo rm -rf lib/modules/* cd .. sudo python3 ./make_sdimage_p3.py -f \\ \n-P rootfs/*,num=2,format=ext3,size=64M \\ \n-P fat/*,num=1,format=fat32,size=48M \\ \n-s 128M \\ \n-n emmc.img cd .. </code></pre> <p>The following image file will be created: </p> <ul> <li><code>$TOP_FOLDER/sd_card/emmc.img</code></li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#flash-instructions","title":"Flash Instructions","text":""},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#write-qspi-image","title":"Write QSPI Image","text":"<p>1. Install the QSPI SDM bootcard on the S10 SoC Development Kit and configure the S10 SoC Development Kit as follows: </p> <ul> <li>SW1: 1:OFF, rest:ON </li> <li>SW2: 1:ON 2:ON 3: ON 4: OFF </li> <li>SW3: all OFF </li> <li>SW4: 1:ON 2:OFF 3:OFF 4:ON </li> </ul> <p>2. Run programmer to write the flash image: </p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;flash_image.jic\" </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#write-emmc-image","title":"Write eMMC Image","text":"<p>The flow for writing the eMMC image is: </p> <ul> <li>Configure the FPGA over JTAG with an image containing a debug HPS FSBL, which just stays in an infinite loop </li> <li>Load and run SPL and U-Boot to HPS over JTAG </li> <li>From U-Boot command prompt, transfer the eMMC image to HPS SDRAM over TFTP </li> <li>From U-Boot command prompt, write the eMMC image from SDRAM to eMMC </li> </ul> <p>1. Configure the FPGA over JTAG with an image containing a dummy HPS SPL, which just stays in an infinite loop: </p> <pre><code>cd $TOP_FOLDER quartus_pgm --no_banner --mode=jtag -o \"p;s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas_hps_debug.sof\" </code></pre> <p>2. Reduce JTAG clock to make sure it will work on older boards for connecting to HPS: </p> <pre><code>jtagconfig --setparam 1 JtagClock 6M </code></pre> <p>3. Run U-Boot from the debugger, as shown here</p> <p>4. The above will cause the U-Boot to start running on HPS. Stop U-Boot counter by pressing any key on the serial console. </p> <p>5. Copy the eMMC image to the TFTP folder on the host computer. Also determine the IP of the host computer by running the \"ifconfig\" command. </p> <p>6. In U-Boot, download the eMMC image, compute the number of blocks, and write it to the eMMC: </p> <pre><code>tftp ${loadaddr} emmc.img setexpr blkcnt ${filesize} / 0x200 mmc write ${loadaddr} 0 ${blkcnt} </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#boot-linux","title":"Boot Linux","text":"<p>1. Configure the S10 SoC Development Kit to configure FPGA and load FSBL from QSPI: </p> <ul> <li>SW1: 1:OFF, rest:ON </li> <li>SW2: 1:ON 2:OFF 3:OFF 4: OFF </li> <li>SW3: all OFF </li> <li>SW4: 1:ON 2:OFF 3:OFF 4:ON </li> </ul> <p>2. Power up the board </p> <p>3. Linux will boot, use 'root' as username to log in - no password will be required.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/emmc/ug-emmc-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/","title":"Stratix\u00ae 10 SoC Fabric Configuration from Linux Example","text":""},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#introduction","title":"Introduction","text":"<p>When using HPS Boot First method, the FPGA device is first configured with a small Phase 1 bitstream, which configures the periphery, and brings up HPS. Then, at a later time, HPS configures the FPGA fabric using a larger Phase 2 bitstream. </p> <p>The HPS can configure the fabric either from U-Boot or Linux. The Golden System Reference Design (GSRD) configures the fabric from U-Boot. The examples in this page demonstrate how to configure the FPGA fabric from Linux, using device tree overlays. </p> <p>Two different examples are provided: </p> <ul> <li>Example building components separately </li> <li>based on the Building Bootloader for Stratix10 example. </li> <li>Manages overlays directly. </li> <li>Example building everything with Yocto </li> <li>Based on the Stratix\u00ae 10 SoC H-Tile GSRD. </li> <li>Manages overlays with the dtbt utility </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>You will need the following items: </p> <ul> <li>Stratix\u00ae 10 SX SoC Development Kit, production version, H-Tile (ordering code DK-SOC-1SSX-H-D):<ul> <li>NAND/eMMC HPS Daughtercard </li> <li>SDM QSPI Bootcard with MT25QU02G flash device </li> </ul> </li> <li>Linux host PC (Ubuntu 22.04LTS was used for developing this project, but other versions may work too) </li> <li>Internet access (for downloading files attached to this page, and cloning git trees from github) </li> <li>TFTP server running on host computer (or other accessible computer on the local network) </li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3</li> </ul> <p>Refer to board documentation for more details about the development kit.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#example-building-components-separately","title":"Example Building Components Separately","text":"<p>This example is build on top of the Building Bootloader for Stratix10 example, with the modification that the fabric is not configured from U-Boot anymore, but from Linux, with a device tree overlay. </p> <p>The device tree overlay and the Phase 2 configuration bitstream core.rbf are stored in the Linux rootfs folder /lib/firmware, where the Linux overlay framework expects them to be by default. </p> <p>Full instructions for building and running the example are provided. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#build-example","title":"Build Example","text":"<p>1. Set Up Environment </p> <pre><code>sudo rm -rf stratix10.fabric_config.separate\nmkdir stratix10.fabric_config.separate cd stratix10.fabric_config.separate\nexport TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Build Hardware Design </p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga s10_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd s10_soc_devkit_ghrd\n# target the h-tile board\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\n# disable SGMII to build faster\nexport HPS_ENABLE_SGMII=0\n# disable PR to build faster\nexport ENABLE_PARTIAL_RECONFIGURATION=0\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>3. Build Arm* Trusted Firmware </p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware make -j 48 bl31 PLAT=stratix10 cd .. </code></pre> <p>4. Build U-Boot </p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk # use 'Image' for kernel image instead of 'kernel.itb'\nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi  # Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb \nCONFIG_BOOTFILE=\"Image\" \n# - Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n \nCONFIG_SPL_NAND_SUPPORT=n \nCONFIG_CMD_NAND_TRIMFFS=n \nCONFIG_CMD_NAND_LOCK_UNLOCK=n \nCONFIG_NAND_DENALI_DT=n \nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n \nCONFIG_SPL_NAND_FRAMEWORK=n \nCONFIG_CMD_NAND=n \nCONFIG_MTD_RAW_NAND=n \nCONFIG_CMD_UBI=n \nCONFIG_CMD_UBIFS=n \nCONFIG_MTD_UBI=n \nCONFIG_ENV_IS_IN_UBI=n \nCONFIG_UBI_SILENCE_MSG=n \nCONFIG_UBIFS_SILENCE_MSG=n \n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; bridge disable; fpga load 0 \\${loadaddr} \\${filesize};bridge enable;setenv bootfile Image;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_SPL_DOS_PARTITION=y \nCONFIG_CMD_PART=y \nCONFIG_SPL_CRC32=y \nCONFIG_LZO=y \nCONFIG_CMD_DHCP=y \n# Enable more QSPI flash manufacturers \nCONFIG_SPI_FLASH_MACRONIX=y \nCONFIG_SPI_FLASH_GIGADEVICE=y \nCONFIG_SPI_FLASH_WINBOND=y \nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper make socfpga_stratix10_defconfig # Use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin . # build\nmake -j 64 cd .. </code></pre> <p>5. Build JIC and Core RBF Files </p> <pre><code>cd $TOP_FOLDER rm -f ghrd.hps.jic ghrd.core.rbf quartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof ghrd.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=1SX280HU2 \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o hps=1 </code></pre> <p>6. Build Linux </p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga cd linux-socfpga make clean &amp;&amp; make mrproper make defconfig # enable device tree overlays and fpga bridges \n./scripts/config --set-val CONFIG_OF_RESOLVE y ./scripts/config --set-val CONFIG_OF_OVERLAY y ./scripts/config --set-val CONFIG_OF_CONFIGFS y ./scripts/config --set-val CONFIG_FPGA_MGR_STRATIX10_SOC y ./scripts/config --set-val CONFIG_FPGA_BRIDGE y ./scripts/config --set-val CONFIG_FPGA_REGION y ./scripts/config --set-val CONFIG_OF_FPGA_REGION y ./scripts/config --set-val CONFIG_OVERLAY_FS y # enable SYSID driver \n./scripts/config --set-val CONFIG_ALTERA_SYSID y make oldconfig make -j 64 Image dtbs </code></pre> <p>7. Create Device Treee Overlay </p> <pre><code>cd $TOP_FOLDER rm -f overlay.dtb overlay.dts cat &lt;&lt; EOF &gt; overlay.dts \n/dts-v1/; \n/plugin/; \n/ { \n fragment@0 { \n target-path = \"/soc/base_fpga_region\"; \n #address-cells = &lt;0x2&gt;; \n #size-cells = &lt;0x2&gt;; \n __overlay__ { \n #address-cells = &lt;0x2&gt;; \n #size-cells = &lt;0x2&gt;; \n ranges = &lt;0x00000000 0x0 0xF9000000 0x0 0x00200000&gt;; \n firmware-name = \"overlay.rbf\"; \n config-complete-timeout-us = &lt;30000000&gt;; \n sysid_qsys_0: sysid@0 { \n compatible = \"altr,sysid-24.2\", \"altr,sysid-1.0\"; \n reg = &lt;0x0 0x00000000 0x0 0x00000010&gt;; \n id = &lt;3405707982&gt;; \n timestamp = &lt;0&gt;; \n }; \n }; \n }; \n}; \nEOF dtc -I dts -O dtb -o overlay.dtb overlay.dts </code></pre> <p>Explanation: </p> <ul> <li><code>Fragment@0</code>: Node Name of the Overlay. </li> <li><code>target-path</code>: This refers to base_fpga_region located in arch/arm64/boot/dts/intel/socfpga_agilex.dtsi. This will invoke the following driver: drivers/fpga/of-fpga-region.c </li> <li>Fragment@0 <code>#address-cells/#size-cells</code>: This specifies the number of cells (32-bit size) to be used for the child's address map. For overlays, we need to set this value to avoid \"default_addr_size\" errors. </li> <li>overlay <code>#address-cells/#size-cells</code>: These fields should match those in arch/arm64/boot/dts/intel/socfpga_agilex.dtsi. </li> <li><code>Ranges</code>: According to the device tree standard, this allows mapping child addresses to parent addresses. In this case: <ul> <li>The first number <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> represents the child's address. </li> <li>The second pair <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> represents the parent's address. </li> <li>The third pair <code>&lt;0x0 0x0 0xF9000000 0x0 0x00200000&gt;</code> specifies the memory region's size. </li> </ul> </li> <li><code>firmware-name = \"overlay.rbf\"</code>: This should contain the fabric's file name. </li> <li><code>sysid_qsys_0: sysid@0</code>: This specifies the device name as well as its alias. </li> <li><code>reg = &lt;0x0 0x0 0x0 0x00000010&gt;</code>: This refers to the addresses specified in the parent range field. <ul> <li><code>&lt;0x0 0x0 0x0 0x00000010&gt;</code>: This represents the child's address. </li> <li><code>&lt;0x0 0x0 0x0 0x00000010&gt;</code>: This is the size of the memory region. </li> </ul> </li> </ul> <p>8. Build Root Filesystem </p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b scarthgap https://git.yoctoproject.org/poky git clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga git clone -b scarthgap https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"stratix10\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf bitbake core-image-minimal </code></pre> <p>9. Build SD Card Image </p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py sed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py chmod +x make_sdimage_p3.py mkdir fat &amp;&amp; cd fat cp $TOP_FOLDER/u-boot-socfpga/u-boot.itb . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb . cd .. mkdir rootfs &amp;&amp; cd rootfs sudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz sudo rm -rf lib/modules/* sudo mkdir -p lib/firmware sudo cp $TOP_FOLDER/ghrd.core.rbf lib/firmware/overlay.rbf sudo cp $TOP_FOLDER/overlay.dtb lib/firmware/overlay.dtb cd .. sudo python3 make_sdimage_p3.py -f \\ \n-P fat/*,num=1,format=fat32,size=48M \\ \n-P rootfs/*,num=2,format=ext3,size=32M \\ \n-s 100M \\ \n-n sdcard.img cd .. </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#run-example","title":"Run Example","text":"<p>1. Write QSPI image <code>$TOP_FOLDER/ghrd.hps.jic</code> </p> <p>2. Write SD card image <code>$TOP_FOLDER/sd_card/sdcard.img</code> </p> <p>3. Power up board </p> <p>4. Log into Linux using 'root' as username, no password will be required. </p> <p>5. Create the overlay folder </p> <pre><code>root@stratix10:~# mkdir /sys/kernel/config/device-tree/overlays/0 </code></pre> <p>6. Configure the overlay: </p> <pre><code>root@stratix10:~# echo overlay.dtb &gt; /sys/kernel/config/device-tree/overlays/0/path [ 35.750389] fpga_manager fpga0: writing overlay.rbf to Stratix10 SOC FPGA Manager [ 36.170960] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges [ 36.181456] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/firmware-name [ 36.192486] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/config-complete-timeout-us </code></pre> <p>7. Locate the sysid in the sysfs: </p> <pre><code>root@stratix10:~# find / -name sysid /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid </code></pre> <p>8. Display the sysid id information: </p> <pre><code>root@stratix10:~# cat /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid/id | xargs printf \"0x%08x\\n\" 0xacd5cafe </code></pre> <p>9. Remove the overlay: </p> <pre><code>root@stratix10:~# rmdir /sys/kernel/config/device-tree/overlays/0 </code></pre> <p>10. Confirm that the overlay was removed: </p> <pre><code>root@stratix10:~# find / -name sysid </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#example-building-everything-with-yocto","title":"Example Building Everything with Yocto","text":"<p>This example is build on top of the Stratix 10 SoC L-Tile GSRD, with the modification that the fabric is not configured from U-Boot anymore, instead through a device tree overlay. </p> <p>Full instructions for building and running the example are provided. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#build-example_1","title":"Build Example","text":"<p>1. Set up environment:</p> <pre><code>sudo rm -rf stratix10.fabric_config.yocto mkdir stratix10.fabric_config.yocto\ncd stratix10.fabric_config.yocto\nexport TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> <p>2. Build hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga s10_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd s10_soc_devkit_ghrd\n# target the h-tile board\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\n# disable SGMII to build faster\nexport HPS_ENABLE_SGMII=0\n# disable PR to build faster\nexport ENABLE_PARTIAL_RECONFIGURATION=0\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>3. Build the core.rbf </p> <pre><code>cd $TOP_FOLDER rm -f ghrd.hps.jic ghrd.core.rbf quartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas_hps_debug.sof \\ \nghrd.jic \\ \n-o device=MT25QU128 \\ \n-o flash_loader=1SX280HU2 \\ \n-o mode=ASX4 \\ \n-o hps=1 rm ghrd.hps.jic </code></pre> <p>4. Clone Yocto script and start the build: </p> <pre><code>cd $TOP_FOLDER rm -rf gsrd_socfpga git clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga cd gsrd_socfpga . stratix10-gsrd-build.sh build_setup </code></pre> <p>5. Get and apply the patch, containing the following changes: </p> <ul> <li>U-Boot boot script is changed to load configuration 0 from the kernel.itb, which does not configure the fabric at boot time </li> <li>Overlay file agilex_fabric_config_overlay.dts was added, pointing to core.rbf file for fabric configuration, and adding the sysid driver </li> <li>core.rbf file is also copied into the /lib/firmware folder where the Linux device tree framwork expects it   =</li> </ul> <pre><code>rm -f stratix10-fabric-config-yocto.patch\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/fabric-config/collateral/stratix10-fabric-config-yocto.patch patch -d meta-intel-fpga-refdes -p1 &lt; stratix10-fabric-config-yocto.patch </code></pre> <p>For reference, the patch looks like this:</p> <pre><code>diff --git a/recipes-bsp/device-tree/device-tree.bb b/recipes-bsp/device-tree/device-tree.bb\nindex 94e5a17..d9387d0 100644\n--- a/recipes-bsp/device-tree/device-tree.bb\n+++ b/recipes-bsp/device-tree/device-tree.bb\n@@ -66,6 +66,7 @@ SRC_URI:append:stratix10 = \" \\\n                   file://stratix10_pr_persona0.dts \\\n                    file://stratix10_pr_persona1.dts \\\n                    file://socfpga_ilc.dtsi \\\n+                   file://fabric_config_overlay.dts \\\n                   \"\n\nSRC_URI:append:stratix10_htile = \" \\\n@@ -75,6 +76,7 @@ SRC_URI:append:stratix10_htile = \" \\\n                   file://stratix10_pr_persona0.dts \\\n                    file://stratix10_pr_persona1.dts \\\n                    file://socfpga_ilc.dtsi \\\n+                   file://fabric_config_overlay.dts \\\n                   \"\n\nSRC_URI:append:agilex5_dk_a5e065bb32aes1 = \" \\\ndiff --git a/recipes-bsp/device-tree/files/fabric_config_overlay.dts b/recipes-bsp/device-tree/files/fabric_config_overlay.dts\nnew file mode 100644\nindex 0000000..4ca15eb\n--- /dev/null\n+++ b/recipes-bsp/device-tree/files/fabric_config_overlay.dts\n@@ -0,0 +1,23 @@\n+/dts-v1/;\n+/plugin/;\n+/ {\n+                fragment@0 {\n+                                target-path = \"/soc/base_fpga_region\";\n+                                #address-cells = &lt;0x2&gt;;\n+                                #size-cells = &lt;0x2&gt;;\n+                                __overlay__ {\n+                                                #address-cells = &lt;0x2&gt;;\n+                                                #size-cells = &lt;0x2&gt;;\n+                                                ranges = &lt;0x00000000 0x0 0xF9000000 0x0 0x00200000&gt;;\n+                                                firmware-name = \"ghrd.core.rbf\";\n+                                                config-complete-timeout-us = &lt;30000000&gt;;\n+\n+                                                sysid_qsys_0: sysid@0 {\n+                                                    compatible = \"altr,sysid-23.4\", \"altr,sysid-1.0\";\n+                                                    reg = &lt;0x0 0x00000000 0x0 0x00000010&gt;;\n+                                                    id = &lt;3405707982&gt;;\n+                                                    timestamp = &lt;0&gt;;\n+                                                };\n+                                };\n+                };\n+};\ndiff --git a/recipes-bsp/ghrd/hw-ref-design.bb b/recipes-bsp/ghrd/hw-ref-design.bb\nindex 36cb532..1120f9d 100644\n--- a/recipes-bsp/ghrd/hw-ref-design.bb\n+++ b/recipes-bsp/ghrd/hw-ref-design.bb\n@@ -205,6 +205,7 @@ do_install () {\n       install -D -m 0644 ${WORKDIR}/${MACHINE}_nand_${ARM64_GHRD_CORE_RBF} ${D}/boot/nand.core.rbf\n        install -D -m 0644 ${WORKDIR}/${MACHINE}_pr_persona0.rbf ${D}${base_libdir}/firmware/persona0.rbf\n        install -D -m 0644 ${WORKDIR}/${MACHINE}_pr_persona1.rbf ${D}${base_libdir}/firmware/persona1.rbf\n+       install -D -m 0644 ${WORKDIR}/${MACHINE}_gsrd_${ARM64_GHRD_CORE_RBF} ${D}${base_libdir}/firmware/${ARM64_GHRD_CORE_RBF}\n   fi\n\n   if ${@bb.utils.contains(\"MACHINE\", \"stratix10_htile\", \"true\", \"false\", d)}; then\n@@ -212,6 +213,7 @@ do_install () {\n       install -D -m 0644 ${WORKDIR}/${MACHINE}_nand_${ARM64_GHRD_CORE_RBF} ${D}/boot/nand.core.rbf\n        install -D -m 0644 ${WORKDIR}/${MACHINE}_pr_persona0.rbf ${D}${base_libdir}/firmware/persona0.rbf\n        install -D -m 0644 ${WORKDIR}/${MACHINE}_pr_persona1.rbf ${D}${base_libdir}/firmware/persona1.rbf\n+       install -D -m 0644 ${WORKDIR}/${MACHINE}_gsrd_${ARM64_GHRD_CORE_RBF} ${D}${base_libdir}/firmware/${ARM64_GHRD_CORE_RBF}\n   fi\n\n   if ${@bb.utils.contains(\"MACHINE\", \"cyclone5\", \"true\", \"false\", d)}; then\ndiff --git a/recipes-bsp/u-boot/files/uboot.txt b/recipes-bsp/u-boot/files/uboot.txt\nindex 8577186..3a0288f 100644\n--- a/recipes-bsp/u-boot/files/uboot.txt\n+++ b/recipes-bsp/u-boot/files/uboot.txt\n@@ -6,7 +6,7 @@ if test ${target} = \"mmc0\"; then\n       mmc rescan;\n        fatload ${devtype} ${devnum}:${distro_bootpart} ${loadaddr} ${bootfile};\n        setenv bootargs \"earlycon panic=-1 root=${mmcroot} rw rootwait\";        \n-       bootm ${loadaddr}#board-${board_id};\n+       bootm ${loadaddr}#board-0;\n       exit;\n    fi\n fi\n</code></pre> <p>6. Customize Yocto Build: </p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/stratix10_gsrd_ghrd.core.rbf ln -s $TOP_FOLDER/ghrd.core.rbf $CORE_RBF OLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_gsrd_\\${ARM64_GHRD_CORE_RBF};name=stratix10_gsrd_core\" NEW_CORE_URI=\"file:\\/\\/stratix10_gsrd_ghrd.core.rbf\" CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") RECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb sed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \") OLD_CORE_SHA=\"SRC_URI\\[stratix10_gsrd_core\\.sha256sum\\] = .*\" NEW_CORE_SHA=\"SRC_URI[stratix10_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\" sed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE </code></pre> <p>7. Build Yocto: </p> <pre><code>bitbake_image package </code></pre> <p>8. Build JIC file: </p> <pre><code>cd $TOP_FOLDER rm -f *jic* *rbf* quartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof \\ \nghrd.jic \\ \n-o hps_path=gsrd_socfpga/stratix10-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\ \n-o device=MT25QU128 \\ \n-o flash_loader=1SX280HU2 \\ \n-o mode=ASX4 \\ \n-o hps=1 </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#run-example_1","title":"Run Example","text":"<p>1. Write QSPI image <code>$TOP_FOLDER/ghrd.hps.jic</code> </p> <p>2. Write SD card image <code>$TOP_FOLDER/gsrd_socfpga/stratix10-gsrd-images/gsrd-console-image-stratix10.wic</code> </p> <p>3. Power up board </p> <p>4. Log into Linux using 'root' as username, no password will be required. </p> <p>5. Apply the overlay: </p> <pre><code>root@stratix10:~# dtbt -a stratix10_fabric_config_overlay.dtbo -p /boot/devicetree Set dtbo search path to /boot/devicetree [ 116.946137] fpga_manager fpga0: writing ghrd.core.rbf to Stratix10 SOC FPGA Manager Applying dtbo: stratix10_fabric_config_overlay.dtbo [ 117.304564] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges [ 117.315044] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/firmware-name [ 117.326087] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/config-complete-timeout-us [ 117.338292] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/sysid_qsys_0 </code></pre> <p>6. List the applied overlays: </p> <pre><code>root@stratix10:~# dtbt -l 1 fabric_config_overlay.dtbo applied /sys/kernel/config/device-tree/overlays/1-fabric_config_overlay.dtbo\n</code></pre> <p>7. Locate the sysid in the sysfs: </p> <pre><code>root@stratix10:~# find / -name sysid /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid </code></pre> <p>8. Display the sysid id information: </p> <pre><code>root@stratix10:~# cat /sys/devices/platform/soc/soc:base_fpga_region/f9000000.sysid/sysid/id | xargs printf \"0x%08x\\n\" 0xacd5cafe </code></pre> <p>9. Remove the overlay: </p> <pre><code>root@stratix10:~# dtbt -r fabric_config_overlay.dtbo -p /boot/devicetree\nSet dtbo search path to /boot/devicetree\nRemoving dtbo: 1-fabric_config_overlay.dtbo\n</code></pre> <p>10. Confirm that the overlay was removed: </p> <pre><code>root@stratix10:~# dtbt -l </code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/fabric-config/ug-linux-fabric-config-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/","title":"Stratix\u00ae 10 SX SoC Development Kit GSRD User Guide","text":""},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#overview","title":"Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Intel Stratix 10 SX SoC Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul> <p>Note: This page and associated binaries refers to the current version of the board, with ordering code DK-SOC-1SSX-H-D, aka \"H-Tile\". There was an older version of this board, ordering code DK-SOC-1SSX-L-D, aka \"L-Tile\", which is now discontinued. See section Boot from SD Card on DK-SOC-1SSX-L-D for an example on how to update the GSRD to target the older board.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required in order to be able to fully exercise the S10 GSRD:</p> <ul> <li>Stratix 10 SoC Development Kit, ordering code DK-SOC-1SSX-H-D<ul> <li>4GB DDR4 HILO memory card</li> <li>SD/MMC HPS Daughtercard</li> <li>SDM QSPI Bootcard(MT25QU02G)</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel FPGA Download Cable II</li> <li>Micro SD card (4GB or greater)</li> </ul> </li> </ul> <ul> <li>Host PC with<ul> <li>Linux - Ubuntu 22.04 was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Micro SD card slot or Micro SD card writer/reader</li> <li>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3</li> <li>Local Ethernet network, with DHCP server (will be used to provide IP address to the board)</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#release-notes","title":"Release Notes","text":"<p>The Intel FPGA HPS Embedded Software release notes can be accessed from the following link: https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#prebuilt-binaries","title":"Prebuilt Binaries","text":"Binaries for SD Card Boot <p>The release files are accessible at https://releases.rocketboards.org/2024.11/gsrd/s10_htile_gsrd/</p> <p>The source code is also included on the SD card in the Linux rootfs path <code>/home/root</code>:</p> File Description linux-socfpga-v6.6.37-lts-src.tar.gz Source code for Linux kernel u-boot-socfpga-v2024.04-src.tar.gz Source code for U-Boot arm-trusted-firmware-v2.11.0-src.tar.gz Source code for Arm Trusted Firmware <p>Before downloading the hardware design please read the agreement in the link https://www.intel.com/content/www/us/en/programmable/downloads/software/license/lic-prog_lic.html</p> Binaries for NAND Boot <p>The release files are accessible at https://releases.rocketboards.org/2024.11/nand/s10_htile_nand/</p> Binaries for QSPI Boot <p>The release files are accessible at https://releases.rocketboards.org/2024.11/qspi/s10_htile_qspi/</p> <p>Note: To boot from QSPI is needed to remove SD card memory as SD Card memory has higher precedence in the boot order.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#component-versions","title":"Component Versions","text":"<p>Altera\u00ae Quartus\u00ae Prime Pro Edition Version 24.3 and the following software component versions are used to build the GSRD: </p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.3_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.37-lts QPDS24.3_REL_GSRD_PR Arm Trusted Firmware https://github.com/arm-trusted-firmware socfpga_v2.11.0 QPDS24.3_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.04 QPDS24.3_REL_GSRD_PR Yocto Project https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap latest Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.3_REL_GSRD_PR"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li> <p>Hard Processor System (HPS)</p> <ul> <li>Quad Arm Cortex-A53 MPCore Processor</li> <li>HPS Peripherals connected to Out-of-Box Experience (OOBE) Daughter Card:<ul> <li>Micro SD for HPS storage</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>I2C</li> <li>USB UART</li> <li>USB 2.0 OTG</li> <li>Two Push buttons and Three LEDs</li> </ul> </li> </ul> <ul> <li>Hard Memory Controller (HMC) for HPS External Memory Interface (EMIF)</li> </ul> </li> </ul> <ul> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>Three user LED outputs</li> <li>Four user DIP switch inputs</li> <li>Four user push-button inputs</li> <li>Interrupt Latency Counter</li> <li>System ID</li> </ul> </li> </ul> <ul> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <ul> <li>JTAG to Avalon Master Bridges connected to:<ul> <li>FPGA-to-SDRAM 0/\u00bd Interfaces</li> <li>FPGA-to-HPS AXI Bridge</li> </ul> </li> </ul> <p></p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#mpu-address-maps","title":"MPU Address Maps","text":"<p>This section presents the address maps as seen from the MPU (Cortex-A53) side.</p> HPS-to-FPGA Address Map <p>The MPU region provide windows of 4 GB into the FPGA slave address space. The lower 1.5 GB of this space is mapped to two separate addresses - firstly from 0x8000_0000 to 0xDFFF_FFFF and secondly from 0x20_0000_0000 to 0x20_5FFF_FFFF. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU (Cortex-A53), which starts at the lightweight HPS-to-FPGA base address of 0xF900_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0000_0000 8 Unique system ID led_pio 0x0000_1080 16 LED outputs button_pio 0x0000_1060 16 Push button inputs dipsw_pio 0x0000_1070 16 DIP switch inputs ILC 0x0000_1100 256 Interrupt latency counter (ILC)"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#jtag-master-address-map","title":"JTAG Master Address Map","text":"<p>There are two JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0000_0000 8 Unique system ID led_pio 0x0000_1080 16 LED outputs button_pio 0x0000_1060 16 Push button inputs dipsw_pio 0x0000_1070 16 DIP switch inputs ILC 0x0000_1100 256 Interrupt latency counter (ILC)"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#interrupt-routing","title":"Interrupt Routing","text":"<p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[0] 4 DIP switch inputs button_pio f2h_irq0[1] 4 Push button inputs <p>The interrupt sources are also connected to an interrupt latency counter (ILC) module in the system, which enables System Console to be aware of the interrupt status of each peripheral in the FPGA portion of the SoC.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#typical-hps-boot-flow","title":"Typical HPS Boot Flow","text":"<p>The GSRD boot flow includes the following stages:</p> <p>1. SDM</p> <p>2. U-Boot SPL</p> <p>3. ATF</p> <p>4. U-Boot</p> <p>5. Linux</p> <p>6. Application</p> <p></p> <p>The following table presents a short description of the different boot stages:</p> Stage Description SDM Secure Device Manager boots first U-Boot SPL Configures IO, FPGA, brings up SDRAM ATF Arm Trusted Firmware, provides SMC handler U-Boot Loads Linux kernel Linux Operating system Application User application <p>For more information, please refer to Intel Stratix 10 SoC Boot User Guide and Intel Stratix 10 Hard Processor System Technical Reference Manual (Booting and Configuration chapter).</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#exercise-prebuilt-gsrd","title":"Exercise Prebuilt GSRD","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p> <p>The following topics are  included:</p> <ul> <li>Configure the board and serial terminal</li> <li>Boot from SD Card</li> <li>Boot from QSPI</li> <li>Boot from NAND</li> <li>Partial Reconfiguration</li> </ul> <p>Most of the applications and features presented in the Boot from SD Card scenario are also available in the other scenarios.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#configure-board","title":"Configure Board","text":"<p>This section presents the necessary board settings in order to run the GSRD on the Intel FPGA Stratix 10 SoC development board.</p> <p></p> <p>First, confirm the following:</p> <ul> <li>DDR4 memory card is installed on HPS HiLo memory socket</li> <li>OOBE Daughter card is installed on HPS Daughter card socket</li> </ul> <p>Then the board switches need to be configured as follows:</p> <ul> <li>SW1: OFF-OFF-ON-ON-ON-ON-ON-ON</li> <li>SW2: ON-ON-ON (SW2.4 is not connected)</li> <li>SW3: All OFF</li> <li>SW4: ON-OFF-OFF-ON</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#configure-serial-connection","title":"Configure Serial Connection","text":"<p>The OOBE Daughter Card has a built-in FTDI USB to Serial converter chip that allows the host computer to see the board as a virtual serial port. Ubuntu and other modern Linux distributions have built-in drivers for the FTDI USB to Serial converter chip, so no driver installation is necessary on those platforms. On Windows, the SoC EDS Pro installer automatically installs the required drivers if necessary.</p> <p>The serial communication parameters are:</p> <ul> <li>Baud-rate: 115,200</li> <li>Parity: none</li> <li>Flow control: none</li> <li>Stop bits: 1</li> </ul> <p>On Windows, utilities such as TeraTerm and PuTTY can be used to connect to the board. They are easily configured from the tool menus.</p> <p>On Linux, the minicom utility can be used. Here is how to configure it:</p> <p>The virtual serial port is usually named /dev/ttyUSB0. In order to determine the device name associated with the virtual serial port on your host PC, please perform the following:</p> <ul> <li>Use the following command to determine which USB serial devices are already installed: ls /dev/ttyUSB*</li> <li>Connect mini USB cable from J7 to the PC. This will enable the PC to communicate with the board, even if the board is not powered yet.</li> <li>Use the ls /dev/ttyUSB* command command again to determine which new USB serial device appeared.</li> <li>Install minicom application on host PC, if not installed.</li> </ul> <ul> <li>On Ubuntu, use sudo apt-get install minicom</li> <li>Configure minicom.</li> </ul> <pre><code>$ sudo minicom -s\n</code></pre> <p>Under Serial Port Setup choose the following:</p> <ul> <li>Serial Device: /dev/ttyUSB0 (edit to match the system as necessary)</li> <li>Bps/Par/Bits: 115200 8N1</li> <li>Hardware Flow Control: No</li> <li>Software Flow Control: No</li> <li>Hit [ESC] to return to the main configuration menu</li> </ul> <p>Select Save Setup as dfl to save the default setup. Then select Exit.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>This section presents how to write the QSPI Flash and SD Card image files, configure the board and boot Linux.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-qspi-image","title":"Write QSPI Image","text":"<p>The QSPI JIC image contains the FPGA configuration bitstream, and the U-Boot SPL.</p> <p>1. Download and extract the image file:</p> <pre><code>wget https://releases.rocketboards.org/2024.11/gsrd/s10_htile_gsrd/ghrd_1sx280hu2f50e1vgas.jic.tar.gz\n\ntar xf ghrd_1sx280hu2f50e1vgas.jic.tar.gz\n</code></pre> <p>2. Configure MSEL to JTAG:</p> <ul> <li>SW2: ON-ON-ON (SW2.4 is not connected)</li> </ul> <p>3. Power cycle the board</p> <p>4. Write the image using the following commands:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_1sx280hu2f50e1vgas.jic\"\n</code></pre> <p>5. Configure MSEL back to QSPI:</p> <ul> <li>SW2: ON-OFF-OFF (SW2.4 is not connected)</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-sd-card-image","title":"Write SD Card Image","text":"<p>This section explains how to create the SD card necessary to boot Linux, using the SD card image available with the pre-built Linux binaries package. Once the SD card has been created, insert the card into the SD slot of the Micro SD daughter card.</p> Write SD Card on Linux <p>1. Download the SD card image from https://releases.rocketboards.org/2024.11/gsrd/s10_htile_gsrd/sdimage.tar.gz and extract it.</p> <p>The extacted file is named <code>gsrd-console-image-stratix10.wic</code>.</p> <p>2. Determine the device associated with the SD card on the host by running the following command before and after inserting the card.</p> <pre><code>$ cat /proc/partitions\n</code></pre> <p>Let's assume it is /dev/sdx.</p> <p>3. Use dd utility to write the SD image to the SD card.</p> <pre><code>$ sudo dd if=gsrd-console-image-stratix10.wic of=/dev/sdx bs=1M\n</code></pre> <p>Note we are using sudo to be able to write to the card.</p> <p>4. Use sync utility to flush the changes to the SD card.</p> <pre><code>$ sudo sync\n</code></pre> Write SD Card on Windows <p>1. Download the SD card image from https://releases.rocketboards.org/2024.11/gsrd/s10_htile_gsrd/sdimage.tar.gz and extract it.</p> <p>The extacted file is named <code>gsrd-console-image-stratix10.wic</code>.</p> <p>2. Rename the wic file as <code>sdcard.img</code></p> <p>3. Use Win32DiskImager to write the image to the SD card. The tool can be downloaded from https://sourceforge.net/projects/win32diskimager/files/latest/download</p> <p></p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-linux","title":"Boot Linux","text":"<p>This section presents how to boot Linux on the board. The required steps are:</p> <p>1. Start serial terminal (when using Minicom it will connect using the selected settings, for others connect manually).</p> <p>2. Power up the board.</p> <p>3. U-Boot SPL is ran</p> <p>4. U-Boot is ran</p> <p>5. Linux boots.</p> <p>6. Login using 'root' and no password.</p> <p>7. Run 'ifconfig' command to determine the IP of the board</p> <pre><code>root@stratix10:~# ifconfig\neth0: flags=4163 mtu 1500\ninet 192.168.1.48 netmask 255.255.255.0 broadcast 192.168.1.255\n inet6 fe80::d429:5dff:fe20:d6f4 prefixlen 64 scopeid 0x20\n ether d6:29:5d:20:d6:f4 txqueuelen 1000 (Ethernet)\nRX packets 57 bytes 9330 (9.1 KiB)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 57 bytes 8062 (7.8 KiB)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 21 base 0x2000\n\neth1: flags=4099 mtu 1500\nether 8a:c5:fe:e4:b5:97 txqueuelen 1000 (Ethernet)\nRX packets 0 bytes 0 (0.0 B)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 0 bytes 0 (0.0 B)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 22 base 0xc000\n\neth2: flags=4099 mtu 1500\nether 66:fd:43:7f:bc:66 txqueuelen 1000 (Ethernet)\nRX packets 0 bytes 0 (0.0 B)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 0 bytes 0 (0.0 B)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\ndevice interrupt 23 base 0xe000\n\nlo: flags=73 mtu 65536\ninet 127.0.0.1 netmask 255.0.0.0\n inet6 ::1 prefixlen 128 scopeid 0x10\n loop txqueuelen 1000 (Local Loopback)\nRX packets 100 bytes 8440 (8.2 KiB)\nRX errors 0 dropped 0 overruns 0 frame 0\nTX packets 100 bytes 8440 (8.2 KiB)\nTX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\n</code></pre> <p>Note: there are three network cards, one connected to the Ethernet port on the HPS Daughtercard, and two to the Ethernet ports on the DevKit, which are connected throgh SGMII.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#run-sample-applications","title":"Run Sample Applications","text":"<p>The GSRD includes a number of sample Linux applications that help demonstrate some of the features of the platform:</p> <ul> <li>Display Hello World message</li> <li>Control LEDs</li> <li>Detect interrupts from push buttons and DIP switches</li> </ul> <p>The sample applications can be used as a starting point for users to write their own applications that interact with software IP through Linux drivers.</p> Prerequisites <p>1. Boot Linux on the target board as described in Booting Linux. You will not need to use the serial terminal if you plan on using ssh connection.</p> <p>2. Connect to the board using one of the following options:</p> <ul> <li>Connect using serial console, as described in Booting Linux</li> <li>Connect using ssh, as described in Connect Using SSH</li> </ul> <p>3. In serial console, or ssh client console, change current folder to be /home/root/intelFPGA. This is where the application binaries are stored.</p> <pre><code>root@stratix10:~# cd /home/root/intelFPGA/\n</code></pre> Display Hello World Message <p>Run the following command to display the Hello World message on the console:</p> <pre><code>root@stratix10:~/intelFPGA# ./hello\nHello SoC FPGA!\n</code></pre> Exercise Soft PIO Driver for LED Control <p>The following LEDs are exercised:</p> User FPGA LED Number Corresponding Board LED 0 D21 1 D23 2 D25 <p>Note: User FPGA LED #3 / D27 is quickly blinking, and cannot be controlled from software.</p> <p>1. In order to blink an LED in a loop, with a specific delay in ms, run the following command:</p> <pre><code>./blink &lt;led_number&gt; &lt;delay_ms&gt;\n</code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The delay_ms is a number that specifies the desired delay in ms between turning the LED on and off.</li> </ul> <p>2. In order to turn an individual LED on or off, run the following command:</p> <pre><code>./toggle &lt;led_number&gt; &lt;state&gt;\n</code></pre> <ul> <li>The led_number specifies the desired LED, and is a value between 0 and 3.</li> <li>The state needs to be 0 to turn the LED off, and 1 to turn the LED on.</li> </ul> <p>3. In order to scroll the FPGA LEDs with a specific delay, please run the following command:</p> <pre><code>./scroll_client &lt;delay&gt;\n</code></pre> <p>The delay specifies the desired scrolling behavior:</p> <ul> <li>delay &gt; 0 - specify new scrolling delay in ms, and start scrolling</li> <li>delay &lt; 0 - stop scrolling</li> <li>delay = 0 - display current scroll delay</li> </ul> System Check Application <p>System check application provides a glance of system status of basic peripherals such as:</p> <ul> <li>USB: USB device driver</li> <li>Network IP (IPv4): Network IP address</li> <li>HPS LEDs: HPS LED state</li> <li>FPGA LEDs: FPGA LED state</li> </ul> <p>Run the application by issuing the following command:</p> <pre><code>root@stratix10:~/intelFPGA# ./syschk\n</code></pre> <p>The window will look as shown below - press 'q' to exit:</p> <pre><code> ALTERA SYSTEM CHECK\n\nIPv4 Address : 192.168.1.48 usb1 : DWC OTG Controller\n\nfpga_led2 : OFF serial1@ffc02100 : disabled\nhps_led2 : OFF serial0@ffc02000 : okay\nfpga_led0 : OFF\nhps_led0 : OFF\nfpga_led3 : OFF\nfpga_led1 : OFF\nhps_led1 : OFF\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#register-interrupts","title":"Register Interrupts","text":"<p>The following are exercised:</p> <ul> <li>User FPGA DIP switches<ul> <li>SW3.1</li> <li>SW3.2</li> <li>SW3.3</li> <li>SW3.4</li> </ul> </li> </ul> <ul> <li>User FPGA push buttons<ul> <li>0: S4</li> <li>1: S5</li> <li>2: S6</li> <li>3: S7</li> </ul> </li> </ul> <p>In order to register an interrupt handler to a specific GPIO, you will first need to determine the GPIO number used.</p> <p>1. Open the Linux Device Tree socfpga_stratix10_qse_pcie_sgmii_ghrd.dtsi file and look up the labels for the DIP switches and Push button GPIOs:</p> <pre><code> button_pio: gpio@f9001060 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0xf9001060 0x10&gt;;\ninterrupt-parent = &lt;&amp;intc&gt;;\ninterrupts = &lt;0 18 4&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;2&gt;;\naltr,interrupt_type = &lt;2&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\ndipsw_pio: gpio@f9001070 {\ncompatible = \"altr,pio-1.0\";\nreg = &lt;0xf9001070 0x10&gt;;\ninterrupt-parent = &lt;&amp;intc&gt;;\ninterrupts = &lt;0 17 4&gt;;\naltr,gpio-bank-width = &lt;4&gt;;\naltr,interrupt-type = &lt;3&gt;;\naltr,interrupt_type = &lt;3&gt;;\n#gpio-cells = &lt;2&gt;;\ngpio-controller;\n};\n</code></pre> <p>2. Run the following to determine the GPIO numbers for the DIP switches</p> <pre><code>root@stratix10:~/intelFPGA# grep -r \"gpio@f9001070\" /sys/class/gpio/gpiochip*/label\n/sys/class/gpio/gpiochip1928/label:/soc/gpio@f9001070\n</code></pre> <p>This means that the GPIOs 1928 .. 1931 are allocated to the DIP switches (there are 4 of them).</p> <p>3. Run the followinig to determine the GPIO numbers for the pushbuttons</p> <pre><code>root@stratix10:~/intelFPGA# grep -r \"gpio@f9001060\" /sys/class/gpio/gpiochip*/label\n/sys/class/gpio/gpiochip1960/label:/soc/gpio@f9001060\n</code></pre> <p>This means that the GPIOs 1960 \u2026 1963 are allocated to the push buttons (there are 4 of them).</p> <p>4. Register interrupt for one of the dipswiches, using the appropriate GPIO number, as determined in a previous step:</p> <pre><code>root@stratix10:~/intelFPGA# modprobe gpio_interrupt gpio_number=1928 intr_type=3\n[ 1090.973366] Interrupt for GPIO:1928\n[ 1090.973366] registered\n</code></pre> <p>5. Toggle the dipswitch a few times, you will see messages from the interrupt handler</p> <pre><code>[ 1096.537830] Interrupt happened at gpio:1928\n[ 1096.547744] Interrupt happened at gpio:1928\n[ 1098.736386] Interrupt happened at gpio:1928\n[ 1098.740482] Interrupt happened at gpio:1928\n</code></pre> <p>6. Remove the driver</p> <pre><code>root@stratix10:~/intelFPGA# rmmod gpio_interrupt\n</code></pre> <p>7. Register the pushbutton interrupt, using the appropriate GPIO number as determine on a previous step</p> <pre><code>rroot@stratix10:~/intelFPGA# modprobe gpio_interrupt gpio_number=1960 intr_type=2\n[ 1138.025297] Interrupt for GPIO:1960\n[ 1138.025297] registered\n</code></pre> <p>8. Push the pusbutton a few times, you will see interrupt handler messages</p> <pre><code>[ 1141.672192] Interrupt happened at gpio:1960\n[ 1142.110673] Interrupt happened at gpio:1960\n[ 1142.499468] Interrupt happened at gpio:1960\n[ 1142.884199] Interrupt happened at gpio:1960\n</code></pre> <p>9. Once done, remove the handler</p> <pre><code>root@stratix10:~/intelFPGA# rmmod gpio_interrupt\n</code></pre> <p>Note: If you are on the ssh console, you will need to run the program dmesg after pressing the button in order to see the messages:</p> <pre><code>root@stratix10:~/intelFPGA# dmesg\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#connect-to-web-server","title":"Connect to Web Server","text":"<p>The GSRD includes a web server running on the target board that can be used to exercise some of the board features:</p> <ul> <li>Turning LEDs ON and OFF</li> <li>Scrolling LEDs in a sequence</li> <li>Displaying the current status of the LEDs</li> </ul> <p>The web page served by the web server also contains links to some relevant information on the Intel website.</p> <p>Perform the following steps to connect to the board web server:</p> <p>1. Boot Linux as described in Booting Linux.</p> <p>2. Determine the IP address of the board using 'ifconfig' as shown above. Note there will be three network interfaces, you can use anyone which is connected to the local network and gets an IP from the DHCP server.</p> <p>Note: There are instances where the DHCP have not assigned an IP to the board before the timeout happens, in which case you may check the IP address via the UART by running ifconfig.</p> <p>3. Open a web browser on the host PC and type http:// on the address box, then type the IP of your board and hit Enter.</p> <p></p> <p>4. Scroll the webpage down to the section named Interacting with Stratix 10 SoC Development Kit.</p> <p></p> <p>You will be able to perform the following actions:</p> <ul> <li>See which LEDs are ON and which are off in the LED Status. Note that if the LEDs are setup to be scrolling, the displayed scrolling speed will not match the actual scrolling speed on the board.</li> <li>Stop LEDs from scrolling, by clicking START and STOP buttons. The delay between LEDs turning ON and OFF is set in the LED Lightshow box.</li> <li>Turn individual LEDs ON and OFF with the ON and OFF buttons. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> <li>Blink individual LEDs by typing a delay value in ms then clicking the corresponding BLINK button. Note that this action is only available when the LED scrolling/lightshow is stopped.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#connect-using-ssh","title":"Connect Using SSH","text":"<p>1. The lower bottom of the web page presents instructions on how to connect to the board using an SSH connection.</p> <p></p> <p>2. If the SSH client is not installed on your host computer, you can install it by running the following command on CentOS:</p> <pre><code>$ sudo yum install openssh-clients\n</code></pre> <p>or the following command on Ubuntu:</p> <pre><code>$ sudo apt-get install openssh-client\n</code></pre> <p>3. Connect to the board, and run some commands, such as pwd, ls and uname to see Linux in action.</p> <pre><code>radu@ubuntu:~$ ssh root@192.168.1.48\nThe authenticity of host '192.168.1.40 (192.168.1.40)' can't be established.\nECDSA key fingerprint is SHA256:fTZa4u/xMgLj7LB0YbeVG0qDumxD2yKCLPsObHqcVXQ.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added '192.168.1.40' (ECDSA) to the list of known hosts.\nLast login: Wed Jan 25 22:12:53 2023\nroot@stratix10:~# pwd\n/home/root\nroot@stratix10:~# ls\nREADME linux-socfpga-v5.15.70-lts-src.tar.gz\narm-trusted-firmware-v2.7-src.tar.gz u-boot-socfpga-v2022.07-src.tar.gz\nintelFPGA\nroot@stratix10:~# uname -a\nLinux stratix10 5.15.70-altera #1 SMP PREEMPT Thu Dec 15 08:50:33 UTC 2022 aarch64 GNU/Linux\nroot@stratix10:~#\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section presents how to boot HPS from QSPI. In this scenario, in addition to the initial FPGA configuration bitstream and the HPS FSBL, the QSPI also contains the rest of the HPS software: U-Boot, Linux and Linux rootfs.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-qspi-image_1","title":"Write QSPI Image","text":"<p>1. Configure MSEL to JTAG:</p> <ul> <li>SW2: ON-ON-ON (SW2.4 is not connected)</li> </ul> <p>2. Power cycle the board</p> <p>3. Retrieve the QSPI image from the prebuilt location:</p> <p>4. Write the image using the following commands:</p> <pre><code>quartus_pgm -c 1 -m jtag -o \"pvi;flash_image.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-linux_1","title":"Boot Linux","text":"<p>1. Configure MSEL back to QSPI:</p> <ul> <li>SW2: ON-OFF-OFF (SW2.4 is not connected)</li> </ul> <p>2. Important! Remove SD card, otherwise U-Boot may try to boot from it.</p> <p>3. Power cycle. Board will boot up to Linux prompt, where you can login as 'root' without a password.</p> <p>Note: First time Linux is booted, the UBIFS rootfs will be initialized, the step taking approximately 3 minutes, as shown in the log below:</p> <pre><code>[ 12.523260] platform soc:leds: deferred probe pending\n \u2026 3 minute 'gap' here ...\n[ 205.105071] UBIFS (ubi0:4): free space fixup complete\n[ 205.234501] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[ 205.241896] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[ 205.251273] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size 8650240 bytes (8 MiB, 133 LEBs)\n</code></pre> <p>On the first boot empty pages are identifies and erased, to ensure all pages are 0xFF and avoid problematic non-0xFF empty page. This is controlled by the \"-F\" parameter passed when creating the rootfs.ubifs image. The next boots will not have this this step. Refer to http://www.linux-mtd.infradead.org/faq/ubifs.html for more details.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-nand","title":"Boot from NAND","text":"<p>This section presents how to exercise the boot from NAND scenario for the GSRD.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#nand-daughtercard","title":"NAND Daughtercard","text":"<p>The NAND/eMMC HPS daughtercard that comes with the S10 SoC DevKit supports both NAND and eMMC.</p> <p>To configure the card for NAND operation, please set the jumpers as shown below:</p> Jumper Setting J2 unpopulated J9 unpopulated J10 populated 2-3 J11 populated 1-1 <p>For reference, the NAND/eMMC schematic is available at https://www.intel.com/content/dam/altera-www/global/en_US/support/boards-kits/arria10/soc/hps_io48_nand_dc.pdf.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-nand-binaries","title":"Write NAND Binaries","text":"<p>1. Copy files to your TFTP server folder:</p> <pre><code>cp -f $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot.itb&lt;your-tftp-server-folder&gt;\ncp -f $TOP_FOLDER/nand-bin/root.ubi &lt;your-tftp-server-folder&gt;\n</code></pre> <p>2. Run U-Boot with the debugger, similar to how it is described at https://rocketboards.org/foswiki/Documentation/BuildingBootloader#Stratix_10_SOC_45_Run_U_45Boot_from_Debugger just change the script to use the binaries directly from <code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/</code>.</p> <p>3. Stop at U-Boot prompt, and run the following instructions to download and write NAND binaries to flash:</p> <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your-tftp-server-ip&gt;\n\ntftp $loadaddr u-boot.itb\nnand erase.part u-boot\nnand write $loadaddr u-boot $filesize\ntftp $loadaddr root.ubi\nnand erase.part clean root\nnand write.trimffs $loadaddr root $filesize\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#write-qspi-image_2","title":"Write QSPI Image","text":"<p>1. Power off board</p> <p>2. Set MSEL to JTAG</p> <p>3. Power on board</p> <p>4. Write jic image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_1sx280hu2f50e1vgas.hps.jic\"\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-linux_2","title":"Boot Linux","text":"<p>1. Power off the board. Make sure MSEL is set to QSPI.</p> <p>2. Power on the board.</p> <p>3. Linux will boot, use 'root' as username, with no password.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#partial-reconfiguration","title":"Partial Reconfiguration","text":"<p>Partial reconfiguration (PR) allows you to reconfigure a portion of the FPGA dynamically, while the rest of the FPGA design continues to function. This section presents how to run the PR scenarios included with the GSRD.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#reference-information","title":"Reference Information","text":"<p>Refer to the following fore more details about Partial Reconfiguration</p> <ul> <li>User Guide<ul> <li>Intel Quartus Prime Pro Edition User Guide: Partial Reconfiguration</li> </ul> </li> </ul> <ul> <li>Partial Reconfiguration for Intel FPGA Devices YouTube videos:<ul> <li>Part1: Introduction &amp; Project Assignments</li> <li>Part2: Design Guidelines &amp; Host Requirements</li> <li>Part3: PR Host IP &amp; Implementations</li> <li>Part4: Output Files &amp; Demonstration</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#hardware-design","title":"Hardware Design","text":"<p>The GHRD contains the following components which enable PR:</p> <ul> <li>A PR region was created in the FPGA fabric, with the following associated IP<ul> <li>PR Freeze Controller - to help control the PR</li> <li>Avalon-MM PR Freeze Bridge - to help isolate the IP in the PR region during the PR process</li> </ul> </li> </ul> <ul> <li>The base revision of the project has the following in the PR region:<ul> <li>SysID located at 0xF900_0800: with id=0xfacecafe</li> <li>OCRAM located at 0xF900_0900</li> </ul> </li> </ul> <ul> <li>An alternate revision of the project contains the following in the PR region:<ul> <li>SysID located at 0xF900_0900: with id=0xcafeface</li> <li>OCRAM located at 0xF900_0800</li> </ul> </li> </ul> <p>The following diagram presents an overview of the PR region and associated IP and how it is connected to HPS:</p> <p></p> <p>Throughout this page, the content of the PR region for the base revision is called \"persona0\" while the content of the PR region for the other revision is called \"persona1\". The diagram below illustrates the differences between the two personas:</p> <p></p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#pr-files","title":"PR Files","text":"<p>The files on the Linux rootfs used for running the PR scenarios are shown below:</p> File Description /sbin/dtbt Tool used for managing the overlays. Available at https://github.com/altera-opensource/dtbt /boot/devicetree/stratix10_htile_pr_fpga_static_region.dtbo overlay for the static region, needs to be applied before persona overlays /boot/devicetree/stratix10_htile_pr_persona0.dtbo overlay for persona0 /boot/devicetree/stratix10_htile_pr_persona1.dtbo overlay for persona1 /lib/firmware/persona0.rbf bitstream used by persona0 overlay /lib/firmware/persona1.rbf bitstream used by persona1 overlay <p>The DTS files for the overlays are available at https://github.com/altera-opensource/meta-intel-fpga-refdes/tree/scarthgap/recipes-bsp/device-tree/files:</p> <ul> <li>stratix10_htile_pr_fpga_static_region.dts</li> <li>stratix10_htile_pr_persona0.dts</li> <li>stratix10_htile_pr_persona1.dts</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#running-pr-scenarios","title":"Running PR Scenarios","text":"<p>1. Boot Linux</p> <p>2. Add the overlay for the static region:</p> <pre><code>root@stratix10:~# dtbt -a stratix10_htile_pr_fpga_static_region.dtbo -p /boot/devicetree\nSet dtbo search path to /boot\nApplying dtbo: fpga_static_region.dtbo\n[ 141.686353] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/ranges\n[ 141.698256] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/external-fpga-config\n[ 141.709907] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/clocks\n[ 141.720335] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /soc/base_fpga_region/clock-names\n[ 141.731276] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/clk_0\n[ 141.740852] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/freeze_controller_0\n[ 141.756396] of-fpga-region soc:base_fpga_region:fpga_pr_region0: FPGA Region probed\n[ 141.780483] altera_freeze_br f9000450.freeze_controller: fpga bridge [freeze] registered\n</code></pre> <p>3. Add the overlay for persona0:</p> <pre><code>root@stratix10:~# dtbt -a stratix10_htile_pr_persona0.dtbo -p /boot/devicetree\nSet dtbo search path to /boot\nApplying dtbo: persona0.dtbo\n[ 190.741610] fpga_manager fpga0: writing persona0.rbf to Stratix10 SOC FPGA Manager\n[ 191.251227] svc_normal_to_secure_thread: STATUS_ERROR\n[ 191.251871] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_clk_100\n[ 191.266963] svc_normal_to_secure_thread: STATUS_ERROR\n[ 191.267349] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_sysid_qsys_0\n[ 191.282704] svc_normal_to_secure_thread: STATUS_ERROR\n</code></pre> <p>4. Locate the sysid and display the associated id:</p> <pre><code>root@stratix10:~# find / -name sysid\n/sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000800.sysid/sysid\nroot@stratix10:~# cat /sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000800.sysid/sysid/id | xargs printf \"0x%08x\\n\"\n0xcafeface\n</code></pre> <p>5. List the applied overlays:</p> <pre><code>root@stratix10:~# dtbt -l\n2 persona0.dtbo applied /sys/kernel/config/device-tree/overlays/2-persona0.dtbo\n1 fpga_static_region.dtbo applied /sys/kernel/config/device-tree/overlays/1-fpga_static_region.dtbo\n</code></pre> <p>6. Remove persona0 overlay:</p> <pre><code>root@stratix10:~# dtbt -r stratix10_htile_pr_persona0.dtbo -p /boot/devicetree\nSet dtbo search path to /boot\nRemoving dtbo: 2-persona0.dtbo\n</code></pre> <p>7. Add the persona1 overlay:</p> <pre><code>root@stratix10:~# dtbt -a stratix10_htile_pr_persona1.dtbo -p /boot/devicetree\nSet dtbo search path to /boot\nApplying dtbo: persona1.dtbo\n[ 343.885073] fpga_manager fpga0: writing persona1.rbf to Stratix10 SOC FPGA Manager\n[ 344.385019] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_clk_100\n[ 344.396098] OF: overlay: WARNING: memory leak will occur if overlay removed, property: /__symbols__/pr_region_0_pr_sysid_qsys_0\n</code></pre> <p>8. Locate the sysid and display the associated id:</p> <pre><code>root@stratix10:~# find / -name sysid\n/sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000900.sysid/sysid\nroot@stratix10:~# cat /sys/devices/platform/soc/soc:base_fpga_region/soc:base_fpga_region:fpga_pr_region0/f9000900.sysid/sysid/id | xargs printf \"0x%08x\\n\"\n0xfacecafe\n</code></pre> <p>9. Remove persona1:</p> <pre><code>root@stratix10:~# dtbt -r stratix10_htile_pr_persona1.dtbo -p /boot/devicetree\nSet dtbo search path to /boot\nRemoving dtbo: 2-persona1.dtbo\n</code></pre> <p>10. List the applied overlays:</p> <pre><code>root@stratix10:~# dtbt -l\n1 fpga_static_region.dtbo applied /sys/kernel/config/device-tree/overlays/1-fpga_static_region.dtbo\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#rebuild-the-gsrd","title":"Rebuild the GSRD","text":"<p>This section presents how to rebuild the GSRD for various scenarios covered by this release.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-sd-card_1","title":"Boot from SD Card","text":""},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-flow","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf stratix10_gsrd\nmkdir stratix10_gsrd\ncd stratix10_gsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-hardware-design","title":"Build Hardware Design","text":"<pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga s10_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd s10_soc_devkit_ghrd\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\nunset QUARTUS_DEVICE\ncd ..\n</code></pre> <p>The following files are created in $TOP_FOLDER/s10_soc_devkit_ghrd/output_files:</p> <ul> <li>ghrd_1sx280hu2f50e1vgas.sof - FPGA SOF file, without HPS FSBL</li> <li>ghrd_1sx280hu2f50e1vgas_hps_debug.sof - FPGA SOF, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-core-rbf","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas_hps_debug.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_1sx280hu2f50e1vgas.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-yocto","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. stratix10_htile-gsrd-build.sh\nbuild_setup\n</code></pre> <pre><code>cd $TOP_FOLDER/gsrd_socfpga\n. ./poky/oe-init-build-env stratix10-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#customize-yocto","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>stratix10_htile_gsrd_ghrd.core.rbf</li> <li>stratix10_htile_pr_persona0.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_htile_pr_persona1.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_htile_nand_ghrd.core.rbf: not applicable, as we have not rebuilt the NAND version</li> </ul> <p>This can be accomplished using the following instructions:</p> <pre><code>GHRD_LOC=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files\nCORE_RBF=$GHRD_LOC/stratix10_htile_gsrd_ghrd.core.rbf\ncp $TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf $CORE_RBF\n</code></pre> <p>2. Update the Yocto recipe at <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> to change the <code>SRC_URI:stratix10</code> from the orginal value:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n${GHRD_REPO}/stratix10_htile_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core \\\n${GHRD_REPO}/stratix10_htile_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n \"\n</code></pre> <p>to be:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n file://stratix10_htile_gsrd_ghrd.core.rbf \\\n${GHRD_REPO}/stratix10_htile_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands from the console:</p> <pre><code>OLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_htile_gsrd_\\${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core\"\nNEW_CORE_URI=\"file:\\/\\/stratix10_htile_gsrd_ghrd.core.rbf\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\n</code></pre> <p>Note we have left the PR and NAND files alone, that will be downloaded from rocketboards.</p> <p>3. Update the same Yocto recipe to change the SHA checksums for the new files:</p> <pre><code>SRC_URI[stratix10_htile_gsrd_core.sha256sum] = \"ea26a77ebc1b3141193de6dd32e22f332785e05c956de85118c3790392141d3c\"\n</code></pre> <p>to the new values using the following commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nOLD_CORE_SHA=\"SRC_URI\\[stratix10_htile_gsrd_core\\.sha256sum\\] = .*\"\nNEW_CORE_SHA=\"SRC_URI[stratix10_htile_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\"\nsed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li> <p>fit_kernel_stratix10.its - its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD and NAND board configurations</li> <li>Core RBF files for SD and NAND board configurations</li> <li>Board configurations for SD and NAND cases</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>stratix10_htile_gsrd_rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>stratix10_htile_gsrd_images</code>: the build script copies here relevant files built by Yocto from the <code>stratix10_htile_gsrd_rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-qspi-image","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o hps_path=gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric. We already have the same file on the SD card.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-qspi_1","title":"Boot from QSPI","text":"<p>This section presents how to boot the Stratix 10 SoC from QSPI, using the rebuilt GSRD binaries.</p> <p>The same binaries as when booting from SD card can be used to boot from QSPI, because:</p> <ul> <li>The QSPI resides on the DevKit board, and not on the HPS daughtercard, so there are no board changes:</li> <li>The same GHRD configuration can be used</li> <li>The same U-Boot devce tree can be used</li> <li>The same Linux device tree can be used</li> <li>U-Boot uses distroboot, which will try first booting from SD/MMC, then from QSPI, then from NAND, so the same U-Boot can be used.</li> </ul> <p>Note: As the QSPI has a much smaller size than the SD card (256MB vs 2GB) the rootfs is smaller, and less functionality is provided. The purpose of this section is just to show Linux booting.</p> <p>Note: The HPS speed for accessing SDM QSPI is limited to ~4MB/s. It is up to you to decide whether this level of performance is sufficient for your application. If not, it is recommended you use an SD card or eMMC device to store the HPS components such as the rootfs. Note that the QSPI speed limitation does not apply when SDM accesses the QSPI, it is just for HPS accessing SDM QSPI.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#qspi-flash-layout","title":"QSPI Flash Layout","text":"MTD PartitionUBI VolumeVolume NameTypeImage/FileSize 0 (bitstream &amp; uboot)N/AN/ARAWbitstream (FPGA image, SDM firmware)64MB N/AN/ARAWu-boot.itb2MB 1 (root.ubi)0envUBIu-boot.env256KB 1scriptUBIu-boot.scr128KB 2kernelUBIkernel.itb24MB 3dtbUBIkernel.dtb256KB 4rootfsUBIFSrootfs.ubifs160MB"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-qspi-image_1","title":"Create QSPI Image","text":"<p>1. Create a folder to contain all the qspi binaries, and create symlinks to actual location for all files:</p> <pre><code>cd $TOP_FOLDER\nrm -rf qspi-boot &amp;&amp; mkdir qspi-boot &amp;&amp; cd qspi-boot\nln -s $TOP_FOLDER/s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof fpga.sof\nln -s $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex spl.hex\nln -s $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/console-image-minimal-stratix10_nor.ubifs rootfs.ubifs\n</code></pre> <p>2. Create U-Boot image:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncp $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>4. Create hps.ubi file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\ncat &lt;&lt;EOT &gt;ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOT\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>5. Create the QSPI image using the provided Quartus Programming File Generator (PFG) file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/gsrd/collateral/stratix10_gsrd.pfg\nquartus_pfg -c stratix10_gsrd.pfg\n</code></pre> <p>The following files will be generated:</p> <ul> <li>$TOP_FOLDER/qspi-boot/flash_image.hps.jic - JIC QSPI flash image</li> <li>$TOP_FOLDER/qspi-boot/s10_flash_image.core.rbf - fabric configuration file, already generated previously with the debug HPS FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-programming-file-generator-file","title":"Create Programming File Generator File","text":"<p>This section presents how to manually re-create the PFG file provided at https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/gsrd/collateral/stratix10_gsrd.pfg</p> <p>1. Start Quartus Programming File Generator GUI:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nqpfgw &amp;\n</code></pre> <p>2. In PFG Output Files tab:</p> <ul> <li>Select Device Family as \"Stratix 10\"</li> <li>Select Configuration Mode as \"Active Serial x4\"</li> <li>Edit Name as \"flash_image\"</li> <li>Check Raw Binary File for HPS Core Configuration (.rbf) option</li> <li>Check the following sub-options:</li> <li>Check JTAG Indirect Configuration File (.jic)</li> <li>Check Memory Map File (.map)</li> </ul> <p></p> <p>3. In PFG Input Files tab:</p> <ul> <li>Click Add Bitstream\", then browse to \"fpga.sof\" link, and add click *Open to add it.</li> <li>Click Bitstream_1&gt;fpga.sof then click Properties the click HPS Bootloader, browse to \"spl.hex\" then click Open to add it.  Note: By the time the fpga.sof file is read the following error is displayed, this was addressed by adding the spl.hex file to the Bitstream:   File fpga.sof is incomplete- HPS is present but bootloader information is missing.</li> <li>Click Add Raw Data then change the extension filter to .bin then browse to \"u-boot.bin\" and click Open to add it.</li> <li>Click on the \"u-boot.bin\" then click \"Properties\" then select Bit swap option to \"On\"</li> <li>Repeat the above 2 steps for the following file:</li> <li>hps.bin</li> </ul> <p>The Input Files tab will now look something like this:</p> <p></p> <p>4. In the PFG Configuration Device tab:</p> <ul> <li>Click Add Device, select the Micron MT25QU02G device then click Add</li> <li>Click the MT25QU02G device, then click Add Partition, select the options as following then click OK:</li> </ul> <p></p> <ul> <li>Click the MT25QU02G device, then click Add Partition, select the options as following then click OK:</li> </ul> <p></p> <ul> <li>Repeat the above step for the rest of binary files, choosing the following offsets:</li> <li>hps: 0x04200000</li> <li>Click Flash Loader &gt; Select then browse to the device used on the devkit then click OK:</li> </ul> <p></p> <p>The Configuration Device tab will now look something like this:</p> <p></p> <p>3. Go to File &gt; Save As and save the configuration file as \"s10_flash_image_qspi.pfg\".</p> <p>4. [Optional] Open the file \"stratix10_gsrd.pfg\" with a text editor and change absolute paths to relative paths.</p> <p>The file will look like this:</p> <pre><code>&lt;pfg version=\"1\"&gt;\n&lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n&lt;output_files&gt;\n&lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n&lt;file_options/&gt;\n&lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n&lt;file_options/&gt;\n&lt;/secondary_file&gt;\n&lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n&lt;/output_file&gt;\n&lt;/output_files&gt;\n&lt;bitstreams&gt;\n&lt;bitstream id=\"Bitstream_1\"&gt;\n&lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n&lt;/bitstream&gt;\n&lt;/bitstreams&gt;\n&lt;raw_files&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n&lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n&lt;/raw_files&gt;\n&lt;flash_devices&gt;\n&lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n&lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x000FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"u-boot\" size=\"0\"/&gt;\n&lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"hps\" size=\"0\"/&gt;\n&lt;/flash_device&gt;\n&lt;flash_loader&gt;1SX280HU2&lt;/flash_loader&gt;\n&lt;/flash_devices&gt;\n&lt;assignments&gt;\n&lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n&lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"0\" partition_id=\"u-boot\"&gt;\n&lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;assignment page=\"0\" partition_id=\"hps\"&gt;\n&lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n&lt;/assignment&gt;\n&lt;/assignments&gt;\n&lt;/pfg&gt;\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-nand_1","title":"Boot from NAND","text":"<p>This section presents how to boot the Stratix 10 SoC from NAND, including how to build all binaries.</p> <p>Build instructions are the same as for standard SD or QSPI boot. The U-Boot, ATF and Linux binaries are all the same. The only differences are:</p> <ul> <li>GHRD is configured for the NAND HPS Daughtercard, then recompiled</li> <li>The PR persona.rbf files are the ones compiled by the GHRD configured for NAND</li> </ul> <p>Note: As the NAND used on the devkit has a smaller size than the SD card (1GB vs 2GB) the rootfs is smaller, and less functionality is provided. The purpose of this section is just to show Linux booting.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#nand-flash-layout","title":"NAND Flash Layout","text":"MTD PartitionUBI VolumeVolume NameTypeImage/FileFlash OffsetSizeSize in Hex 0 (u-boot)N/AN/ARAWu-boot.itb0x000000002MB0x00200000 1 (root.ubi)0envUBIu-boot.env0x00200000256KB0x40000 1scriptUBIu-boot.scr0x00240000128KB0x0020000 2kernelUBIkernel.itb0x00260000 onwards64MB0x04000000 3dtbUBIkernel.dtb256KB0x0004000 4rootfsUBIFSrootfs.ubifs&lt;957MB&lt;0x3BD70000"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-environment_1","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf stratix10_gsrd.nand\nmkdir stratix10_gsrd.nand\ncd stratix10_gsrd.nand\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-hardware-design_1","title":"Build Hardware Design","text":"<p>Build the GHRD targeting the NAND HPS daughtercard, by passing the correct parameter to the make utility:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga s10_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd s10_soc_devkit_ghrd\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\nexport DAUGHTER_CARD=devkit_dc_nand\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\nunset QUARTUS_DEVICE\nunset DAUGHTER_CARD\ncd ..\n</code></pre> <p>The following files are created in $TOP_FOLDER/s10_soc_devkit_ghrd/output_files:</p> <ul> <li>ghrd_1sx280hu2f50e1vgas.sof - FPGA SOF file, without HPS FSBL</li> <li>ghrd_1sx280hu2f50e1vgas_hps_debug.sof - FPGA SOF, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-core-rbf_1","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas_hps_debug.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_1sx280hu2f50e1vgas.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf</code> - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-yocto_1","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. stratix10_htile-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up again the yocto build environments, if you closed the current window (for example when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd_socfpga\n. ./poky/oe-init-build-env stratix10-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#customize-yocto_1","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>stratix10_htile_gsrd_ghrd.core.rbf: not applicable, as we have not rebuilt the standard GSRD version supporting SD card in this case</li> <li>stratix10_htile_pr_persona0.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_htile_pr_persona1.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_htile_nand_ghrd.core.rbf</li> </ul> <p>This can be accomplished using the following instructions:</p> <pre><code>GHRD_LOC=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files\nCORE_RBF=$GHRD_LOC/stratix10_htile_nand_ghrd.core.rbf\ncp $TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf $CORE_RBF\n</code></pre> <p>2. Update the Yocto recipe at <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> to change the <code>SRC_URI:stratix10</code> from the orginal value:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n${GHRD_REPO}/stratix10_htile_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core \\\n${GHRD_REPO}/stratix10_htile_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n \"\n</code></pre> <p>to be:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n${GHRD_REPO}/stratix10_htile_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core \\\n file://stratix10_htile_nand_ghrd.core.rbf \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands from the console:</p> <pre><code>OLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_htile_nand_\\${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core\"\nNEW_CORE_URI=\"file:\\/\\/stratix10_htile_nand_ghrd.core.rbf\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\n</code></pre> <p>Note we have left the NAND file alone, that will be downloaded from rocketboards.</p> <p>3. Update the same Yocto recipe to change the SHA checksums for the new files:</p> <pre><code>SRC_URI[stratix10_htile_gsrd_core.sha256sum] = \"ea26a77ebc1b3141193de6dd32e22f332785e05c956de85118c3790392141d3c\"\nSRC_URI[stratix10_htile_nand_core.sha256sum] = \"d782c05085f8f13cb792b687fd002773e0897e4d7ecf5451994b1823d62cdc92\"\n</code></pre> <p>to the new values using the following commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nOLD_CORE_SHA=\"SRC_URI\\[stratix10_htile_nand_core\\.sha256sum\\] = .*\"\nNEW_CORE_SHA=\"SRC_URI[stratix10_htile_nand_core.sha256sum] = \\\"$CORE_SHA\\\"\"\nsed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li> <p>fit_kernel_stratix10.its - its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD and NAND board configurations</li> <li>Core RBF files for SD and NAND board configurations</li> <li>Board configurations for SD and NAND cases</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-yocto_1","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>stratix10_htile_gsrd_rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>stratix10_htile_gsrd_images</code>: the build script copies here relevant files built by Yocto from the <code>stratix10_htile_gsrd_rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images</code> folder are:</p> File Description gsrd-console-image-stratix10_htile_nand.ubifs UBI root partition image u-boot-stratix10-socdk-gsrd-atf/u-boot.itb U-Boot FIT image u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-qspi-image_2","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o hps_path=gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric. We already have the same file on the SD card.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-nand-binaries","title":"Build NAND Binaries","text":"<p>1. Gather the files into a single folder, using symlinks:</p> <pre><code>cd $TOP_FOLDER\nrm -rf nand-bin &amp;&amp; mkdir nand-bin &amp;&amp; cd nand-bin\nln -s $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/boot.scr.uimg .\nln -s $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/gsrd-console-image-stratix10_nand.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/socfpga_stratix10_socdk_nand.dtb .\n</code></pre> <p>2. Install <code>mtd-tools</code> if not already installed. On Ubuntu the command is:</p> <pre><code>sudo apt-get install mtd-tools\n</code></pre> <p>3. Create UBI configuration file for the root partition;</p> <pre><code>cat &lt;&lt;EOT &gt;ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=64MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nimage=socfpga_stratix10_socdk_nand.dtb\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=400MiB\nvol_flag=autoresizeENDCOLOR%\nEOT\n</code></pre> <p>4. Create the <code>root.ubi</code> file:</p> <pre><code>ubinize -o root.ubi -p 128KiB -m 2048 -s 2048 ubinize.cfg\n</code></pre> <p>This is what the above parameters mean:</p> <ul> <li>-p: physical eraseblock size of the flash</li> <li>-m: minimum input/output unit size of the flash</li> <li>-s: sub-pages and sub-page size, ubinize will take into account and put the VID header to same NAND page as the EC header</li> </ul> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/nand-bin/root.ubi</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#partial-reconfiguration_1","title":"Partial Reconfiguration","text":"<p>Important Note: The instructions from this section build the latest version of the GSRD. See Latest Source Release Contents for a list of used component versions.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-flow_1","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-environment_2","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf stratix10_gsrd.pr\nmkdir stratix10_gsrd.pr\ncd stratix10_gsrd.pr\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-hardware-design_2","title":"Build Hardware Design","text":"<pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga s10_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd s10_soc_devkit_ghrd\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\nexport ENABLE_PARTIAL_RECONFIGURATION=1\nexport HPS_ENABLE_SGMII=0\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\nunset QUARTUS_DEVICE\nunset ENABLE_PARTIAL_RECONFIGURATION\nunset HPS_ENABLE_SGMII\ncd ..\n</code></pre> <p>The following files are created in $TOP_FOLDER/s10_soc_devkit_ghrd/output_files:</p> <ul> <li>ghrd_1sx280hu2f50e1vgas.sof - FPGA SOF file, without HPS FSBL</li> <li>ghrd_1sx280hu2f50e1vgas_hps_debug.sof - FPGA SOF, with HPS Debug FSBL</li> <li>ghrd_1sx280hu2f50e1vgas.pr_partition_0.rbf - PR bitsream for the baseline persona</li> <li>alternate_persona.pr_partition_0.rbf - PR bitstream for the alternate persona</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-core-rbf_2","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas_hps_debug.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_1sx280hu2f50e1vgas.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-yocto_2","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. stratix10_htile-gsrd-build.sh\nbuild_setup\n</code></pre> <pre><code>cd $TOP_FOLDER/gsrd_socfpga\n. ./poky/oe-init-build-env stratix10-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#customize-yocto_2","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>stratix10_htile_gsrd_ghrd.core.rbf</li> <li>stratix10_htile_pr_persona0.rbf</li> <li>stratix10_htile_pr_persona1.rbf</li> <li>stratix10_htile_nand_ghrd.core.rbf: not applicable, as we have not rebuilt the NAND version</li> </ul> <p>This can be accomplished using the following instructions:</p> <pre><code>GHRD_LOC=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files\nCORE_RBF=$GHRD_LOC/stratix10_htile_pr_ghrd.core.rbf\nPER0_RBF=$GHRD_LOC/stratix10_htile_pr_persona0.rbf\nPER1_RBF=$GHRD_LOC/stratix10_htile_pr_persona1.rbf\ncp $TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf $CORE_RBF\ncp $TOP_FOLDER/s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.pr_partition_0.rbf $PER0_RBF\ncp $TOP_FOLDER/s10_soc_devkit_ghrd/output_files/alternate_persona.pr_partition_0.rbf $PER1_RBF\n</code></pre> <p>2. Update the Yocto recipe at <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> to change the <code>SRC_URI:stratix10</code> from the orginal value:</p> <pre><code>SRC_URI:stratix10_htile ?= \"\\\n${GHRD_REPO}/stratix10_htile_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core \\\n${GHRD_REPO}/stratix10_htile_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core \\\n${GHRD_REPO}/stratix10_htile_pr_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_pr_core \\\n${GHRD_REPO}/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0 \\\n${GHRD_REPO}/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1 \\\n    \"\n</code></pre> <p>to be:</p> <pre><code>SRC_URI:stratix10_htile ?= \"\\\n${GHRD_REPO}/stratix10_htile_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core \\\n${GHRD_REPO}/stratix10_htile_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_htile_nand_core \\\n    file://stratix10_htile_pr_ghrd.core.rbf \\    \n    file://stratix10_htile_pr_persona0.rbf \\\n    file://stratix10_htile_pr_persona1.rbf \\\n \"\n</code></pre> <p>using the following commands from the console:</p> <pre><code>OLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_htile_pr_\\${ARM64_GHRD_CORE_RBF};name=stratix10_htile_pr_core\"\nNEW_CORE_URI=\"file:\\/\\/stratix10_htile_pr_ghrd.core.rbf\"\nOLD_PER0_URI=\"\\${GHRD_REPO}\\/stratix10_htile_pr_persona0.rbf;name=stratix10_htile_pr_persona0\"\nNEW_PER0_URI=\"file:\\/\\/stratix10_htile_pr_persona0.rbf\"\nOLD_PER1_URI=\"\\${GHRD_REPO}\\/stratix10_htile_pr_persona1.rbf;name=stratix10_htile_pr_persona1\"\nNEW_PER1_URI=\"file:\\/\\/stratix10_htile_pr_persona1.rbf\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\nsed -i \"s/$OLD_PER0_URI/$NEW_PER0_URI/g\" $RECIPE\nsed -i \"s/$OLD_PER1_URI/$NEW_PER1_URI/g\" $RECIPE\n</code></pre> <p>Note we have left the NAND file alone, that will be downloaded from rocketboards.</p> <p>3. Update the same Yocto recipe to change the SHA checksums for the new files:</p> <pre><code>SRC_URI[stratix10_htile_gsrd_core.sha256sum] = \"6a7e4b9ed6146fa02ad6f37896d7d7a34ed14a0895e9e7ef92e2d6e442c8fd62\"\nSRC_URI[stratix10_htile_nand_core.sha256sum] = \"3ea5efca3cb223e150d0600742881daf7b1f1c364498d60d20dd952d5150e3ef\"\nSRC_URI[stratix10_htile_pr_core.sha256sum] = \"a10931cbb11efb091d8794f9e87cfec65b5a53067926d212449a914bab411b88\"\nSRC_URI[stratix10_htile_pr_persona0.sha256sum] = \"150c60bb1d6abd5b8998599bd244d2a687a3d5e6433d0edc2f8035dea7c9311f\"\nSRC_URI[stratix10_htile_pr_persona1.sha256sum] = \"80ba157a813a2db2fdbd03d05735f85a4ecde37553a26ebdf27eb07bdc259bc6\"\n</code></pre> <p>to the new values using the following commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nPER0_SHA=$(sha256sum $PER0_RBF | cut -f1 -d\" \")\nPER1_SHA=$(sha256sum $PER1_RBF | cut -f1 -d\" \")\nOLD_CORE_SHA=\"SRC_URI\\[stratix10_htile_pr_core\\.sha256sum\\] = .*\"\nNEW_CORE_SHA=\"SRC_URI[stratix10_htile_pr_core.sha256sum] = \\\"$CORE_SHA\\\"\"\nOLD_PER0_SHA=\"SRC_URI\\[stratix10_htile_pr_persona0\\.sha256sum\\] = .*\"\nNEW_PER0_SHA=\"SRC_URI[stratix10_htile_pr_persona0.sha256sum] = \\\"$PER0_SHA\\\"\"\nOLD_PER1_SHA=\"SRC_URI\\[stratix10_htile_pr_persona1\\.sha256sum\\] = .*\"\nNEW_PER1_SHA=\"SRC_URI[stratix10_htile_pr_persona1.sha256sum] = \\\"$PER1_SHA\\\"\"\nsed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE\nsed -i \"s/$OLD_PER0_SHA/$NEW_PER0_SHA/g\" $RECIPE\nsed -i \"s/$OLD_PER1_SHA/$NEW_PER1_SHA/g\" $RECIPE\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li> <p>fit_kernel_stratix10.its - its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD and NAND board configurations</li> <li>Core RBF files for SD and NAND board configurations</li> <li>Board configurations for SD and NAND cases</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-yocto_2","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>stratix10_htile_gsrd_rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>stratix10_htile_gsrd_images</code>: the build script copies here relevant files built by Yocto from the <code>stratix10_htile_gsrd_rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-qspi-image_3","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2 \\\n-o hps_path=gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric. We already have the same file on the SD card.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#boot-from-sd-card-on-dk-soc-1ssx-l-d","title":"Boot from SD Card on DK-SOC-1SSX-L-D","text":"<p>This section demonstrates how to build the binaries targeting the DK-SOC-1SSX-L-D board which is now obsolete.</p> <p>Only the SD card boot scenario is covered, but similar instructions can be used for the other scenarios.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-flow_2","title":"Build Flow","text":"<p>The following diagram illustrates the full build flow for the GSRD based on source code from GitHub.</p> <p></p> <p>The current build flow creates a single boot image which is able to boot in different board configurations (either using OOBE or eMMC/NAND daughter card). For more information about how this single boot image is created, please refer to the following article: https://rocketboards.org/foswiki/Documentation/SingleImageBoot.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-environment_3","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf stratix10_gsrd.enpirion\nmkdir stratix10_gsrd.enpirion\ncd stratix10_gsrd.enpirion\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-hardware-design_3","title":"Build Hardware Design","text":"<pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga s10_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd s10_soc_devkit_ghrd\nmake scrub_clean_all\nmake generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created in $TOP_FOLDER/s10_soc_devkit_ghrd/output_files:</p> <ul> <li>ghrd_1sx280lu2f50e2vg.sof - FPGA SOF file, without HPS FSBL</li> <li>ghrd_1sx280lu2f50e2vg_hps_debug.sof - FPGA SOF, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-core-rbf_3","title":"Build Core RBF","text":"<p>Create the Core RBF file to be used in the rootfs created by Yocto by using the HPS Debug SOF built by the GHRD makefile:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280lu2f50e2vg_hps_debug.sof \\\nghrd_1sx280lu2f50e2vg.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280LU2 \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_1sx280lu2f50e2vg.hps.jic\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280lu2f50e2vg.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric</li> </ul> <p>Note we are also creating an HPS JIC file, but we are discarding it, as it has the HPS Debug FSBL, while the final image needs to have the U-Boot SPL created by the Yocto recipes.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#set-up-yocto_3","title":"Set Up Yocto","text":"<p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. stratix10-gsrd-build.sh\nbuild_setup\n</code></pre> <pre><code>cd $TOP_FOLDER/gsrd_socfpga\n. ./poky/oe-init-build-env stratix10-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#customize-yocto_3","title":"Customize Yocto","text":"<p>1. Copy the rebuilt files to <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files</code> using the following names, as expected by the yocto recipes:</p> <ul> <li>stratix10_gsrd_ghrd.core.rbf</li> <li>stratix10_pr_persona0.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_pr_persona1.rbf: not applicable, PR not enabled in this scenario</li> <li>stratix10_nand_ghrd.core.rbf: not applicable, as we have not rebuilt the NAND version</li> </ul> <p>This can be accomplished using the following instructions:</p> <pre><code>GHRD_LOC=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files\nCORE_RBF=$GHRD_LOC/stratix10_gsrd_ghrd.core.rbf\ncp $TOP_FOLDER/ghrd_1sx280lu2f50e2vg.core.rbf $CORE_RBF\n</code></pre> <p>2. Update the Yocto recipe at <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> to change the <code>SRC_URI:stratix10</code> from the orginal value:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n${GHRD_REPO}/stratix10_gsrd_${ARM64_GHRD_CORE_RBF};name=stratix10_gsrd_core \\\n${GHRD_REPO}/stratix10_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_nand_core \\\n${GHRD_REPO}/stratix10_pr_persona0.rbf;name=stratix10_pr_persona0 \\\n${GHRD_REPO}/stratix10_pr_persona1.rbf;name=stratix10_pr_persona1 \\\n \"\n</code></pre> <p>to be:</p> <pre><code>SRC_URI:stratix10 ?= \"\\\n file://stratix10_gsrd_ghrd.core.rbf \\\n${GHRD_REPO}/stratix10_nand_${ARM64_GHRD_CORE_RBF};name=stratix10_nand_core \\\n${GHRD_REPO}/stratix10_pr_persona0.rbf;name=stratix10_pr_persona0 \\\n${GHRD_REPO}/stratix10_pr_persona1.rbf;name=stratix10_pr_persona1 \\\n \"\n</code></pre> <p>using the following commands from the console:</p> <pre><code>OLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_gsrd_\\${ARM64_GHRD_CORE_RBF};name=stratix10_gsrd_core\"\nNEW_CORE_URI=\"file:\\/\\/stratix10_gsrd_ghrd.core.rbf\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\n</code></pre> <p>Note we have left the PR and NAND files alone, that will be downloaded from rocketboards.</p> <p>3. Update the same Yocto recipe to change the SHA checksums for the new files:</p> <pre><code>SRC_URI[stratix10_gsrd_core.sha256sum] = \"ea26a77ebc1b3141193de6dd32e22f332785e05c956de85118c3790392141d3c\"\n</code></pre> <p>to the new values using the following commands:</p> <pre><code>CORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nOLD_CORE_SHA=\"SRC_URI\\[stratix10_gsrd_core\\.sha256sum\\] = .*\"\nNEW_CORE_SHA=\"SRC_URI[stratix10_gsrd_core.sha256sum] = \\\"$CORE_SHA\\\"\"\nsed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE\n</code></pre> <p>4. Optionally change the following files in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/</code>:</p> <ul> <li>uboot.txt - distroboot script</li> <li>uboot_script.its - its file for creating FIT image from the above script</li> </ul> <p>5. Optionally change the following file in <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts</code>:</p> <ul> <li> <p>fit_kernel_stratix10.its - its file for creating the kernel.itb image, containing by default:</p> <ul> <li>Kernel</li> <li>Device trees for SD and NAND board configurations</li> <li>Core RBF files for SD and NAND board configurations</li> <li>Board configurations for SD and NAND cases</li> </ul> </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#build-yocto_3","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>Once the build is completed successfully, you will see the following two folders are created:</p> <ul> <li><code>stratix10_gsrd_rootfs</code>: area used by OpenEmbedded build system for builds. Description of build directory structure - https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build</li> <li><code>stratix10_gsrd_images</code>: the build script copies here relevant files built by Yocto from the <code>stratix10_gsrd_rootfs/tmp/deploy/images/agilex</code> folder, but also other relevant files.</li> </ul> <p>The two most relevant files created in the <code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images</code> folder are:</p> File Description sdimage.tar.gz SD Card Image u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex U-Boot SPL Hex file"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#create-qspi-image_4","title":"Create QSPI Image","text":"<p>The QSPI image will contain the FPGA configuration data and the HPS FSBL and it can be built using the following command:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280lu2f50e2vg.sof \\\nghrd_1sx280lu2f50e2vg.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280LU2 \\\n-o hps_path=gsrd_socfpga/stratix10-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following files will be created:</p> <ul> <li>$TOP_FOLDER/ghrd_1sx280lu2f50e2vg.hps.jic - Flash image for HPS First configuration bitstream, phase 1: HPS and DDR</li> <li>$TOP_FOLDER/ghrd_1sx280lu2f50e2vg.core.rbf - HPS First configuration bitstream, phase 2: FPGA fabric. We already have the same file on the SD card.</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/gsrd/ug-gsrd-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/","title":"Stratix\u00ae 10 SoC FPGA Remote Debug Example","text":""},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#introduction","title":"Introduction","text":"<p>Intel offers an integrated set of System Level Debug (SLD) tools, including:</p> <ul> <li>SignalTap II Logic Analyzer</li> <li>In-System Sources and Probes (ISSP),</li> <li>In-System Memory Content Editor)</li> </ul> <p>Typically, the System-Level Debugging (SLD) communication solution was interfacing with the outside world through the JTAG. Then either an USB or Ethernet Blaster could be used to interface JTAG to the host PC.</p> <p></p> <p></p> <p>Another alternative approach is also available, to interface the SLD to the outside world directly through Ethernet on board, without requiring either an USB or Ethernet Blaster.</p> <p></p> <p>This page presents an example on how enable this remote debug feature on top of the GSRD.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#architecture","title":"Architecture","text":"<p>In the traditional approach the SLD communication solution was based on the Altera JTAG Interface (AJI) which interfaced with the JTAG TAP controller (hard atom in Altera devices which implements the JTAG protocol). The SLD tools used the JTAG channel for communication between software and hardware.</p> <p></p> <p>The remote FPGA debugging solution consists of the following:</p> <ul> <li>JTAG-Over Protocol (JOP) Component: Platform Designer component which enables access to debug information through an Avalon\u00ae-MM slave bus</li> <li>Etherlink: HPS application exporting debug information over Ethernet, available on github: https://github.com/altera-opensource/remote-debug-for-intel-fpga</li> </ul> <p></p> <p>The JOP component requires reset and clocking and also provides an Avalon\u00ae-MM slave bus through which is configured and debug information is accessed.</p> <p>Th Etherlink application runs on HPS, accesses the JOP component slave bus to access the debug information, and provides a TCP/IP link from the host PC running the Quartus Pro debug tools to the board.</p> <p>The etherlink works with the standard UIO Linux kernel driver.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#example","title":"Example","text":"<p>This section shows an example of how to use the Remote Debug feature. Communication is established from the board to the host PC through Ethernet, so that the board appears as another JTAG device, listed by jtagconfig utility.</p> <p>The example is based on the GSRD, with the following changes:</p> <ul> <li>Adding JOP component to the GHRD</li> <li>Adding JOP to the Linux device tree</li> </ul> <p>Notes:</p> <ul> <li>UIO driver is enabled as module in the default kernel configuration file</li> <li>etherlink is already part of the rootfs, built by the Yocto recipes</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>The following are required:</p> <ul> <li>Stratix\u00ae 10 SX SoC Development Kit, production version, H-Tile (ordering code DK-SOC-1SSX-H-D)<ul> <li>4GB DDR4 HILO memory card</li> <li>SD/MMC HPS Daughtercard</li> <li>SDM QSPI Bootcard(MT25QU02G)</li> <li>Mini USB cable for serial output</li> <li>Micro USB cable for on-board Intel\u00ae FPGA Download Cable II</li> </ul> </li> <li>Host PC with:<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Altera Quartus\u00ae Prime Pro Edition Version 24.3</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> <p>Refer to board documentation for more details about the development kit.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#set-up-environment","title":"Set up Environment","text":"<p>Create a top folder for this example, as the rest of the commands assume this location:</p> <pre><code>sudo rm -rf stratix10.remote_debug\nmkdir stratix10.remote_debug\ncd stratix10.remote_debug\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#build-hardware-design","title":"Build Hardware Design","text":"<p>The hardware design is based on the GSRD, with the JOP component added.</p> <p>1. Generate the hardware design:</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga s10_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd s10_soc_devkit_ghrd\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\nmake scrub_clean_all\nmake generate_from_tcl\n</code></pre> <p>2. Open the project in Quartus, open the <code>qsys_top.qsys</code> file in Platform Designer.</p> <p>3. In the IP Catalog search for jop and double-click the component to add it to the system:</p> <p></p> <p>4. Configure the JOP component as follows:</p> <p></p> <p>5. Connect the reset and clock to JOP component, also connect it's slave bus to the HPS LW bridge, and map it at offset 0x0002_0000:</p> <p></p> <p>6. Alternatively, steps 2-5 can be peformed from command line, using the provided tcl script:</p> <pre><code>cd $TOP_FOLDER\nrm -f s10-ghrd-add-jop.tcl\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/remote-debug/collateral/s10-ghrd-add-jop.tcl\ncd s10_soc_devkit_ghrd\nqsys-script --qpf=ghrd_1sx280hu2f50e1vgas.qpf --script=../s10-ghrd-add-jop.tcl --system-file=qsys_top.qsys\n</code></pre> <p>7. Finish compilation of the GHRD from command line:</p> <pre><code>cd $TOP_FOLDER/s10_soc_devkit_ghrd\nmake sof\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof</code> - FPGA configuration file, without HPS FSBL</li> <li><code>$TOP_FOLDER/s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas_hps_debug.sof</code> - FPGA configuration file, with HPS Debug FSBL</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#build-corerbf-file","title":"Build Core.RBF File","text":"<p>This section shows how to create the core RBF file, which is needed by the Yocto recipes:</p> <pre><code>cd $TOP_FOLDER\nrm -f *jic* *rbf*\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas_hps_debug.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU02G \\\n-o flash_loader=1SX280HU2F50E1VGAS \\\n-o mode=ASX4 \\\n-o hps=1\nrm ghrd_1sx280hu2f50e1vgas.hps.jic\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf</code></li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#build-yocto","title":"Build Yocto","text":"<p>Perform the following steps to build Yocto:</p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd_socfpga\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/gsrd_socfpga\ncd gsrd_socfpga\n. stratix10_htile-gsrd-build.sh\nbuild_setup\n</code></pre> <p>3. Enable the JOP UIO driver in the Linux device tree, by editing the file <code>meta-intel-fpga-refdes</code> to inlcude the changes shown below:</p> <pre><code>diff --git a/recipes-bsp/device-tree/files/socfpga_ilc.dtsi b/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\nindex 387d8bd..156dbb8 100644\n--- a/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\n+++ b/recipes-bsp/device-tree/files/socfpga_ilc.dtsi\n@@ -14,5 +14,10 @@\n            status = \"disabled\";\n            altr,sw-fifo-depth = &lt;32&gt;;\n        };\n+        jop@f9008000{\n+                                compatible = \"generic-uio\";\n+                                reg = &lt;0xf9008000 0x5000&gt;;\n+                                reg-names = \"jop\";\n+                };\n    };\n };\n</code></pre> <p>Note that the range of memory where the JOP is located is <code>0xf9008000</code> .. <code>0xf900dfff</code>.</p> <p>This can be done with the provided patch file:</p> <pre><code>rm -f s10-dts-add-jop.patch\nwget https://altera-fpga.github.io/rel-24.3/embedded-designs/stratix-10/sx/soc/remote-debug/collateral/s10-dts-add-jop.patch\npushd meta-intel-fpga-refdes\npatch -p1 &lt; ../s10-dts-add-jop.patch\npopd\n</code></pre> <p>4. Update your Yocto recipes to use the core RBF file you have built, similar to how the GSRD does it:</p> <pre><code>GHRD_LOC=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files\nCORE_RBF=$GHRD_LOC/stratix10_htile_gsrd_ghrd.core.rbf\ncp $TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.core.rbf $CORE_RBF\nOLD_CORE_URI=\"\\${GHRD_REPO}\\/stratix10_htile_gsrd_\\${ARM64_GHRD_CORE_RBF};name=stratix10_htile_gsrd_core\"\nNEW_CORE_URI=\"file:\\/\\/stratix10_htile_gsrd_ghrd.core.rbf\"\nRECIPE=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"s/$OLD_CORE_URI/$NEW_CORE_URI/g\" $RECIPE\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nOLD_CORE_SHA=\"SRC_URI\\[stratix10_htile_gsrd_core\\.sha256sum\\] = .*\"\nNEW_CORE_SHA=\"SRC_URI[stratix10_htile_gsrd_core.sha256sum] =  \\\"$CORE_SHA\\\"\"\nsed -i \"s/$OLD_CORE_SHA/$NEW_CORE_SHA/g\" $RECIPE\n</code></pre> <p>5. Build the Yocto recipes:</p> <pre><code>bitbake_image\n</code></pre> <p>6. Gather the Yocto binaries:</p> <pre><code>package\n</code></pre> <p>The following relevant files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/u-boot-agilex7-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/gsrd-console-image-stratix10.wic</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/stratix10_htile-gsrd-images/sdimage.tar.gz</code></li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#build-qspi-image","title":"Build QSPI Image","text":"<p>Run the following commands to build the QSPI image:</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c s10_soc_devkit_ghrd/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\nghrd_1sx280hu2f50e1vgas.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=1SX280HU2 \\\n-o hps_path=gsrd_socfpga/stratix10_htile-gsrd-images/u-boot-stratix10-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.hps.jic</code></li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#run-example","title":"Run Example","text":"<p>The instructions from this section present how to run the remote debug example. Refer to the GSRD for more detailed instructions on how to set up the board, serial port, and write the binaries.</p> <p>1. Write the QSPI image <code>$TOP_FOLDER/ghrd_1sx280hu2f50e1vgas.jic</code> to flash.</p> <p>2. Extract and write the SD card image <code>$TOP_FOLDER/gsrd_socfpga/stratix10_htile-gsrd-images/gsrd-console-image-stratix10.wic</code> to the SD card</p> <p>3. Boot board and log into Linux.</p> <p>4. Determine board IP address by running the <code>ifconfig</code> command:</p> <pre><code>root@stratix10:~# ifconfig\neth0: flags=4163  mtu 1500\ninet 10.122.105.175  netmask 255.255.255.0  broadcast 10.122.105.255\n        inet6 fe80::b830:37ff:fe25:aa4b  prefixlen 64  scopeid 0x20\n        ether ba:30:37:25:aa:4b  txqueuelen 1000  (Ethernet)\nRX packets 35  bytes 5398 (5.2 KiB)\nRX errors 0  dropped 1  overruns 0  frame 0\nTX packets 51  bytes 8687 (8.4 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 19  base 0x2000  </code></pre> <p>5. Remove pre-existing instances of the driver, and load it again:</p> <pre><code>root@stratix10:~# rmmod uio_pdrv_genirq\nroot@stratix10:~# modprobe uio_pdrv_genirq of_id=\"generic-uio\"\n</code></pre> <p>6. Start the etherlink application, specifying which port to accept connections on as shown below:</p> <pre><code>root@stratix10:~# etherlink --port=33301\nINFO: Etherlink Server Configuration:\nINFO:    H2T/T2H Memory Size  : 4096\nINFO:    Listening Port       : 33301\nINFO:    IP Address           : 0.0.0.0\nINFO: UIO Platform Configuration:\nINFO:    Driver Path: /dev/uio0\nINFO:    Address Span: 20480\nINFO:    Start Address: 0x0\nINFO: Server socket is listening on port: 33301\n</code></pre> <p>7. On the host, establish the JTAG communication to the board through Ethernet, using the board IP and the selected port number:</p> <pre><code>$ jtagconfig --add JTAG-over-protocol sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0\n</code></pre> <p>8. Also on the host, run the 'jtagconfig' command to show the newly added connection:</p> <pre><code>$ jtagconfig\n1) JTAG-over-protocol [sti://localhost:0/intel/remote-debug/10.122.105.175:33301/0]\n020D10DD   VTAP10\n</code></pre> <p>At this point, the connection can be used by the tools which need a JTAG connection, like SignalTap.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/remote-debug/ug-remote-debug-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/","title":"Stratix\u00ae 10 SoC HPS Remote System Update Example","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D), including the following.</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> </ul> <ul> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> </ul> <ul> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>Refer to Stratix\u00ae 10 Hard Processor System Remote System Update User Guide for details about the Remote System Update. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#component-versions","title":"Component Versions","text":"<p>This example was created with Quartus\u00ae Prime Pro Edition Version 24.3 and the following component versions.</p> Repository Branch/Tag ghrd-socfpga QPDS24.3_REL_GSRD_PR linux-socfpga socfpga-6.6.37-lts/QPDS24.3_REL_GSRD_PR arm-trusted-firmware socfpga_v2.11.0/QPDS24.3_REL_GSRD_PR u-boot-socfpga socfpga_v2024.04/QPDS24.3_REL_GSRD_PR intel-rsu master <p>For RSU example previous 24.2 version, please refer to Stratix 10 HPS Remote System Update.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus\u00ae Prime Pro Edition Version 24.3 for compiling the hardware projects, generating the flash images and writing to flash </li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li> Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) production version  for running the example. </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are listed next.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul> <p>Note: To build binaries for a different development kit than the one used in this page, please refer to the Building the Hardware Projects section in the corresponding  GSRD page for that development kit, which is the section that may differ from the instructions presented here.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf s10-rsu mkdir s10-rsu cd s10-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download the compiler toolchain, add it to the PATH variable, to be used by the GHRD makefile to build the HPS Debug FSBL:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\\ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Enable Quartus tools to be called from command line:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.3/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next. </p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below. </p> <pre><code>cd $TOP_FOLDER\n# compile hardware designs: 0-factory, 1,2-applications, 3-factory update \nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw\nrm -rf ghrd-socfpga s10_soc_devkit_ghrd\ngit clone -b QPDS24.3_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/s10_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\n# use fpga configuration first mode \nexport BOOTS_FIRST=fpga\n# enable watchdog operation \nexport ENABLE_WATCHDOG_RST=1\n# configure watchdog to trigger remote update \nexport WATCHDOG_RST_ACTION=remote_update\n# disable sgmii and partial reconfiguration - to decrease build time \nexport HPS_ENABLE_SGMII=0\nexport ENABLE_PARTIAL_RECONFIGURATION=0\n# Select device for S10 H-Tile\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\n\nfor version in {0..3}\ndo\nrm -rf ghrd.$version\ncp -r s10_soc_devkit_ghrd ghrd.$version\ncd ghrd.$version\n# change sysid to make binaries slightly different\nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' create_ghrd_qsys.tcl\nmake scrub_clean_all\nmake generate_from_tcl\necho \"set_global_assignment -name RSU_MAX_RETRY_COUNT 3\" &gt;&gt; ghrd_1sx280hu2f50e1vgas.qsf\n# change the board id to ha a simple boot from sd \nsed -i 's/set_global_assignment -name STRATIX_JTAG_USER_CODE .*/set_global_assignment -name STRATIX_JTAG_USER_CODE 0/g' ghrd_1sx280hu2f50e1vgas.qsf\nmake all\ncd ..\ndone\nrm -rf s10_soc_devkit_ghrd\ncd ..\n</code></pre> <p>After completing the above steps, the following SOF files are created are listed next. </p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/output_files/ghrd_1sx280hu2f50e1vgas.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/output_files/ghrd_1sx280hu2f50e1vgas.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/output_files/ghrd_1sx280hu2f50e1vgas.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/output_files/ghrd_1sx280hu2f50e1vgas.sof </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\n# checkout the branch used for this document, comment out to use default\n# git checkout -b test -t origin/socfpga_v2.11.0\nmake bl31 PLAT=stratix10 DEPRECATED=1\ncd ..\n</code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux. </p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga\ngit clone https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\n# checkout the branch used for this document, comment out to use default\n# git checkout -b test -t origin/socfpga-6.6.37-lts\n# configure the RSU driver to be built into the kernel\nmake clean &amp;&amp; make mrproper\nmake defconfig\n./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y\nmake oldconfig\nmake -j 48 Image dtbs\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created. </p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga\n# comment out next line to use the latest default branch\n# git checkout -b test -t origin/socfpga_v2024.04\n# enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# use 'Image' for kernel image instead of 'kernel.itb'\nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n# remove the NAND configuration from device tree\nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi\n\n# link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin .\n\n# Create configuration custom file.\ncat &lt;&lt; EOF &gt; config-fragment-stratix10\n# - Disable NAND/UBI related settings from defconfig.\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# - Disable distroboot and use specific boot command.\nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"bridge enable;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\nCONFIG_SYS_PROMPT=\"SOCFPGA # \"\nEOF\n# build U-Boot \nmake clean &amp;&amp; make mrproper\nmake socfpga_stratix10_defconfig\n# Use created custom configuration file to merge with the default configuration obtained in .config file.\n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-stratix10\nmake -j 48\ncd ..\n</code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is provided below so and you can easily create the initial flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER\ncat &lt;&lt; EOF &gt; initial_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.0/output_files/ghrd_1sx280hu2f50e1vgas.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n        &lt;bitstream id=\"Bitstream_2\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.1/output_files/ghrd_1sx280hu2f50e1vgas.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0010FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00110000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x02000000\" e_addr=\"0x02FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03000000\" e_addr=\"0x03FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;1SX280HU2F50E1VGAS&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/intelFPGA_pro/24.2/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg\n</code></pre> <p>Here are the complete instructions on how to create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER\nqpfgw &amp;\n</code></pre> </li> <li> <p>Select the Device family as Stratix 10, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bitswap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file ghrd_1sx280hu2f50e1vgas.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/output_files/ghrd_1sx280hu2f50e1vgas.sof image. This is the initial application image. The tab now looks like below. </p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. This opens the window to browse for the FSBL and select authentication and encryption settings. </p> <p> </p> </li> <li> <p>Click the Bootloader (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the MT25QU02G in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (ghrd_1sx280hu2f50e1vgas). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0090FFFF in order to reserve 8MB for the factory image. This end address was calculated by adding 8MB to the end of the BOOT_INFO partition. Click OK. </p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be trieed after all the application images failed. </p> </li> <li> <p>Select the MT25QU02G flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(ghrd_1sx280hu2f50e1vgas.sof). This becomes the initial application image. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x01000000 and End Address = 0x01FFFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.   The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image. </p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions) and set the start and end addresses as follows.</p> <p>* P2: Start Address = 0x02000000 and End Address = 0x02FFFFFF.    * P3: Start Address = 0x03000000 and End Address = 0x03FFFFFF. </p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER quartus_pfg -c initial_image.pfg\n</code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example. </p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -rf images/application2.rpd\nquartus_pfg -c hw/ghrd.2/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\nimages/application2.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON\n</code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/factory_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\nimages/factory_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON\n</code></pre> <p>The following factory update image is created.</p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example. </p> <pre><code>cd $TOP_FOLDER\nmkdir -p images\nrm -f images/decision_firmware_update.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\nimages/decision_firmware_update.rpd \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o firmware_only=ON\n</code></pre> <p>The following decision firmware update image is created.</p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images\nrm -f images/combined_application.rpd\nquartus_pfg -c hw/ghrd.3/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\nimages/combined_application.rpd \\\n-o app_image=hw/ghrd.2/output_files/ghrd_1sx280hu2f50e1vgas.sof \\\n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o bitswap=ON \\\n-o rsu_upgrade=ON \\\n-o app_image_only=ON\n</code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul> <p>Notes:</p> <ul> <li>The first SOF file contains the factory image, from which data is taken to fill out the new decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from this SOF file is not used.</li> <li>The app_image parameter contains the SOF that is used for the application image section of the combined image.</li> <li>The hps_path parameter is unused, and may be removed in the future.</li> <li>The app_image_hps_path parameter contains the HPS FSBL hex file to be used for the application imge section of the combined image.</li> <li>When using HPS first, the additional parameter \"-o hps=1\" needs to be added, and the following files are created combined_application.hps.rpd (combined application image)  and combined_application.core.rbf (corresponding fabric configuration file).</li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <p>1. Make sure you have Yocto system requirements met: https://docs.yoctoproject.org/5.0.1/ref-manual/system-requirements.html#supported-linux-distributions.</p> <p>The command to install the required packages on Ubuntu 22.04 is:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code> sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use a Docker container to build the Yocto recipes, refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <p>2. Run the following commands to build the root file system. </p> <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"stratix10\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER\nrm -rf zlib-1.3.1\nwget http://zlib.net/zlib-1.3.1.tar.gz\ntar xf zlib-1.3.1.tar.gz\nrm zlib-1.3.1.tar.gz\ncd zlib-1.3.1/\nexport CROSS_PREFIX=${CROSS_COMPILE}\n./configure\nmake\nexport ZLIB_PATH=`pwd`\ncd ..\n</code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.2.11/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.2.11/libz.so - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application.</p> <pre><code>cd $TOP_FOLDER rm -rf intel-rsu\ngit clone https://github.com/altera-opensource/intel-rsu\ncd intel-rsu\n# checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/master\ncd lib\n# add -I$(ZLIB_PATH) to CFLAGS \nsed -i 's/\\(CFLAGS := .*\\)$/\\1 -I\\$\\(ZLIB_PATH\\)/g' makefile\nmake\ncd ..\ncd example\n# add -L$(ZLIB_PATH) to LDFLAGS \nsed -i 's/\\(LDFLAGS := .*\\)$/\\1 -L\\$\\(ZLIB_PATH\\)/g' makefile\nmake\ncd ..\ncd ..\n</code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/intel-rsu/lib/librsu.so - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/intel-rsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/intel-rsu/example/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example. </p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2021.04/gsrd/\\ \ntools/make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\n# prepare the fat contents\nmkdir fat &amp;&amp; cd fat\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb .\ncp $TOP_FOLDER/images/*.rpd .\ncd ..\n# prepare the rootfs partition contents \nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/\\\ncore-image-minimal-stratix10.rootfs.tar.gz\nsudo sed -i 's/stratix10/linux/g' etc/hostname\nsudo rm -rf lib/modules/*\nsudo cp $TOP_FOLDER/images/*.rpd home/root\nsudo cp $TOP_FOLDER/intel-rsu/example/rsu_client home/root/\nsudo cp $TOP_FOLDER/intel-rsu/lib/librsu.so lib/\nsudo cp $TOP_FOLDER/intel-rsu/etc/qspi.rc etc/librsu.rc\nsudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/\ncd ..\n# create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\\n-P fat/*,num=1,format=vfat,size=100M \\\n-P rootfs/*,num=2,format=ext3,size=100M \\\n-s 256M \\\n-n sdcard_rsu.img\ncd ..\n</code></pre> <p>This creates the SD card image as. </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card.</p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Stratix 10 SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Stratix 10 SoC Development Kit as follows, to have MSEL set to JTAG:</p> <p>- SW1: 1:OFF, rest:ON    - SW2: 1:ON 2:ON 3: ON 4:N/A (SW2.4 is is not connected)    - SW3: all OFF    - SW4: 1:ON 2:OFF 3:OFF 4:ON </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer. </p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\" </code></pre> </li> <li> <p>Configure the Stratix 10 SoC Development Kit tas follows, to have MSEL set to QSPI.</p> <p>- SW2: 1:ON 2:OFF 3:OFF 4: OFF </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Stratix 10 SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <ol> <li> <p>Power cycle the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2024.04-35102-g135e53726d-dirty (Nov 23 2024 - 13:23:54 -0600)\nReset state: Cold\nMPU         1200000 kHz\nL3 main     400000 kHz\nMain VCO    2400000 kHz\nPer VCO     2000000 kHz\nEOSC1       25000 kHz\nHPS MMC     50000 kHz\nUART        100000 kHz\nDDR: 4096 MiB\nSDRAM-ECC: Initialized success with 986 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nNOTICE:  BL31: v2.11.0(release):QPDS24.3_REL_GSRD_PR\nNOTICE:  BL31: Built : 13:23:25, Nov 23 2024\nU-Boot 2024.04-35102-g135e53726d-dirty (Nov 23 2024 - 13:23:54 -0600)socfpga_stratix10\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Stratix 10 SoCDK\nDRAM:  2 GiB (effective 4 GiB)\nCore:  26 devices, 21 uclasses, devicetree: separate\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:   Warning: ethernet@ff800000 (eth0) using random MAC address - 66:b9:e3:95:2d:82\neth0: ethernet@ff800000\nHit any key to stop autoboot:  0 SOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options.</p> <pre><code>SOCFPGA # rsu \nrsu - Stratix 10 SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name &lt;name&gt; - find slot by name and display the slot number slot_count - display the slot count slot_disable &lt;slot&gt; - remove slot from CPB slot_enable &lt;slot&gt; - make slot the highest priority slot_erase &lt;slot&gt; - erase slot slot_get_info &lt;slot&gt; - display slot information slot_load &lt;slot&gt; - load slot immediately slot_load_factory - load factory immediately slot_priority &lt;slot&gt; - display slot priority slot_program_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program buffer into slot, and make it highest priority slot_program_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program raw buffer into slot slot_program_factory_update_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program factory update buffer into slot, and make it highest priority slot_rename &lt;slot&gt; &lt;name&gt; - rename slot slot_delete &lt;slot&gt; - delete slot slot_create &lt;name&gt; &lt;address&gt; &lt;size&gt; - create slot slot_size &lt;slot&gt; - display slot size slot_verify_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against buffer slot_verify_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against raw buffer status_log - display RSU status update &lt;flash_offset&gt; - Initiate firmware to load bitstream as specified byflash_offset notify &lt;value&gt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt &lt;address&gt; - restore SPT from an address save_spt &lt;address&gt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb &lt;address&gt; - restore CPB from an address save_cpb &lt;address&gt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status.</p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 LastFail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 24.3.0 DCMF1 version = 24.3.0 DCMF2 version = 24.3.0 DCMF3 version = 24.3.0 </code></pre> </li> <li> <p>Display information about the slots:      <pre><code>SOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 16777216. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 16777216. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 16777216. </code></pre></p> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n3358720 bytes read in 153 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000002000000 size=3358720. </code></pre> </li> <li> <p>Verify that the application image was written correctly: </p> <pre><code>SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000002000000 size=3358720. </code></pre> </li> <li> <p>Confirm that slot 1 (partition P2) contains now the highest priority image:      <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre></p> </li> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands.</p> <pre><code>SOCFPGA # rsu update 0x01000000 \nRSU: RSU update to 0x0000000001000000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log      to confirm it:      <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre></p> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following.</p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code>SOCFPGA # mw.l 0xffd00204 0 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value.</p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf0061234 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it.</p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nCPBs are GOOD!!! Slot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n3485696 bytes read in 158 ms (21 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nCPBs are GOOD!!! Slot 2 was programmed with buffer=0x0000000002000000 size=3485696. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=3485696. </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB:      <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre></p> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2.</p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x02000000 0x10000 \nSF: 16384 bytes @ 0x2000000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status.</p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 256KB).</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB,     total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x80000 0x10000 \nSF: 4096 bytes @ 0x80000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x10000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 2 \nNAME P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB,    total 256 MiB SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d00f Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs.</p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image : 0x01000000 Last Fail Image : 0x00100000 State : 0xf004d010 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted Current Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d011 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected.</p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <pre><code>SOCFPGA # rsu clear_error_status \n</code></pre> <p>Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds.</p> <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status: </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes.</p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF Bad SPT0 magic number 0xFFFFFFFF no valid SPT0 and SPT1 found Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails.</p> <pre><code>SOCFPGA # rsu slot_count \ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#using-the-combined-application-image","title":"Using the Combined Application Image","text":"<p>This section shows an example of using a combined application image, from U-Boot. Similar commands can be used from Linux.</p> <p>The combined application images are used the exact same way as regular application images, just that they first update the decision firmware and decision firmware data if necessary, before the device is configured with the functionality from the application SOF.</p> <p>Note: The combined application images do not have absolute pointers inside like the regular application images, the factory update images, or the decision firmware update images. Because of this, they can be written to flash with any of the U-Boot and LibRSU APIs that write to slots.</p> <ol> <li> <p>Program the RSU initial image created with the previous version ($TOP_FOLDER/initial_image_prev.jic).</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;./initial_image_prev.jic\"\n</code></pre> </li> <li> <p>Power cyle the board, stop to U-Boot prompt and query the decision firmware information from U-Boot, this should be a previous version.</p> <pre><code>SOCFPGA # rsu display_dcmf_version\nDCMF0 version = 24.2.0\nDCMF1 version = 24.2.0\nDCMF2 version = 24.2.0\nDCMF3 version = 24.2.0\n</code></pre> </li> <li> <p>Find an unused slot (slot 1, P2), erase it, write the combined application image to it, verify that it was programmed successfully  and check it is now the highest priority.</p> <pre><code>SOCFPGA # rsu slot_erase 1\nSlot 1 erased.\nSOCFPGA # fatload mmc 0:1 ${loadaddr} combined_application.rpd\n151552 bytes read in 9 ms (16.1 MiB/s)\nSOCFPGA # rsu slot_program_buf 1 ${loadaddr} ${filesize}\nSlot 1 was programmed with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_verify_buf 1 ${loadaddr} ${filesize}\nSlot 1 was verified with buffer=0x0000000002000000 size=3510272.\nSOCFPGA # rsu slot_get_info 1\nNAME: P2\nOFFSET: 0x0000000002000000\nSIZE: 0x01000000\nPRIORITY: 1\n</code></pre> </li> <li> <p>Pass control to the combined application update image.</p> <pre><code>SOCFPGA # rsu slot_load 1\n</code></pre> </li> <li> <p>The combined application image checks the currently used decision firmware copy, it sees that it is older, then it updates the decision firmware and decision firmware data, then it loads the actual application image section. Everything takes a few seconds.</p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware is updated, and the application image is running fine.</p> <pre><code>SOCFPGA # rsu status_log\nCurrent Image : 0x02000000\nLast Fail Image : 0x00000000\nState : 0x00000000\nVersion : 0x00000202\nError location : 0x00000000\nError details : 0x00000000\nRetry counter : 0x00000000\nSOCFPGA # rsu display_dcmf_version\nDCMF0 version = 24.3.0\nDCMF1 version = 24.3.0\nDCMF2 version = 24.3.0\nDCMF3 version = 24.3.0\n</code></pre> </li> <li> <p>Power cycle the board, the same combined application image is loaded, as it is the highest priority. But it takes a couple of seconds less, as the decision firmware does not need to be updated.</p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <ol> <li> <p>Power cycle the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message.</p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 21.2.0 DCMF1 version = 21.2.0 DCMF2 version = 21.2.0 DCMF3 version = 21.2.0 Operation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status. It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following.</p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power cycle the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report. </p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux. </p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number.</p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power cycle the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power cycle the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.   - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB.</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot. </p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes.</p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is requried to have the status availabe in Linux. </p> <ol> <li> <p>Power cycle the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x80000 0x10000 \nSF: 4096 bytes @ 0x80000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed rootlinux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requries a valid CPB - verify it is not rejected. </p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Ther are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash. </p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin \nOperation completed \nroot@linux:~# sync \n</code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.    Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails.</p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#using-separate-ssbl-per-bitstream","title":"Using Separate SSBL Per Bitstream","text":"<p>When using Remote System Update on Stratix\u00ae 10, Agilex\u2122 7, Agilex\u2122 5 and N5X\u2122 devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> <li>Agilex\u2122 5 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"host-attach-util/fpgaconf/fpgaconf/","title":"fpgaconf","text":""},{"location":"host-attach-util/fpgaconf/fpgaconf/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgaconf [-hvVn] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] &lt;gbs&gt;</code></p>"},{"location":"host-attach-util/fpgaconf/fpgaconf/#description","title":"DESCRIPTION","text":"<p><code>fpgaconf</code> configures the FPGA with the accelerator function (AF). It also checks the AF for compatibility with  the targeted FPGA and the FPGA Interface Manager (FIM). <code>fpgaconf</code> takes the following arguments: </p> <p><code>-h, --help</code></p> <pre><code>Prints usage information.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-V, --verbose</code></p> <pre><code>Prints more verbose messages while enumerating and configuring. Can be\nrequested more than once.\n</code></pre> <p><code>-n, --dry-run</code></p> <pre><code>Performs enumeration. Skips any operations with side-effects such as the\nactual AF configuration.\n</code></pre> <p><code>-S, --segment</code></p> <pre><code>PCIe segment number of the target FPGA.\n</code></pre> <p><code>-B, --bus</code></p> <pre><code>PCIe bus number of the target FPGA.\n</code></pre> <p><code>-D, --device</code></p> <pre><code>PCIe device number of the target FPGA.\n</code></pre> <p><code>-F, --function</code></p> <pre><code>PCIe function number of the target FPGA.\n</code></pre> <p><code>--force</code></p> <pre><code>Reconfigure the AFU even if it is in use.\n</code></pre> <p><code>fpgaconf</code> enumerates available FPGA devices in the system and selects compatible FPGAs for configuration. If more than one FPGA is compatible with the AF, <code>fpgaconf</code> exits and asks you to be more specific in selecting the target FPGAs by specifying a a PCIe BDF.</p>"},{"location":"host-attach-util/fpgaconf/fpgaconf/#examples","title":"EXAMPLES","text":"<p><code>fpgaconf my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to a compatible FPGA.\n</code></pre> <p><code>fpgaconf -V -B 0x3b my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA in bus 0x3b, if compatible,\nwhile printing out slightly more verbose information.\n</code></pre> <p><code>fpgaconf 0000:3b:00.0 my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA at address 0000:3b:00.0.\n</code></pre>"},{"location":"host-attach-util/fpgad/fpgad/","title":"fpgad","text":""},{"location":"host-attach-util/fpgad/fpgad/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgad --daemon [--version] [--directory=&lt;dir&gt;] [--logfile=&lt;file&gt;] [--pidfile=&lt;file&gt;] [--umask=&lt;mode&gt;] [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code> <code>fpgad [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code></p>"},{"location":"host-attach-util/fpgad/fpgad/#description","title":"DESCRIPTION","text":"<p>fpgad monitors the device sensors, checking for sensor values that are out of the prescribed range. </p> <p>When any of the sensors is detected to be out of bounds, fpgad will focus on keeping the server from rebooting by masking PCIE AER, and send a message to system administrator. System administrator can take further actions like stop the application and stop the FPGA, but fpgad just focus on monitor the sensors and will not take any cooling actions. </p> <p>Note: fpgad must be running (as root) and actively monitoring devices when a sensor anomaly occurs in order to initiate Graceful Shutdown.  If fpgad is not loaded during such a sensor anomaly, the out-of-bounds scenario will not be detected, and the resulting effect on the hardware is undefined.</p>"},{"location":"host-attach-util/fpgad/fpgad/#arguments","title":"ARGUMENTS","text":"<p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-d, --daemon</code></p> <pre><code>When specified, fpgad executes as a system daemon process.\n</code></pre> <p><code>-D, --directory &lt;dir&gt;</code></p> <pre><code>When running in daemon mode, run from the specified directory.\nIf omitted when daemonizing, `fpgad` uses /tmp.\n</code></pre> <p><code>-l, --logfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, send output to file. When not in daemon mode, the output goes to stdout.\nIf omitted when daemonizaing, fpgad uses /tmp/fpgad.log.\n</code></pre> <p><code>-p, --pidfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, write the daemon's process id to a file.\nIf omitted when daemonizing, fpgad uses /tmp/fpgad.pid.\n</code></pre> <p><code>-m, --umask &lt;mode&gt;</code></p> <pre><code>When running in daemon mode, use the mode value as the file mode creation mask passed to umask.\nIf omitted when daemonizing, fpgad uses 0.\n</code></pre> <p><code>-s, --socket &lt;sock&gt;</code></p> <pre><code>Listen for event API registration requests on the UNIX domain socket on the specified path. \nThe default=/tmp/fpga_event_socket.\n</code></pre> <p><code>-n, --null-bitstream &lt;file&gt;</code></p> <pre><code>Specify the NULL bitstream to program when an AP6 event occurs. This option may be specified multiple\ntimes. The AF, if any, that matches the FPGA's PR interface ID is programmed when an AP6\nevent occurs.\n</code></pre>"},{"location":"host-attach-util/fpgad/fpgad/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>If you encounter any issues, you can get debug information in two ways:</p> <ol> <li>By examining the log file when in daemon mode.</li> <li>By running in non-daemon mode and viewing stdout.</li> </ol>"},{"location":"host-attach-util/fpgad/fpgad/#examples","title":"EXAMPLES","text":"<p><code>fpgad --daemon --null-bitstream=my_null_bits.gbs</code></p> <p>This command starts fpgad as a system daemon process: <pre><code>sudo systemctl start fpgad\n</code></pre></p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/","title":"fpgainfo","text":""},{"location":"host-attach-util/fpgainfo/fpgainfo/#synopsis","title":"SYNOPSIS","text":"<pre><code>   fpgainfo [-h] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR]\n            {errors,power,temp,fme,port,bmc,mac,phy,security}\n</code></pre>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#description","title":"DESCRIPTION","text":"<p>fpgainfo displays FPGA information derived from sysfs files. The command argument is one of the following: <code>errors</code>, <code>power</code>, <code>temp</code>, <code>port</code>, <code>fme</code>, <code>bmc</code>, <code>phy</code> or <code>mac</code>,<code>security</code>,<code>events</code>. Some commands may also have other arguments or options that control their behavior.</p> <p>For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#fpgainfo-commands","title":"FPGAINFO COMMANDS","text":"<p><code>errors</code></p> <p>Show/clear errors of an FPGA resource that the first argument specifies. <code>fpgainfo</code> displays information in human readable form.</p> <p><code>power</code></p> <p>Show total the power in watts that the FPGA hardware consumes.</p> <p><code>temp</code></p> <p>Show FPGA temperature values in degrees Celcius.</p> <p><code>port</code></p> <p>Show information about the port such as the AFU ID of currently loaded AFU.</p> <p><code>fme</code></p> <p>Show information about the FPGA platform including the partial reconfiguration (PR) Interface ID, the OPAE version, and the FPGA Interface Manager (FIM) ID.</p> <p><code>bmc</code></p> <p>Show all Board Management Controller sensor values for the FPGA resource, if available.</p> <p><code>phy</code></p> <p>Show information about the PHY integrated in the FPGA, if available.</p> <p><code>mac</code></p> <p>Show information about the MAC address in ROM attached to the FPGA, if available.</p> <p><code>security</code></p> <p>Show information about the security keys, hashs and flash count, if available.</p> <p><code>events</code></p> <p>Show information about events and sensors, if available.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p> <p><code>--version, -v</code></p> <p>Prints version information and exit.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#common-arguments","title":"COMMON ARGUMENTS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-S, --segment</code></p> <p>PCIe segment number of resource.</p> <p><code>-B, --bus</code></p> <p>PCIe bus number of resource.</p> <p><code>-D, --device</code></p> <p>PCIe device number of resource.</p> <p><code>-F, --function</code></p> <p>PCIe function number of resource.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#errors-arguments","title":"ERRORS ARGUMENTS","text":"<p>The first argument to the <code>errors</code> command specifies the resource type. It must be one of the following:    <code>fme</code>,<code>port</code>,<code>all</code></p> <p><code>fme</code></p> <p>Show/clear FME errors. </p> <p><code>port</code></p> <p>Show/clear PORT errors.</p> <p><code>all</code></p> <p>Show/clear errors for all resources.</p> <p>The optional <code>&lt;command-args&gt;</code> arguments are:</p> <p><code>--clear, -c</code></p> <p>Clear errors for the given FPGA resource.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#phy-arguments","title":"PHY ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--group, -G</code></p> <p>Select which PHY group(s) information to show.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#events-arguments","title":"EVENTS ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--list,-l</code></p> <p>List boots (implies --all).</p> <p><code>--boot,-b</code></p> <p>Boot index to use, i.e: \u00a0\u00a0\u00a0\u00a00 for current boot (default). \u00a0\u00a0\u00a0\u00a01 for previous boot, etc.</p> <p><code>--count,-c</code></p> <p>Number of events to print.</p> <p><code>--all,-a</code></p> <p>Print all events.</p> <p><code>--sensors,-s</code></p> <p>Print sensor data too.</p> <p><code>--bits,-i</code></p> <p>Print bit values too.</p> <p><code>--help,-h</code></p> <p>Print this help.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#examples","title":"EXAMPLES","text":"<p>This command shows the current power telemetry: <pre><code>./fpgainfo power\n</code></pre></p> <p>This command shows the current temperature readings: <pre><code>./fpgainfo temp\n</code></pre></p> <p>This command shows FME resource errors: <pre><code>./fpgainfo errors fme\n</code></pre> This command clears all errors on all resources: <pre><code>./fpgainfo errors all -c\n</code></pre> This command shows information of the FME on bus 0x5e <pre><code>./fpgainfo fme -B 0x5e\n</code></pre> This command shows information of the FPGA security on bus 0x5e <pre><code>./fpgainfo security -B 0x5e\n</code></pre> This command shows all events and sensors information including sensor bits: <pre><code>./fpgainfo events -asi\n</code></pre></p>"},{"location":"host-attach-util/fpgaport/fpgaport/","title":"fpgaport","text":""},{"location":"host-attach-util/fpgaport/fpgaport/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgaport [-h] [-N NUMVFS] [-X] [--debug] {assign,release} device [port]\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#description","title":"DESCRIPTION","text":"<p>The <code>fpgaport</code> enables and disables virtualization. It assigns and releases control of the port to the virtual function (VF). By default, the driver assigns the port to the physical function (PF) in the non-virtualization use case.</p>"},{"location":"host-attach-util/fpgaport/fpgaport/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{assign, release}</code></p> <pre><code>Action to perform.\n</code></pre> <p><code>device</code></p> <pre><code>The FPGA device being targeted with this action.\n</code></pre> <p><code>port</code></p> <pre><code>The number of the port.\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-N NUMVFS, --numvfs NUMVFS</code></p> <pre><code>Create NUMVFS virtual functions. The typical value is 1.\n</code></pre> <p><code>-X, --destroy-vfs</code></p> <pre><code>Destroy all virtual functions prior to assigning.\n</code></pre> <p><code>--debug</code></p> <pre><code>Display additional log information.\n</code></pre> <p><code>-h, --help</code></p> <pre><code>Print usage information.\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#example","title":"EXAMPLE","text":"<p><code>fpgaport release /dev/dfl-fme.0 0</code></p> <pre><code>Release port 0 from physical function control.\n</code></pre> <p><code>fpgaport assign /dev/dfl-fme.0 0</code></p> <pre><code>Assign port 0 to physical function control.\n</code></pre>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/","title":"fpgasupdate","text":""},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgasupdate [--log-level=&lt;level&gt;] file [bdf]</code></p>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#description","title":"DESCRIPTION","text":"<p>The <code>fpgasupdate</code> command implements a secure firmware update for the following programmable accelerator cards (PACs): * Intel\u00ae PAC with Intel Arria\u00ae 10 GX FPGA * Intel\u00ae FPGA PAC D5005 * Intel\u00ae PAC N3000 * Intel\u00ae FPGA SmartNIC N6001-PL with Intel&amp;reg Agilex&amp;reg FPGA * Intel\u00ae FPGA IPU F2000X-PL</p> <p><code>--log-level &lt;level&gt;</code></p> <pre><code>Specifies the `log-level` which is the level of information output to your command tool.\nThe following seven levels  are available: `state`, `ioctl`, `debug`, `info`, `warning`,\n`error`, `critical`. Setting `--log-level=state` provides the most verbose output.\nSetting `--log-level=ioctl` provides the second most information, and so on. The default\nlevel is `info`.\n</code></pre> <p><code>file</code></p> <pre><code>Specifies the secure update firmware file to be programmed. This file may be to program a\nstatic region (SR), programmable region (PR), root entry hash, key cancellation, or other\ndevice-specific firmware.\n</code></pre> <p><code>bdf</code></p> <pre><code>The PCIe&amp;reg; address of the PAC to program. `bdf` is of the form `[ssss:]bb:dd:f`,\ncorresponding to PCIe segment, bus, device, function. The segment is optional. If\nyou do not specify a segment, the segment defaults to `0000`. If the system has only\none PAC you can omit the `bdf` and let `fpgasupdate`  determine the address\nautomatically.\n</code></pre>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>To gather more debug output, decrease the <code>--log-level</code> parameter. </p>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#examples","title":"EXAMPLES","text":"<p><code>fpgasupdate firmware.bin</code> <code>fpgasupdate firmware.bin 05:00.0</code> <code>fpgasupdate firmware.bin 0001:04:02.0 --log-level=ioctl</code></p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/","title":"host_exerciser","text":""},{"location":"host-attach-util/host_exerciser/host_exerciser/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: host_exerciser [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=warning\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mode UINT:value in {lpbk-&gt;0,read-&gt;1,trput-&gt;3,write-&gt;2} OR {0,1,3,2}=lpbk\n                              host exerciser mode {lpbk,read, write, trput}\n  --cls UINT:value in {cl_1-&gt;0,cl_2-&gt;1,cl_4-&gt;2,cl_8-&gt;3} OR {0,1,2,3}=cl_1\n                              number of CLs per request{cl_1, cl_2, cl_4, cl_8}\n  --continuousmode BOOLEAN=false\n                              test rollover or test termination\n  --atomic UINT:value in {cas_4-&gt;9,cas_8-&gt;11,fadd_4-&gt;1,fadd_8-&gt;3,off-&gt;0,swap_4-&gt;5,swap_8-&gt;7} OR {9,11,1,3,0,5,7}=off\n                              atomic requests (only permitted in combination with lpbk/cl_1)\n  --encoding UINT:value in {default-&gt;0,dm-&gt;1,pu-&gt;2,random-&gt;3} OR {0,1,2,3}=default\n                              data mover or power user encoding -- random interleaves both in the same stream\n  -d,--delay BOOLEAN=false    Enables random delay insertion between requests\n  --interleave UINT=0         Interleave requests pattern to use in throughput mode {0, 1, 2}\n                              indicating one of the following series of read/write requests:\n                              0: rd-wr-rd-wr\n                              1: rd-rd-wr-wr\n                              2: rd-rd-rd-rd-wr-wr-wr-wr\n  --interrupt UINT:INT in [0 - 3]\n                              The Interrupt Vector Number for the device\n  --contmodetime UINT=1       Continuous mode time in seconds\n  --testall BOOLEAN=false     Run all tests\n  --clock-mhz UINT=0          Clock frequency (MHz) -- when zero, read the frequency from the AFU\nSubcommands:\n  lpbk                        run simple loopback test\n  mem                         run simple mem test\n</code></pre>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#description","title":"DESCRIPTION","text":"<p>A host exerciser is used to exercise and characterize the various host-FPGA interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-loopback-he-lb","title":"Host Exerciser Loopback (HE-LB)","text":"<p>The HE-LB module is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth.  Host Exerciser Loopback (HE-LB) AFU can move data between host memory and FPGA.</p> <p>HE-LB IP supports: 1. Latency (AFU to Host memory read) 2. MMIO latency (Write+Read) 3. MMIO BW (64B MMIO writes) 4. BW (Read/Write, Read only, Wr only)</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-memory-he-mem","title":"Host Exerciser Memory (HE-MEM)","text":"<p>The HE-MEM module is used to exercise use of FPGA connected DDR; data read from the host is  written to DDR, and the same data is read from DDR before sending it back to the  host. HE-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized version of the AVMM interface to communicate with the EMIF memory controller.</p> <p>Execution of these exercisors requires the user to bind specific VF endpoint to vfio-pci Bind the correct endpoint for a device with B/D/F 0000:b1:00.0</p> <p><code>[user@localhost]: sudo opae.io init -d 0000:b1:00.2 user:user</code></p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-sub-commands","title":"HOST EXERCISER SUB COMMANDS","text":"<p><code>lpbk</code></p> <p>run host exerciser loopback test</p> <p><code>mem</code></p> <p>run host exerciser memory test</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set host exerciser tool log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>host exerciser tool time out, by default time out 60000</p> <p><code>-m,--mode</code></p> <p>host exerciser test modes are lpbk, read, write, trput</p> <p><code>--cls</code></p> <p>Number of cachelines per request 1, 2, 3, 4.</p> <p><code>--continuousmode</code></p> <p>Configures test rollover or test termination mode.</p> <p><code>--atomic</code></p> <p>atomic requests.</p> <p><code>--encoding</code></p> <p>select data mover mode or power user mode or random.</p> <p><code>-d,--delay</code></p> <p>Enables random delay insertion between requests.</p> <p><code>--interleave</code></p> <p>Enables interleave requests in throughput mode. Value:3'b000-Rd,Wr,Rd,Wr Value:3'b001-Rd,Rd,Wr,Wr Value:3'b010-Rd,Rd,Rd,Rd,Wr,Wr,Wr,Wr Value:3'b011-Not supported</p> <p><code>--interrupt</code></p> <p>Accelerator interrupt vector Number.</p> <p><code>--contmodetime</code></p> <p>Continuous mode time in seconds.</p> <p><code>--testall</code></p> <p>Run all host exerciser tests.</p> <p><code>--clock-mhz</code></p> <p>pcie clock frequency, default value 350Mhz.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#examples","title":"EXAMPLES","text":"<p>This command exerciser Loopback afu: <pre><code>host_exerciser lpbk\n</code></pre></p> <p>This command exerciser memory afu: <pre><code>host_exerciser mem\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0: <pre><code>host_exerciser --pci-address 000:3b:00.0    lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run in write mode: <pre><code>host_exerciser --pci-address 000:3b:00.0   --mode write lpbl\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run 2 cache lines per request: <pre><code>host_exerciser --pci-address 000:3b:00.0   --cls cl_2  lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run continuous mode for 10 seconds: <pre><code>host_exerciser --pci-address 000:3b:00.0   -cls cl_1   -m 0 --continuousmode true --contmodetime 10 lpbk\n</code></pre></p>"},{"location":"host-attach-util/hssi/hssi/","title":"hssi","text":""},{"location":"host-attach-util/hssi/hssi/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi COMMON_OPTIONS MODE MODE_OPTIONS</code></p>"},{"location":"host-attach-util/hssi/hssi/#description","title":"DESCRIPTION","text":"<p>The <code>hssi</code> application provides a means of interacting with the 10G, 100G, and 200G/400F HE-HSSI AFUs. In all operating modes, the application initializes the AFU and completes the desired transfer as described by the mode- specific options.</p> <p>COMMON_OPTIONS - application options common to the 10G, 100g, and 200G/400G modes.</p> <p><code>-h, --help</code></p> <pre><code>Display common command-line help and exit.\n</code></pre> <p><code>-p, --pci-address ADDR</code></p> <pre><code>The PCIe address of the desired accelerator in ssss:bb:dd.f format.\n</code></pre> <p><code>-s, --shared on|off</code></p> <pre><code>Whether to open the accelerator in shared mode. The default is off.\n</code></pre> <p><code>-t, --timeout VALUE</code></p> <pre><code>The application timeout value in milliseconds. The default timeout is 60000 msec.\n</code></pre> <p>MODE - select AFU. Valid values are hssi_10g, hssi_100g, hssi_200g_400g.</p> <p>MODE_OPTIONS [hssi_10g] - application options specific to the 10G AFU.</p> <p><code>-h, --help</code></p> <pre><code>Display 10G AFU specific command-line help and exit.\n</code></pre> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--random-length fixed|random</code></p> <pre><code>Specify packet length randomization. Valid values are fixed and\nrandom. The default is fixed (no randomization).\n</code></pre> <p><code>--random-payload incremental|random</code></p> <pre><code>Specify payload randomization. Valid values are incremental and\nrandom. The default is incremental.\n</code></pre> <p><code>--packet-length LENGTH</code></p> <pre><code>Specify packet length. The default is 64 bytes.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--rnd-seed0 SEED0</code></p> <pre><code>Specify the prbs generator bits [31:0]. The default is 1592590336.\n</code></pre> <p><code>--rnd-seed1 SEED1</code></p> <pre><code>Specify the prbs generator bits [47:32]. The default is 1592590337.\n</code></pre> <p><code>--rnd-seed2 SEED2</code></p> <pre><code>Specify the prbs generator bits [91:64]. The default is 155373.\n</code></pre> <p>MODE_OPTIONS [hssi_100g] - application options specific to the 100G AFU.</p> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--gap random|none</code></p> <pre><code>Inter-packet gap. Valid values are random and none. The default is none.\n</code></pre> <p><code>--pattern random|fixed|increment</code></p> <pre><code>Pattern mode. Valid values are random, fixed, or increment. The default\nis random.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--start-size SIZE</code></p> <pre><code>Specify the packet size in bytes, or the first packet size for --pattern increment.\n</code></pre> <p><code>--end-size SIZE</code></p> <pre><code>Specify the end packet size in bytes.\n</code></pre> <p><code>--end-select pkt_num|gen_idle</code></p> <pre><code>Specify packet generation end mode.\n</code></pre> <p>MODE_OPTIONS [pkt_filt_10g] - application options specific to the Packet Filter 10G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.0\n</code></pre> <p>MODE_OPTIONS [pkt_filt_100g] - application options specific to the Packet Filter 100G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.1\n</code></pre> <p>MODE_OPTIONS [hssi_200g_400g] - application options specific to the 200G/400G AFU.</p> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. Must be a multiple of 32. Default value is 32. Increasing the timeout (--timeout) may be necessary if specifying a large number of packets.\n</code></pre>"},{"location":"host-attach-util/hssi/hssi/#examples","title":"EXAMPLES","text":"<p><code>hssi -h</code> <code>hssi hssi_10g -h</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_10g --eth-loopback=on --num-packets=500</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_100g --pattern=increment</code> <code>sudo hssi --pci-address=0000:0d:00.6 hssi_200g_400g --num-packets=640000</code></p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/","title":"HSSI ethernet loopback","text":""},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssiloopback [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS] --loopback [{enable,disable}]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#description","title":"DESCRIPTION","text":"<p>The <code>hssiloopback</code>  tool enables and disable ethernet loopback.</p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p> <p><code>--loopback [{enable,disable}]</code></p> <p>Ethernet enable or disable loopback.</p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#examples","title":"EXAMPLES","text":"<p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback enable</code></p> <p>Enables ethernet loopback</p> <p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback disable</code></p> <p>Disable ethernet loopback</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/","title":"HSSI ethernet mac","text":""},{"location":"host-attach-util/hssi_ethernet/hssimac/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssimac [-h] --pcie-address PCIE_ADDRESS [--port PORT]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#description","title":"DESCRIPTION","text":"<p>The <code>hssimac</code>  tool provides Maximum TX and RX frame size.</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0).</p> <p><code>--port PORT</code></p> <p>hssi port number.</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#examples","title":"EXAMPLES","text":"<p><code>hssimac --pcie-address  0000:04:00.0 --port 1</code></p> <p>prints Maximum TX and RX frame size for port 1.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/","title":"HSSI ethernet statistics","text":""},{"location":"host-attach-util/hssi_ethernet/hssistats/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssistats [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#description","title":"DESCRIPTION","text":"<p>The <code>hssistats</code>  tool provides the MAC statistics.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#examples","title":"EXAMPLES","text":"<p><code>hssistats --pcie-address  0000:04:00.0</code></p> <p>prints the MAC statistics </p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/","title":"hssi_loopback","text":""},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#name","title":"NAME","text":"<p>hssi_loopback - Software utility to run HSSI loopback tests on FPGA</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi_loopback [[--bus|-b &lt;bus number&gt;] [--device | -d &lt;device number&gt;] [--function | -f &lt;function number&gt;]]|[--socket-id &lt;socket-id&gt;]       [--mode|-m auto|e40|e10]        [send [&lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]] |status [clear] | stop | readmacs</code></p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#description","title":"DESCRIPTION","text":"<p>The <code>hssi_loopback</code> utility works in conjunction with a packet generator accelerator function unit (AFU) to test high-speed serial interface (HSSI) cards. The <code>hssi_loopback</code> utility tests both external and internal loopbacks. <code>hssi_loopback</code> runs an external loopback test when the command line arguments include both source and destination ports. <code>hssi_loopback</code> runs an internal loopback test when command line arguments include a single port. <code>hssi_loopback</code> only runs on the Intel Xeon with Arria 10 FPGA. You cannot run it on the Intel PAC (programmable accelerator card).</p> <p>NOTE: The following limitations apply to the current version of hssi_loopback:</p> <ul> <li>For the external loopback the two port arguments can be the same. For the e10 design, the ports should be the same.</li> <li>The <code>hssi_loopback</code> test supports only the e40 and e10 E2E AFUs.  The e10 E2E AFU tests HSSI with a retimer card.</li> <li>The <code>hssi_loopback</code> test uses the control and status registers (CSRs) defined in the AFU.</li> </ul>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#options","title":"OPTIONS","text":"<p><code>-S SOCKET_ID, --socket-id SOCKET_ID</code></p> <p>Socket ID FPGA resource.</p> <p><code>-B BUS, --bus BUS</code></p> <p>Bus ID of FPGA resource.</p> <p><code>-D DEVICE, --device DEVICE</code></p> <p>Device ID of FPGA resource.</p> <p><code>-F FUNCTION, --function FUNCTION</code></p> <p>Function ID of FPGA resource.</p> <p><code>-G, --guid</code></p> <p>Specifies guid for the resource enumeration.</p> <p><code>-m, --mode</code></p> <p>One of the following: [<code>auto</code>, <code>e40</code>, <code>e10</code>] <code>auto</code> is the default and indicates that the software runs the mode based on the first accelerator functional unit it identifies.</p> <p><code>-t, --timeout</code></p> <p>Timeout (in seconds) before the application terminates in continuous mode. Continuous mode is the default when you do not specify the number of packets.</p> <p><code>-y, --delay</code></p> <p>Delay (in seconds) between printing out a simple status line. Default is 0.100 seconds (100 milliseconds).</p> <p><code>-c, --packet-count</code></p> <p>The number of packets to send.</p> <p><code>-d, --packet-delay</code></p> <p>The delay in between packets. This delay is the number of 100 MHz clock cycles, roughly 10 nanoseconds.</p> <p><code>-s, --packet-size</code></p> <p>The packet size to send. The minimum is 46 bytes and the maximum is 1500 bytes. The default is 46 bytes.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#commands","title":"COMMANDS","text":"<p><code>send &lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]</code></p> <p>Send packets from one port to the other. If the command line does not specify a destination port, the test runs an internal  loopback. Otherwise, the test runs an external loopback from the source port to the destination port.</p> <p><code>status [clear]</code></p> <p>Read and interpret the status registers and print to the screen. <code>clear</code> clears the status registers.</p> <p><code>stop</code></p> <p>Issue a stop command to all Ethernet controllers in the AFU.</p> <p><code>readmacs</code></p> <p>Read and display the port MAC addresses. An EEPROM stores the MAC addresses.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#exit-codes","title":"EXIT CODES","text":"<p>0    Success - Number of packets received are equal to the number of packets sent and no errors           are reported.</p> <p>-1    Loopback failure - Either number of packets does not match or the test detected errors.</p> <p>-2    Errors parsing arguments.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#examples","title":"EXAMPLES","text":"<p>Read the MAC addresses of the AFU loaded on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback readmacs -B 0x5e\n</code></pre> <p>Run an external loopback, sending 100 packets from port 0 to port 1. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 1 -c 100\n</code></pre> <p>Run an internal loopback until a timeout of 5 seconds is reached. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 -t 5\n</code></pre>"},{"location":"host-attach-util/mem_tg/mem_tg/","title":"mem_tg","text":""},{"location":"host-attach-util/mem_tg/mem_tg/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: mem_tg [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -g,--guid TEXT=4DADEA34-2C78-48CB-A3DC-5B831F5CECBB\n                              GUID\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=info\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mem-channel UINT=0     Target memory bank for test to run on (0 indexed)\n  --loops UINT=1              Number of read/write loops to be run\n  -w,--writes UINT=1          Number of unique write transactions per loop\n  -r,--reads UINT=1           Number of unique read transactions per loop\n  -b,--bls UINT=1             Burst length of each request\n  --stride UINT=1             Address stride for each sequential transaction\n  --data UINT:value in {fixed-&gt;0,prbs15-&gt;2,prbs31-&gt;3,prbs7-&gt;1,rot1-&gt;3} OR {0,2,3,1,3}=fixed\n                              Memory traffic data pattern: fixed, prbs7, prbs15, prbs31, rot1\n  -f,--mem-frequency UINT=0   Memory traffic clock frequency in MHz\nSubcommands:\n  tg_test                     configure &amp; run mem traffic generator test\n</code></pre>"},{"location":"host-attach-util/mem_tg/mem_tg/#description","title":"DESCRIPTION","text":"<p>The memory traffic generator (TG) used to exercise and test available memory channels with a configurable traffic pattern.</p> <p>Execution of this application requires the user to bind the specific VF endpoint containing the mem_tg AFU id to vfio-pci</p> <p>In the TG, read responses are checked against a specified pattern. If the application is configured to perform a read only test on a region of memory that has not previously been initialized to contain that pattern it will flag a test failure.</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set application log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>mem_tg application time out, by default time out 60000</p> <p><code>-m,--mem-channel</code></p> <p>Target memory bank for test to run on (0 indexed)  default: 0</p> <p><code>--loops</code></p> <p>Number of read/write loops to be run  default: 1</p> <p><code>-w,--writes</code></p> <p>Number of unique write transactions per loop.  default: 1</p> <p><code>-r,--reads</code></p> <p>Number of unique read transactions per loop  default: 1</p> <p><code>-b,--bls</code></p> <p>AXI4 burst length of each request.  Supports 1-256 transfers beginning from 0. default: 0</p> <p><code>--stride</code></p> <p>Address stride for each sequential transaction (&gt;= burst length)  default: 1</p> <p><code>--data</code></p> <p>Memory traffic data pattern. 0 = fixed {0xFF, 0x00} 1 = prbs7 2 = prbs15 3 = prbs31 4 = rot1</p> <p>default: fixed</p> <p><code>-f, --mem-frequency</code></p> <p>Memory traffic clock frequency in MHz  default: 300 MHz</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#examples","title":"EXAMPLES","text":"<p>This command will run a basic read/write test on the channel 0 traffic generator: <pre><code>mem_tg tg_test\n</code></pre></p> <p>This command will run the application for an afu on pcie 000:b1:00.7: <pre><code>mem_tg --pci-address 000:b1:00.7 tg_test\n</code></pre></p> <p>This command will test channel 2 write bandwidth: <pre><code>mem_tg -loops 1000 -w 1000 -r 0 -m 2 tg_test\n</code></pre></p> <p>This command will perform a read bandwidth test with a burst of 16 on channel 1 and perform a data comparison with the prbs7 pattern: <pre><code>mem_tg -loops 1000 -w 0 -r 1000 -b 0xF --data prbs7 -m 1 tg_test\n</code></pre></p> <p>This command will perform a read/write test with 1 MB strided access to channel 0 memory: <pre><code>mem_tg -loops 10000 --stride 0x100000 tg_test\n</code></pre></p>"},{"location":"host-attach-util/mmlink/mmlink/","title":"mmlink","text":""},{"location":"host-attach-util/mmlink/mmlink/#synopsis","title":"Synopsis","text":"<p><code>mmlink [-v] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;TCP port&gt;] [-I &lt;IP Address&gt;]</code></p>"},{"location":"host-attach-util/mmlink/mmlink/#description","title":"Description","text":"<p>The Remote Signal Tap logic analyzer provides real-time hardware debugging for the Accelerator Function Unit (AFU).  It provides a signal trace capability that the Quartus Prime software adds to the AFU. The Remote Signal Tap logic analyzer provides access to the Remote Signal Tap part of the Port MMIO space and then runs the remote protocol.</p>"},{"location":"host-attach-util/mmlink/mmlink/#examples","title":"Examples","text":"<p><code>./mmlink  -B 0x5e -P 3333</code></p> <p>MMLink app starts and listens for connection.</p>"},{"location":"host-attach-util/mmlink/mmlink/#options","title":"Options","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-S,--socket</code> </p> <p>FPGA socket number.</p> <p><code>-P,--port</code> </p> <p>TCP port number.</p> <p><code>-I,--ip</code> </p> <p>IP address of FPGA system. </p>"},{"location":"host-attach-util/mmlink/mmlink/#notes","title":"Notes","text":"<p>Driver privilege:</p> <p>Change AFU driver privilege to user:</p> <pre><code>$ chmod 777 /dev/intel-fpga-port.0\n</code></pre> <p>Change locked memory size:</p> <p>edit the file /etc/security/limits.conf</p> <pre><code>$ sudo vi /etc/security/limits.conf\n\nuser    hard   memlock           10000\n\nuser    soft   memlock           10000\n</code></pre> <p>Exit terminal and log into a new terminal.</p> <p>Verify that the locked memory is now set:  ``` $ ulimit -l 10000</p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/","title":"ofs.uio","text":""},{"location":"host-attach-util/ofs_uio/ofs_uio/#synopsis","title":"SYNOPSIS","text":"<p><code>ofs.uio [-h] [--pcie-address PCIE_ADDRESS] [--uio uiox] [--feature-id FEATURE_ID] [--region-index REGION_INDEX]                   [--mailbox-cmdcsr offset] [--bit-size {8,16,32,64}] [--peek offset] [--poke offset value]                   [--mailbox-read offset] [--mailbox-dump address size] [--mailbox-write address value]</code></p> <p><code>ofs.uio [--uio uiox] [--peek offset]</code> <code>ofs.uio [--uio uiox] [--poke offset value]</code> <code>ofs.uio [--uio uiox] [--mailbox-read address]</code> <code>ofs.uio [--uio uiox] [--mailbox-write address value]</code> <code>ofs.uio [--uio uiox] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#description","title":"DESCRIPTION","text":"<p><code>ofs.uio</code> is a tool that provides user space access to DFL UIO devices, command line options like peek, poke, mailbox-read, mailbox-write, mailbox-dump to  access Configuration and Status Registers (CSRs).</p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#options","title":"OPTIONS","text":""},{"location":"host-attach-util/ofs_uio/ofs_uio/#peek","title":"Peek","text":"<p>Peek/Read UIO CSR offset <code>ofs.uio [--uio uio] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#poke","title":"Poke","text":"<p>Poke/Write value to UIO CSR offset <code>ofs.uio [--uio uio] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-read","title":"Mailbox Read","text":"<p>Read CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-write","title":"Mailbox Write","text":"<p>Write value to CSR address using mailbox  <code>ofs.uio [--uio uio] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-dump","title":"Mailbox Dump","text":"<p>Reads/Dumps block size of CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#bit-size","title":"Bit size","text":"<p>Read/Write bit-field 8,16,32,64 sizes <code>ofs.uio [--uio uio] --bit-size 8 [--peek offset]</code> <code>ofs.uio [--uio uio] --bit-size 32 [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#pcie-address","title":"PCIe Address","text":"<p>PCIE_ADDR PCIe address of FPGA device <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#uio-region-index","title":"UIO region index","text":"<p>UIO region index, default region index is 0  <code>ofs.uio [--uio uio] --region-index 0 [--peek offset]</code> <code>ofs.uio [--uio uio] --region-index 1 [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-command-status-csr-offset","title":"Mailbox command status csr offset","text":"<p>Mailbox command status csr offset,  default value set to dfl pcie subsystem system feature mailbox command status register offset 0x28  <code>ofs.uio [--uio uio] --mailbox-cmdcsr 0xa8 [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] --mailbox-cmdcsr 0xa8  [--mailbox-read address]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#examples","title":"EXAMPLES","text":"<p>Peek/Read <pre><code>ofs.uio --uio uio0 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio6 --peek 0x0\npeek(0x0): 0x3000000100000020\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio0 --peek 0x0 --bit-size 32\npeek(0x0): 0x10002015\n</code></pre></p> <p>Poke/Write <pre><code>ofs.uio --uio uio6 --peek 0x8\npeek(0x8): 0x0\nofs.uio --uio uio6 --poke  0x8 0xabcdd12345\npoke(0x8):0xabcdd12345\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x8): 0x0\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --poke  0x8 0x1234\npoke(0x8):0x1234\n</code></pre></p> <p>Mailbox Read <pre><code>ofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --uio uio6 --mailbox-read 0x8\nMailboxRead(0x8): 0x110c000\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x8 \nMailboxRead(0x8): 0x110c000\n</code></pre></p> <p>Mailbox Write <pre><code>ofs.uio --uio uio6 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0):0x1234\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0 \nMailboxRead(0x0):0x1234\n</code></pre></p> <p>Mailbox Dump <pre><code>ofs.uio --uio uio6 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n</code></pre></p>"},{"location":"host-attach-util/opae_io/opae_io/","title":"opae.io","text":""},{"location":"host-attach-util/opae_io/opae_io/#synopsis","title":"SYNOPSIS","text":"<p><code>opae.io ls [-v,--viddid VIDDID] [-s,--sub-viddid SUB_VIDDID] [--all] [--system-class]</code> <code>opae.io init [-d,--device PCI_ADDR] [USER[:GROUP]]</code> <code>opae.io release [-d,--device PCI_ADDR]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] walk [--offset [OFFSET]] [-u,--show-uuid] [-D,--dump] [-c,--count COUNT] [-y,--delay DELAY] [-s,--safe]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] dump [--offset [OFFSET]] [-o,--output OUTPUT] [-f,--format {bin,hex}] [-c,--count COUNT]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] peek OFFSET</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] poke OFFSET VALUE</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] script SCRIPT ARG1 ARG2 ... ARGN</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION]</code></p>"},{"location":"host-attach-util/opae_io/opae_io/#description","title":"DESCRIPTION","text":"<p><code>opae.io</code> is an interactive Python environment packaged on top of <code>libopaevfio.so</code>, which provides user space access to PCIe devices via the vfio-pci driver. The main feature of opae.io is its built-in Python command interpreter, along with some Python bindings that provide a means to access Configuration and Status Registers (CSRs) that reside on the PCIe device.</p> <p><code>opae.io</code> has two operating modes: command line mode and interactive mode.</p>"},{"location":"host-attach-util/opae_io/opae_io/#command-line-mode","title":"COMMAND LINE MODE","text":"<p>To view the accelerator devices that are present on the system, <code>opae.io</code> provides the <code>ls</code> command option.</p> <p><code>opae.io ls [-v,--viddid VIDDID] [-s,--sub-viddid SUB_VIDDID] [--all] [--system-class]</code></p> <p>Each accelerator device is listed along with the PCIe address, the PCIe vendor/device ID, a brief description of the device, and the driver to which the device is currently bound.</p> <p>Device filtering is available by providing a Vendor ID:Device ID pair, eg -v 8086:bcce. Further filtering can be done by providing a sub- Vendor ID:sub-Device ID pair, eg -s 8086:1771. The --all option provides a list of all of the PCIe devices in the system, which an be quite verbose. The --system-class option prints the PCIe database class of the accelerator device, rather than the product name.</p> <p><code>opae.io</code> provides an option to initialize a PCIe device for use with the vfio-pci driver. In order for the device CSRs to be accessed from user space, the device must first be bound to the vfio-pci driver. This is the job of the <code>init</code> command option.</p> <p><code>opae.io init [-d,--device PCI_ADDR] [USER[:GROUP]]</code></p> <p>The <code>init</code> command unbinds the specified device from its current driver and binds it to vfio-pci. This creates a new vfio group under /dev/vfio. This group path is then used by the <code>libopaevfio.so</code> library to interact with the device.</p> <p>To release the PCIe device from vfio-pci and return it to use with its previous driver, the <code>release</code> command option is used.</p> <p><code>opae.io release [-d,--device PCI_ADDR]</code></p> <p>The <code>release</code> command option reverses the actions of the last <code>init</code> command, releasing the device from vfio-pci and binding it to the driver which was bound at the time the <code>init</code> command was issued.</p> <p>The <code>walk</code> command option traverses and displays the Device Feature List of the given region.</p> <p><code>opae.io walk [--offset [OFFSET]] [-u,--show-uuid] [-D,--dump] [-c,--count COUNT] [-y,--delay DELAY] [-s,--safe]</code></p> <p>The various fields of each Device Feature Header are displayed. The <code>--show-uuid</code> option additionally displays the GUID for each feature. OFFSET can be used to specify the beginning of the DFL in the MMIO region. --dump displays the raw DFH contents in hex format. COUNT limits the number of DFH entries traversed. DELAY causes a pause between each printout. --safe examines each DFH offset for proper alignment.</p> <p>The <code>dump</code> command provides a means to dump the MMIO space in ASCII hex or binary format.</p> <p><code>opae.io dump [--offset [OFFSET]] [-o,--output OUTPUT] [-f,--format {bin,hex}] [-c,--count COUNT]</code></p> <p>OFFSET specifies the starting MMIO offset. OUTPUT gives the name of a file to capture the dump output, where sys.stdout is used by default. --format allows changing the output format. COUNT specifies the number of qwords to dump.</p> <p>The <code>peek</code> command option reads and displays a CSR value.</p> <p><code>opae.io peek OFFSET</code></p> <p>The <code>poke</code> command option writes a given value to a CSR.</p> <p><code>opae.io poke OFFSET VALUE</code></p> <p><code>opae.io</code> can also execute Python scripts from the command line. These Python scripts may contain calls to the device built-in functions that are available during an interactive session. Refer to the description of interactive mode for details.</p> <p><code>opae.io script myscript.py a b c</code></p> <p>In order to enter the interactive mode of <code>opae.io</code>, simply invoke it and optionally pass the desired device address and MMIO region options.</p> <p><code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION]</code></p>"},{"location":"host-attach-util/opae_io/opae_io/#interactive-mode","title":"INTERACTIVE MODE","text":"<p>Upon entering interactive mode, <code>opae.io</code> begins a Python interpreter session and displays the command prompt shown below:</p> <p>0000:3f:00.0[0]&gt;&gt;</p> <p>The first portion of the prompt shows the address of the active PCIe device, here 0000:3f:00.0. The part in square brackets shows the active MMIO region, here [0].</p> <p>The interpreter waits for a valid Python command, then attempts to execute the given command in the usual way. The only differences between the traditional Python command intepreter and <code>opae.io</code> are that opae.io provides 1) the notion of an active PCIe device and MMIO region and 2) several built-in functions and objects that allow manipulating the active device and MMIO region.</p>"},{"location":"host-attach-util/opae_io/opae_io/#built-in-functions","title":"BUILT-IN FUNCTIONS","text":"<p>The <code>opae.io</code> built-in functions assume an active device and MMIO region. Attempting to use the built-in functions without first opening a device and region will result in errors.</p> <p><code>peek(OFFSET)</code></p> <p>The <code>peek</code> built-in function reads and displays a CSR value from the active device and region, at the offset supplied by its argument.</p> <p>0000:3f:00.0[0]&gt;&gt; peek(0x28) 0xdeadbeef</p> <p><code>poke(OFFSET, VALUE)</code></p> <p>The <code>poke</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; poke(0x28, 0xdeadbeef)</p> <p><code>read_csr(OFFSET)</code></p> <p>The <code>read_csr</code> built-in function returns the value of the CSR at the active MMIO region and the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; print('0x{:0x}'.format(read_csr(0x28))) 0xdeadbeef</p> <p><code>write_csr(OFFSET, VALUE)</code></p> <p>The <code>write_csr</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; write_csr(0x28, 0xdeadbeef)</p> <p><code>device(PCI_ADDR)</code></p> <p>The <code>device</code> built-in function allows changing the active PCIe device.</p> <p>0000:3f:00.0[0]&gt;&gt; device('0000:2b:00.0') 0000:2b:00.0&gt;&gt;</p> <p><code>region(REGION)</code></p> <p>The <code>region</code> built-in function allows changing the active MMIO region.</p> <p>0000:2b:00.0&gt;&gt; region(0) 0000:2b:00.0[0]&gt;&gt;</p> <p><code>allocate_buffer(SIZE)</code></p> <p>The <code>allocate_buffer</code> built-in function creates and returns a DMA buffer object. The underlying buffer will be SIZE bytes in length.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = allocate_buffer(4096) 0000:2b:00.0[0]&gt;&gt; print(b1.size, '0x{:0x}'.format(b1.address), b1.io_address) 4096 0x7f9361c66000 0</p> <p><code>version()</code></p> <p>The <code>version</code> built-in function returns a tuple containing the four components used to identify the opae.io version:</p> <p>0000:2b:00.0[0]&gt;&gt; print(version()) ('opae.io', 0, 2, 0)</p>"},{"location":"host-attach-util/opae_io/opae_io/#built-in-objects","title":"BUILT-IN OBJECTS","text":"<p><code>opae.io</code> interactive mode provides two global objects corresponding to the current device and that device's current MMIO region. These objects are referred to by global variables <code>the_device</code> and <code>the_region</code>, respectively.</p> <p>The <code>device</code> class:</p> <p>the_device.descriptor() : method that returns the integer file descriptor of the <code>VFIO container</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.descriptor()) 5</p> <p>the_device.repr() : method that is invoked when a <code>device</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device) 0000:2b:00.0</p> <p>the_device.allocate(SIZE) : method that allocates and returns a <code>system_buffer</code> object. The buffer will be mapped into the DMA space of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = the_device.allocate(4096)</p> <p>the_device.pci_address() : read-only property that returns the PCIe address of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.pci_address) 0000:2b:00.0</p> <p>the_device.num_regions : read-only property that returns the number of MMIO regions in <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.num_regions) 2</p> <p>the_device.regions : read-only property that returns a list of the active MMIO regions of <code>the_device</code>:</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.regions) [0, 2]</p> <p>The <code>region</code> class:</p> <p>the_region.write32(OFFSET, VALUE) : method that writes a 32-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read32(OFFSET) : method that returns a 32-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write32(0x28, 0xdeadbeef) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read32(0x28))) 0xdeadbeef</p> <p>the_region.write64(OFFSET, VALUE): method that writes a 64-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read64(OFFSET): method that returns a 64-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write64(0x28, 0xbaddecaf) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read64(0x28))) 0xbaddecaf</p> <p>the_region.index(): method that returns the MMIO index of <code>the_region</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region.index()) 0</p> <p>the_region.repr(): method that is invoked when a <code>region</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region) 0</p> <p>the_region.len(): method that is invoked to determine the MMIO region size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(len(the_region)) 524288</p> <p>The <code>allocate_buffer()</code> built-in function and the <code>device.allocate()</code> method return objects of type <code>system_buffer</code>.</p> <p>The <code>system_buffer</code> class is as follows:</p> <p><code>buf.size</code>: read-only property that gives the buffer size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(b1.size) 4096</p> <p><code>buf.address</code>: read-only property that gives the buffer's user mode virtual address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.address)) 0x7f2c15d8200</p> <p><code>buf.io_address</code>: read-only property that gives the buffer's IO address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.io_address)) 0x0</p> <p><code>buf.__getitem__</code> and <code>buf.__setitem__</code>: indexing get/set of 64-bit data item.</p> <p>0000:2b:00.0[0]&gt;&gt; b1[0] = 0xdecafbad 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1[0])) 0xdecafbad</p> <p><code>buf.read8(OFFSET)</code> <code>buf.read16(OFFSET)</code> <code>buf.read32(OFFSET)</code> <code>buf.read64(OFFSET)</code> : methods that read the given size data item from the given buffer OFFSET.</p> <p><code>buf.fill8(VALUE)</code> <code>buf.fill16(VALUE)</code> <code>buf.fill32(VALUE)</code> <code>buf.fill64(VALUE)</code> : methods that fill the buffer with the given VALUE, using the given size.</p> <p><code>b1.compare(b2)</code>: method that compares buffers. The method returns the index of the first byte that miscompares, or the length of b1.</p>"},{"location":"host-attach-util/opaeuio/opaeuio/","title":"opaeuio","text":""},{"location":"host-attach-util/opaeuio/opaeuio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaeuio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-v] [device]</code></p>"},{"location":"host-attach-util/opaeuio/opaeuio/#description","title":"DESCRIPTION","text":"<p>The <code>opaeuio</code> command enables the binding/unbinding of a DFL device to/from the dfl-uio-pdev device driver. See https://kernel.org/doc/html/v4.14/driver-api/uio-howto.html for a description of uio.</p>"},{"location":"host-attach-util/opaeuio/opaeuio/#options","title":"OPTIONS","text":"<p><code>device</code>     The DFL device name, eg dfl_dev.10</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given device for uio.\nUsed in conjunction with -u, -g, and -d.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given device from uio.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when binding to uio.\nThe default value is dfl-uio-pdev.\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to uio. A new device node is created in\n/dev when the device is bound to uio. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to uio. Use this option to specify the\nnew device group for the device created in /dev.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/opaeuio/opaeuio/#examples","title":"EXAMPLES","text":"<p><code>opaeuio -h</code> <code>opaeuio -v</code> <code>sudo opaeuio -i -u lab -g labusers dfl_dev.10</code> <code>sudo opaeuio -r dfl_dev.10</code></p>"},{"location":"host-attach-util/opaevfio/opaevfio/","title":"opaevfio","text":""},{"location":"host-attach-util/opaevfio/opaevfio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaevfio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-n] [-v] [addr]</code></p>"},{"location":"host-attach-util/opaevfio/opaevfio/#description","title":"DESCRIPTION","text":"<p>The <code>opaevfio</code> command enables the binding/unbinding of a PCIe device to/from the vfio-pci device driver. See https://kernel.org/doc/Documentation/vfio.txt for a description of vfio-pci.</p>"},{"location":"host-attach-util/opaevfio/opaevfio/#options","title":"OPTIONS","text":"<p><code>addr</code>     The PCIe address of the device in ssss:bb:dd.f format, eg 0000:7f:00.0</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given addr for vfio.\nUsed in conjunction with -u, -g, and -n.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given addr from vfio.\nUsed in conjunction with -d.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when releasing from vfio.\nWhen omitted, the device is not rebound to a driver (default).\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to vfio. A new device node is created in\n/dev/vfio when the device is bound to vfio-pci. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to vfio. Use this option to specify the\nnew device group for the device created in /dev/vfio.\n</code></pre> <p><code>-n, --no-sriov</code></p> <pre><code>Do not enable SR-IOV when binding to vfio. The default value for this option\nis FALSE, ie the script should specify SR-IOV functionality when binding to\nthe vfio-pci driver. When omitted, the modprobe command which loads the vfio-pci\ndriver will contain the `enable_sriov=1` option. When given, it will not.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/opaevfio/opaevfio/#examples","title":"EXAMPLES","text":"<p><code>opaevfio -h</code> <code>opaevfio -v</code> <code>sudo opaevfio -i -u lab -g labusers 0000:7f:00.0</code> <code>sudo opaevfio -r 0000:7f:00.0</code></p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/","title":"pac_hssi_config","text":"<pre><code># pac_hssi_config #\n\n## SYNOPSIS ##\n```console\npac_hssi_config.py [-h] subcommand [subarg] [bdf]\n</code></pre>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#description","title":"DESCRIPTION","text":"<p>The <code>pac_hssi_config.py</code> tool exercises the Ethernet 10 Gbps (10GbE) and 40GbE transceivers for designs using the Intel\u00ae Programmable Acceleration Card (PAC) with Intel Arria\u00ae 10 GX FPGA. This tool does not support the  Intel Xeon\u00ae Processor with Integrated FPGA. </p> <p></p> <p>The two required arguments to the <code>pac_hssi_config.py</code> tool specify the subcommand and bus, device, and function (BDF) for the PCIe device under test. You must provide the BDF parameter for systems with more than one PCIe card. </p> <pre><code>.. note::\n    If you do not provide the BDF when required, the command prints a list of valid BDFs for the system. You can also\n    determine the BDF using the ``lspci`` command.\n</code></pre> <p>For usage help, type the following at a command prompt:</p> <p><code>pac_hssi_config.py [-h|--help]</code></p> <p>To configure the network ports, send data, and read statistics, use the following form of the <code>pac_hssi_config.py</code> script:</p> <p><code>pac_hssi_config.py subcommand [subarg] [bdf]</code></p> <p>Only a subset of subcommand arguments support <code>subarg</code>. </p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-1-general-subcommands","title":"Table 1. General Subcommands","text":"Subcommand Subarg Description <code>stat</code> N/A Prints high speed serial interface (HSSI) controller statistics. <code>eeprom</code> N/A Reads the 128-bit unique board ID, MAC address, and board-specific IDs from EEPROM."},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-2-1040-gbe-traffic-generation-subcommands","title":"Table 2. 10/40 GbE Traffic Generation Subcommands","text":"Subcommand Subarg Description <code>e10init</code> and <code>e40init</code> N/A Initializes HSSI PHY to 10GbE or 40GbE mode.  Clears statistics and enable internal HSSI transceiver loopback. <code>e10loop</code> and <code>e40loop</code> On/Off Turns on or off internal HSSI transceiver loopback. <code>e10reset</code> and <code>e40reset</code> On/Off Asserts or deasserts AFU reset.  Clears packet statistics and disables internal HSSI transceiver loopback. <code>e10send</code> and <code>e40send</code> N/A Sends 1,000,000 1500-byte packets. For 10GbE sends packets on all four ports. 40GbE has a single port. <code>e10stat</code> and <code>e40stat</code> N/A Prints packet statistics. <code>e10statclr</code> and <code>e40statclr</code> N/A Clears packet statistics.  Use this command after switching loopback modes to clear any transient statistics accumulated during the mode switch. <p>The transceiver equalization <code>eqwrite</code> and <code>eqread</code> subcommands write and read transceiver equalization settings.  These subcommands require you to specify the transceiver channel, the equalization setting, and the value (for writes).  Use the following form for the <code>eqwrite</code> command:</p> <p><code>pac_hssi_config.py eqwrite [transceiver channel number] [equalization setting] [equalization value] [bdf]</code></p> <p>Use the following form for the <code>eqread</code>command:</p> <p><code>pac_hssi_config.py eqread [transceiver channel number] [equalization setting] [bdf]</code> </p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-3-transceiver-equalization-subcommands","title":"Table 3. Transceiver Equalization Subcommands","text":"Subcommand Channel Number Equalization Setting Value <code>eqwrite</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) Specifies the value for the specified equalization setting. <code>eqread</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) N/A <p>For more information about reconfiguring transceiver analog parameter settings In Arria\u00ae 10 devices, refer to \"Changing PMA Analog Parameters\" in the  Intel\u00ae Arria\u00ae 10 Transceiver PHY User Guide.</p>"},{"location":"host-attach-util/packager/packager/","title":"packager","text":""},{"location":"host-attach-util/packager/packager/#synopsis","title":"SYNOPSIS","text":"<p><code>packager &lt;cmd&gt; [arguments]</code></p>"},{"location":"host-attach-util/packager/packager/#description","title":"Description","text":"<p>The packager provides tools that Accelerator Functional Unit (AFU) developers use to create Accelerator Function (AF)  files. The AF file is the programming file for an AFU on Intel\u00ae FPGA platforms. The packager tool concatenates the metadata from the JSON file to a raw binary file <code>(.rbf)</code> that the Intel Quartus\u00ae Prime software generates. </p> <p>The packager's only function is to create an AF file. Refer to Packager Command Syntax for more information about invoking the packager. The packager depends on a JSON file to describe AFU metadata. Refer to  Accelerator Description File for more information about the JSON file.</p> <p>The packager requires Python 2.7.1 and Python 2.7.3. The tool indicates if it is being called with a compatible  of Python.</p>"},{"location":"host-attach-util/packager/packager/#packager-command-syntax","title":"Packager Command Syntax","text":"<p>The packager is a command line tool with the following syntax:</p> <p><code>$ packager &lt;cmd&gt; [arguments]</code></p> <p>The following table describes the <code>&lt;CMD&gt;</code> arguments:</p> Command Arguments Description <code>create-gbs</code> <code>--rbf=&lt;RBF_PATH&gt;</code> <code>--afu=&lt;AFU_JSON_PATH&gt;</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> Creates the AF file. The engineering name for this file is the green bit stream, abbreviated gbs. The <code>--rbf</code> and <code>--afu</code>   arguments are required.  <code>&lt;RBF_PATH&gt;</code> is the path to the RBF file for the AFU. The Quartus\u00ae Prime software generates this RBF by compiling the AFU design. <code>&lt;AFU_JSON_PATH&gt;</code> is the path to the Accelerator Description file. This is a JSON file that describes the metadata that <code>create-gbs</code> appends to the RBF. <code>&lt;GBS_PATH&gt;</code> is the path to the RBF file for the FPGA Interface Manager (FIM) that contains the FPGA interface unit and other interfaces. If you do not specify the <code>--gbs</code>, the command defaults to <code>&lt;rbf_name&gt;.gbs</code>. You can use the optional <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>modify-gbs</code> <code>--gbs=&lt;gbs_PATH&gt;</code> Modifies the AF file. The <code>--input-gbs</code>argument is required. If you do not provide the <code>--output-gbs</code> argument, <code>modify-gbs</code> overwrites the <code>--input-gbs</code> file. Use the <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>gbs-info</code> <code>--input-gbs=&lt;gbs_PATH&gt;</code> Prints information about the AF file. The <code>--input-gbs</code> argument is required. <code>get-rbf</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--rbf=&lt;RBF_PATH&gt;</code> Creates the RBF by extracting it from the AF file. The <code>--gbs</code>argument is required. If you do not specify the <code>--rbf</code> argument, the command defaults to <code>&lt;gbs_name.rbf</code> . None, or any <code>&lt;CMD&gt;</code> <code>--help</code> Summarizes the <code>&lt;CMD&gt;</code> options. Typing <code>packager --help</code> gives a list of <code>&lt;CMD&gt;</code> values. Typing <code>packager &lt;CMD&gt; --help</code> provides detailed help for <code>&lt;CMD&gt;</code>"},{"location":"host-attach-util/packager/packager/#examples","title":"Examples","text":"<p>To generate an AF file, run:</p> <p><code>$ packager create-gbs --rbf=&lt;RBF_PATH&gt; --afu=&lt;AFU_JSON_PATH&gt; --gbs=&lt;GBS_PATH&gt;</code></p> <p>TIP: JSON files are very particular about syntax such as trailing commas. If you are getting errors, use <code>jsonlint.com</code> to validate that your JSON is formatted correctly. </p> <p>To modify metadata in an existing AF, run the following command:</p> <p><code>$ packager modify-gbs --input-gbs=&lt;PATH_TO_GBS_TO_BE_MODIFIED&gt; --outputgbs=&lt;NAME_FOR_NEW_GBS&gt; --set-value &lt;key&gt;:&lt;value&gt;</code></p> <p>You can pass in a number of : pairs with --set-value to update values in an AF.  <p>To print the metadata of an existing AF: </p> <p><code>$ packager get-info --gbs=&lt;GBS_PATH&gt;</code> </p> <p>To extract the RBF from the AF:</p> <p><code>$ packager get-rbf --gbs=&lt;GBS_PATH&gt; --rbf=&lt;NAME_FOR_RBF&gt;</code></p>"},{"location":"host-attach-util/packager/packager/#accelerator-description-file","title":"Accelerator Description File","text":"<p>The Accelerator Description File is a JSON file that describes the metadata associated with an AFU. The Open Progammable Accelerator Engine (OPAE) uses this metadata during reconfiguration. Here is an example file:</p> <p><pre><code>{\n   \"version\": 1,\n   \"platform-name\": \"DCP\",\n   \"afu-image\": {\n      \"magic-no\": 488605312,\n      \"interface-uuid\": \"01234567-89AB-CDEF-0123-456789ABCDEF\",\n      \"power\": 0,\n      \"accelerator-clusters\": [{\n         \"name\": \"dma_test_afu\",\n         \"total-contexts\": 1,   \n         \"accelerator-type-uuid\": \"331DB30C-9885-41EA-9081-F88B8F655CAA\"\n      }\n      ]  \n   }\n}\n</code></pre> The packager stores these parameter values in the resultant AF. After reprogramming the AFU using partial reconfiguration (PR), the  software driver reconfigures the PLLs by writing the clock-frequency-high and clock-frequency-low values (if present) over the  PCIe\u00ae and CCI interfaces. </p> <p>.. note:: <pre><code>The JSON file format may change as the architecture evolves. Any changes to the current format trigger an update\nto the version number.  \n</code></pre></p> <p>CATEGORY | NAME | TYPE | DESCRIPTION | MANDATORY ---------|------|------|-------------|:----------:| Per-AFU  | version | Integer | Version of the metadata format. | Yes Per-AFU  | magic-no (to be deprecated)| Integer | Magic no. Associated with the FPGA Interface Manager. | No Per-AFU  | platform-name | String | Name of the platform for which the metadata is intended. The field value is \u201cDCP\u201d for Intel  Acceleration Stack for FPGAs. | No Per-AFU  | interface-uuid | UUID | Interface id associated with the FPGA Interface Manager. | Yes Per-AFU  | power | Integer | Accelerator Function power consumption, in watts. Set to 0 for Intel Acceleration Stack for FPGAs platforms. | Yes Per-AFU  | clock-frequency-low | Float | Clock frequency for 1st PLL (Clock network)1 in MHz. | No Per-AFU  | clock-frequency-high | Float | Clock frequency for 2nd PLL (0 if absent) in MHz. | No Per-AFC Cluster | total-contexts | Integer | Number of AFCs in this cluster. Always be 1 in current architectures. | Yes Per-AFC Cluster | afc-type-uuid |  UUID | AFC type = AFU ID in current architectures. | Yes Per-AFC Cluster | name | string | AFC name = AFU name in current architectures. | Yes</p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"host-attach-util/pci_device/pci_device/","title":"pci_device","text":""},{"location":"host-attach-util/pci_device/pci_device/#synopsis","title":"SYNOPSIS","text":"<p><code>pci_device [-h] [-E] device-filter [{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}]</code></p>"},{"location":"host-attach-util/pci_device/pci_device/#description","title":"DESCRIPTION","text":"<p>pci_device is a tool to aid in common operations for managing PCIe devices and drivers.</p>"},{"location":"host-attach-util/pci_device/pci_device/#options","title":"OPTIONS","text":""},{"location":"host-attach-util/pci_device/pci_device/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<pre><code>`device filter`\n\nPCIe address of a device or vendor/device ID pair.\nThe PCIe address follows the format of [segment:]bus:device.function\nwhile the vendor/device ID pair follows the format [vendor ID]:[device ID]\nwhere at least one of these must be present.\n\n`{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}`\n\naction to perform on device\n\n`aer`\nPerform AER (Advanced Error Reporting) operations.\nThe aer action has its own sub-commands which are listed below:\n\n* `dump` sub-command will print out the AER error counters as reported\n   by the sysfs files for the device.\n* `mask` can either print out the current AER mask bits or set them\n  * If `show` or `print` (or nothing) is given after the `mask`\n    command, it will show the current mask bits for AER.\nBy default output will be written in stdout but can be written to an\noutput file if `-o|--output FILENAME` argument is given.\n  * If `all` is given after the `mask` command, it will mask all bits\n    (by setting the values to 0xffffffff and 0xffffffff).\n  * If `off` is given after the `mask` command, it will unmask all\n    bits (by setting the values to 0x0 and 0x0).\n  * If two numbers are present after the `mask` command, those two\n    numbers will be used to set the mask bits.\nValues for setting the mask can also be read in from an input file if\n`-i|--input FILENAME` argument is given.\n\n_NOTE_: mask related operations require root privileges\n\n`bind`\n\nAssociate a device with its driver.\n\n`plug`\n\nRestore a device that was previously given to `pci_device &lt;device&gt; unplug`\n\n`remove`\n\nRemove the pci device from the pci bus\n\n`rescan`\n\nRescan the bus as identified by the bus component of the PCIe device address\n\n'topology`\n\nPrint the PCIe topology from the root port to the PCIe device.\nThis shows the PCIe tree rooted at the PCIe root port.\nEach line shows the the PCIe address, vendor ID, and device ID along with\nthe driver bound to the device. The indentation is used to show\nparent/child relationship of devices.\n\nThe line listing the target PCIe device as identified by the given PCIe\naddress will be highlighted in green while the endpoints will be\nhighlighted in cyan.\n\nThe example below shows the topology of an N3000 device with eight virtual\nfunctions created from one of the Ethernet controllers:\n\n```console\n[pci_address(0000:3a:00.0), pci_id(0x8086, 0x2030)] (pcieport)\n    [pci_address(0000:3b:00.0), pci_id(0x10b5, 0x8747)] (pcieport)\n        [pci_address(0000:3c:09.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3f:00.0), pci_id(0x8086, 0x0b30)] (dfl-pci)\n        [pci_address(0000:3c:11.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:43:00.0), pci_id(0x8086, 0x0b32)] (no driver)\n    [pci_address(0000:3c:08.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3d:02.0), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.7), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.5), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.3), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.1), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.6), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.4), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.2), pci_id(0x8086, 0x154c)] (iavf)\n        [pci_address(0000:3c:10.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:41:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:41:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n\n```\n\n`unbind`\n\nUnbind the driver bound to the device.\n\n`unplug`\n\nRemove device from PCI bus in anticipation of a RSU event by configuring its root port and associated endpoints.\n\n`vf`\n\nCreate/destroy VFs (virtual functions) by setting the number here.\nThe number given here will be written to sriov_numvfs sysfs file triggering\nthe PCIe subsystem to create/destroy VFs so that the current number of VFs\nwill be equal to the given number. If the number given is outside of the total VFs supported, an error message will be displayed to indicate this.\n</code></pre>"},{"location":"host-attach-util/pci_device/pci_device/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<pre><code>`-h, --help`\n\nshow this help message and exit\n\n`-E, --other-endpoints`\n\nperform action on peer PCIe devices\n</code></pre>"},{"location":"host-attach-util/pci_device/pci_device/#examples","title":"EXAMPLES","text":"<pre><code>pci_device 0000:3d:00.0 remove\npci_device 0000:3d:00.0 rescan\npci_device 3d:00.0 topology\npci_device :0b30 topology\npci_device :0b30 aer\npci_device :0b30 aer mask\npci_device :0b30 aer mask all\npci_device :0b30 aer mask -o mask.dat\npci_device :0b30 aer mask -i mask.dat\n</code></pre>"},{"location":"host-attach-util/rsu/rsu/","title":"rsu","text":""},{"location":"host-attach-util/rsu/rsu/#synopsis","title":"SYNOPSIS","text":"<pre><code>rsu [-h] [-d] {bmc,bmcimg,retimer,fpga,sdm,fpgadefault} [PCIE_ADDR]\n</code></pre>"},{"location":"host-attach-util/rsu/rsu/#description","title":"DESCRIPTION","text":""},{"location":"host-attach-util/rsu/rsu/#mode-1-rsu","title":"Mode 1: RSU","text":"<pre><code>rsu bmc --page=(user|factory) [PCIE_ADDR]\nrsu retimer [PCIE_ADDR]\nrsu fpga --page=(user1|user2|factory) [PCIE_ADDR]\nrsu sdm --type=(sr|pr|sr_cancel|pr_cancel) [PCIE_ADDR]\n</code></pre> <p>Perform RSU (remote system update) operation on PAC device given its PCIe address. An RSU operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either BMC, Retimer, SDM, (on devices that support these) or the FPGA.</p>"},{"location":"host-attach-util/rsu/rsu/#mode-2-default-fpga-image","title":"Mode 2: Default FPGA Image","text":"<pre><code>rsu fpgadefault --page=(user1|user2|factory) --fallback=&lt;csv&gt; [PCIE_ADDR]\n</code></pre> <p>Set the default FPGA boot sequence. The --page option determines the primary FPGA boot image. The --fallback option allows a comma-separated list of values to specify fallback images.</p>"},{"location":"host-attach-util/rsu/rsu/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{bmc,bmcimg,retimer,fpga,sdm,fpgadefault}</code></p> <p>type of RSU operation or set Default FPGA Image operation.</p> <p><code>PCIE_ADDR</code>  PCIe address of device to do rsu (e.g. 04:00.0 or 0000:04:00.0) </p>"},{"location":"host-attach-util/rsu/rsu/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code> show this help message and exit</p> <p><code>-d, --debug</code> log debug statements</p> <p><code>--force</code> force rsu operation</p>"},{"location":"host-attach-util/rsu/rsu/#example","title":"EXAMPLE","text":"<pre><code># rsu bmc --page=user 25:00.0\n</code></pre> <p>Triggers a boot of the BMC image (user page) for the device with PCIe  address 25:00.0.</p> <pre><code># rsu bmc --page=factory 25:00.0\n</code></pre> <p>Triggers a factory boot of the BMC image for the device with  PCIe address 25:00.0.</p> <pre><code># rsu fpga --page=user2 25:00.0\n</code></pre> <p>Triggers a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0.</p> <pre><code># rsu --force fpga --page=user2 25:00.0\n</code></pre> <p>Forces a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0. Default behavior is to not perform  the rsu operation if DPC (downstream port containment) is not supported  and AER (advanced error reporting) is also not supported. Using --force  changes this behavior to perform rsu operation regardless but may result  in a surprise removal of pci devices which may cause the Linux kernel  to panic.</p> <pre><code># rsu fpga --page=factory 25:00.0\n</code></pre> <p>Triggers a factory reconfiguration of the FPGA for the device  with PCIe address 25:00.0.</p> <pre><code># rsu sdm --type=sr 25:00.0\n</code></pre> <p>Triggers Static Region key programming for the device with  PCIE address 25:00.0.</p> <pre><code># rsu fpgadefault --page=factory --fallback=user1,user2 25:00.0\n</code></pre> <p>Sets the FPGA boot sequence to factory with fallbacks user1, user2.</p>"},{"location":"host-attach-util/userclk/userclk/","title":"userclk","text":""},{"location":"host-attach-util/userclk/userclk/#synopsis","title":"SYNOPSIS","text":"<p><code>userclk [-hv] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] [-H &lt;User clock high frequency&gt;] -L &lt;User clock low frequency&gt;]</code></p>"},{"location":"host-attach-util/userclk/userclk/#description","title":"DESCRIPTION","text":"<p>userclk sets the frequency range for an AFU. </p>"},{"location":"host-attach-util/userclk/userclk/#examples","title":"EXAMPLES","text":"<p><code>./userclk -B 0x5e -H 400 -L 200</code></p> <p>Sets AFU frequency.</p>"},{"location":"host-attach-util/userclk/userclk/#options","title":"OPTIONS","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-S,--segment</code> </p> <p>FPGA segment number.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-H,--freq-high</code> </p> <p>User clock high frequency. </p> <p><code>-L,--freq-low</code> </p> <p>User clock low frequency. </p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"host-attach-util/vabtool/vabtool/","title":"vabtool","text":""},{"location":"host-attach-util/vabtool/vabtool/#synopsis","title":"SYNOPSIS","text":"<p><code>vabtool [-r RETRIES] [-d] [-y] [-v] &lt;ACTION&gt;</code></p> <p>Where ACTION is defined as one of the following:</p> <p><code>vabtool sr_key_provision PCIE_ADDRESS SR_RKH_FILE FPGA_IMG_FILE</code> <code>vabtool sr_status PCIE_ADDRESS</code> <code>vabtool pr_key_provision PCIE_ADDRESS PR_AUTH_CERT_FILE PR_RKH_FILE</code> <code>vabtool pr_status PCIE_ADDRESS</code> <code>vabtool sr_key_cancel PCIE_ADDRESS SR_RKH_CANCEL_FILE</code> <code>vabtool sr_cancel_status PCIE_ADDRESS</code> <code>vabtool pr_key_cancel PCIE_ADDRESS PR_RKH_CANCEL_FILE</code> <code>vabtool pr_cancel_status PCIE_ADDRESS</code></p>"},{"location":"host-attach-util/vabtool/vabtool/#description","title":"DESCRIPTION","text":"<p>The <code>vabtool</code> command helps perform Vendor Authenticated Boot provisioning of Static Region and Partial Reconfiguration Region key hashes and helps perform SR and PR hash cancellation and status reporting.</p>"},{"location":"host-attach-util/vabtool/vabtool/#options","title":"OPTIONS","text":"<p><code>-r RETRIES, --retries RETRIES</code></p> <pre><code>Specifies the number of times a failed SR or PR key provision is to be\nretried. The default value for RETRIES is 3.\n</code></pre> <p><code>-d, --dry-run</code></p> <pre><code>Don't execute the actual fpgasupdate and rsu commands, but only print\nthe commands that would be executed during a normal run of the script.\n</code></pre> <p><code>-y, --yes</code></p> <pre><code>The tool will respond with an automatic Yes answer to all confirmation\nprompts posed by the sub-tools.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/vabtool/vabtool/#examples","title":"EXAMPLES","text":"<p><code>sudo vabtool -y sr_key_provision 0000:bc:00.0 my_sr_rkh.bin my_fpga.bin</code> <code>sudo vabtool sr_status 0000:bc:00.0</code> <code>sudo vabtool -y pr_key_provision 0000:bc:00.0 pr_auth_cert.bin my_pr_rkh.bin</code> <code>sudo vabtool pr_status 0000:bc:00.0</code> <code>sudo vabtool sr_key_cancel 0000:bc:00.0 my_sr_rhk_cancel.bin</code> <code>sudo vabtool sr_cancel_status 0000:bc:00.0</code> <code>sudo vabtool pr_key_cancel 0000:bc:00.0 my_pr_rhk_cancel.bin</code> <code>sudo vabtool pr_cancel_status 0000:bc:00.0</code></p>"},{"location":"linux-dfl/dfl/dfl/","title":"Device Feature List Driver","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl/dfl/#introduction","title":"Introduction","text":"<p>This driver defines a feature list structure that creates a linked list of feature headers (DFHs) within the MMIO space to provide an extensible way of adding features for FPGA. The driver can walk through feature headers to enumerate feature devices (e.g. FPGA Management Engine, Port and Accelerator Function Unit) and their private features for FPGA devices that support the DFL structure. This linked list is then itself traversed and each feature/private feature is associated with a driver.</p> Driver Mapping Source(s) Required for DFL dfl.ko Device Feature List Driver drivers/fpga/dfl.c Y <p>An example DFL:</p> <p></p> <p>Also known as the DFL \"walker\", <code>dfl-ko</code> walks the DFL and instantiates other DFL-enabled drivers. The same driver is used on both host-attach and in HPS, assuming they are connected by either a soft or hard PCIe IP. The same DFL walker is used regardless of the chosen OFS attach method (PCIe Attach, Direct Attach). This driver is required for all DFL-enabled FPGA designs.</p> <p>The following chart visualizes DFL discovery:</p> <p></p>"},{"location":"linux-dfl/dfl/dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl.c</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl.c?h=master.</p>"},{"location":"linux-dfl/dfl/dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Access PCIe BAR to create a linked list within MMIO for all DFL features</li> </ul>"},{"location":"linux-dfl/dfl/dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL</p> <p></p>"},{"location":"linux-dfl/dfl/dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl/dfl/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl/dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/","title":"Accelerator Functional Unit (aka workload) Driver For Host Attach","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#introduction","title":"Introduction","text":"<p>This driver extends the capability of the Accelerator Functional Unit or application workload by implementing management features. You can connect to FPGA infrastructure through the AFU's port interface. An application layer, called Open Programmable Acceleration Engine (OPAE) is built on top of the AFU driver group and can directly communicate with the AFU port regardless of whether the workload sits in a partial reconfiguration region or not. The AFU driver is composed of 4 source files that define its core functionality.</p> Driver Mapping Source(s) Required or Optional DFL Driver? dfl-afu.ko AFU Driver drivers/fpga/dfl-afu.h Optional <p><code>dfl-afu-dma-region.c</code> (Upstream) provides DMA region management. It can pin/unpin pages in memory for transfers to occur, create/destroy/find DMA regions, and map/unmap regions of memory.</p> <p><code>dfl-afu-error.c</code> (Upstream) handles error reporting from the AFU / Port. It can mask/unmask port errors, clear errors, and show various errors associated with the AFU.</p> <p><code>dfl-afu-region.c</code> (Upstream) provides the portion of the driver responsible for MMIO Region Management. It can add/destroy MMIO regions, and find regions by offset or index.</p> <p><code>dfl-afu-main.c</code> (Upstream) handles management capabilities of the AFU / Port. It can enable/disable/reset AFU ports, open/close/probe access to AFU devices, and show the current state of the AFU's power consumption, <code>userclk</code> frequency, and AFU ID, and provides various other capabilities related to port management.</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#accelerator-functional-unit","title":"Accelerator Functional Unit","text":"<p>The AFU region is the region where a user can put their custom application logic.  It can optionally contain a Partial Reconfiguration region for dynamic workload updates.</p> <p></p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga.</p> <p>The Upstream source code for this driver can be found at [(https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga?h=master]((https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga?h=master).</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Create AFU MMIO Regions, DMAs</li> <li>Report on AFU related errors</li> <li>Create Memory Mappings and pin memory between device and host</li> </ul>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_AFU</p> <p></p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs that support an AFU region. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/","title":"Host Attach Memory Subsystem IP Driver","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#introduction","title":"Introduction","text":"<p>This driver is for the Memory Subsystem IP private feature implemented under FPGA Device Feature List (DFL) framework. It is used to expose memory interface status information as well as memory clearing control.</p> Driver Mapping Source(s) Required or Optional DFL Driver? dfl-emif.ko FPGA DFL EMIF Driver drivers/memory/dfl-emif.c Optional"},{"location":"linux-dfl/dfl_emif/dfl_emif/#agilex-7-f-series-and-i-series-fpga-memory-subsystem-ip","title":"Agilex 7 F-Series and I-Series FPGA Memory Subsystem IP","text":"<p>The memory subsystem IP is a high-level solution on top of the External Memory Interfaces Agilex\u00ae 7 FPGA IP, providing an easy way to instantiate up to 8 external memory interfaces (EMIFs) with application-level optimizations.  The memory subsystem IP provides the following components:</p> <ul> <li>Up to 8 lookup IP instances.</li> <li>Up to 8 EMIF instances.</li> <li>A memory controller that implements all the memory commands and protocol-level requirements.</li> <li>A soft logic adapter to boost memory throughput by traffic shaping.</li> </ul> <p>The memory subsystem supports DDR4 and DIMMs. For more information about this IP, please refer to the Agilex 7 F-Series and I-Series FPGA Memory Subsystem IP User Guide.</p> <p></p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#stratix-10-external-memory-interface","title":"Stratix 10 External Memory Interface","text":"<p>The External Memory Interfaces Stratix 10 FPGA IP provides an physical later interface which builds the data path and manages timing transfers between the FPGA and the memory device.  It also includes a memory controller which implements all the memory commands and protocol level requirements.  This IP supports a variety of memory types including DDR4, QDR-IV and DIMMs.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/memory/dfl-emif.c#L4</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/memory/dfl-emif.c?h=master.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Access status of memory calibration</li> <li>Memory clearing control</li> </ul>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_EMIF</p> <p></p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#example-designs","title":"Example Designs","text":"<p>This driver is used in the PCIe Attach shell designs for Agilex 7 and in the PCIe Attach shell design for Stratix 10 FPGA.  Please refer to the Open FPGA Documentation site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/","title":"Host Attach DFL FPGA Management Engine IP Driver","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#introduction","title":"Introduction","text":"<p>This set of drivers is designed to support FME functionality, as implemented under FPGA Device Feature List (DFL) framework. It is used to expose FME capabilities.</p> Driver Mapping Source(s) Required for DFL dfl-fme.ko FPGA Management Engine IP drivers/fpga/ - dfl-fme.h, dfl-fme-main.c, dfl-fme-pr.c, dfl-fme-error.c, dfl-fme-perf.c Y dfl-fme-mgr.ko PR IP drivers/fpga/dfl-fme-mgr.c N dfl-fme-br.ko SW Dependency drivers/fpga/dfl-fme-br.c N dfl-fme-region.ko SW Dependency drivers/fpga/dfl-fme-region.c N <pre><code>graph TD;\n    A[dfl-fme]--&gt;B[dfl-fme-mgr];\n    A[dfl-fme]--&gt;C[dfl-fme-br];\n    A[dfl-fme]--&gt;D[dfl-fme-region]; </code></pre>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#fpga-management-engine-ip","title":"FPGA Management Engine IP","text":"<p>The FPGA Management Engine IP provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA. Implementation of a PR region is optional.</p> <p>Each FME feature exposes its capability to host software drivers through a device feature header (DFH) register found at the beginning of its control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link. For more information about DFHs, refer to the Device Feature Header (DFH) structure.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for these drivers can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga, where branches labelled fpga-ofs-dev-*-lts correspond with the latest developmental versions of the DFL driver suite on that specific kernel version.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/fpga?h=master.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#driver-capabilities","title":"Driver Capabilities","text":"<p>This driver set is a DFL specific implementation of generic FPGA drivers available in the kernel. <code>dfl-fme-mgr</code> is a DFL specific instantiation of the generic FPGA manager (drivers/linux/fpga/fpga-mgr.c), <code>dfl-fme-br</code> builds on top of a generic FPGA bridge (drivers/fpga/fpga-bridge.c), and <code>dfl-fme-region</code> instantiates an FPGA region. All three supplementary DFL Drivers depend on <code>dfl-fme</code>.</p> <p>The DFL FME driver is a feature device implemented under the Device Feature List (DFL) framework. It enables the platform driver for the FME IP and implements all FPGA platform level management features. Only one FME is created per DFL based FPGA device. The DFL Bridge, Manager, and Region drivers are only required when attempting to configure a PR region in the FIM.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_FME</p> <p></p> <p>FPGA_DFL_FME_MGR</p> <p></p> <p>FPGA_DFL_FME_BRIDGE</p> <p></p> <p>FPGA_DFL_FME_REGION</p> <p></p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#example-designs","title":"Example Designs","text":"<p>The FPGA Management Engine IP is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/","title":"FPGA DFL NIOS Driver for Intel PAC N3000","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Arria 10 GX</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#introduction","title":"Introduction","text":"<p>This is the driver for the N3000 Nios private feature on Intel PAC (Programmable Acceleration Card) N3000. It communicates with the embedded Nios processor to configure the retimers on the card. It also instantiates the SPI master (spi-altera) for the card's BMC (Board Management Controller). It matches and probes based on the Nios private feature node on a DFL from an Intel N3000 device. This driver also depends on the generic DFL driver.</p> Driver Mapping Source(s) Required for DFL dfl-n3000-nios.ko FPGA DFL NIOS Driver for Intel PAC N3000 drivers/fpga/dfl-n3000-nios.c N"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl-n3000-nios.c#L4.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl-n3000-nios.c.</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Instantiate the SPI interface for an N3000</li> <li>Communicate with N3000 retimers</li> </ul>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_NIOS_INTEL_PAC_N3000</p> <p></p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/","title":"DFL PCI Express Subsystem IP Driver","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#introduction","title":"Introduction","text":"<p>This driver enables PCIe functionality for PCIe based FPGA solutions that implement the DFL. This driver provides interfaces for user-space applications to configure, enumerate, open and access FPGA accelerators on the FPGA DFL devices, enables system level management functions such as FPGA partial reconfiguration, power management and virtualization with DFL framework.</p> <p>The <code>dfl-pci</code> driver is a DFL specific instantiation of the generic <code>pci.ko</code> driver.</p> Driver Mapping Source(s) Required for DFL dfl-pci.ko FPGA DFL PCIe Device Driver drivers/fpga/dfl-pci.c Y"},{"location":"linux-dfl/dfl_pci/dfl_pci/#agilex-7-pcie-susbystem","title":"Agilex 7 PCIe Susbystem","text":"<p>The PCIe Subsystem is one of three subsystems supported by the OFS FIM. It contains configuration registers for the Vendor, Device and Subsystem Vendor IDs. These registers are used in PCIe add-in cards to uniquely identify the card for assignment to software drivers.</p> <p>The host-side PCIe SS supports PCIe Gen 4x16 speeds using an AXI-ST Data mover interface across a hardened P-Tile. Is natively supports multiple configurations - including 2 PFs, and 1 PF with multiple VFs. It contains optional support for DMA engines and Single-root I/O Virtualization (SR-IOV). Full documentation on the FPGA IP Subsystem for PCI Express IP User Guide can be found on the Open FPGA Stack Git site.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl-pci.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl-pci.c?h=master.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize DFL-enabled PCIe SS instances</li> <li>Probe for DFLs in PCIe BAR space, and enumerate their features</li> <li>Configure SR-IOV</li> </ul>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_PCI</p> <p></p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#example-designs","title":"Example Designs","text":"<p>The PCIe SS is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/","title":"Max\u00ae 10 Board Management Controller Driver","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <ul> <li><code>intel-m10-bmc-log</code> is not upstreamed.</li> </ul> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#introduction","title":"Introduction","text":"<p>This driver is designed to support the core functionality of the Max 10 Board Management Controller. It provides support for accessing the BMC, and supports all operations that are in turn supported by the BMC itself including configuring non-volatile FPGA flash, reading telemetry data, and remotely updating the FPGA and BMC images.</p> Driver Mapping Source(s) Required for DFL intel-m10-bmc-core.ko MAX 10 Board Management Controller drivers/mfd/intel-m10-bmc-core.c N intel-m10-bmc-pmci.ko MAX 10 Board Management Controller with PMCI drivers/mfd/intel-m10-bmc-pmci.c N intel-m10-bmc-spi.ko MAX 10 Board Management Controller with SPI drivers/mfd/intel-m10-bmc-spi.c N intel-m10-bmc-sec-update.ko MAX10 BMC Secure Update driver drivers/fpga/intel-m10-bmc-sec-update.c N intel-m10-bmc-hwmon.ko MAX10 BMC Hardware Monitoring drivers/hwmon/intel-m10-bmc-hwmon.c N <pre><code>graph TD;\n    A[intel-m10-bmc-core]--&gt;B[intel-m10-bmc-spi] \n    A[intel-m10-bmc-core]--&gt;C[intel-m10-bmc-pmci]\n    A[intel-m10-bmc-core]--&gt;E[intel-m10-bmc-hwmon]\n    A[intel-m10-bmc-core]--&gt;F[intel-m10-bmc-sec-update]</code></pre> <p><code>intel-m10-bmc-core</code> provides common code for the Board Management Controller chip. It polls the M10 handshake register, can access and update BMC CSRs, display version information, and read MAC statistics.</p> <p>Either <code>intel-m10-bmc-spi</code> or <code>intel-m10-bmc-pmci</code> are required for a given BMC, depending on which communication standard is supported by the board as provide by its DFH. D5005 uses SPI, Agilex 7 devices use PMCI. Both of these drivers assist in communicating across the connection between the FPGA fabric and the Max 10 by acting as a master device. As the SPI master the driver will covert SPI messages to Avalon transactions. Both drivers consume the common code present in <code>intel-m10-bmc-core</code>.</p> <p><code>intel-m10-bmc-hwmon</code> hooks into the generic Linux <code>hwmon</code> framework already present in the Kernel and instantiations the Max 10 BMC instance. This includes support for all on-board sensors for voltage, current, and temperature.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#board-management-controller","title":"Board Management Controller","text":"<p>The Board Management Controller (BMC) supports features such as board power management, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate Max\u00ae 10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver suite can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/, and under the <code>fpga</code>, <code>mfd</code>, and <code>hwmon</code> directories.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mfd?h=master.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Communicate with BMC handshake register, issue supported commands</li> <li>Read / write to BMC attached flash</li> <li>Register on-board sensors with kernel hwmon framework</li> </ul>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#kernel-configurations","title":"Kernel Configurations","text":"<p>MFD_INTEL_M10_BMC_CORE</p> <p></p> <p>MFD_INTEL_M10_BMC_SPI</p> <p></p> <p>MFD_INTEL_M10_BMC_PMCI</p> <p></p> <p>FPGA_M10_BMC_SEC_UPDATE</p> <p></p> <p>SENSORS_INTEL_M10_BMC_HWMON</p> <p></p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/","title":"Intel HSSI configurable ethernet phy driver","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#introduction","title":"Introduction","text":"<p>This is the Intel HSSI configurable ethernet phy driver. It provides the ability to view and change some of the transceiver tuner parameters for a QSFP interface on legacy D5005 designs.</p> Driver Mapping Source(s) Required for DFL intel-s10-phy.ko Intel HSSI configurable ethernet phy driver drivers/net/phy/intel-s10-phy.c N"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/fpga-ofs-dev-6.1-lts/drivers/net/phy/intel-s10-phy.c.</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Read and write XCVR status and statistics</li> </ul>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#kernel-configurations","title":"Kernel Configurations","text":"<p>INTEL_S10_PHY</p> <p></p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/","title":"Ethernet IEEE 1588 Time of Day Clock FPGA IP Driver for Host Attach","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#introduction","title":"Introduction","text":"<p>This page provides an overview of the Time-of-day driver for the Time of Day Clock FPGA IP that is used in the 1588PTP Design examples.  The Time of Day Clock FPGA IP is exposed as PTP Hardware Clock (PHC) device to the Linux PTP stack to synchronize the system clock to its ToD information using phc2sys utility of the Linux PTP stack.</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#time-of-day-clock-fpga-ip","title":"Time of Day Clock FPGA IP","text":"<p>The Time-of-day (TOD) Clock streams 96-bit and 64-bit time-of-day to one or more timestamping units in an IEEE 1588v2 solution. For information regarding this soft IP core, please refer to the Ethernet Design Example Components User Guide.</p> <p></p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/ptp/ptp_dfl_tod.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/ptp/ptp_dfl_tod.c?h=master.</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Reads and writes time in Time of Day timestamp registers.</li> <li>Performs fine and course clock offset adjustment.</li> <li>Periodic time drift adjustment.</li> <li>Only tested on Host attach Agilex 7</li> </ul>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_PTP_DFL_TOD</p> <p></p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/","title":"Memory Based QSFP Support Driver for Host Attach","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10, Arria 10 GX</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#introduction","title":"Introduction","text":"<p>This legacy driver builds on top of the QSFP Module and Ethernet IP drivers and enables them in a DFL design. This DFL-based driver will shadow the QSFP module's memory pages in memory. It leverages the core driver code from <code>qsfp-mem-core.ko</code>.</p> Driver Mapping Source(s) Required for DFL qsfp-mem-dfl.ko Memory Based QSFP Support for DFL drivers/net/phy/qsfp-mem-dfl.c N qsfp-mem-platform.ko Memory based QSFP support drivers/net/phy/qsfp-mem-platform.c N qsfp-mem-core.ko Memory based QSFP support drivers/net/phy/qsfp-mem-core.c N <pre><code>graph TD;\n    A[regmap-mmio]--&gt;B[qsfp-mem-core];\n    B[qsfp-mem-core]--&gt;C[qsfp-mem-platform];\n    B[qsfp-mem-core]--&gt;D[qsfp-mem-dfl];</code></pre>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/fpga-ofs-dev-6.1-lts/drivers/net/phy.</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probe and match the corresponding DFL Device</li> <li>Init a QSFP Device</li> <li>Send data over I2C</li> </ul>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>QSFP_MEM_CORE</p> <p></p> <p>QSFP_MEM</p> <p></p> <p>QSFP_MEM_DFL</p> <p></p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/s10hssi/s10hssi/","title":"Control Plane Driver for Stratix 10 HSSI","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#introduction","title":"Introduction","text":"<p>This driver provides control plane support for a Stratix 10 High Speed Serial Interface. The Stratix 10 High Speed Serial Interface provides a data path between the FPGA and the external QSFP interfaces. This data path does not involve packets transferred between host memory and the fpga. As such a very limited set of networking functionality is provided.</p> Driver Mapping Source(s) Required for DFL s10hssi.ko Control Plane Driver for Stratix 10 HSSI drivers/net/ethernet/s10hssi.c N"},{"location":"linux-dfl/s10hssi/s10hssi/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/fpga-ofs-dev-6.1-lts/drivers/net/ethernet/intel/s10hssi.c.</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Read and write XCVR status and statistics</li> <li>Set MAC address</li> <li>Enable loopback</li> </ul>"},{"location":"linux-dfl/s10hssi/s10hssi/#kernel-configurations","title":"Kernel Configurations","text":"<p>S10HSSI</p> <p></p>"},{"location":"linux-dfl/s10hssi/s10hssi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/","title":"Generic Serial Flash Interface Intel FPGA IP Driver","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#introduction","title":"Introduction","text":"<p>This driver is the DFL specific implementation of the Generic Serial Flash Interface Intel FPGA IP driver, which provides access to Serial Peripheral Interface (SPI) flash devices. This is a DFL bus driver for the Altera SPI master controller, which is connected to a SPI slave to Avalon bridge in an Intel Max10 BMC. It handles the probing for available DFL-enabled SPI devices, will initialize any discovered SPI devices, and allows you to read and write over an available interface. The driver supports writing both Configuration memory (configuration data for Active Serial configuration schemes) and General purpose memory. Generic Serial Flash Interface Intel\u00ae FPGA IP User Guide. This driver also depends on the generic DFL driver.</p> Driver Mapping Source(s) Required for DFL spi-altera-core.ko Altera SPI Controller core code drivers/spi/spi-altera-core.c N spi-altera-platform.ko Device Feature List Driver drivers/spi/spi-altera-platform.c N spi-altera-dfl.ko Device Feature List Driver drivers/spi/spi-altera-dfl.c N <pre><code>graph TD;\n    A[spi-altera-core]--&gt;B[spi-altera-platform];\n    A[spi-altera-core]--&gt;C[spi-altera-dfl];\n    D[dfl]--&gt;C[spi-altera-dfl]; </code></pre>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/spi.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl.c?h=master.</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Match and probe DFL-enabled SPI interfaces on the DFL</li> <li>Read / write into memory over a given interface</li> </ul>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>SPI_ALTERA</p> <p></p> <p>SPI_ALTERA_CORE</p> <p></p> <p>SPI_ALTERA_DFL</p> <p></p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/uart_16550/uart_16550/","title":"Altera 16550 Compatible UART Core Driver for Host Attach","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#introduction","title":"Introduction","text":"<p>This driver for the 16550 Compatible UART Core to establish TTY communications to FPGA through PCIe.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#16550-compatible-uart-core","title":"16550 Compatible UART Core","text":"<p>The 16550 UART (Universal Asynchronous Receiver/Transmitter) soft IP core with Avalon\u00ae interface is designed to be register space compatible with the de-facto standard 16550 found in the PC industry. The core provides RS-232 Signaling interface, False start detection, Modem control signal and registers, Receiver error detection and Break character generation/detection. The core also has an Avalon\u00ae Memory-Mapped ( Avalon\u00ae -MM) agent interface that allows Avalon\u00ae -MM host peripherals (such as Nios\u00ae II and Nios\u00ae V processors) to communicate with the core simply by reading and writing control and data registers. For information regarding this soft IP core, please refer to the Embedded Peripherals IP User Guide.</p> <p></p>"},{"location":"linux-dfl/uart_16550/uart_16550/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/tty/serial/8250/8250_dfl.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/serial/8250/8250_dfl.c?h=master.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Establishes serial connection with FPGA.</li> </ul>"},{"location":"linux-dfl/uart_16550/uart_16550/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SERIAL_8250_DFL</p> <p></p>"},{"location":"linux-dfl/uart_16550/uart_16550/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#example-designs","title":"Example Designs","text":"<p>This driver is used in the PCIe Attach shell designs for Agilex 7.  Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/","title":"Generic DFL driver for Userspace I/O devices","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Stratix 10</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#introduction","title":"Introduction","text":"<p>This DFL based driver provides direct access to DFL devices from userspace. A sample userspace application using this driver is available for download in a git repository: git clone https://github.com/OPAE/opae-sdk.git It can be found at: opae-sdk/libraries/libopaeuio/.</p> Driver Mapping Source(s) Required for DFL uio_dfl.ko Generic DFL driver for Userspace I/O devices drivers/uio/uio_dfl.c Y <pre><code>graph TD;\n    A[uio]--&gt;C[uio-dfl];\n    B[dfl]--&gt;C[uio-dfl];</code></pre>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/uio/uio_dfl.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/uio/uio_dfl.c.</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probe and match DFL UIO device(s)</li> </ul>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>UIO_DFL</p> <p></p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/apb_timers/apb_timers/","title":"General-Purpose Timers Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Device Supported: Agilex 5 , Agilex 7</p>"},{"location":"linux-embedded/apb_timers/apb_timers/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides four 32-bit general-purpose timers connected to the level 4 (L4) peripheral bus. The timers optionally generate an interrupt when the 32-bit binary count-down timer reaches zero.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/apb_timers/apb_timers/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/clocksource/dw_apb_timer.c.</p>"},{"location":"linux-embedded/apb_timers/apb_timers/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supports interrupt generation</li> <li>Supports free-running mode</li> <li>Supports user-defined count mode</li> </ul>"},{"location":"linux-embedded/apb_timers/apb_timers/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_APB_TIMER</p> <p></p>"},{"location":"linux-embedded/apb_timers/apb_timers/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/apb_timers/apb_timers/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/apb_timers/apb_timers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/clock_manager/clock_manager/","title":"Clock Manager Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: No</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/clock_manager/clock_manager/#introduction","title":"Introduction","text":"<p>Hard Processor System (HPS) clock generation is centralized in the clock manager. The clock manager is responsible for providing software-programmable clock control to configure all clocks generated in the HPS. Clocks are organized into clock groups.</p> <p>A clock group is a set of clock signals that originate from the same clock source which may be synchronous to each other. The Clock Manager has a two Phase-Locked Loop (PLL) clock group where the clock source is a common PLL voltage-controlled oscillator (VCO). A clock group which is independent and asynchronous to other clocks may only have a single clock, also known as clock slice. Peripheral clocks are a group of independent clock slices.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/clock_manager/clock_manager/#features","title":"Features","text":"<ul> <li>Generates and manages clocks in the HPS.</li> <li>Contains two flexible PLL blocks Main PLL and Peripheral PLL.</li> <li>Generates clock gate controls for enabling and disabling most of the clocks.</li> <li>Allows software to program clock characteristics.</li> <li>Supports interrupting the Cortex-A53 MPCore on PLL-lock and loss-of-lock.</li> </ul>"},{"location":"linux-embedded/clock_manager/clock_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/clk/socfpga/clk-agilex5.c.</p>"},{"location":"linux-embedded/clock_manager/clock_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Support to configure peripherals clock through common clock framework.</li> <li>Support to enable or disable software-managed clocks.</li> </ul>"},{"location":"linux-embedded/clock_manager/clock_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_CLK_INTEL_SOCFPGA64</p> <p></p>"},{"location":"linux-embedded/clock_manager/clock_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p> <p>Also dt-bindings can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/include/dt-bindings/clock/agilex5-clock.h</p>"},{"location":"linux-embedded/clock_manager/clock_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/clock_manager/clock_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/dma/dma/","title":"Direct Memory Access Controller (DMAC) Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/dma/dma/#introduction","title":"Introduction","text":"<p>The DMAC driver supports two DMACs with a maximum of four channels each. This driver transfers data between memory and peripherals and other memory locations in the system.</p>"},{"location":"linux-embedded/dma/dma/#hps-direct-memory-access-controller-dmac","title":"HPS Direct Memory Access Controller (DMAC)","text":"<p>The DMAC is part of the Hard Processor System (HPS) of the FPGA.  The HPS provides two DMACs to handle the data transfer between memory-mapped peripherals and memories, off-loading this work from the MPU system complex. Some common features are listed below.</p> <ul> <li>Software programmable with dedicated register field</li> <li>Supports multiple transfer types</li> <li>Each DMAC channels supports four channels</li> <li>Each DMAC supports interrupt interface to the Generic Interrupt Controller (GIC)</li> <li>Supports up to 48 peripheral request interfaces</li> </ul> <p></p> <p>For more information please refer to the following guide: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"linux-embedded/dma/dma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c</p>"},{"location":"linux-embedded/dma/dma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>DMA bus width configuration</li> <li>Transaction configuration</li> <li>Interrupt control and handling</li> </ul>"},{"location":"linux-embedded/dma/dma/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_AXI_DMAC</p> <p></p>"},{"location":"linux-embedded/dma/dma/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the dma: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/dma/dma/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/dma/dma/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/edac/edac/","title":"Error Detection and Correction (EDAC) Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/edac/edac/#introduction","title":"Introduction","text":"<p>The Error Detection and Correction (EDAC) driver supports use of the Error Checking and Correction (ECC) Controller in the HPS.  The ECC controllers are implemented in the on-chip RAM, USB OTG 2.0 and 3.1 and Ethernet MACs in the HPS.  To find out more about the ECC controller please refer to the Hard Processor Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/edac/edac/#driver-sources","title":"Driver Sources","text":"<p>The source code for the driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/edac/altera_edac.c.</p>"},{"location":"linux-embedded/edac/edac/#driver-capabilities","title":"Driver Capabilities","text":"<p>The Error Detection and Correction (EDAC) driver comprises the ECC manager main component and sub-components of the supported EDAC SoC components.</p> <p>The driver's main functions are to register the EDAC platform drivers in Linux, initialize the EDAC sub-components by performing initial setup of the IRQ interrupt handlers and soft-error handling for uncorrected error events, and to support debugging features like soft-error injections and reads of the error counters.</p> <p>The data flow diagram of EDAC is shown below:</p> <p></p>"},{"location":"linux-embedded/edac/edac/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_EDAC_ALTERA</p> <p></p>"},{"location":"linux-embedded/edac/edac/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/edac/edac/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/emac/emac/","title":"Ethernet Media Access Controller (EMAC) Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/emac/emac/#introduction","title":"Introduction","text":"<p>The Ethernet Media Access Controller (EMAC) Driver controls initialization, configuration and traffic shaping of the three EMACs in the Hard Processor System (HPS).</p> Driver Capability /drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c Sets PHY layer configuration such as GMII, RGMII, RMII and speed. /drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c Obtains the features EMAC features supported to main driver /drivers/net/ethernet/stmicro/stmmac/stmmac_main.c Sets ethtool operations Initializes hardware Initializes traffic control Calls networking API (NAPI) Registers IP as netdev Initialize PHY, DMA, MAC Transaction Layer, Management MAC counters, Precision Time Protocol, Watchdog Timer, Ring Length, PCS protocol and TCP Segmentation Offload /drivers/net/ethernet/stmicro/stmmac/hwif.c Initializes hardware interface and obtains device ID and IP version /drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c Configures filters, link speed, MDIO/MII bus /drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c Provides bus interface for MII registers <p>The following group of drivers is required to support EMAC functionality:</p> <pre><code>graph TD;\n    A[dwmac-socfpga.c]--&gt;B[stmmac_platform.c];\n    B[stmmac_platform.c]--&gt;C[stmmac_main.c];\n    C[stmmac_main.c]--&gt;D[hwif.c]; \n    D[hwif.c]--&gt;E[dwxgmac2_core.c];\n    E[dwxgmac2_core.c]--&gt;F[stmmac_mdio.c];  </code></pre>"},{"location":"linux-embedded/emac/emac/#emac-ip","title":"EMAC IP","text":"<p>The hard processor system (HPS) provides three Ethernet media access controller (EMAC) peripherals. Each EMAC can be used to transmit and receive data at 10M/100M/1G/2.5G speeds over Ethernet connections in compliance with the IEEE 802.3-2018 specification and enable support for Time Sensitive Networking (TSN) applications.</p> <p>The EMAC has an extensive memory-mapped Control and Status Register (CSR) set, which can be accessed by the on-board Arm processors.</p> <p>The EMAC is an integration of the Synopsys Ethernet XGMAC IP with the SMTG hub and external memory. The EMAC can be accessed from HPS or FPGA fabric over an AXI interface. For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <ul> <li>IEEE 1588-2008 Advanced Timestamp: Precision Time Protocol (PTP), 2-steps, PTP offload and timestamping</li> <li>IEEE 802.1AS: Timing and synchronization</li> <li>IEEE 802.1Qav: Time-sensitive streams forwarding queuing</li> <li>The XGMAC supports the following features<ul> <li>Full-duplex operation at 10M/100M/1G/2.5 Gbps (GMII)</li> <li>Full-duplex RGMII support (10M/100M/1 G)</li> <li>Half-duplex operation in 10/100 Mbps modes</li> <li>Separate transmission, reception, and configuration (control and status register) interfaces to the application</li> <li>MDIO interface for multiple PHY devices and their configuration and management</li> <li>Programmable frame length, supporting standard or jumbo Ethernet frames up to 9 KB</li> </ul> </li> </ul> <p></p>"},{"location":"linux-embedded/emac/emac/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/net/ethernet/stmicro/stmmac/.  </p>"},{"location":"linux-embedded/emac/emac/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Set PHY layer configurations such as GMII, RGMII, RMII and speed.</li> <li>Initializes hardware, traffic control, calls networking API (NAPI), registers IP as netdev, initializes PHY, DMA, MAC Transaction Layer, Management MAC Counters, Precision Time Protocol, Watchdog Timer, Ring Length, PCS Protocol, and TCP Segmentation Offload.</li> <li>Initializes the hardware interface and obtains the device ID and IP version.</li> <li>Configures filters, link speed, MDIO/MII bus.</li> <li>Provides a bus interface for MII registers.</li> </ul>"},{"location":"linux-embedded/emac/emac/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_STMMAC_ETH</p> <p></p>"},{"location":"linux-embedded/emac/emac/#device-tree","title":"Device Tree","text":"<p>Example Device tree location: https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/emac/emac/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/emac/emac/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/gpio/gpio/","title":"General Purpose I/O Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5, Agilex 7</p>"},{"location":"linux-embedded/gpio/gpio/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides two General-Purpose I/O (GPIO) interface modules.</p> <p>The GPIO interface supports Digital debounce, configurable interrupt mode, and has up to 48 dedicated I/O pins. For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p>The figure below shows a block diagram of the GPIO interface:</p> <p></p>"},{"location":"linux-embedded/gpio/gpio/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpio/gpio-dwapb.c.</p>"},{"location":"linux-embedded/gpio/gpio/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>GPIO muxed between I2C and SPI.</li> <li>Interrupt propagation between the device and logic on board.</li> <li>Control other circuitry on board.</li> <li>Digital debounce.</li> <li>Configurable interrupt mode.</li> </ul>"},{"location":"linux-embedded/gpio/gpio/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_GPIO_DWAPB</p> <p></p>"},{"location":"linux-embedded/gpio/gpio/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/gpio/gpio/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/gpio/gpio/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/hssi/hssi/","title":"Ethernet Subsystem (HSSI) Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/hssi/hssi/#introduction","title":"Introduction","text":"<p>The Ethernet Subsystem FPGA IP driver acts as a bridge between the software operating in the HPS and the Ethernet Subsystem within the FPGA. It provides various levels of abstraction to simplify communication with the underlying Ethernet Subsystem IP. The Ethernet Subsystem driver exposes Ethernet <code>netdev</code> driver APIs that higher-level software layers can utilize to interact with the Ethernet Subsystem IP</p>"},{"location":"linux-embedded/hssi/hssi/#ethernet-subsystem-fpga-ip","title":"Ethernet Subsystem FPGA IP","text":"<p>The Ethernet Subsystem FPGA IP is a subsystem IP that includes a configurable, Media Access Control (MAC) and Physical Coding Sublayer (PCS) presenting a consistent interface to user logic. It consists of 20 ports. Depending on the tile chosen, each port is implemented based on either the Agilex\u00ae 7 E-Tile Hard IP for Ethernet FPGA IP Core or the F-Tile Hard IP for Ethernet FPGA IP core.</p> <p>This IP provides a seamless and fast way to instantiate a multi-port design, given that it integrates the required discrete Hard IP and Soft IP ingredients. Furthermore, the Subsystem IP provides a user interface to facilitate enabling required features and parameters of operation.</p> <p>For E-Tile, this subsystem IP provides Ethernet data rate profiles of 10Gbps, 25Gbps, and 100Gbps with optional RS-FEC and 1588 Precision Time Protocol (PTP). The subsystem also provides profiles for PCS, OTN, FlexE and CPRI.</p> <p>For F-Tile, this subsystem IP provides Ethernet data rate profiles of 10Gbps, 25Gbps, 40Gbps, 50Gbps, 100Gbps, 200Gbps, and 400Gbps with optional RS-FEC and 1588 Precision Time Protocol (PTP). Quartus\u00ae Prime software version 23.2 supports only Media Access Control (MAC) and Physical Coding Sublayer (PCS) sub-profile.</p> <p>For more information please refer to the Ethernet Subsystem FPGA IP User Guide.</p> <p></p>"},{"location":"linux-embedded/hssi/hssi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_fpga_hssiss.c</p>"},{"location":"linux-embedded/hssi/hssi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Get Link state.</li> <li>Get MAC stats. These abstractions are used by the HSSI ethernet netdev driver to provide ethernet functionality to the above layers.</li> </ul>"},{"location":"linux-embedded/hssi/hssi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_HSSISS</p> <p></p>"},{"location":"linux-embedded/hssi/hssi/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the HSSI:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/hssi/hssi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/hssi/hssi/#example-designs","title":"Example Designs","text":"<p>HSSI SS driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/hssi/hssi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/","title":"Ethernet Subsystem Intel FPGA IP Tile Specific Ethernet MAC Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#introduction","title":"Introduction","text":"<p>The Ethernet MAC driver is used to manage the configuration parameters of the particular tile. It currently supports F-tile and E-tile of the Ethernet Subsystem Intel FPGA IP</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#f-tile-and-e-tile-fpga-ip","title":"F-tile and E-tile FPGA IP","text":"<p>To get more information on F-tile Hard IP please refer to the F-tile Architecture and PMA and FEC Direct PHY IP User Guide.</p> <p>And for E-tile Hard IP please refer to the E-Tile Hard IP User Guide: E-Tile Hard IP for Ethernet and E-Tile CPRI PHY IPs.</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#driver-sources","title":"Driver Sources","text":"<p>The source code to generate <code>intel_fpga_hssi_xtile.o</code> can be found at the following directory location:</p> <p>https://github.com/altera-opensource/linux-socfpga/tree/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera</p> <pre><code>graph TD;\n    A[intel_fpga_hssi_xtile.o]--&gt;B[intel_fpga_eth_main.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;C[intel_fpga_hssi_etile_fec.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;D[intel_fpga_etile_driver.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;E[intel_fpga_hssi_etile_ethtool.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;F[intel_fpga_ftile_driver];\n    A[intel_fpga_hssi_xtile.o]--&gt;G[intel_fpga_hssi_ftile_fec.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;H[intel_fpga_hssi_ftile_ethtool.c];</code></pre>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>To set the tile specific parameters, like enable support for interrupts, DMA and also the ethtool related configuration.</li> </ul>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_HSSI_XTILE</p> <p></p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#device-tree","title":"Device Tree","text":"<p>Example of Device tree location to configure the hssi_xtile: </p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#example-designs","title":"Example Designs","text":"<p>HSSI xtile (E-tile/F-tile) driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP </p> <p></p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/hwmon/hwmon/","title":"Altera\u00ae Hardware Monitor Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status:  Not Upstreamed</p> <p>Devices supported: Agilex\u2122 7, Agilex\u2122 5</p>"},{"location":"linux-embedded/hwmon/hwmon/#introduction","title":"Introduction","text":"<p>The devices in which this driver is supported provide you with on-chip voltage and temperature sensors. You can use these sensors to monitor on-chip operation conditions such as the internal power rail and on-chip junction temperature. Some of the sensors also allow you the measure external voltages.</p> <p>The sensor monitoring system in the secure device manager (SDM) is in charge of sampling signals and keeping the latest digital value for each sensor available,  so this data can be provided under request. You can read the voltage and temperature values in the SDM by using the Mailbox Client FPGA IP or the Mailbox Client with Avalon\u00ae Streaming Interface Intel\u00ae FPGA IP.</p> <p>The Hard Processor System (HPS) is also capable of retrieve the voltage and temperature levels from the HPS-to-SDM mailbox. The Linux driver performs all the operations needed to facilitate the access to the sampled values from the sensors from the user space.</p> <p></p>"},{"location":"linux-embedded/hwmon/hwmon/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/HEAD/drivers/hwmon/soc64-hwmon.c</p>"},{"location":"linux-embedded/hwmon/hwmon/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>The driver is supported by the Linux Kernel hardware monitor framework.</li> <li>Identification of meassurement points for voltage and temperature (i.e. sensor location) are defined through device tree nodes. Up to 16 sensors for each one can be defined.</li> <li>The driver registers each one of the meassurement point as a device under /sys/class/hwmon/hwmon0. The voltage and temperature value is avaiable in the User space through the reading of the corresponding file.</li> <li>The driver performs an ATF SVC call to ask for the value in certain sensor identified through a parameter. The ATF interacts with SDM to ask for this value and once it gets it, this forwards the value to the driver.</li> <li>Voltage values are converted to mV (millivolts) while temperature values are provided in mC (milliCelsius).</li> </ul>"},{"location":"linux-embedded/hwmon/hwmon/#detailed-description","title":"Detailed Description","text":"<p>The Hardware Monitor Linux driver allows you to read from the user space the voltage and temperature values from the on-chip sensors. These sensors are located at specific locations in the SoC so an application can monitor them either to observe the current state of the device or identify any possible fail condition. In Agilex\u2122 7 and Agilex\u2122 5 devices is possible also to use some of the sensors to monitor external signals.</p> <p>The diagram below describes the components that are involved on the voltage and temperature monitor system in the SoC and the also the software flows related to this process. The diagram is described in detail next.</p> <p></p> <ol> <li> <p>There are voltage and temperature sensors in different locations of the SoC. The sensors and their locations are defined  in the device corresponding Power Management User Guide (Sensor Monitoring System chapter).  The SoC also includes ADCs  used to sample these variables and convert them to a digital value. The SDM is in charge of the sampling of the voltage and temperature signals and also convert them to a meaningful digital value using a reference voltage. This sampling is performed constantly and the corresponding last digital value is always available in case any agent request this to the SDM.</p> <p>NOTE: The temperature sensors in the SoC are active only if the corresponding location is also active in the device. For example, sensors in the core fabric are only available if the core fabric has been programed. The same case for sensors in the tiles, they will become active only if they has been instantiated in the design. The sensor in the SDM is always available. </p> </li> <li> <p>In the Linux side, the Altera\u00ae hardware monitor driver (drivers/hwmon/soc64-hwmon.c) performs the following actions:</p> <ul> <li> <p>Parses the device tree to identify the nodes for each one of the sensors described. Up to 16 voltage sensors and 16 temperature sensors can be defined. The sensor nodes are defined under firmware &gt;&gt; svc &gt;&gt; hwmon &gt;&gt; temperature and firmware &gt;&gt; svc &gt;&gt; hwmon &gt;&gt;  voltage nodes respectively. The driver, supported by the hardware monitor framework (drivers/hwmon/hwmon.c), creates a device (seen as a file) under /sys/class/hwmon/hwmon0 for each one of these nodes defined in the device tree. These devices are accessible from the user space and reading them corresponds to reading the lecture from the corresponding sensor. The driver also creates a file/device to identify the corresponding sensor returning the name of the sensor (referred as label). The following table describes the format of the device name created and also the starting index of these devices.</p> Sensor type Device name (value) Device name (identifier) Starting index Voltage inX_input inX_label 0 Temperature tempX_input tempX_label 1 <p>The following image shows an example of the device created when defining 9 voltage sensors and 15 temperature sensors. </p> <p>Refer to the Device Tree section for more information about the sensor definition in the device tree.</p> </li> </ul> <ul> <li>As indicated earlier, the SDM is in charge of capturing the voltage and temperature levels from the sensors. The Linux driver performs the voltage read operation through the soc64_read() function which uses SVC (service client) call to the ATF to ask this to request to the SDM the current value of a specific sensor. The driver indicates to the SVC if it wants to read a voltage or a temperature through a command (COMMAND_HWMON_READTEMP or COMMAND_HWMON_READVOLT). It also specifies which of the sensors need to be read using an argument in the SVC message. The driver obtains this argument information about the sensor to read from the reg field in the corresponding sensor node in the device tree (refer to Device Tree section for more information about this). Once the SVC message is sent, the driver waits for a response from the ATF. This response includes the value of the voltage or temperature that was returned by the SDM. The driver do some additional conversion so the value that this returns is in milli Celsius(mC) for temperature and milli Volts (mV) for voltage. The value that this function returns is the actual value that you will observe from the inX_input or tempX_input device under /sys/class.     </li> </ul> </li> <li> <p>In the ATF side, the SVC message sent by the Linux driver to request the reading of a temperature or voltage level is received by the SIP SMC handler, sip_smc_handler_V1(). This handler process the incoming command to identify if  voltage or temperature read is requested. Following the software flow, the ATF converts the SVC message into a HPS to SDM mailbox message (MBOX_HWMON_READTEMP and MBOX_HWMON_READVOLT) to request the SDM to provide the latest temperature or voltage sample taken. Once that the SDM responds to this request, the ATF also responds to the SVC message with the signal level provided by the SDM.</p> </li> <li>As indicated earlier, the SDM already has available the latest value of temperature of voltage of all the sensors, so when it receives the mailbox request from ATF to provide the latest value taken from any of the sensors, the SDM just responds the mailbox message with the value requested.</li> </ol>"},{"location":"linux-embedded/hwmon/hwmon/#kernel-configurations","title":"Kernel Configurations","text":"<p>In order to include into the Linux kernel the hardware monitor and all the components required for the voltage and temperature monitor system, the following Kernel configurations are required:</p> Kernel Configuration Description CONFIG_HWMON=y This enables the build and inclusion into the Linux kernel of the hardware monitor kernel framework (drivers/hwmon/hwmon.c) CONFIG_SENSORS_SOC64=y This enables the build inclusion into the Linux kernel of the Altera\u00ae hardware monitor driver to read temperature and voltage from the on-chip sensors (drivers/hwmon/soc64-hwmon.c). CONFIG_INTEL_STRATIX10_SERVICE=y This enables the build and inclusion into the Linux kernel of the SVC service client support needed to used the ATF resident software( /drivers/firmware/stratix10-svc.c)."},{"location":"linux-embedded/hwmon/hwmon/#device-tree","title":"Device Tree","text":"<p>The Altera\u00ae hardware monitor driver relies on the definition of the temperature and voltage sensors in the device tree. Up to 16 sensors of each type can be defined in the device tree. Since there is dependency on the SVC services to get the value of the sampled data from the sensors, the voltage and temperature nodes need to be defined  under svc node. The Linux driver is probed using the \"intel,soc64-hwmon\" compatible statement, so a child node for the hardware monitor is defined and under these the voltage and temperature nodes are defined. An example of the structure is shown next:</p> <pre><code>firmware {\nsvc {\ncompatible = \"intel,agilex5-svc\";\n:\n              temp_volt: hwmon {\ncompatible = \"intel,soc64-hwmon\";\n};\n};\n:\n&amp;temp_volt {\ntemperature {\n#address-cells = &lt;1&gt;;\n#size-cells = &lt;0&gt;;\n&lt;temperature node&gt;\n          &lt;temperature node&gt;\n          :\n          &lt;temperature node&gt;\n\n};\nvoltage {\n#address-cells = &lt;1&gt;;\n#size-cells = &lt;0&gt;;\n&lt;voltage node&gt;\n         &lt;voltage node&gt;\n         :\n         &lt;voltage node&gt;\n      };              };\n</code></pre> <p>The format of the node is shown next: <pre><code>  input@sensor_id_value {\nlabel = \"sensor_name\";\nreg = &lt;sensor_id_value&gt;;\n};\n</code></pre> Each one of the sensors nodes requires the following fields:</p> Field Description label Name of the sensor. The name may be related to the voltage that is being meassured or the location of the temperature sensor that is being meassured.  This text will be the one displayed when reading /sys/class/hwmon/hwmon0/_label. reg This is a 32-bit value that is used to identify the sensor to which the node corresponds to. The format of this identifier may varies depending on the type of sensor. In the case of voltage sensors the value indicates the ADC channel to read (0, 1, 2 ,3, etc.). For temperature sensors the value is composed by the sensor location (bits 31:16, values 0,1,2,3, etc.) and the sensor number in that location (bits 15:0, values 0,1,2,3,...). The driver converts the value in reg to the appropriate value that needs to be sent to the ATF and later to the SDM to read the sensor value.    For more information about the sensor identification please refer to the device corresponding Power Management User Guide (Sensor Monitoring System chapter). <p>You can refer to the following example in which the Agilex\u2122 5 Linux device tree is patch to observe how some voltage and temperature nodes are defined under the hwmon node: Example of sensors nodes definition for Agilex\u2122 5</p>"},{"location":"linux-embedded/hwmon/hwmon/#reading-of-voltage-and-temperature-sensors-from-user-space","title":"Reading of Voltage and Temperature Sensors from User Space","text":"<p>The following Shell script shows an example about how the voltage and temperature from the sensors defined in the device tree can be read from the user space by reading the value and label from the devices created under /sys/class/hwmon/hwmon0/. This was executed in an Agilex\u2122 5 Premium Devkit. In this example 9 voltage sensors and 15 temperature sensors were defined in the device tree. In the example the cat command is used to get the value of the voltage/temperature value.</p> <p><pre><code>#!/bin/bash\necho \"Voltage Sensors:\" for i in 0 1 2 3 4 5 6 7 8\ndo\nvalPath=\"/sys/class/hwmon/hwmon0/in${i}_input\"\nlabelPath=\"/sys/class/hwmon/hwmon0/in${i}_label\"\nval=$(cat $valPath)\nlabel=$(cat $labelPath)        echo \"Sensor: ${i} ${label}: ${val} mv\"    done\necho \"Temperature Sensors:\" for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\ndo\nvalPath=\"/sys/class/hwmon/hwmon0/temp${i}_input\"\nlabelPath=\"/sys/class/hwmon/hwmon0/temp${i}_label\"\nval=$(cat $valPath)\nlabel=$(cat $labelPath)        echo \"Sensor: ${i} ${label}: ${val} mC\" done\n</code></pre> The output of the script is shown next:</p> <pre><code>root@agilex5_dk_a5e065bb32aes1:~# ./readSensors Voltage Sensors:\nSensor: 0 VSIGP: 1 mv\nSensor: 1 VSIGN: 0 mv\nSensor: 2 VCC: 693 mv\nSensor: 3 VCCIO_SDM: 1800 mv\nSensor: 4 VCCPT: 1800 mv\nSensor: 5 VCCRCORE: 1208 mv\nSensor: 6 VCCH_SDM: 924 mv\nSensor: 7 VCCL_SDM: 694 mv\nSensor: 8 VCCADC: 1816 mv\nTemperature Sensors:\nSensor: 1 SDM: 32125 mC\nSensor: 2 LOWER LEFT MAX: 42500 mC\nSensor: 3 LOWER LEFT CORNER: 42500 mC\nSensor: 4 LOWER LEFT XCVR 2: 26125 mC\nSensor: 5 LOWER LEFT XCVR 3: 26125 mC\nSensor: 6 LOWER LEFT CENTER: 25750 mC\nSensor: 7 LOWER RIGHT MAX: 42500 mC\nSensor: 8 LOWER RIGHT CORNER: 42875 mC\nSensor: 9 LOWER RIGHT XCVR 2: 25500 mC\nSensor: 10 LOWER RIGHT XCVR 3: 25750 mC\nSensor: 11 UPPER RIGHT MAX: 43125 mC\nSensor: 12 UPPER RIGHT CORNER: 43125 mC\nSensor: 13 UPPER RIGHT XCVR 3: 26750 mC\nSensor: 14 UPPER RIGHT CENTER: 26375 mC\nSensor: 15 HPS: 27000 mC   </code></pre>"},{"location":"linux-embedded/hwmon/hwmon/#known-issues","title":"Known Issues","text":"<ul> <li>At the moment of the writing of this page, in Agilex\u2122 5, the Altera hardware monitor driver is being probed twice. The first time it fails since the SVC driver has not been initialized yet. By the time the SVC driver is initialized, the hardware monitor is probed again, succeeding this time.</li> </ul>"},{"location":"linux-embedded/hwmon/hwmon/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/i2c/i2c/","title":"I2C Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Agilex 5</p>"},{"location":"linux-embedded/i2c/i2c/#introduction","title":"Introduction","text":"<p>The I2C controller provides support for a communication link between integrated circuits on a board. It is a simple two-wire bus which consists of a serial data line (SDA) and a serial clock (SCL).</p> <p>The hard processor system (HPS) provides five I2C controllers to enable system software to communicate serially with I2C buses. Each I2C controller can operate in master or slave mode and support standard mode of up to 100 Kbps or fast mode of up to 400 Kbps. These I2C controllers are instances of the Synopsys DesignWare controller.</p> <p>Each I2C controller must be programmed to operate in either master or slave mode only. Operating as a master and slave simultaneously is not supported.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/i2c/i2c/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/i2c/busses.</p> <pre><code>graph TD;\n    A[i2c-core-base]--&gt;B[i2c_designware_core];\n    B[i2c_designware_core]--&gt;C[i2c_designware_master]\n    C[i2c_designware_master]--&gt;E[i2c_designware_slave]</code></pre>"},{"location":"linux-embedded/i2c/i2c/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the communication for I2C Master buses as well as Slave.</li> <li>Handle the data transfer between connected devices over the I2C bus.</li> </ul>"},{"location":"linux-embedded/i2c/i2c/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_I2C_DESIGNWARE_CORE</p> <p></p> <p>CONFIG_I2C_DESIGNWARE_SLAVE</p> <p></p>"},{"location":"linux-embedded/i2c/i2c/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the i2c:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/i2c/i2c/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/i2c/i2c/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/i3c/i3c/","title":"I3C Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/i3c/i3c/#introduction","title":"Introduction","text":"<p>The I3C controller device driver only supports running as a master. The main master is a specialized master that comes up after power-on-reset, and is responsible for assigning dynamic addresses to the I3C devices. The secondary master is an I3C instance capable of both master and slave functionality. It comes up as a slave upon power-on-reset. The secondary master must get ownership of the I3C bus to become a current master before initiating any transfer to its associated slaves.</p> <p>I3C slave controller is not supported. The latest Linux kernel does not support the slave I3C framework.</p> <p>I3C master controller slave DMA is not be supported even though I3C also supports external DMA. The latest Linux kernel does not support DMA.</p>"},{"location":"linux-embedded/i3c/i3c/#i3c-fpga-ip","title":"I3C FPGA IP","text":"<p>The I3C interface is a high-bandwidth bus interface for connecting peripherals to HPS. The I3C interface is intended to improve upon the features of the I2C interface, while preserving backward compatibility. This interface is targeted for applications such as event camera sensors which require I3C interface capability.</p> <p>The hard processor system (HPS) provides two I3C controllers to enable system software to communicate serially with I3C buses. For information regarding this soft IP core, please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/i3c/i3c/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/i3c/master/dw-i3c-master.c.</p>"},{"location":"linux-embedded/i3c/i3c/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configure the I3C Controller driver at system boot-up.</li> <li>Provide support for device detection and enumeration for compatible I3C devices.</li> <li>Support the Dynamic address assignment.</li> </ul>"},{"location":"linux-embedded/i3c/i3c/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_I3C</p> <p></p>"},{"location":"linux-embedded/i3c/i3c/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the I3C:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/i3c/i3c/#known-issues","title":"Known Issues","text":"<ul> <li>I3C slave controller shall not be supported. The latest Linux kernel does not support the slave i3c framework.</li> <li>I3C master controller slave DMA shall not be supported even-though I3C also supports external DMA. The latest Linux kernel does not support DMA</li> </ul>"},{"location":"linux-embedded/i3c/i3c/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/","title":"Interrupt controller (GICv3) Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#introduction","title":"Introduction","text":"<p>The interrupt controller driver handles general initialization of the interrupt controller in the HPS.</p> <p>The Arm\u00ae Generic Interrupt Controller (GIC) handles interrupts from peripherals to the cores and between cores. To find out more about the features and functions of the GIC controller, please refer to Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/irqchip/irq-gic-v3.c</p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configure the GICv3 interrupt controller hardware during system boot-up.</li> <li>Handles interrupts generated by various sources in the system.</li> <li>Routes interrupt from their sources to the appropriate CPU cores.</li> <li>Provides generic API to manage interrupts.</li> <li>Support distributed interrupts across multiple GIC instances.</li> </ul>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ARM_GIC_V3</p> <p></p> <p>CONFIG_ARM_GIC_V3_ITS</p> <p></p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the irq_gic_v3:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/msgdma/msgdma/","title":"A Modular Scatter-Gather DMA (mSGDMA) Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/msgdma/msgdma/#introduction","title":"Introduction","text":"<p>In a processor subsystem, data transfers between two memory spaces can happen frequently. In order to offload the processor from moving data around a system, a Direct Memory Access (DMA) engine is introduced to perform this function instead. The Modular Scatter-Gather DMA (mSGDMA) is capable of performing data movement operations with preloaded instructions, called descriptors. Multiple descriptors with different transfer sizes, and source and destination addresses have the option to trigger interrupts.</p>"},{"location":"linux-embedded/msgdma/msgdma/#msgdma-fpga-ip","title":"mSGDMA FPGA IP","text":"<p>The mSGDMA provides three configuration structures for handling data transfers: between the Avalon-MM to Avalon-MM, Avalon-MM to Avalon-ST, and Avalon-ST to Avalon-MM. The sub-core of the mSGDMA is instantiated automatically according to the structure configured for the mSGDMA use model. For more information on MSGDMA IP core please refer to https://www.intel.com/content/www/us/en/docs/programmable/683130/23-1/modular-scatter-gather-dma-core.html.</p>"},{"location":"linux-embedded/msgdma/msgdma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/dma/altera-msgdma.c</p>"},{"location":"linux-embedded/msgdma/msgdma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage multiple DMA channels provided by the MSGDMA IP core.</li> <li>Provides support for interrupt handling.</li> <li>Provides support for Scatter-gather DMA operation through a set of buffer descriptors.</li> <li>Data transfer to non-contiguous memory space.</li> </ul>"},{"location":"linux-embedded/msgdma/msgdma/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ALTERA_MSGDMA</p> <p></p>"},{"location":"linux-embedded/msgdma/msgdma/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/msgdma/msgdma/#example-designs","title":"Example Designs","text":"<p>Moified version of MSGDMA driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP and also the source code is available at https://github.com/altera-opensource/linux-socfpga/tree/socfpga-6.1.55-lts/drivers/net/ethernet/altera.</p> <p></p>"},{"location":"linux-embedded/msgdma/msgdma/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/nand/nand/","title":"NAND Flash Controller Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/nand/nand/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides a NAND Flash controller to interface with external NAND Flash memory in Intel system-on-a-chip (SoC) systems. External Flash memory can be used to store software, or as extra storage capacity for large applications or user data. For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"linux-embedded/nand/nand/#features","title":"Features","text":"<ul> <li>The triple-level cell (TLC) devices are supported only in parts that are compatible with the ONFI specification</li> <li>Supports three operation modes that make the controller easy to operate while also providing enough flexibility to be adapted to your project's needs.</li> <li>Supports DMA data transfer which optimizes the transfer rate for read and write operations using DMA primary and DMA secondary interfaces.</li> <li>Supports devices with page sizes up to 64 KB.</li> <li>Support up to 8 operation threads that can be executed in parallel.</li> <li>Provides data buffering where necessary in order to achieve maximum performance.</li> </ul>"},{"location":"linux-embedded/nand/nand/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mtd/nand/raw/cadence-nand-controller.c.</p>"},{"location":"linux-embedded/nand/nand/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialization and configuration of the NAND controller hardware.</li> <li>Determine the characteristics like page size and block size.</li> </ul>"},{"location":"linux-embedded/nand/nand/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MTD_NAND_CADENCE</p> <p></p>"},{"location":"linux-embedded/nand/nand/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/nand/nand/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/nand/nand/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/","title":"Ethernet 1588 PTP Time of Day Clock IP Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#introduction","title":"Introduction","text":"<p>The driver for the Ethernet 1588 PTP Time of Day Clock FPGA IP is used in the 1588 PTP Design examples provided by Altera. The Time of Day Clock FPGA IP is exposed as a PTP Hardware Clock (PHC) device to the Linux PTP stack to synchronize the system clock to its ToD information using <code>phc2sys</code> utility in the Linux PTP stack.</p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#time-of-day-clock-fpga-ip","title":"Time of Day Clock FPGA IP","text":"<p>The Time-of-day (TOD) Clock streams 96-bit and 64-bit time-of-day to one or more time stamping units in an IEEE 1588v2 solution. For information regarding this soft IP core, please refer to the Ethernet Design Example Components User Guide.</p> <p></p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_fpga_tod.c.</p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Registers PTP clock driver to kernel</li> <li>Calculates the ToD of clock offset adjustments</li> </ul>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_TOD</p> <p></p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the TOD:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#example-designs","title":"Example Designs","text":"<p>This driver is used in the Agilex 7 SoC F-Tile Design Example for 25GbE and 10GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/qsfp/qsfp/","title":"QSFP Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/qsfp/qsfp/#introduction","title":"Introduction","text":"<p>The QSFP driver is responsible for interacting with the onboard QSFP module. It reads the QSFP Serial Electrically Erasable Programmable Read-Only Memory (SEEP) and controls the power and interrupt pins of the QSFP.</p>"},{"location":"linux-embedded/qsfp/qsfp/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/phy/qsfp.c.</p>"},{"location":"linux-embedded/qsfp/qsfp/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Registers QSFP driver to kernel.</li> <li>Reads the registers through the I2C bus and provide information to high level software stack.</li> </ul>"},{"location":"linux-embedded/qsfp/qsfp/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_QSFP</p> <p></p>"},{"location":"linux-embedded/qsfp/qsfp/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_10g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/qsfp/qsfp/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/qsfp/qsfp/#example-designs","title":"Example Designs","text":"<p>This driver is used in the Agilex 7 SoC F-Tile Design Example for 25GbE and 10GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/qsfp/qsfp/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/qspi/qspi/","title":"QSPI Driver for Hard Processor System (HPS)","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/qspi/qspi/#introduction","title":"Introduction","text":"<p>The Quad Serial Peripheral Interface (QSPI) driver manages the QSPI controller in the HPS.  The QSPI has the capability to access serial NOR Flash connected to the Secure Device Manager (SDM) QSPI. The QSPI controller supports standard SPI Flash devices as well as high-performance dual and quad SPI Flash devices. The QSPI controller module features are:</p> <ul> <li>SPIx1, SPIx2, or SPIx4 (QSPI) serial NOR flash devices</li> <li>Supported clock frequencies up to 166 MHz</li> <li>Direct access and indirect access modes</li> <li>Single I/O, dual I/O, or quad I/O instructions</li> <li>Up to four chip selects</li> <li>Configurable clock polarity and phase</li> <li>Programmable write-protected regions</li> <li>Programmable delays between transactions</li> </ul> <p>To find out more about the QSPI controller within the HPS please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual. </p>"},{"location":"linux-embedded/qspi/qspi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configuration of the QSPI controller.</li> <li>Handles data transfer and address.</li> </ul>"},{"location":"linux-embedded/qspi/qspi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/spi/spi-cadence-quadspi.c.</p>"},{"location":"linux-embedded/qspi/qspi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SPI_CADENCE_QUADSPI</p> <p></p>"},{"location":"linux-embedded/qspi/qspi/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/qspi/qspi/#known-issues","title":"Known Issues","text":"<p>None kKnown</p>"},{"location":"linux-embedded/qspi/qspi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/reset_manager/reset_manager/","title":"Reset Manager Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/reset_manager/reset_manager/#introduction","title":"Introduction","text":"<p>The reset manager generates module reset signals based on reset requests from various sources in the HPS, and performs software writing to the module-reset control registers.</p> <p>The HPS contains multiple reset domains. Each reset domain can be reset independently. A reset can be initiated externally, internally, or through software.  For more information about the reset manager, please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/reset_manager/reset_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/reset/reset-simple.c</p>"},{"location":"linux-embedded/reset_manager/reset_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the system level reset.</li> <li>Support Assert and De-assert of the reset signal.</li> <li>Monitor the status of the reset signal.</li> </ul>"},{"location":"linux-embedded/reset_manager/reset_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_RESET_SIMPLE</p> <p></p>"},{"location":"linux-embedded/reset_manager/reset_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location for reset signal parameter:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p> <p>Also dt-bindings can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/include/dt-bindings/reset/altr%2Crst-mgr-agilex5.h</p>"},{"location":"linux-embedded/reset_manager/reset_manager/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/reset_manager/reset_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/","title":"SD-EMMC Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#introduction","title":"Introduction","text":"<p>The Secure Digital/Embedded Multimedia Card (SD/eMMC) driver supports the SD/eMMC controller in the Hard Processor System (HPS) which interfaces with external SD Flash cards, secure digital I/O (SDIO) devices, and eMMC storage devices.</p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mmc/host/sdhci-cadence.c</p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage SD/eMMC features such as configuration and reset and timeout clock frequency</li> <li>Supports SDMA and ADMA modes.</li> <li>Handles data transfer to/from the SD/eMMC.</li> </ul>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MMC_SDHCI_CADENCE</p> <p></p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the SD/eMMC:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga_agilex5-ES_RC/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/smmu/smmu/","title":"System Memory Management Unit (SMMU) Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/smmu/smmu/#introduction","title":"Introduction","text":"<p>SMMU converts virtual addresses to physical addresses for external peripheral devices. This allows multiple external devices to perform direct memory access (DMA) to the entire range of the system physical memory.</p> <p>As an example, certain peripheral devices limited to accessing only 24 bits of address space would now be able to access all 64 bits addresssing through the memory translation tables of the SMMU.</p> <p>The SDM SMMU is used solely by the FCS Cryptography feature. The accelerator like FCS_Crytpo sends a VA to SMMU and SMMU queries the PA from the page table.</p> <p>SMMU registers are configured through ARM Trusted firmware (ATF) BL31 SMC calls by the Crytography device drivers. The ATF performs default SMMU initializations of the stream IDs through the system manager and SMMU secure registers configuration during the boot-up process.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/smmu/smmu/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/iommu/arm/arm-smmu-v3</p>"},{"location":"linux-embedded/smmu/smmu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Queue manipulation, sizing</li> <li>Command queue locking or insertion</li> <li>Error reporting</li> <li>Updating Stream Table Entry</li> </ul>"},{"location":"linux-embedded/smmu/smmu/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ARM_SMMU_V3</p> <p></p>"},{"location":"linux-embedded/smmu/smmu/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the smmu:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga_agilex5-ES_RC/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/smmu/smmu/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/smmu/smmu/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/spi/spi/","title":"SPI Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex7, Agilex 5</p>"},{"location":"linux-embedded/spi/spi/#introduction","title":"Introduction","text":"<p>Serial master and serial slave controllers Enable serial communication with serial-master or serial-slave peripheral devices. Each SPI master has a maximum bit rate of 60 Mbps. Each SPI slave has a maximum bit rate of 33.33 Mbps. The DMA controller interface is integrated with the HPS DMA controller.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/spi/spi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/spi.</p>"},{"location":"linux-embedded/spi/spi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Handle the data transfer between connected devices over the SPI bus.</li> <li>Support the peripheral slave DMA.</li> </ul>"},{"location":"linux-embedded/spi/spi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SPI_ALTERA</p> <p></p>"},{"location":"linux-embedded/spi/spi/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the SPI:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/spi/spi/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/spi/spi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/system_manager/system_manager/","title":"System Manager Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/system_manager/system_manager/#introduction","title":"Introduction","text":"<p>The system manager contains the memory-mapped control and status registers (CSRs) and logic to control system level functionality in a hard processor system (HPS).</p> <p>The system manager connects to different modules in the HPS such as a Direct memory access (DMA) controller, Microprocessor unit (MPU) system complex, NAND flash controller, Secure Digital/Embedded Multimedia Card (SD/eMMC) controller, or GPIO interface between HPS and other modules.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/system_manager/system_manager/#features","title":"Features","text":"<ul> <li>Provides memory-mapped control signals to other modules and peripherals</li> <li>Provides watchdogs stop functionality on debug requests.</li> <li>Provides software access to control and status signals of other HPS modules.</li> <li>Enables and disables HPS peripheral interfaces to the FPGA.</li> <li>Provides ten 32-bit registers to store handoff information between the preloader and the operating system.</li> </ul>"},{"location":"linux-embedded/system_manager/system_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Handle the probing and resource allocation.</li> <li>Provides API to perform read/write operations.</li> <li>Access the CSRs in the system manager to control and monitor various functions of modules.</li> </ul>"},{"location":"linux-embedded/system_manager/system_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mfd/altera-sysmgr.c.</p>"},{"location":"linux-embedded/system_manager/system_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MFD_ALTERA_SYSMGR</p> <p></p>"},{"location":"linux-embedded/system_manager/system_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/system_manager/system_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/system_manager/system_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/uart/uart/","title":"UART Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Agilex 5</p>"},{"location":"linux-embedded/uart/uart/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides two UART controllers for asynchronous serial communication.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/uart/uart/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/serial/8250/8250_dw.c.</p>"},{"location":"linux-embedded/uart/uart/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probing and resource allocation as well as memory mapping.</li> <li>It provides the support for busy detect interrupt.</li> </ul>"},{"location":"linux-embedded/uart/uart/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SERIAL_8250_DW</p> <p></p>"},{"location":"linux-embedded/uart/uart/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the uart:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/uart/uart/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/uart/uart/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/","title":"USB 2.0 OTG Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Agilex 5</p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) provides a USB On-The-Go (OTG) controller that supports both device and host functions. The controller is fully compliant with the On The Go and Embedded Host Supplement to the USB Revision 1.3 and Revision 2.0 Specification. The controller can be programmed for both device and host functions to support data movement over the USB protocol</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/dwc2</p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Provides basic services for accessing and managing the hardware.</li> <li>Enable support for Host and peripheral mode.</li> <li>Handle control and data transfers between the USB host and connected USB peripherals.</li> </ul>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_USB_DWC2</p> <p></p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the usb2_0_otg:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/usb3_1/usb3_1/","title":"USB 3.1 Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/usb3_1/usb3_1/#introduction","title":"Introduction","text":"<p>The HPS provides a single instance of a USB 3.1 Gen 1 controller that supports both device and host functions for high-speed applications. The general use cases of USB 3.1 are for the HPS system to support all USB devices such as:</p> <ul> <li>Portable electronic devices</li> <li>High-bandwidth applications like audio and video.</li> <li>Debug trace applications</li> </ul> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/usb3_1/usb3_1/#usb-31-glue-driver","title":"USB 3.1 Glue Driver","text":"<p><code>drivers/usb/dwc3/dwc3-of-simple.c</code> is a USB glue driver for the <code>dw3-agilex-edge.c</code> component depicted in the diagram below. This glue driver is used to control dynamic mode switching.</p> <p></p>"},{"location":"linux-embedded/usb3_1/usb3_1/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/usb/dwc3/dwc3-of-simple.c</p>"},{"location":"linux-embedded/usb3_1/usb3_1/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>It provides a reference to the Clock which is required by the rest of the interfaces.</li> </ul>"},{"location":"linux-embedded/usb3_1/usb3_1/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_USB_DWC3</p> <p></p>"},{"location":"linux-embedded/usb3_1/usb3_1/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the usb3_1:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/usb3_1/usb3_1/#known-issues","title":"Known Issues","text":"<ul> <li>Currently dynamic mode switching is not supported</li> <li>Real-time detection of USB-C slave devices not supported</li> </ul>"},{"location":"linux-embedded/usb3_1/usb3_1/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/","title":"Watchdog Timers Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Device Supported: Agilex 5</p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#introduction","title":"Introduction","text":"<p>The watchdog timers are peripherals you can use to recover from system lockup that might be caused by software or system related issues. The hard processor system (HPS) provides five programmable watchdog timers, which are connected to the level 4 (L4) peripheral bus.</p> <p>Each watchdog timer consists of a slave interface for control and status register (CSR) access, a register block, and a 32-bit down counter that operates on the slave interface clock (l4_sys_free_clk). A pause input, driven by the system manager, optionally pauses the counter when a CPU is being debugged.The watchdog timer drives an interrupt request to the MPU and a reset request to the reset manager.</p> <p>For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/watchdog/dw_wdt.c.</p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Allows configuration of the watchdog timer timeout period, specifying the duration after which the watchdog will trigger a system reset if not reset by the software</li> <li>Initializes the watchdog timer hardware during system boot, setting up the necessary registers and configurations to enable watchdog functionality.</li> <li>Handles interrupts generated by the watchdog timer hardware, allowing the system to respond appropriately to watchdog events, such as timer expiration.</li> </ul>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_WATCHDOG</p> <p></p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/","title":"Zarlink Clock Synchronizer Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#introduction","title":"Introduction","text":"<p>The Microchip\u00ae Zarlink ZL30733 3-Channel SyncE &amp; 1588 Network Synchronizer takes charge of frequency synchronization, monitors reference clock quality, manages reference clock switching, and provides holdover functionality for SyncE and PTP1588 support. It has support for multiple reference clocks and can be used to generate the outputs. The device is constantly monitoring the quality of the reference clocks and it switches to an alternative clock source when the measured period of the current reference signal is incorrect, or if it has excessive jitter.</p> <p>I2C based zl30733</p> <pre><code>graph TD;\n    A[intel_freq_control.c]--&gt;B[intel_freq_ctrl_common_i2c.c];\n    A[intel_freq_control.c]--&gt;C[intel_freq_ctrl_zl30733_i2c.c];</code></pre> <p>SPI based zl30793</p> <pre><code>graph TD;\n    A[intel_freq_control.c]--&gt;B[intel_freq_ctrl_common_spi.c];\n    A[intel_freq_control.c]--&gt;C[intel_freq_ctrl_zl30793_spi.c];</code></pre>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#zarlink-chip-information","title":"Zarlink chip information","text":"<p>For Microchip\u00ae Zarlink ZL30733 documentation please refer to https://www.microchip.com/en-us/product/zl30733 and https://www.microchip.com/en-us/product/zl30793.</p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <ul> <li>General Frequency control driver</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_control.c</p> <ul> <li>I2C based ZL30733 support</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_zl30733_i2c.c</p> <ul> <li>I2C based common api for frequency control</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_common_i2c.c</p> <ul> <li>SPI based zl30793 support</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_zl30793_spi.c</p> <ul> <li>SPI based common api for frequency control</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_common_spi.c</p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Support frequency synchronization, monitor reference clock quality, manage reference clock switching.</li> <li>Provides holdover functionality for SyncE and PTP1588 support.</li> </ul>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#example-designs","title":"Example Designs","text":"<p>Zarlink driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL* and the OpenCL* logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"sw-tools-list/host-attach-tools/","title":"Host Attach Software Tools","text":"<p>The table below provides a comprehensive list of host software tools available for Altera 7 FPGAs. These utilities are part of the  called Open Programmable Acceleration Engine (OPAE) software development kit which is part of the Open FPGA Stack (OFS) software framework.  More documentation on OPAE and OFS can be found here.</p> <p>You can use the filter fields to narrow your search.</p> Utility Supported Devices Description fpgaconf Agilex 7 FPGA Configuration fpgad Agilex 7 FPGA Diagnostics fpgainfo Agilex 7 FPGA Card Information fpgaport Agilex 7 FPGA Port Information fpgasupdate Agilex 7 FPGA Secure Update host_exerciser Agilex 7 Host Interface Exerciser hssi Agilex 7 HE-HSSI Controller hssi_ethernet Agilex 7 HSSI/Ethernet Statistics hssi_loopback Agilex 7 HSSI Loopback hssimac Agilex 7 HSSI MAC mem_tg Agilex 7 Memory Traffic Generator mmlink Agilex 7 Memory Mapped Link ofs.uio Agilex 7 OFS DFL UIO opae.io Agilex 7 OFS DFL OPAE IO opaeuio Agilex 7 OFS OPAE User IO opaevfio Agilex 7 OFS DFL Virt IO pac_hssi_config Agilex 7 Programmable Acceleration Card HSSI Configuration packager Agilex 7 AFU Packager pcie_device Agilex 7 PCIe Device rsu Agilex 7 Remote System Update (RSU) userclk Agilex 7 User Clock Control vabtool Agilex 7 Vendor Authorized Boot Tool"},{"location":"zephyr-embedded/clock_manager/clock_manager/","title":"Clock Manager Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) clock generation is centralized in the clock manager. The clock manager is responsible for providing software-programmable clock control to configure all clocks generated in the HPS. Clocks are organized in clock groups. A clock group is a set of clock signals that originate from the same clock source which may be synchronous to each other. The clock manager has two phase-locked loop (PLL) clock group where the clock source is a common PLL voltage-controlled oscillator (VCO). A clock group that is independent and asynchronous to other clocks may only have a single clock, also known as a clock slice. Peripheral clocks are a group of independent clock slices.</p> <p></p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/clock_control/clock_control_agilex5.c.</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supply clock to each HPS peripheral as configured in the boot loader and provide an API to retrieve the clock for each peripheral.</li> <li>Clock Manager will be initialized only one time during boot up by FSBL (ATF BL2) based on external user settings stored in HPS handoff data in bitstream.</li> </ul>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_CLOCK_CONTROL</p> <p></p> <p>CONFIG_CLOCK_CONTROL_AGILEX5</p> <p></p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p> <p>A clock manager node will be added in device tree.  Then, the peripheral can associate the clock manager in device tree so that the peripheral driver code can retrieve the clock frequency from clock manager. One such example is shown below.</p> <p></p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#known-issues","title":"Known Issues","text":"<p>None Known. </p>"},{"location":"zephyr-embedded/dma/dma/","title":"DMA Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: No</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/dma/dma/#introduction","title":"Introduction","text":"<p>DMA Controller controls the transfer of data between I/O devices and memory without CPU involvement. DMA controller can access the memory directly for reading and writing. This helps to enhance the performance of the cores to do some other operations, as the data transfers are handled by the DMA controller.</p> <p>The hard processor system (HPS) provides two DMA Controllers based on the Synopsis-Designware IP.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/dma/dma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/drivers/dma/dma_dw_axi.c.</p>"},{"location":"zephyr-embedded/dma/dma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Driver supports scatter-gather list.</li> <li>Driver can be configured for one of the possible three use cases.     * Memory to Memory Transfer     * Device to Memory Transfer     * Memory to Device Transfer</li> <li>Each DMA controller can support up to four channels for DMA transfer.</li> <li>Driver supports DMA transfer suspend.</li> <li>Driver supports DMA transfer resume.</li> <li>Driver supports to stop active DMA transfer.</li> </ul>"},{"location":"zephyr-embedded/dma/dma/#kernel-configurations","title":"Kernel Configurations","text":""},{"location":"zephyr-embedded/dma/dma/#device-tree","title":"Device Tree","text":"<p>Device Tree location to configure DMA is</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <pre><code>dma0: dma@10DB0000 {\ncompatible = \"snps,dw-axi-dma\";\n#dma-cells = &lt;2&gt;;\nreg = &lt;0x10DB0000 0x1000&gt;;\ninterrupt-parent = &lt;&amp;gic&gt;;\ninterrupts = &lt;GIC_SPI 81 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 82 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 83 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 84 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;;\ndma-channels = &lt;4&gt;;\nresets = &lt;&amp;reset RSTMGR_DMA_RSTLINE&gt;;\nstatus = \"disabled\";\n};\n</code></pre>"},{"location":"zephyr-embedded/dma/dma/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/dma/mem_to_mem/.</p> <p>The most relevant files are:</p> <ol> <li>Project yml -&gt; sample.yml:</li> </ol> <pre><code> 1 sample:\n 2   name: DMA\n 3   description: DMA Driver sample application\n 4 common:\n 5   tags:\n 6     - drivers\n 7     - dma\n 8 tests:\n 9   sample.drivers.dma.mem_to_mem:\n10     build_only: true\n11     harness: console\n12     integration_platforms:\n13       - intel_socfpga_agilex5_socdk\n14     harness_config:\n15       type: multi_line\n16       ordered: true\n17       regex:\n18         - \"Sample application for Memory to Memory transfer using dma controller\"\n19         - \"Successfully transferred\"\n20         - \"Sample application for dma transfer complete\"\n21     filter: DT_HAS_SNPS_DESIGNWARE_DMA_ENABLED\n22     depends_on: dma\n</code></pre> <ol> <li> <p>Config overlay -&gt; prj.conf: <pre><code>  1 CONFIG_DMA=y\n  2 CONFIG_LOG=y\n</code></pre></p> </li> <li> <p>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</p> </li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (c) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 &amp;dma0 {\n  8         status = \"okay\";\n  9 };\n</code></pre> 4. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/dma/mem_to_mem/src/main.c.</p>"},{"location":"zephyr-embedded/dma/dma/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/dma/mem_to_mem/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/dma/dma/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n[00:00:00.125,000] &lt;inf&gt; clock_control_agilex5: Intel Agilex5 clock driver initialized!\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nSample application for Memory to Memory transfer using dma controller\ndma@10DB0000: Successfully transferred 10 blocks of size:200 channel:1\nSample application for dma transfer complete\n</code></pre>"},{"location":"zephyr-embedded/dma/dma/#known-issues","title":"Known Issues","text":"<p>None Known. </p>"},{"location":"zephyr-embedded/gpio/gpio/","title":"General Purpose I/O Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/gpio/gpio/#introduction","title":"Introduction","text":"<p>General Purpose Input/Output (GPIO) Controller provides the low-level configuration through software or hardware to control the actual general purpose IO cells/pads present in the HPS.  The below diagram represents block diagram of the GPIO controller connected with other components in the system.</p> <p></p> <p>Two GPIO module instances present in HPS and each having support of 24 GPIO ports. Only Port A of GPIO Controller is configured. All the design contained of this document is referred from \u201cSynopsys GPIO Databook\u201d.</p> <p>Functional Modes:</p> <ul> <li>Software Control Mode: In the software control mode, the port direction is set by writing to the corresponding port control register of a GPIO pin. These port control registers are memory mapped.</li> <li>Hardware Control Mode : If a signal is configured for hardware control, an external auxiliary hardware-signal controls the direction of the port. For the SM, Auxiliary H/W support is not enabled.</li> </ul> <p>For More information please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/gpio/gpio/#features","title":"Features","text":"<ul> <li>Digital debounce</li> <li>Configurable interrupt mode</li> <li>Up to 48 dedicated I/O pins</li> </ul>"},{"location":"zephyr-embedded/gpio/gpio/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/drivers/gpio/gpio_intel_socfpga.c.</p>"},{"location":"zephyr-embedded/gpio/gpio/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>GPIO Pin configure as input or output.</li> <li>GPIO Port/Pin set value using mask.</li> <li>GPIO Port/Pin get value using mask.</li> <li>GPIO Port/Pin toggle using mask.</li> </ul>"},{"location":"zephyr-embedded/gpio/gpio/#kernel-configurations","title":"Kernel Configurations","text":"<p>No additional Kernel configurations needed to enable GPIO driver functionality.</p>"},{"location":"zephyr-embedded/gpio/gpio/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/gpio/gpio/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/basic/blinky.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: Blinky Sample\n 3 tests:\n 4   sample.basic.blinky:\n 5     tags:\n 6       - LED\n 7       - gpio\n 8     filter: dt_enabled_alias_with_parent_compat(\"led0\", \"gpio-leds\")\n 9     depends_on: gpio\n10     harness: led\n11     integration_platforms:\n12       - frdm_k64f\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code>CONFIG_GPIO=y\n</code></pre> <ol> <li>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 #include &lt;dt-bindings/gpio/gpio.h&gt;\n  8 \n  9 / {\n 10         aliases {\n 11                 led0 = &amp;myled0;\n 12         };\n 13 \n 14         leds {\n 15                 compatible = \"gpio-leds\";\n 16                 myled0: led_0 {\n 17                         gpios = &lt;&amp;gpio1 19 GPIO_ACTIVE_HIGH&gt;;\n 18                 };\n 19         };\n 20 };\n 21 \n 22 &amp;gpio1 {\n 23         status = \"okay\";\n 24 };\n</code></pre> 4. Agilex\u2122 5 specific board configuration -&gt;  intel_socfpga_agilex5_socdk.conf  <pre><code>  1 # Copyright (c) 2023, Intel Corporation.\n  2 # SPDX-License-Identifier: Apache-2.0\n  3 \n  4 CONFIG_STDOUT_CONSOLE=y\n  5 CONFIG_PRINTK=y\n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/basic/blinky.</p>"},{"location":"zephyr-embedded/gpio/gpio/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/basic/blinky  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/gpio/gpio/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nGPIO blinky application started\nGPIO toggle started for 10 times\nGPIO blinky Application completed!!!\n</code></pre>"},{"location":"zephyr-embedded/gpio/gpio/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/gpio/gpio/#other-consideration","title":"Other Consideration","text":"<p>Pinmux configuration should be in GPIO mode to use respective IO functionality.</p>"},{"location":"zephyr-embedded/psci/psci/","title":"Power State Coordination Interface (PSCI) driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/psci/psci/#introduction","title":"Introduction","text":"<p>Power State Coordination Interface (PSCI) is an Arm\u00ae standard that describes a software interface for power management between and operating system and supervisory firmware. Refer to Arm PSCI Platform Design Document for the PSCI interface specification.</p> <p>The following diagram shows the interaction between Zephyr/OS and Secure Monitor firmware ATF BL31 for PSCI interface.</p> <p></p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/psci/psci/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/pm_cpu_ops/pm_cpu_ops_psci.c</p>"},{"location":"zephyr-embedded/psci/psci/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>This driver provides the cold and warm reset functionality.</li> <li>This driver/module also provides a shell interface via which user can issue cold/warm reset commands.</li> </ul>"},{"location":"zephyr-embedded/psci/psci/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_PM_CPU_OPS</p> <p></p> <p>CONFIG_PM_CPU_OPS_PSCI</p> <p></p>"},{"location":"zephyr-embedded/psci/psci/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the PSCI:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/psci/psci/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/qspi/qspi/","title":"QSPI Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/qspi/qspi/#introduction","title":"Introduction","text":"<p>The HPS has the capability to access serial NOR Flash connected to the SDM quad serial peripheral interface (SPI). The quad SPI flash controller supports standard SPI Flash devices as well as high-performance dual and quad SPI Flash devices.</p> <p>On power up, the SDM owns the QSPI controller. For the HPS to use the QSPI controller, the HPS must request ownership from the SDM.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>QSPI driver (Polling-based mechanism - Upstreamed): https://github.com/zephyrprojectrtos/zephyr/blob/main/drivers/flash/flash_cadence_qspi_nor.c</p> <p>QSPI driver (with Interrupt-based mechanism \u2013 Not yet Upstreamed): https://github.com/altera-opensource/zephyrsocfpga/blob/socfpga_rel_23.4/drivers/flash/flash_cadence_qspi_nor.c</p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supported Operations: Read, Write, Erase</li> </ul>"},{"location":"zephyr-embedded/qspi/qspi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_FLASH</p> <p></p> <p>CONFIG_FLASH_CAD_QSPI_NOR</p> <p></p> <p>CONFIG_FLASH_PAGE_LAYOUT</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the QSPI: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/soc_flash_qspi.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <p>```   1  sample:   2   description: Cadence QSPI Driver sample application.   3   name: cdns_qspi_nor   4 tests:   5   sample.drivers.flash.soc_flash_qspi:   6     platform_allow:   7       - intel_socfpga_agilex5_socdk   8     integration_platforms:   9       - intel_socfpga_agilex5_socdk  10     tags:  11       - flash  12       - cdns  13     harness: console  14     harness_config:  15       fixture: external_flash  16       type: multi_line  17       ordered: true</p> <p>```</p> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <p><pre><code>  1 # Copyright (c) 2023, Intel Corporation.\n  2 # SPDX-License-Identifier: Apache-2.0\n  3 \n  4 # Misc\n  5 CONFIG_HEAP_MEM_POOL_SIZE=363840\n  6 \n  7 # Enable Flash\n  8 CONFIG_FLASH=y\n  9 CONFIG_FLASH_PAGE_LAYOUT=y\n 10 CONFIG_LOG=y\n</code></pre> 4. Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay <pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  * SPDX-License-Identifier: Apache-2.0\n  4  */\n  5\n  6 /* The overlay file should be used to enable any\n  7  * dts nodes required by this application for this\n  8  * board.\n  9  */\n 10\n 11 / {\n 12         aliases {\n 13                 qspi = &amp;qspi;\n 14         };\n 15 };\n 16\n 17 &amp;qspi {\n 18         status = \"okay\";\n 19 };\n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/soc_flash_qspi/src/main.c.</p>"},{"location":"zephyr-embedded/qspi/qspi/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/soc_flash_qspi/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/qspi/qspi/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n[00:00:00.219,000] &lt;inf&gt; clock_control_agilex5: Intel Agilex5 clock driver initialized!\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: Initializing Qspi\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: QSPI Capacity: 10000000\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: Flash size: 268435456 Bytes\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nQSPI flash driver test sample\nQSPI flash device block size = 100\nQSPI flash number of pages = 100000\nQSPI flash driver block size 100\nThe Page size of 100\nQSPI flash driver data erase successful....\nQSPI flash driver write completed....\nQSPI flash driver read completed....\nQSPI flash driver read verified\nQSPI flash driver data erase successful....\nQSPI flash driver read verified after erase....\nQSPI flash driver test sample completed....\n</code></pre>"},{"location":"zephyr-embedded/qspi/qspi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/","title":"Reset Manager for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#introduction","title":"Introduction","text":"<p>The Reset Manager generates individual module reset signals. Each module takes its module reset signal from the Reset Manager and conditions it to match the reset requirements of that module. The reset controller is designed to work with the SDM, which acts as the software-controlled master reset for the HPS. </p> <p>The following diagram shows the Reset Manager connectivity with Agilex5 HPS.</p> <p></p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/commits/main/drivers/reset/reset_intel_socfpga.c.</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Reset manager provides the capability to reset (bring it out of reset state) each peripheral in the system separately.</li> <li>It provides API to assert, de-assert, and toggle the reset line of each peripheral.</li> </ul>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_RESET</p> <p></p> <p>CONFIG_RESET_INTEL_SOCFPGA</p> <p></p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the Reset manager IP:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/seu/seu/","title":"Seu","text":"<p>Single Error Upset (SEU) Driver for Hard Processor System</p> <p>Last updated: December 08, 2024 </p> <p>Upstream Status: In Progress</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/seu/seu/#introduction","title":"Introduction","text":"<p>The SEU driver is meticulously crafted to fulfill a dual purpose within its operational framework. Its primary function lies in promptly detecting and reporting single event upsets errors to users. Additionally, this subsystem offers a streamlined mechanism for the deliberate insertion of errors.</p> <p>For more information, please refer to the Agilex5 SEU Mitigation.</p>"},{"location":"zephyr-embedded/seu/seu/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/pull/67097.</p>"},{"location":"zephyr-embedded/seu/seu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supports user register/unregister callback</li> <li>Support inject ECC error</li> <li>Support injects single/multibit errors</li> </ul>"},{"location":"zephyr-embedded/seu/seu/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SEU</p> <p></p> <p>CONFIG_SEU_INTEL_SOCFPGA</p> <p></p> <p>CONFIG_SEU_MAX_CLIENT</p> <p></p> <p>CONFIG_ MAX_TIMEOUT_MSECS</p> <p></p>"},{"location":"zephyr-embedded/seu/seu/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the SEU is at https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi.</p> <p></p>"},{"location":"zephyr-embedded/seu/seu/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"zephyr-embedded/smp/smp/","title":"SMP (Symmetric Multi-Processing) support for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/smp/smp/#introduction","title":"Introduction","text":"<p>SMP (Symmetric Multi-Processing) refers to running operating system on multiple CPU cores. Zephyr kernel supports SMP which can turn on and off the non-boot cores (aka secondary cores).</p> <p>Zephyr sends \u201cCPU_ON\u201d and \u201cCPU_OFF\u201d functions via PSCI SMC to ATF BL31 to turn on and off individual core. Zephyr supports CPU hot plug which provides public API and command line to turn on and off the individual core including both boot and non-boot cores during runtime. </p> <p>The below diagram shows HPS SMP flow (CPU_ON and CPU_OFF) supported by Zephyr:</p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/smp/smp/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/arch/arm64/core/smp.c</p>"},{"location":"zephyr-embedded/smp/smp/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Bring up secondary cores; power-on, initialize the secondary cores and make them ready to run as part of multi-core boot system.</li> </ul>"},{"location":"zephyr-embedded/smp/smp/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SMP</p> <p></p> <p>CONFIG_MP_MAX_NUM_CPUS=4</p> <p></p>"},{"location":"zephyr-embedded/smp/smp/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the smp:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/smp/smp/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/timer/timer/","title":"General Purpose Timer Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/timer/timer/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) provides four 32-bit general-purpose timers. The timer generates an interrupt when the 32-bit binary count-down timer reaches zero.</p> <p>Each timer can operate in one-shot mode (alarm mode) or periodic mode.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/counter/counter_dw_timer.c.</p>"},{"location":"zephyr-embedded/timer/timer/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>The timer can be configured to run as a one-shot timer(alarm).</li> <li>The timer can be configured to run as a periodic timer.</li> <li>Run timer in free running mode.</li> <li>Stop Timer.</li> </ul>"},{"location":"zephyr-embedded/timer/timer/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_COUNTER_SNPS_DW</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the timer:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/counter/alarm.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: Counter RTC Driver Sample\n 3 tests:\n 4   sample.drivers.counter.alarm:\n 5     tags:\n 6       - drivers\n 7       - counter\n 8     harness: console\n 9     platform_allow:\n10       - nucleo_f746zg\n       .....   \n27       - stm32h573i_dk\n28     integration_platforms:\n29       - nucleo_f746zg\n30     harness_config:\n31       type: multi_line\n32       ordered: true\n33       regex:\n34         - \"Counter alarm sample\"\n35         - \"Set alarm in 2 sec\"\n36         - \"!!! Alarm !!!\"\n37         - \"Now: [2|3]\"\n38     depends_on: counter\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code> 1 CONFIG_PRINTK=y\n 2 CONFIG_COUNTER=y                     \n</code></pre> <ol> <li>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 &amp;timer0 {\n  8         status = \"okay\";\n  9 };\n</code></pre> 4. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/counter/alarm/src/main.c.</p>"},{"location":"zephyr-embedded/timer/timer/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/counter/alarm  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/timer/timer/#output","title":"Output","text":"<pre><code>NOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nCounter alarm sample\n\nSet alarm in 2 sec (200000000 ticks)\n!!! Alarm !!!\nNow: 1\nSet alarm in 4 sec (400000000 ticks)\n</code></pre>"},{"location":"zephyr-embedded/timer/timer/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/uart/uart/","title":"UART Driver for Hard Processor System","text":"<p>Last updated: December 08, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/uart/uart/#introduction","title":"Introduction","text":"<p>Universal Asynchronous Receiver/Transmitter (UART) that is part of the hardened Hard Processor System (HPS) of the FPGA performs parallel to serial data conversion from HPS CPU to device or serial-to-parallel data conversion from device to HPS CPU. The UART controllers are based on an industry standard 16550 UART controller.</p> <p>The below diagram represents block diagram of the UART controller connected with other components in the system.</p> <p></p> <p>Functional blocks:</p> <ul> <li>Slave interface: connects to APB bus.</li> <li>Register block: responsible for the main UART functionality including control, status, and interrupt generation.</li> <li>FIFO block: responsible for FIFO control and storage.</li> <li>Baud block generator: produces the transmitter and receiver baud clock along with the output reference clock signal.</li> <li>Serial transmitter: converts the parallel data-written to the UART-into serial form and adds all additional bits, as specified by the control register, for transmission. These serial data referred to as a character.</li> <li>Serial receiver: converts the serial data character-specified by the control register-receive in the UART to parallel form. This block controls, parity, framing and line break detection errors.</li> </ul> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/uart/uart/#features","title":"Features","text":"<ul> <li>Programmable character properties, such as number of data bits per character, optional parity bits, and number of stop bits.</li> <li>Automatic hardware flow control as per the 16750 standards.</li> <li>128-byte transmit and receive FIFO buffers.</li> <li>Transmit Holding Register Empty (THRE) interrupt mode.</li> <li>DMA controller handshaking interface.</li> <li>Parity error detection, Framing error detection and, Line break detection.</li> <li>Prioritized interrupt identification with different interrupt types.</li> </ul>"},{"location":"zephyr-embedded/uart/uart/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/commits/main/drivers/serial/uart_ns16550.c.</p>"},{"location":"zephyr-embedded/uart/uart/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the asynchronous communication between HPS CPU and device, and vice versa.</li> <li>Supports Full Duplex communication and Polling/Interrupt based mechanism for data transfer. </li> <li>Supports 16 bytes FIFO with automatic hardware flow control (RTS and CTS lines).</li> </ul>"},{"location":"zephyr-embedded/uart/uart/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_UART_NS16550</p> <p></p> <p>CONFIG_UART_INTERRUPT_DRIVEN</p> <p></p> <p>CONFIG_UART_NS16550_ACCESS_WORD_ONLY</p> <p></p>"},{"location":"zephyr-embedded/uart/uart/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the uart:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/uart/uart/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/uart/echo_bot.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: UART driver sample\n 3 tests:\n 4   sample.drivers.uart:\n 5     integration_platforms:\n 6       - qemu_x86\n 7     tags:\n 8       - serial\n 9       - uart\n10     filter: CONFIG_SERIAL and\n11             CONFIG_UART_INTERRUPT_DRIVEN and\n12             dt_chosen_enabled(\"zephyr,shell-uart\")\n13     harness: keyboard\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code>  1 CONFIG_SERIAL=y\n  2 CONFIG_UART_INTERRUPT_DRIVEN=y\n</code></pre> <ol> <li>Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/uart/echo_bot/src/main.c.</li> </ol>"},{"location":"zephyr-embedded/uart/uart/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/uart/echo_bot/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/uart/uart/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nHello! I'm your echo bot.\nTell me something and press enter:\nEcho: hello there\n</code></pre>"},{"location":"zephyr-embedded/uart/uart/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"zephyr-embedded/watchdog/watchdog/","title":"Watchdog Timer Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#introduction","title":"Introduction","text":"<p>The watchdog timer is used mainly to recover from system lockup that might be caused by software or system-related issues. </p> <p>The hard processor system (HPS) provides five Watchdog Timers based on synopsis designware.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/watchdog/wdt_dw.c.</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Watchdog can be enabled/disabled in driver initialization when zephyr boots through Kconfig option.</li> <li>Enable/Disable watchdog interrupt when the timer expires.</li> <li>Watchdog Timers counts down from a preset value to zero, then performs one of the following user-configurable operations:     * Generates a system reset.     * Generates an interrupt, restarts the timer, and if the timer is not cleared before a second timeout occurs, generates a system reset Driver can be configured for one of the possible three use cases.</li> </ul>"},{"location":"zephyr-embedded/watchdog/watchdog/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ WDT_DW</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the Watchdog:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/watchdog.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <p>```   1 sample:   2   name: Watchdog Driver Sample   3 common:   4   tags:   5     - drivers   6     - watchdog   7   harness: console   8   harness_config:   9     type: multi_line  10     ordered: true  11     regex:  12       - \"Watchdog sample application\"  13       - \"Feeding watchdog...\"  14       - \"Waiting for reset...\"  15       - \"Watchdog sample application\"  16   depends_on: watchdog</p> <p>```</p> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <p><pre><code>  1 CONFIG_LOG=y\n  2 CONFIG_LOG_MODE_IMMEDIATE=y\n  3 CONFIG_WDT_LOG_LEVEL_DBG=y\n  4 CONFIG_WATCHDOG=y\n  5 CONFIG_WDT_DISABLE_AT_BOOT=n\n</code></pre> 3. Specific board config -&gt; intel_socfpga_agilex5_socdk.conf  <pre><code>  1 CONFIG_WDT_DW_RESET_MODE=2\n  2 CONFIG_WDT_DW_PAUSE_BY_DBG=y\n</code></pre> 4. Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay <pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6\n  7 / {\n  8         aliases {\n  9                 watchdog0 = &amp;watchdog0;\n 10         };\n 11 };\n 12\n 13 &amp;watchdog0 {\n 14         interrupt-parent = &lt;&amp;gic&gt;;\n 15         interrupts = &lt;GIC_SPI 117 IRQ_TYPE_LEVEL\n 16                         IRQ_DEFAULT_PRIORITY&gt;;\n 17         status = \"okay\";\n 18 };             \n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/watchdog/src/main.c.</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/watchdog/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/watchdog/watchdog/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nWatchdog sample application\nAttempting to test pre-reset callback\nFeeding watchdog 5 times\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nWaiting for reset...\nHandled things..ready to reset\nNOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nWatchdog sample application\nAttempting to test pre-reset callback\nFeeding watchdog 5 times\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nWaiting for reset...\n</code></pre>"},{"location":"zephyr-embedded/watchdog/watchdog/#known-issues","title":"Known Issues","text":"<p>None known</p>"}]}