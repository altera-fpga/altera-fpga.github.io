{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Altera FPGA Developer Site  <p>Welcome to the Altera FPGA Developer Site!</p> <p>This site provides key information for Altera Agilex\u2122 5 and Agilex\u2122 7 FPGAs including:</p> <ul> <li>Comprehensive driver information for Linux and software utilities.</li> </ul> <ul> <li>Documentation for how to use example designs and tutorials found on our altera-fpga GitHub site.</li> </ul> <p>   <p></p> <p>Use the table below to help you get started.</p>    Software Developer FPGA Developer Application Developer          Take advantage of our software resources to develop a full stack solution for your applications:* Linux Drivers  * Host Attach Utilities Use our design example resources as a starting point for your own custom design or peruse our demos to learn more about a specific topic: * Example Designs * Demos Review our software utilities and higher level stack offerings:* Host Attach Utilities","text":""},{"location":"common/templates/linux_driver_template/","title":"Linux driver template","text":""},{"location":"common/templates/linux_driver_template/#host-attach-dfl-fpga-management-engine-ip-driver","title":"Host Attach DFL FPGA Management Engine IP Driver","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"common/templates/linux_driver_template/#introduction","title":"Introduction","text":"<p>This set of drivers is designed to support FME functionality, as implemented under FPGA Device Feature List (DFL) framework. It is used to expose FME capabilities.</p> Driver Mapping Source(s) Required for DFL dfl-fme.ko FPGA Management Engine IP drivers/fpga/ - dfl-fme.h, dfl-fme-main.c, dfl-fme-pr.c, dfl-fme-error.c, dfl-fme-perf.c Y dfl-fme-mgr.ko PR IP drivers/fpga/dfl-fme-mgr.c N dfl-fme-br.ko SW Dependency drivers/fpga/dfl-fme-br.c N dfl-fme-region.ko SW Dependency drivers/fpga/dfl-fme-region.c N <pre><code>graph TD;\n    A[dfl-fme]--&gt;B[dfl-fme-mgr];\n    A[dfl-fme]--&gt;C[dfl-fme-br];\n    A[dfl-fme]--&gt;D[dfl-fme-region]; </code></pre>"},{"location":"common/templates/linux_driver_template/#fpga-management-engine-ip","title":"FPGA Management Engine IP","text":"<p>The FPGA Management Engine IP provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA. Implementation of a PR region is optional.</p> <p>Each FME feature exposes its capability to host software drivers through a device feature header (DFH) register found at the beginning of its control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link. For more information about DFHs, refer to the Device Feature Header (DFH) structure.</p>"},{"location":"common/templates/linux_driver_template/#driver-sources","title":"Driver Sources","text":"<p>The source code for these drivers can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga, where branches labelled fpga-ofs-dev-*-lts correspond with the latest developmental versions of the DFL driver suite on that specific kernel version.</p>"},{"location":"common/templates/linux_driver_template/#driver-capabilities","title":"Driver Capabilities","text":"<p>This driver set is a DFL specific implementation of generic FPGA drivers available in the kernel. <code>dfl-fme-mgr</code> is a DFL specific instantiation of the generic FPGA manager (drivers/linux/fpga/fpga-mgr.c), <code>dfl-fme-br</code> builds on top of a generic FPGA bridge (drivers/fpga/fpga-bridge.c), and <code>dfl-fme-region</code> instantiates an FPGA region. All three supplementary DFL Drivers depend on <code>dfl-fme</code>.</p> <p>The DFL FME driver is a feature device implemented under the Device Feature List (DFL) framework. It enables the platform driver for the FME IP and implements all FPGA platform level management features. Only one FME is created per DFL based FPGA device. The DFL Bridge, Manager, and Region drivers are only required when attempting to configure a PR region in the FIM.</p>"},{"location":"common/templates/linux_driver_template/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_FME</p> <p></p> <p>FPGA_DFL_FME_MGR</p> <p></p> <p>FPGA_DFL_FME_BRIDGE</p> <p></p> <p>FPGA_DFL_FME_REGION</p> <p></p>"},{"location":"common/templates/linux_driver_template/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"common/templates/linux_driver_template/#example-designs","title":"Example Designs","text":"<p>The FPGA Management Engine IP is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"doc_modules/Notices_%26_Disclaimers/","title":"Notices & Disclaimers","text":""},{"location":"doc_modules/Notices_%26_Disclaimers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"driver-list/driver-list-all/","title":"All Drivers","text":"<p>This table provides a comprehensive list for all drivers available for Agilex 5 and Agilex 7. </p> <p>You can filter your search by entering your query into any number of available columns.</p> <ul> <li>The Name column indicate the name of the IP that the driver supports.</li> <li>If a driver exists then a link to a driver page is provided for more details. N/A means driver support \"Not Available\" for the particular IP.</li> </ul> IP Name Linux Driver Zephyr Driver Altera 16550 Compatible UART Core Linux Zephyr Clock Manager Linux Zephyr Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) N/A PSCI Device Feature List (DFL) Capability Linux N/A DFL Accelerator Functional Unit (AFU workload) Linux N/A DFL FPGA Management Engine IP Linux N/A DFL Memory Interface/Subsystem Linux N/A DFL Time of Day Clock Intel FPGA IP Linux: Host Attach TOD Linux: Embedded TOD N/A Direct Memory Access Controller (DMAC) Linux zephyr Error Detection and Correction (EDAC) Linux N/A Ethernet Media Access Controller Linux N/A Ethernet Subsystem (HSSI SS) Linux N/A Ethernet Subsystem Intel FPGA IP (HSSI xTile) Linux N/A Ethernet 1588 PTP Time of Day Clock Linux N/A General Purpose Timers Linux N/A Generic Serial Flash Interface Intel FPGA IP Linux N/A GPIO Linux Zephyr I2C Linux N/A I3C Linux N/A Interrupt Controller (GICv3) Linux Agilex 5  Agilex 7 Microchip\u00ae Zarlink ZL30793 Network Synchronizer Linux N/A MSGDMA Linux N/A NAND Controller Linux N/A PCIe Subsystem Linux N/A QSPI Linux Zephyr QSFP Linux N/A Reset Manager Linux Zephyr Single Error Upset (SEU) N/A Zephyr SD/eMMC Controller Linux N/A SMMU Linux N/A SPI Linux N/A System Manager Linux N/A Timer N/A Zephyr UART Linux N/A USB 2.0 OTG Linux N/A Watchdog Timer Linux Zephyr"},{"location":"driver-list/driver-list-baremetal/","title":"Bare Metal Drivers","text":"<p>The table below provides a comprehensive list of the drivers available for Agilex 5 FPGA IP.</p> <ul> <li>The target link indicate the devices this driver supports.  </li> <li>The description link provides feature description, architectural details, known issues and release information.</li> <li>Upstreamed column indicates if driver is being mainstreamed in the Linux tree.</li> </ul> <p>Location column indicates the link where the driver is located (userspace, linux.org, Quartus).</p> Name Supported Device(s) Documentation Upstream Status Kernel Source N/A N/A N/A N/A N/A"},{"location":"driver-list/driver-list-linux/","title":"Linux Drivers","text":"<p>The table below provides a comprehensive list of the drivers available for Agilex 5 and Agilex 7.</p> <ul> <li>IP Name column indicates what type of IP the driver targets.  </li> <li>HPS or PCIe column indicates if the driver is targeting the embedded Host Processor System found on our devices or a server host or both.</li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) HPS or PCIe Host Documentation Upstream Status Kernel Source Altera 16550 Compatibe UART Core Agilex 7 PCIe UART Yes 8250_dfl Clock Manager Agilex 5 HPS Clock Manager No clk_agilex5 Device Feature List  (DFL) Capability Stratix 10  Agilex 7 PCIe dfl Yes dfl DFL Accelerator Functional Unit (AFU workload) Agilex 7  Stratix 10 PCIe dfl-afu Yes dfl-afu-dma-regiondfl-afu-errordfl-afu-regiondfl-afu-main DFL FPGA Management Engine IP Agilex 7 Stratix 10 PCIe dfl-fme Yes dfl-fme-mgr dfl-fme-brdfl-fme-region DFL Memory Interface/Subsystem Agilex 7Stratix 10 PCIe Memory Yes dfl-emif Direct Memory Access Controller (DMAC) Agilex 5 HPS DMAC Yes dmac Error Detection and Correction (EDAC) Agilex 5 HPS EDAC Yes altera_edac Ethernet 1588 PTP Time of Day Clock Agilex 7 HPS/PCIe PCIe Attach ToD Embedded ToD Yes ToD PCIe-Attach driver  ToD Embedded driver  Ethernet Media Access Controller Agilex 5 HPS EMAC No dwxgmac2_core Ethernet Subsystem Intel FPGA IP (MAC-Specific) Agilex 7 HPS HSSI No intel_fpga_hssiss Ethernet Subsystem Intel FPGA IP (Tile-Specific) Agilex 7 HPS hssi_xtile No eth_main etile_fec etile_driver etile_ethtool ftile_ethtool ftile_fec ftile_driver General Purpose Timers Agilex 7  Agilex 5 HPS GP Timers Yes dw_apb_timer Generic Serial Flash Interface Intel FPGA IP Agilex 7Stratix 10 PCIe Generic Serial Flash Yes spi General Purpose I/O (GPIO) Agilex 7  Agilex 5 HPS gpio Yes gpio-dwapb I2C Agilex 7  Agilex 5 HPS I2C Yes I2c driver I3C Agilex 5 HPS I3C Yes I3c driver Interrupt Controller (GICv3) Agilex 5 HPS GICv3 Yes GICv3 driver Microchip\u00ae Zarlink ZL30793 Network Synchronizer Agilex 7 HPS Zarlink No Zarlink driver  MSGDMA Agilex 7 HPS MSGDMA No MSGDMA driver NAND Controller Agilex 5 HPS NAND Yes cadence-nand-controller PCIe Subsystem Agilex 7 PCIe PCIe Subsystem Yes dfl-pcie QSFP Agilex 7 HPS QSFP No qsfp QSPI Agilex 5 HPS QSPI No spi-cadence-quadspi Reset Manager Agilex 5 HPS Reset Manager No Reset Manager driver SD/eMMC Controller Agilex 5 HPS SD/eMMC Yes SD/eMMC driver SPI Agilex 7 Agilex 5 HPS SPI Yes SPI driver System Manager Agilex 5 HPS System manager Yes sysmgr System Memory Management Unit Agilex 5 HPS SMMU Yes SMMU driver UART Agilex 7  Agilex 5 HPS UART Yes UART driver USB 2.0 OTG Agilex 7  Agilex 5 HPS USB2.0 Yes USB 2.0 driver  Userspace I/O (UIO) Agilex 7 Stratix 10 PCIe UIO Yes UIO driver Watchdog Timer Agilex 5 HPS Watchdog Timer Yes dw_wdt"},{"location":"driver-list/driver-list-zephyr/","title":"Zephyr Drivers","text":"<p>The table below provides a comprehensive list of embedded Zephyr drivers available for the HPS and Nios V on Agilex 5 FPGA devices.</p> <ul> <li>IP Name column indicates what type of IP the driver targets. </li> <li>Target is </li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) Target Documentation Upstream Status Kernel Source Arm\u00ae Silicon Provider (SiP) Services Agilex 5 HPS SiP-SVC Yes sip_smc_intel_socfpga Clock Manager Agilex 5 HPS Clock Manager Yes clock_control_agilex5 Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS PSCI Yes pm_cpu_ops_psci DMAC Agilex 5 HPS DMAC Yes dma General Purpose Timer Agilex 5 HPS Timer Yes counter_dw_timer GPIO Agilex 5 HPS gpio No gpio_intel_socfpga Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS psci No psci QSPI Agilex 5 HPS QSPI Yes flash_cadence_qspi_nor Reset Manager Agilex 5 HPS Reset Manager Yes reset_intel_socfpga Single Event Upset (SEU) Agilex 5 HPS SEU In Progress pull/67097 SMP Agilex 5 HPS SMP Yes smp UART Agilex 5 HPS UART Yes uart_ns16550 Watchdog Timer Agilex 5 HPS Watchdog Timer Yes wdt_dw"},{"location":"driver-list_all/","title":"All Drivers","text":"<p>This table provides a comprehensive list for all drivers available for Agilex 5 and Agilex 7. </p> <p>You can filter your search by entering your query into any number of available columns.</p> <ul> <li>The Name column indicate the name of the IP that the driver supports.</li> <li>If a driver exists then a link to a driver page is provided for more details. N/A means driver support \"Not Available\" for the particular IP.</li> </ul> IP Name Linux Driver Zephyr Driver Altera 16550 Compatible UART Core Linux Zephyr Clock Manager Linux Zephyr Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) N/A PSCI Device Feature List (DFL) Capability Linux N/A DFL Accelerator Functional Unit (AFU workload) Linux N/A DFL FPGA Management Engine IP Linux N/A DFL Memory Interface/Subsystem Linux N/A DFL Time of Day Clock Intel FPGA IP Linux: Host Attach TOD Linux: Embedded TOD N/A Direct Memory Access Controller (DMAC) Linux zephyr Error Detection and Correction (EDAC) Linux N/A Ethernet Media Access Controller Linux N/A Ethernet Subsystem (HSSI SS) Linux N/A Ethernet Subsystem Intel FPGA IP (HSSI xTile) Linux N/A Ethernet 1588 PTP Time of Day Clock Linux N/A General Purpose Timers Linux N/A Generic Serial Flash Interface Intel FPGA IP Linux N/A GPIO Linux Zephyr I2C Linux N/A I3C Linux N/A Interrupt Controller (GICv3) Linux Agilex 5  Agilex 7 Microchip\u00ae Zarlink ZL30793 Network Synchronizer Linux N/A MSGDMA Linux N/A NAND Controller Linux N/A PCIe Subsystem Linux N/A QSPI Linux Zephyr QSFP Linux N/A Reset Manager Linux Zephyr Single Error Upset (SEU) N/A Zephyr SD/eMMC Controller Linux N/A SMMU Linux N/A SPI Linux N/A System Manager Linux N/A Timer N/A Zephyr UART Linux N/A USB 2.0 OTG Linux N/A Watchdog Timer Linux Zephyr"},{"location":"driver-list_baremetal/","title":"Bare Metal Drivers","text":"<p>The table below provides a comprehensive list of the drivers available for Agilex 5 FPGA IP.</p> <ul> <li>The target link indicate the devices this driver supports.  </li> <li>The description link provides feature description, architectural details, known issues and release information.</li> <li>Upstreamed column indicates if driver is being mainstreamed in the Linux tree.</li> </ul> <p>Location column indicates the link where the driver is located (userspace, linux.org, Quartus).</p> Name Supported Device(s) Documentation Upstream Status Kernel Source N/A N/A N/A N/A N/A"},{"location":"driver-list_linux/","title":"Linux Drivers","text":"<p>The table below provides a comprehensive list of the drivers available for Agilex 5 and Agilex 7.</p> <ul> <li>IP Name column indicates what type of IP the driver targets.  </li> <li>HPS or PCIe column indicates if the driver is targeting the embedded Host Processor System found on our devices or a server host or both.</li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) HPS or PCIe Host Documentation Upstream Status Kernel Source Altera 16550 Compatibe UART Core Agilex 7 PCIe UART Yes 8250_dfl Clock Manager Agilex 5 HPS Clock Manager No clk_agilex5 Device Feature List  (DFL) Capability Stratix 10  Agilex 7 PCIe dfl Yes dfl DFL Accelerator Functional Unit (AFU workload) Agilex 7  Stratix 10 PCIe dfl-afu Yes dfl-afu-dma-regiondfl-afu-errordfl-afu-regiondfl-afu-main DFL FPGA Management Engine IP Agilex 7 Stratix 10 PCIe dfl-fme Yes dfl-fme-mgr dfl-fme-brdfl-fme-region DFL Memory Interface/Subsystem Agilex 7Stratix 10 PCIe Memory Yes dfl-emif Direct Memory Access Controller (DMAC) Agilex 5 HPS DMAC Yes dmac Error Detection and Correction (EDAC) Agilex 5 HPS EDAC Yes altera_edac Ethernet 1588 PTP Time of Day Clock Agilex 7 HPS/PCIe PCIe Attach ToD Embedded ToD Yes ToD PCIe-Attach driver  ToD Embedded driver  Ethernet Media Access Controller Agilex 5 HPS EMAC No dwxgmac2_core Ethernet Subsystem Intel FPGA IP (MAC-Specific) Agilex 7 HPS HSSI No intel_fpga_hssiss Ethernet Subsystem Intel FPGA IP (Tile-Specific) Agilex 7 HPS hssi_xtile No eth_main etile_fec etile_driver etile_ethtool ftile_ethtool ftile_fec ftile_driver General Purpose Timers Agilex 7  Agilex 5 HPS GP Timers Yes dw_apb_timer Generic Serial Flash Interface Intel FPGA IP Agilex 7Stratix 10 PCIe Generic Serial Flash Yes spi General Purpose I/O (GPIO) Agilex 7  Agilex 5 HPS gpio Yes gpio-dwapb I2C Agilex 7  Agilex 5 HPS I2C Yes I2c driver I3C Agilex 5 HPS I3C Yes I3c driver Interrupt Controller (GICv3) Agilex 5 HPS GICv3 Yes GICv3 driver Microchip\u00ae Zarlink ZL30793 Network Synchronizer Agilex 7 HPS Zarlink No Zarlink driver  MSGDMA Agilex 7 HPS MSGDMA No MSGDMA driver NAND Controller Agilex 5 HPS NAND Yes cadence-nand-controller PCIe Subsystem Agilex 7 PCIe PCIe Subsystem Yes dfl-pcie QSFP Agilex 7 HPS QSFP No qsfp QSPI Agilex 5 HPS QSPI No spi-cadence-quadspi Reset Manager Agilex 5 HPS Reset Manager No Reset Manager driver SD/eMMC Controller Agilex 5 HPS SD/eMMC Yes SD/eMMC driver SPI Agilex 7 Agilex 5 HPS SPI Yes SPI driver System Manager Agilex 5 HPS System manager Yes sysmgr System Memory Management Unit Agilex 5 HPS SMMU Yes SMMU driver UART Agilex 7  Agilex 5 HPS UART Yes UART driver USB 2.0 OTG Agilex 7  Agilex 5 HPS USB2.0 Yes USB 2.0 driver  Userspace I/O (UIO) Agilex 7 Stratix 10 PCIe UIO Yes UIO driver Watchdog Timer Agilex 5 HPS Watchdog Timer Yes dw_wdt"},{"location":"driver-list_zephyr/","title":"Zephyr Drivers","text":"<p>The table below provides a comprehensive list of embedded Zephyr drivers available for the HPS and Nios V on Agilex 5 FPGA devices.</p> <ul> <li>IP Name column indicates what type of IP the driver targets. </li> <li>Target is </li> <li>Documentation column provides a link to driver description, architectural details, driver capabilities and configurations, known issues and release information.</li> <li>Upstream Status column indicates mainstream status of driver.</li> <li>Kernel Source indicates location of driver.</li> </ul> <p>You can use the filter fields to narrow your search.</p> IP Name Supported Device(s) Target Documentation Upstream Status Kernel Source Arm\u00ae Silicon Provider (SiP) Services Agilex 5 HPS SiP-SVC Yes sip_smc_intel_socfpga Clock Manager Agilex 5 HPS Clock Manager Yes clock_control_agilex5 Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS PSCI Yes pm_cpu_ops_psci DMAC Agilex 5 HPS DMAC Yes dma General Purpose Timer Agilex 5 HPS Timer Yes counter_dw_timer GPIO Agilex 5 HPS gpio No gpio_intel_socfpga Cold &amp; Warm Reset -Power State Coordination Interface (PSCI) Agilex 5 HPS psci No psci QSPI Agilex 5 HPS QSPI Yes flash_cadence_qspi_nor Reset Manager Agilex 5 HPS Reset Manager Yes reset_intel_socfpga Single Event Upset (SEU) Agilex 5 HPS SEU In Progress pull/67097 SMP Agilex 5 HPS SMP Yes smp UART Agilex 5 HPS UART Yes uart_ns16550 Watchdog Timer Agilex 5 HPS Watchdog Timer Yes wdt_dw"},{"location":"ed-demo-list/demo-list/","title":"Demonstrations","text":"<p>The table below provides a comprehensive list of Altera demonstrations.  Demos are self-contained RTL, software or incomplete designs that demonstrate a concept.</p> <ul> <li>Demos Repository provides direct link to repository containing hardware source code and release.</li> <li>Supported Devices column indicates the demos device targets.  A listing of \"All\" means that this demo can be run on any device family.</li> <li>Development Kit Target lists development kits on which the demonstration is tested.</li> <li>Summary provides a short description of the demonstration.</li> <li>Documentation column provides a link to corresponding user documentation.</li> </ul> <p>You can use the filter fields to narrow your search.</p> Demos Repository Supported Device(s) Development Kit Target Summary Documentation HPS-FPGA Interface Demos Agilex 5 * Agilex 5 E-Series Premium Development Kit * Third Party Boards Shows how users can implement and interact with the various hardware interfaces between the Hard Processing System (SoC) and FPGA fabric on the Agilex 5 FPGA device family HPS-FPGA Interfaces Demos User Guide"},{"location":"ed-demo-list/ed-list/","title":"Example Designs","text":"<p>The table below provides a comprehensive list of example designs. </p> <ul> <li>Demonstration Repository provides direct link to repository containing hardware source code and release.</li> <li>Supported Devices column indicates demonstration device targets.  A listing of \"All\" means that this demo can be run on any device family.</li> <li>Development Kit Target lists development kits on which the demonstration is tested.</li> <li>Summary provides a short description of the demonstration.</li> <li>Documentation column provides a link to corresponding user documentation.</li> </ul> <p>You can use the filter fields to narrow your search.</p> Example Design Supported Device(s) Embedded/Host Attach/Hostless Development Kit Target Summary Documentation Golden System Reference Design (GSRD) Agilex 5 Embedded * Agilex 5 E-Series Premium Development Kit * Agilex 5 E-Series Modular Development Kit Provides instructions on how to test a basic HPS example with software on the development kit * Agilex 5 E-Series Premium Development Kit GSRD User Guide* Agilex 5 E-Series Modular Development Kit GSRD User Guide Golden System Reference Design (GSRD) Agilex 5 Embedded Agilex 5 E-Series Universal Virtual Platforms Provides instructions on how to exercise several    use cases in which HPS software is running on the Intel Simics simulator using virtual platforms * Agilex\u2122 5 Intel Simics Virtual Platform Example User Guide - Linux GSRD *Agilex\u2122 5 Intel Simics Virtual Platform Example User Guide - Zephyr GSRD Golden Hardware Reference Design (GHRD) Boot Examples Agilex 5 Embedded * Agilex 5 E-Series Premium Development Kit * Agilex 5 E-Series Modular Development Kit Provides instructions on how to build Linux systems from separate components * Agilex 5 E-Series Premium Development Kit GHRD Linux Boot Examples * Agilex 5 E-Series Modular Development Kit GHRD Linux Boot Examples HPS Remote System Update Example Agilex 7 Embedded Agilex\u2122 7 Transceiver-SoC Development kit P-Tile E-Tile production Linear power solution (DK-SI-AGF014EB) Provides a complete Remote System Update example including build and execution Agilex 7 HPS Remote System Update Example HPS Remote System Update Example Stratix 10 Embedded Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) Provides a complete Remote System Update example including build and execution Stratix 10 HPS Remote System Update Example"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/","title":"Agilex\u2122 5 Intel Simics Virtual Platform Example User Guide - Linux GSRD","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#overview","title":"Overview","text":"<p>Agilex\u2122 5 E-Series devices provide the next-generation hard processor system (HPS) after those provided with the Agilex\u2122 7 and  Stratix\u00ae 10 SoC FPGA devices. Agilex\u2122 5 E-Series devices support new features, such as TSN, USB 3.1 Gen 1, and I3C, SPI.</p> <p>The Agilex\u2122 5 E-Series HPS application processors can run Linux or an RTOS, such as Zephyr*, with a scalable performance using one to four Arm* Cortex*-A cores with variable frequencies that allow for a wide range of applications.</p> <p>The Agilex\u2122 5 E-Series Simics virtual platform models the HPS processor with two Arm Cortex-A55 cores, two Arm Cortex-A76 cores, and HPS peripherals. The Agilex\u2122 5 E-Series HPS virtual platform is released as part of the Simics\u00ae Simulator for Intel\u00ae FPGAs software, which also includes several virtual platforms where the Agilex\u2122 5 E-Series device is instantiated, emulating the concept of having different versions of a development kit or daughter cards.</p> <p>The Agilex\u2122 5 E-Series device has the following supported virtual platforms:</p> <ul> <li>Agilex\u2122 5 E-Series Virtual Platform - Universal</li> </ul> <p>The following sections describe the prerequisites for the Intel Simics Simulator for Intel\u00ae FPGA and the available virtual platforms, including prebuilt binaries, and instructions for building these binaries. It also covers some common use cases that you can exercise on the virtual platforms.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#prerequisites","title":"Prerequisites","text":"<p>To exercise the instructions presented on this page (build your binaries and exercise the use cases), your system must satisfy the following prerequisites:</p> <ul> <li>Host PC with Linux OS. (Note: Instructions on this page use Ubuntu 22.04 LTS.)</li> <li>The following packages are needed to deploy the Simics project:<ul> <li>GCC 6.3 compiler or higher</li> <li>g++ 9.4 or higher</li> <li>GNU make 4.1 or higher</li> </ul> </li> <li>Local Ethernet network with DHCP server (provides IP address to the board).</li> <li>Intel Simics Simulator for Intel FPGAs installed.</li> <li>Intel Agilex\u2122 5 Virtual Platform components available to be deployed.</li> </ul> <p>Notes:</p> <ul> <li>For binaries building instructions, see Build Instructions.</li> <li>For installation instructions for the Intel Simics Simulator for Intel FPGAs and the Agilex\u2122 5 E-Series virtual platforms, refer to the following documents:<ul> <li>Intel\u00ae Simics\u00ae Simulator for Intel\u00ae FPGAs User Guide</li> <li>Agilex\u2122 5 E-Series Virtual Platform User Guide</li> </ul> </li> <li>U-Boot, Linux compilation, Yocto compilation, and the creation of an SD card image require a Linux host PC.   To create these binaries, the toolchain and other software required need to be downloaded. This is described as part of the instructions in each section.</li> <li>The Intel Simics Simulator for Intel\u00ae FPGAs is available only for Linux systems.</li> <li>In case any use case requires additional prerequisites, these are listed as part of the use case description.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#release-content","title":"Release Content","text":"<p>Version: 24.2</p> SW Component Repository Branch/TAG/Version U-Boot https://github.com/altera-opensource/u-boot-socfpga v2024.01/QPDS24.2_REL_GSRD_PR/ 157b759210e2024649081657b56adfc41fb56f34 ATF https://github.com/altera-opensource/arm-trusted-firmware v2.10.1/QPDS24.2_REL_GSRD_PR/ 4837356693ede42b849ed72f1864cc9c76c53a46 Linux https://github.com/altera-opensource/linux-socfpga v6.6.22/QPDS24.2_REL_GSRD_PR/ f939c80e4195178b511c7577e0dc2a570ca0a426 Reference Design Sources https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap(5.0)/QPDS24.2_REL_GSRD_PR/ 538621d98ec91ce4c474c14e65b72c99615531e8 GSRD https://github.com/altera-opensource/gsrd-socfpga scarthgap Yocto Project https://git.yoctoproject.org/poky scarthgap(5.0)/ a099b484c5b245a335a5ec9b293638e1362383ae Reference Design Recipes https://git.yoctoproject.org/meta-intel-fpga scarthgap(5.0)/QPDS24.2_REL_GSRD_PR/ 03de87a47b70d7cec1d6cb657714b0ef55e47cae Arm Debugger http://fpgasoftware.intel.com/armds ARM DS 2022.2 Ashling RiscFree https://www.intel.com/content/www/us/en/software-kit/826843/intel-quartus-prime-pro-edition-design-software-version-24-2-for-linux.html Additional Software/Stand-Alone Software tab 24.2 <p>Note: For information prior 24.2 release, please refer to Linux GSRD Intel Simics Virtual Platform for Intel Agilex\u00ae 5 E-Series. </p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>Note: For 24.2 release, there are not binaries since this is a source code release.</p> <p>You can find the prebuilt binaries from the GSRD prebuilt at the following URL: https://releases.rocketboards.org/2024.05/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ . The files in this folder allow you to boot directly from SDCard. It also contains some of the files that are used to generate the final images used to boot from QSPI and from NAND. The following folders contain the remaining files used by the recipes to create the binaries to boot from QSPI and NAND.</p> <ul> <li>QSPI: QSPI boot complement files. Here is the link to obtain the uboot_script.its file which is also needed.</li> <li>NAND: No available since NAND is not supported in silicon yet.</li> </ul> <p>Note: The final images used to boot from QSPI and NAND are not provided, but the binaries used to generate these are provided, so you can generate the final images following the instructions in Build QSPI Boot Image and Build NAND Boot Image sections.</p> <p>Note:  In 24.2 release the binaries targeted for silicon can also be used with Simics simulator.</p> HPS Peripheral Supported eMMC/SDCard &amp; Combo Phy Controllers Yes DMA Controller Yes XGMAC Ethernet Controller Yes USB 3.1 Gen1 Controller Yes USB 2.0 Controller Yes GPIO Controller Yes I2C Controller Initiator/Target Yes SPI Controller Initiator/Target Yes I3C Controller Initiator Yes I3C Controller Target Yes NAND Controller &amp; Combo PHY Controller Yes APB Timer Yes QSPI Controller Yes GICv3 Interrupt controller Yes EDAC RAS Driver Yes Clock manager Yes Reset manager Yes UART Yes WatchDog timer Yes System manager Yes SVC SOC FPGA manager Yes SVC FPGA firmware Yes SMMU Yes SVC FCS Crypto Yes SVC HWMON Yes SVC RSU Yes CVP Yes PMU Yes"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-instructions","title":"Build Instructions","text":"<p>The following diagram illustrates the full-build flow for the binaries used with the Intel Simics simulator. The build flow utilizes the source code placed in GitHub in repositories and uses a flow based on Yocto.</p> <p></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#set-up-the-environment","title":"Set Up the Environment","text":"<pre><code>sudo rm -rf agilex5_gsrd\nmkdir agilex5_gsrd\ncd agilex5_gsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre> <p>Download the compiler toolchain. Define environment variables so that the toolchain can be used to build the binaries:</p> <pre><code># Setup toolchain\ncd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>Set up the Quartus tools in the PATH, so they are accessible without full path:</p> <pre><code># Setup Quartus tool in PATH\nexport QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-the-hardware-design","title":"Build the Hardware Design","text":"<p>In Simics, the SOF file generated as result of the build of the hardware design is not used at all in the simulation, but this is needed to create the RPD file to excercise the QSPI boot. This is the reason why we provide the steps to build the hardware desgin here.</p> <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#set-up-the-yocto-build-system","title":"Set Up the Yocto Build System","text":"<ol> <li>Ensure your system satisfies the Yocto system requirements provided at https://docs.yoctoproject.org/3.4.1/ref-manual/system-requirements.html#supported-linux-distributions.</li> </ol> <p>Use the following commands to install required packages on Ubuntu 22.04:</p> <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc\\ \nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping\\ \npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd\\ \nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd\\ \ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1\\ \ndevice-tree-compiler curl mtd-utils mtd-tools u-boot-tools net-tools swig -y\n</code></pre> <p>On Ubuntu 22.04, point the /bin/sh to /bin/bash, as the default is a link to /bin/dash:</p> <pre><code>sudo ln -sf /bin/bash /bin/sh\n</code></pre> <p>Note: You can also use Docker containers to build the Yocto recipes. Refer to https://rocketboards.org/foswiki/Documentation/DockerYoctoBuild for details. When using a Docker container, it does not matter what Linux distribution or packages you have installed on your host, as all dependencies are provided by the Docker container.</p> <ol> <li>Clone the Yocto script and prepare the build:</li> </ol> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b scarthgap https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> <p>Note: Run the following commands to set up the yocto build environments again, if you closed the current window (for example, when rebooting the Linux host) and want to resume the next steps:</p> <pre><code>cd $TOP_FOLDER/gsrd-socfpga\n. ./poky/oe-init-build-env agilex5_devkit-gsrd-rootfs/\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#customize-the-yocto-build","title":"Customize the Yocto Build","text":"<ol> <li> <p>(Optional) Change the following files in gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/:</p> <ul> <li>distroboot script:uboot.txt</li> <li>its file for creating FIT image fromthe above script: uboot_script.its </li> </ul> </li> <li> <p>(Optional) Change the following file in gsrd-socfpga/meta-intel-fpga-refdes/recipes-kernel/linux/linux-socfpga-lts:</p> <ul> <li>its file for creating the kernel.itb image: fit_kernel_agilex5.its , which by default contains the following:     * Kernel     * Distroboot boot script     * Device tree configurations     * Board configurations </li> </ul> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-yocto","title":"Build Yocto","text":"<p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package </code></pre> <p>After the build is completed successfully, the following two folders are created:</p> <ul> <li><code>agilex5_devkit-gsrd-rootfs</code>: area used by OpenEmbedded build system for builds. For the description of the build directory structure, refer to https://docs.yoctoproject.org/ref-manual/structure.html#the-build-directory-build.</li> <li><code>agilex5_devkit-gsrd-images</code>: the build script copies here are relevant files built by Yocto from the <code>agilex5_devkit-gsrd-rootfs/tmp/deploy/images/agilex5</code> folder. It also includes other relevant files.</li> </ul> <p>Note: If you want to build binaries creating each one of the binaries independently, you could refer to Agilex\u2122 5 E-Series GHRD Linux Boot Examples.</p> <p>The most relevant files created in the <code>$TOP_FOLDER/gsrd-socfpga/agilex5_devkit-gsrd-images</code> folder are:</p> File Description SD Card Boot QSPI Boot NAND Boot ghrd_a5ed065bb32ae6sr0.sof SOF file from the hardware design * u-boot-spl-dtb.bin U-Boot SPL binary file * * * u-boot.itb U-Boot (SSBL) * * * boot.scr.uimg Distroboot boot script * * kernel.itb Linux kernel fit image * * * console-image-minimal-agilex5_nand.ubifs File system for NAND boot * console-image-minimal-agilex5_nor.ubifs File system for QSPI boot * gsrd-console-image-agilex5.wic SD Card Image * uboot.txt U-Boot Distroboot script * uboot_script.its ITS file to create FIT binary of U-Boot Distroboot script *"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-qspi-boot-image","title":"Build QSPI Boot Image","text":"<p>The next step consists of creating the QSPI image with UBIFS format that will be used by in the simulation that exercises this use case. To build this image the same binaries generated from the GSRD build are used.</p> <p>The layout of the QSPI image is shown in the following table:</p> MTD Partition UBI Volume Volume Name Type Image/Individual File Group File Start Addr Size 0 (qspi_bootinfo) N/A N/A RAW Bootinfo (Empty) N/A 0x0 2MB 1 (qspi_uboot) N/AN/A N/AN/A RAWRAW bitstream (FPGA image, SDM firmware)u-boot.itb N/A 0x002000000x04000000 ~1 MBAUTO 2 (qspi_root) 01234 envscriptkerneldtbrootfs UBIUBIUBIUBIUBIFS u-boot.envu-boot.scrkernel.itbkernel.dtbrootfs.ubifs root.ubi 0x4200000AutoAutoAutoAuto 256KB128KB24MB256KB160MB <pre><code># Gattering files\ncd $TOP_FOLDER\nrm -rf qspi-bin &amp;&amp; mkdir qspi-bin &amp;&amp; cd qspi-bin ln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof agilex5_factory.sof\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb u-boot-itb.bin\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex u-boot-spl.hex\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/kernel.itb kernel-image\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nor.ubifs  rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg boot.scr.uimg\n</code></pre> <ol> <li>Create the PFG file that describes the format of the QSPI image: </li> </ol> <pre><code># Gattering more files\ncd $TOP_FOLDER/qspi-bin\ncat &lt;&lt; EOF &gt; agilex5_flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" directory=\".\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"flash_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"./u-boot-spl.hex\"&gt;./agilex5_factory.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot-itb.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00200000\" e_addr=\"0x0030FFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"U-Boot\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_e_addr=\"1\" e_addr=\"0xFFFFFFF\" id=\"HPS\" s_addr=\"0x4200000\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"U-Boot\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n</code></pre> <ol> <li>Create UBI configuration file for the rootfs partition:</li> </ol> <pre><code># Creating UBI Configuration file\ncd $TOP_FOLDER/qspi-bin\ncat &lt;&lt; EOT &gt;ubinize_nor.cfg \n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel-image     \nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOT\n</code></pre> <p>The following file is created:    * $TOP_FOLDER/qspi-bin/ubinize_nor.cfg</p> <ol> <li>Generate the root.ubi file for root partition. For this, the ubinize_nor.cfg is used with the files obtained from the previous steps. This file defines the components to be included in the root.ubi file as indicated in the table above. The ubinize executable is available as part of the mtd-tools package.  The parameters for ubinize command are: -p: physical erase block size of the flash -m: minimum input/output unit size of the flash -s: sub-pages and sub-page size </li> </ol> <p>Once the root.ubi files is created this is renamed as hps.bin.  Required files for this step: ubinize_nor.cfg,  boot.scr.uimg,  kernel-image,  rootfs.ubifs</p> <pre><code># Generate hps.bin file with UBI format\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize_nor.cfg\nmv root.ubi hps.bin\n</code></pre> <p>The following file is created:    * $TOP_FOLDER/qspi-bin/hps.bin</p> <ol> <li>Using Quartus Programming File Generator to compile an RPD file by using the configuration specified in the PFG file.</li> </ol> <p>Required files for this step: u-boot-spl.hex,  agilex5_factory.sof, u-boot-itb.bin and hps.bin   Note: Make sure the filenames are specified correctly in agilex5_flash_image.pfg</p> <p>Run the Quartus File Generator command below to generate an RPD file:</p> <pre><code># Creating QSPI image\nquartus_pfg -c agilex5_flash_image.pfg\n</code></pre> <p>The following file is created:    * $TOP_FOLDER/qspi-bin/flash_image_jic.rpd</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#build-nand-boot-image","title":"Build NAND Boot Image","text":"<p>The next step consists of creating the NAND image that will be used by in the simulation that exercises this use case. For this, the NAND image will have the layout shown in the following figure:</p> MTD Partition UBI Volume Volume Name Type Image/Individual File Group File Flash Offset Size Size in Hex 0 (u-boot) N/A N/A RAW u-boot.itb N/A 0x00000000 2 MB 0x200000 1 (root) 01234 envscriptkerneldtbrootfs UBIUBIUBIUBIUBIFS u-boot.envu-boot.scrkernel.itbkernel.dtbrootfs.ubifs root.ubi 0x00200000 onwards 256KB128KB24MB256KB272MB 0x400000x200000xA000000x400000x11000000 <p>Based on the table above, we have 2 partitions. One contains just the U-Boot fit image located at address 0x0 and the other contains the rest of the software components in a ubi file (with UBIFS format) located at address 0x200000. Continue with the following steps to create the NAND boot image.</p> <ol> <li>Bring the required files from the GSRD build directory to a NAND boot directory:</li> </ol> <pre><code># Gathering the required files\ncd $TOP_FOLDER\nrm -rf nand-bin &amp;&amp; mkdir nand-bin &amp;&amp; cd nand-bin\nln -s $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/uboot_script.its uboot_script.its cp $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/uboot.txt .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb u-boot.itb\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/kernel.itb kernel-image\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/socfpga_agilex5_socdk_nand_vanilla.dtb kernel-dtb\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nand.ubifs rootfs.ubifs\n</code></pre> <ol> <li>The Agilex 5 E-Series Universal virtual virtual returns by default a board_id = 0 when U-Boot reads the STRATIX_JTAG_USER_CODE parameter. The board_id is used to select the desired configuration (linux kernel image + device tree + fpga fabric design) as described in Single  Image Boot flow. Starting from 24.2 release, the configuration for board_id = 0 defines the device tree for the OOB board in the premium dev kit (SD card daughter card). Since we want to load the configuratio that works for NAND boot, we require to use the device tree specific for the NAND daughter card. In order to address this problem, one solution is to force having a board_id that defines the configuration for NAND (and also without defining a FPGA core fabric since in Simics programming the fabric is not supported). For this, we require to set in U-Boot the  board_id environment variable to 7 for which the socfpga_agilex5_socdk_nand_vanilla.dtb device tree is used (as can be seen in fit_kernel_agilex5_devkit.its). This is achieved with the following code:</li> </ol> <pre><code># Update boot script to modify board_id so we can boot from nand_vanila device tree\ncd $TOP_FOLDER/nand-bin\nsed -i '/Trying to boot Linux from device/a setenv board_id 7 ' uboot.txt\nmkimage -f uboot_script.its boot.scr.uimg\n</code></pre> <ol> <li>Create UBI configuration file for the root partition:</li> </ol> <pre><code># Create the UBI Configuration file\ncd $TOP_FOLDER/nand-bin\ncat &lt;&lt;EOT &gt;ubinize_nand.cfg \n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nimage=boot.scr.uimg\nvol_id=1\nvol_name=script\nvol_size=128KiB\nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel-image     \nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nimage=kernel-dtb\nvol_id=3\nvol_name=dtb\nvol_size=256KiB\nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=400MiB\nvol_flag=autoresize\nEOT\n</code></pre> <p>Note: kernel-dtb is not really used since the dtb used is inside the kernel-image file.</p> <ol> <li>Generate root.ubi file for root partition, using the ubinize_nand.cfg file generated in previous step. This file defines the components to be included in the root.ubi file as indicated in the table above. The command used to generate the file is ubinize which is available as part of the mtd-tools package. The parameters that ubinize command received are listed next:</li> </ol> <ul> <li>-p: physical erase block size of the flash</li> <li>-m: minimum input/output unit size of the flash</li> <li>-s: sub-pages and sub-page size, ubinize will take into account and put the VID header to same NAND page as the EC header</li> </ul> <pre><code># Create the UBI file with root partition\ncd $TOP_FOLDER/nand-bin\nubinize -o root.ubi -p 1024KiB -m 8192 -s 8192 ubinize_nand.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li>$TOP_FOLDER/nand-bin/root.ubi</li> </ul> <ol> <li>Generate final NAND image (nand.img) using dd command. This file includes the U-Boot built from the GSRD and the root.ubi file generated in the step before. The location in the NAND image is indicated in the table above.</li> </ol> <pre><code># Creating the NAND image\nexport COMBINEDFILE=nand.img\ndd if=/dev/zero bs=1024M count=1 | tr '\\0' $'\\xFF' &gt; $COMBINEDFILE\n# Adding u-boot.itb\ndd conv=notrunc bs=1 if='u-boot.itb' of=$COMBINEDFILE seek=$((0x00000000))\n# Adding root.ubi\ndd conv=notrunc bs=1 if='root.ubi' of=$COMBINEDFILE seek=$((0x00200000))\n</code></pre> <p>The following file is created: - $TOP_FOLDER/nand-bin/nand.img</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#known-issues-with-the-release","title":"Known Issues with the Release","text":"<p>For known issues in this release please refer to the Intel Simics Simulator for FPGA Release page.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#agilextm-5-e-series-simics-virtual-platform-universal","title":"Agilex\u2122 5 E-Series Simics Virtual Platform - Universal","text":"<p>This virtual platform is associated with the agilex5e-universal.simics target script. The following figure shows a high-level block diagram of this virtual platform. In this diagram, you can observe the main components that can be exercised during the execution of the use cases described later on this page. The implementation of this virtual platform allows all the peripherals in the HPS to be enabled at the same time, which is not possible in physical hardware implementations. The pinmux and Combo PHY impose restrictions on the physical hardware. In the case of the pinmux in the physical hardware, you can enable only a subset of peripherals simultaneously because there are not enough pins if all pins are enabled simultaneously. This limitation does not exist in the Agilex\u2122 5 E-Series Universal Virtual Platform. For the Combo PHY, the physical hardware allows only one flash controller (NAND or SDMMC) to be enabled at a time. However, the virtual platform allows both to be enabled simultaneously.</p> <p></p> <p>In this block diagram:</p> <ul> <li>The architecture of the virtual platform follows a hierarchy that goes from target script \u2192 system \u2192 board \u2192 fpga \u2192 qsys_top \u2192 hps_subsystem \u2192 agilex_hps, which is aligned with the Simics virtual platform development philosophy that tries to match with the real golden hardware reference design (GHRD) architecture.</li> <li>The target script instantiates the system component, provides the CLI run time commands, and creates the network configuration. This script also defines the parameters that configure other components.</li> <li>The system component represents the complete virtual platform system and instantiates the board component. This component is implemented in a Python file.</li> <li>The board component represents the model of a PCB (analogous to a development kit). It includes the instance of the FPGA component and all board components connected to the FPGA (for example, flash devices, ethernet PHY). The GPIO loopback connection is implemented here. This component is implemented in a Python file.</li> <li>The FPGA component represents the top-level hardware design model in the Quartus Prime software project design that targets the Agilex\u2122 5 E-Series SoC FPGA device. It matches the logical hierarchy of the fictitious GHRD that the Agilex\u2122 5 E-Series Universal Virtual Platform models. This component only instantiates the qsys_top component and is implemented as a Python script.</li> <li>The qsys_top component matches the design's top view being modeled and corresponds to the system seen from the Platform Designer under the GHRD (soc_inst instance). The HPS subsystem component and the components included as part of the FPGA fabric design are instantiated under the qsys_top component. The qsys_top component is modeled as a Python script.</li> <li>The FPGA fabric design corresponds to the logic model implemented in the FPGA fabric.</li> <li>The HPS subsystem component corresponds to the model of the module that integrates all components associated with the HPS in the Agilex\u2122 5 E-Series device. It includes the HPS models, SDM mailbox, and EMIF model.</li> <li>The Agilex\u2122 5 HPS component in the virtual platform is an Intel Simics model that corresponds to the Hard Processor System Agilex\u2122 5 FPGA IP in the  Quartus Prime software.</li> <li>The embedded software running in the HPS component is expected to be the same that can be run in the real silicon. Exercising the HPS-embedded software in this virtual platform allows you to debug the software using the Simics debug capabilities.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#main-features-supported-by-the-intel-agilextm-5-e-series-universal-virtual-platform","title":"Main Features Supported by the Intel Agilex\u2122 5 E-Series Universal Virtual Platform","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#boot-an-operative-system","title":"Boot an Operative System","text":"<p>The Agilex\u2122 5 E-Series Virtual Platform allows exercising the HPS software in all parts of the boot flow for Linux* and Zephyr* operating systems. You can exercise the boot flow from a flash device such as an SD Card, NAND flash, or QSPI flash. Booting from an SD Card is the default boot mode.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#basic-ethernet","title":"Basic Ethernet","text":"<p>The basic ethernet functionality is configured from the agilex5e-universal.simics target script. The virtual platform simulates a network switch and a router in the simulated environment using the service node component referred to as service_node_cmp0. This provides a TFTP server to transfer files from the host PC to the target system and a DHCP server to assign an IP to the target system dynamically.</p> <p>The service node acts as a simulated environment router configured with the 10.10.0.1 IP address. The DHCP service is configured to assign an IP in the range of 10.10.0.100 and 10.10.0.199. The service node is also configured to provide Network Address Port Translation (NAPT) for outgoing traffic, allowing it to interact with the host PC enabling TFTP, SCP, and SSH services.</p> <p>The target device provides ethernet functionality using the XGMAC/TSN devices, enabling an ethX ethernet link. This link connects with an ethernet switch instantiated in the target script. Only the TSN0 instance is connected to this switch using the Marvell ethernet Phy instantiated at the board level.</p> <p>Basic ethernet support in the virtual platform allows the target software to set a MAC address locally to allow communication over the network. This supports all key transport layers of a protocol, such as TCP, UDP, and ICMP. Basic ethernet allows communication over IPv4 and IP6 protocols while supporting different hardware offloading features. The virtual platform supports L2, L3, and L4 filtering and can show network statistics.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#cpu-power-on-and-boot-core-selection","title":"CPU Power-On and Boot Core Selection","text":"<p>The virtual platform supports setting the CPU power-on settings and the CPU boot core selection. This configuration is defined at the target script level (agilex5e-universal.simics) for this virtual platform. Based on the configuration, the virtual platform exposes only the appropriate number of cores available to the target software. When multiple CPUs are enabled, the virtual platform is configured to support symmetric multiprocessing (SMP).</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#reset-flow","title":"Reset Flow","text":"<p>The virtual platform is designed to support all key reset flows described in the Agilex\u2122 5 E-Series Technical Reference Manual. Reset flows initiated by the CPU are simulated through the same mechanism in which the CPU writes to the appropriate addresses (reset manager device). Resets triggered by the external hardware signaling are simulated with Simics' commands.</p> Reset Type Recipe Notes Power-on reset Not supported The power-on reset is not supported as its effect is equivalent to restarting the simulation in a virtual platform simulation. However, if this is required for some exceptional use cases, you can trigger the cold reset instead, as this resets most domains. HPS cold reset system.board.hps-cold-reset Simulates toggling the HPS_COLD_nRESET pin using the command registered in the board component. HPS warm reset system.board.fpga.soc_inst.hps_subsys.agilex_hps.hps-warm-reset Simulates a warm reset of the HPS without triggering any other event. This type of reset is not enabled through external means in hardware. The command is registered in the HPS component. Watchdog reset Software-based The watchdog timer peripheral in the HPS can be configured and enabled through software. When the watchdog expires, the HPS resets (only the trigger of warm reset is supported)."},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#gpio-loopback-connection","title":"GPIO Loopback Connection","text":"<p>The virtual platform supports the feature that allows creating a loopback connection in certain pins in GPIO0 and GPIO1 ports. This is implemented at the board component level. The loopback implementation directly connects GPIO in and out pins of the GPIO ports in both directions to reflect the same state on those pins. In each GPIO port, the pair of pins that are connected are shown in the following table:</p> Pin Source Pin Destination 0 1 5 6 18 19 20 21 <p>The Simics command to activate the GPIO loop-back connection is <code>system.board.create-gpio-loopback</code>.</p> <p>Note: The loopback connection is activated by default from the target script.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#usb-disks-hot-plug-support","title":"USB Disks Hot-Plug Support","text":"<p>The virtual platform instantiates three USB disks that support hot-plugging by using Simics CLI commands to emulate plugging and unplugging the USB disks.</p> <p>The current connection of the USB disks in this virtual platform is indicated in the following table:</p> Disk Type Slot USB Controller usb3_disk SuperSpeed (SS) usb3 USB 3.1 Gen 1 usb3_hs_disk High Speed (HS) usb2 USB 3.1 Gen 1 usbotg_disk High Speed (HS) otg USB 2.0 OTG"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#fpga-fabric-example-design","title":"FPGA Fabric Example Design","text":"<p>The FPGA Fabric example design includes one instance of a On-Chip memory design exist in the FGPA fabric model. This is located directly under the qsys_top component. This On-Chip memory instance has a size of 1 MB and is connected to the HPS2FPGA bridge. This On-Chip memory model supports reading and writing to any memory location. You can access the memory designs using direct memory access to the memory locations in which these are mapped under the HPS2FPGA bridge memory space or by accessing the memories example design as a memory space or by accessing the memories example design as a memory space.</p> <p>The mapping of the memory instance is defined as follows:</p> Example Design Name Bridge Size Start address End Address example_design hps2fpga 1 MB 0x0040000000 0x00400FFFFF <p>The memory instance in the FPGA fabric example design receives a parameter named base_addr. The description of this parameter is described as follows:</p> Parameter Description Range Default Value base_addr An offset value that indicates the mapping of the instance taking as reference the Start Address value defined in the previous table. Integer 0x00000000 <p>The FPGA fabric example design also includes a Peripheral subsystem which is integrated by 3 I/O IP components, each one to access or allow to control a set of LEDs, a Dip switch and a push button. The peripheral subsystem is mapped into the lwhps2pga bridge starting at a base address of 0x20000000. These components includes some internal registers that allow to control the state of the output (for LED component) and also to read state of the input of push button and dip-switch components. The mapping of these components and their registers are shown next:</p> Component Mapping Address Range Register Information button_pio 0x00010060 0x10 [0x0] - DATA[0:0]: Read state of the button. Read Only. [0x8] - INTERRUPTMASK[0:0]- Enable('1\u2019)/Disable('0\u2019) the interrupt trigger. When dsiable, the interrupt is cleared. Read/Write dipsw_pio 0x00010070 0x10 [0x0] - DATA[0:0]: Read state of the button. Read Only. [0x8] - INTERRUPTMASK[0:0]- Enable('1\u2019)/Disable('0\u2019) the interrupt trigger. When dsiable, the interrupt is cleared. Read/Write led_pio 0x00010080 0x10 [0x0] - DATA[31:0]: Set and read the state of the LEDs. Read/Write <p>The DIP switch and push button component can trigger an interrupt to the HPS on the assertion of the corresponding input signal.</p> Component Interrupt HPS Interrupt Connection button_pio periph_button_irq f2s_fpga_irq[0] \u2013 SIP 49 dipsw_pio periph_dipsw_irq f2s_fpga_irq[1] \u2013 SIP 50 <p></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#fpga-to-hps-bridges","title":"FPGA-to-HPS Bridges","text":"<p>The FPGA-To-HPS bridges provide a way in which the FPGA fabric IPs can interact with the HPS subsystem and the SDRAM. The bridge implementation includes two new memory spaces in the FPGA logic model that are used to send read and write transactions to the HPS or SDRAM component from the FPGA logic passing through the FPGA-to-HPS bridges.</p> <ul> <li>FPGA to HPS bridge (FPGA2HPS): Connects the FPGA2HPS memory space with the HPS component.</li> <li>FPGA to SDRAM bridge (FPGA2SDRAM): Connects the F2SDRAM memory space with the HPS component.</li> </ul> <p>You can send read and write transactions through each one of the bridges from the Intel Simics CLI.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#configurable-parameters-in-the-intel-agilextm-5-e-series-universal-virtual-platform","title":"Configurable Parameters in the Intel Agilex\u2122 5 E-Series Universal Virtual Platform","text":"<p>The parameters that you can configure are shown in the following table:</p> Parameter Description Range Default Value sd_image_filename Name of the SD image to load into the SD memory model of the board component. Supported formats are <code>.img</code> and <code>.wic</code>. Filename string \"\" fsbl_image_filename First-stage boot loader file. The supported format is <code>.bin</code>. Filename string \"\" hps_boot_core The CPU to use as the boot core. Integer [0,2] 0 hps_core0_1_power_on The power-on states of CPU 0/1. Boolean True hps_core2_power_on The power-on states of CPU 2. Boolean True hps_core3_power_on The power-on states of CPU 3. Boolean True create_hps_serial0_console Choose whether to create or not a console component and connect it to the <code>serial0</code> peripheral of the HPS IP. Boolean True create_hps_eth0_network Choose whether to create or not a basic ethernet network and connect the <code>ethX</code> peripheral of the HPS IP to this. Boolean True create_hps_sd_card Create the SD card in the board component and connect it to the SD/eMMC controller. You can set either the create_hps_sd_card or create_hps_mmc parameter to true at a time. Boolean True create_hps_mmc Create the eMMC card in the board component and connect it to the SD/eMMC controller. You can set either the create_hps_sd_card or create_hps_mmc parameter to true at a time. Boolean False nand_data_image_filename Name of the NAND image to load into the NAND memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" nand_spare_image_filename Name of the NAND spare image to load into the NAND memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" qspi_image_filename Name of the QSPI image to load into the QSPI memory model of the board component. The supported format is raw binary (.bin or .craff). Filename string \"\" usb3_image_filename Name of the USB disk image corresponding to the SuperSpeed disk in the board component connected to the USB 3.1 controller. Filename string \"\" usb3_hs_image_filename Name of the USB disk image corresponding to the high-speed disk in the board component connected to the USB 3.1 controller. Filename string \"\" usb_otg_image_filename Name of the USB disk image corresponding to the high-speed disk in the board component connected to the USB 2.0 OTG controller. Filename string \"\" hps_cpu_freq_mhz ARM cores frequency in Megahertz (MHz). Integer [400 - 1500] 400"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-cases-supported-by-the-agilextm-5-e-series-universal-virtual-platform","title":"Use Cases Supported by the Agilex\u2122 5 E-Series Universal Virtual Platform","text":"<p>The following sections explain some supported use cases using the Agilex\u2122 5 E-Series Universal virtual platform. The preconditions required to execute them are listed in the following section:</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#simulation-setup","title":"Simulation Setup","text":"<p>Consider that the Intel Simics Simulator for Intel FPGAs Simulator has been installed on a Linux System and the output binaries generated from Build Instructions section are already available.</p> <ol> <li>Create a project directory under the Intel Simics Simulator installation directory (Assuming it is SimicsInstallDir):</li> </ol> <pre><code>$ mkdir project-1\n$ cd project-1\n</code></pre> <ol> <li>Under the new project directory created, deploy the agilex5e-universal virtual platform:</li> </ol> <pre><code>$&lt;Simics installation dir&gt;/simics/bin/simics_intelfpga_cli \u2013-deploy agilex5e-universal\nSimics(R) Simulator for Intel(R) FPGA CLI:\nINFO: Preparing to initialize /home/simicsUser/SimicsInstallDir/project-1 as a\nSimics workspace\nProject created successfully\n# Observe that the directory has been initialized and the simics and simics-gui\n# commands appear in the project directory. Also, the target directory is\n# created. This includes the target script corresponding to the deployed\n# platform.\n</code></pre> <ol> <li>Build the virtual platform components:</li> </ol> <pre><code>$ make\n=== Environment Check ===\n'/home/simicsUser/SimicsInstallDir/project-1' is up-to-date\ngcc version 9\n=== Building module agilex5e-universal-board-comp ===\n:\n=== Building module agilex5e-universal-fpga-comp ===\n:\n=== Building module agilex5e-universal-system-comp ===\n:\nCopying agilex5_icon_84x84.png\n</code></pre> <ol> <li>Copy the following binaries created in Build Instructions section to the Simics project directory:</li> </ol> <ul> <li>gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/gsrd-console-image-agilex5.wic</li> <li>gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.bin</li> <li>qspi-bin/flash_image_jic.rpd</li> <li>nand-bin/nand.img</li> </ul> <ol> <li>Customize the configuration of the Agilex\u2122 5 E-Series Universal virtual platform, according to the setup required to exercise any specific use case. Set up the fsbl_image_filename parameter with the first-stage bootloader. If the boot implies booting from an SD Card device, configure sd_image_filename and create_hps_sd_card parameters (this image should include the main bootloader and the OS and/or application images). As part of the configuration, select the core used to boot using the hps_boot_core parameter, which could be core 0 (A55) or core 2 (A76).</li> </ol> <p>You can configure the virtual platform either by updating the agilex5e-universal.simics**target script or creating a separate top-level target script (named based on the simulation purpose) that is expected to be run with this (example: **uboot-linux_sdcard.simics used to boot from U-Boot to Linux from an SD Card device). You become the owner of this new target script, in which, you can set the required parameters and call the original virtual platform target script (targets/agilex5e-universal/agilex5e-universal.simics path). An example of the setup required to run a simulation that exercises the boot flow going from U-Boot to Linux, booting from an SD Card is shown in the following:</p> <pre><code>#uboot-linux_sdcard.simics\n$sd_image_filename = \"gsrd-console-image-agilex5.wic\"\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$hps_boot_core = 0\n$create_hps_sd_card = TRUE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> <p>Note: The uboot-linux_sdcard.simics file must be created under the Intel Simics project directory.</p> <p>Tip: Any specific configuration needed for a use case is indicated under the Setup section of that use case.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-sdcard-boot-flow-from-fsbl-to-linux","title":"Use Case: Exercise SDCard Boot Flow from FSBL to Linux","text":"<p>This use case consists of booting from an SDCard device going from U-Boot to Linux prompt passing through U-Boot SPL \u2192 ATF \u2192 U-Boot \u2192 Linux.</p> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <p>To exercise this use case, follow the below steps once the Simulation setup is complete:</p> <ol> <li>From the project directory, launch the simulation using the uboot-linux_sdcard.simics target script. This script launches the simulator and the current terminal becomes the Simics CLI:</li> </ol> <p><pre><code>$ ./simics uboot-linux_sdcard.simics </code></pre> 2. From the Simics CLI, start running the simulation with the run command.</p> <pre><code>simics&gt;  run\n</code></pre> <ol> <li>Wait to get to the Linux prompt in the target serial console. 4. Login into the Linux prompt using the root user without a password.</li> </ol> <p><pre><code># Target Serial console \nU-Boot SPL 2024.01 (Jun 25 2024 - 09:28:56 +0000)\nReset state: Cold\nMPU           875000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\nio96b_mb_init: num_instance 1\nio96b_mb_init: get memory interface IO96B 0\n:\nDDR: size check success\nDDR: firewall init success\nDDR: init success\nQSPI: Reference clock at 400000 kHz\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.10.1  (release):rel_socfpga_v2.10.1_24.05.02_pr-4-g483735669\nNOTICE:  BL31: Built : 08:56:04, Jun 25 2024\nU-Boot 2024.01 (Jun 25 2024 - 09:28:56 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  51 devices, 26 uclasses, devicetree: separate\nWDT:   Not starting watchdog@10d00200\nWDT:   Not starting watchdog@10d00300\nWDT:   Not starting watchdog@10d00400\nWDT:   Not starting watchdog@10d00500\nWDT:   Not starting watchdog@10d00600\nNAND:  4096 MiB\nMMC:   mmc0@10808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nLoading Environment from UBI... SF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\n:\nScanning mmc 0:1...\nFound U-Boot script /boot.scr.uimg\n2411 bytes read in 12 ms (195.3 KiB/s)\n## Executing script at 81000000\ncrc32+ Trying to boot Linux from device mmc0\nFound kernel in mmc0\n17685575 bytes read in 33 ms (511.1 MiB/s)\n## Loading kernel from FIT Image at 82000000 ...\n:\nSF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\nEnabling QSPI at Linux DTB...\nWorking FDT set to ffad6000\nQSPI clock frequency updated\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\n\nStarting kernel ...\n\nDeasserting all peripheral resets\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.22-altera-g6ad76f9ca568 (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240620) #1 SMP PREEMPT Fri Jun 21 09:02:27 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n:\nPoky (Yocto Project Reference Distro) 5.0.2 agilex5dka5e065bb32aes1 ttyS0\n\n[   37.547237] kauditd_printk_skb: 15 callbacks suppressed\n[   37.547244] audit: type=1334 audit(1709054800.368:33): prog-id=27 op=UNLOAD\n[   37.548523] audit: type=1334 audit(1709054800.368:34): prog-id=26 op=UNLOAD\n[   37.549259] audit: type=1334 audit(1709054800.368:35): prog-id=25 op=UNLOAD\nagilex5dka5e065bb32aes1 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for\ntesting and development purposes only. It is recommended that you create your\nown distribution for production use.\n\nroot@agilex5dka5e065bb32aes1:~# </code></pre> This finishes the main scenario of this use case, but there are some extensions that are described next.</p> <p>Note: You can speed-up the boot process by skipping the U-Boot autoboot countdown by pressing any key and then typing the boot command:</p> <pre><code>U-Boot 2024.01 (Jun 25 2024 - 09:28:56 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\n\n:\nNet:   No ethernet found.\nHit any key to stop autoboot:  0 SOCFPGA_AGILEX5 # boot\nswitch to partitions #0, OK\nmmc0 is current device\nScanning mmc 0:1...\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-hello-application","title":"Use Case: Exercise Hello Application","text":"<p>This is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes executing the hello application from the Linux prompt.</p> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Execute the hello application located in the intelFPGA directory. After executing this application, the Hello SoC FPGA! message is displayed on the command prompt:</p> </li> </ol> <pre><code># Target Serial console \nroot@dhcp0:~#  ./intelFPGA/hello Hello SoC FPGA!\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-system-check-application-with-hps-led-turn-onoff-control","title":"Use Case: Exercise System Check Application with HPS LED Turn On/Off control","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes executing the System Check Application to observe the state of the HPS LEDs. The execution of this use case works under the assumption that the LEDs are connected to the corresponding GPIOs in the virtual platform.</p> Setup <p>Same setup as the parent use case.</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>From the target system serial console, execute the System Check application (syschk) located under the intelFPGA directory. This shows some system information, such as the target system IP address and the state of the HPS LEDs. Observe that the initial state of the three HPS LEDs is OFF.</p> <p>Note:  When using device tree targeted for OOB card, only hps_led1 is available, so the System Check application only shows this led.</p> </li> </ol> <pre><code># Target Serial console \nroot@dhcp0:~#  ./intelFPGA/syschk # Target Serial console \nActual changes:\n                              ALTERA SYSTEM CHECK                              lo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                        usb2                  : xHCI Host Contro\nhps_led2              : OFF\nhps_led0              : OFF             serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : OFF\n</code></pre> <ol> <li>Change the state of any of the HPS LEDs using the /sys/class/led/hps_ledX/brightness files writing either a '1' or '0' to these. For this, you need to first close the System Check application by typing Ctrl+C in the target serial console. Change the state of the LEDs to 'ON' state as indicated next and reopen the System Check application to observe the new state of the LEDs.</li> </ol> <pre><code># Target Serial console \nroot@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led0/brightness root@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led1/brightness root@dhcp0:~# echo 1 &gt; /sys/class/leds/hps_led2/brightness root@dhcp0:~# ./intelFPGA/syschk # Target Serial console \nActual changes:\n                                    ALTERA SYSTEM CHECK\n\nlo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                        usb2                  : xHCI Host Contro\nhps_led2              : ON\nhps_led0              : ON              serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : ON\n</code></pre> <ol> <li>Close the System Check application with Ctrl+C and return the HPS LEDs to the OFF state. Reconfirm that the state of the LEDs was updated to the new state in the System Check application.</li> </ol> <pre><code># Target Serial console \nroot@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led0/brightness root@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led1/brightness root@dhcp0:~# echo 0 &gt; /sys/class/leds/hps_led2/brightness root@dhcp0:~# ./intelFPGA/syschk # Target Serial console \nActual changes:\n                              ALTERA SYSTEM CHECK                              lo                    : 127.0.0.1       usb3                  : xHCI Host Contro\neth1                  : 10.10.0.100     usb1                  : DWC OTG Controll\n                                        usb2                  : xHCI Host Contro\nhps_led2              : OFF\nhps_led0              : OFF             serial@10c02100       : disabled\nmmc0::                : OFF             serial@10c02000       : okay\nhps_led1              : OFF\n</code></pre> <ol> <li>Close the System Check application with Ctrl+C.</li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-access-the-web-server-application-from-host-pc","title":"Use Case: Access the Web Server Application from Host PC","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes accessing from the host PC a web page that is being hosted by the target system, which runs a web server application. This application is launched automatically as part of the Linux boot process.</p> Setup <p>Using the uboot-linux_sdcard.simics Simics script, create an incoming port forwarding shown in the following:</p> <pre><code>connect-real-network-port-in ethernet-link = ethernet_switch0 target-ip=10.10.0.100 target-port = 80 host-port = 4080 -tcp </code></pre> <p>The port forwarding created allows you to access the webpage from the host PC. In the configuration, use the connect-real-network-port-in command, port 4080 in the host PC, and the target port in the target system is 80 (HTTP port). You also assign as the target IP, the IP that corresponds to the target system, which is 10.10.0.100. Also, indicate that this port forwarding is related to the TCP protocol. YOu can check the new port forwarding setup using the list-port-forwarding-setup command (this setup also could be done from the Simics CLI but in this case, the simulation should be stopped to perform the network configuration).</p> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>From the host PC, open a web browser and access the webpage running in the target system using the address: http://localhost:4080 . Note that the host machine is referred to as localhost and the port is 4080, which is the one visible from the host PC. </p> <p></p> </li> </ol> <p>Note: The IP address of the host PC could be used as well instead of localhost.</p> <p>Note: The webpage displays instructions to connect to the target system using SSH. These instructions are valid if you run these binaries in real hardware. If you want to establish the SSH connection with a simulated target system, create a second incoming port forwarding with the following setup:</p> <p>connect-real-network-port-in ethernet-link = ethernet_switch0 target-ip=10.10.0.100 target-port = 22 host-port = 4022 -tcp</p> <p>Then, connect to the target system using ssh -p 4022 root@localhost from the host PC or ssh -p 4022 root@ from any other PC in the same network. <p>A variation of this use case consists of accessing the web page from another PC under the same network that the host PC (both PCs in a real network). For this, use the IP address of the host PC instead of localhost and continue using the same port: http://&lt;host PC address&gt;:4080.</p> <p>Note: In the Linux Ubuntu system, you can get the IP address using the ifconfig command from a terminal. Also, ensure that the firewall in this PC is not blocking port 80.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-access-on-chip-ram-in-fpga-example-design-from-linux-prompt","title":"Use Case: Access ON-Chip RAM in FPGA Example Design from Linux Prompt","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and includes accessing from Linux the FPGA fabric example design for read and write operations. For this, the devmem2 Linux application is used. Also, a Simics CLI script is used to write some initial content to the memories in the example design.</p> Setup <p>Start with the setup as the parent use case. From the Simics CLI or using the uboot-linux_sdcard.simics Simics script, add the script branch that adds some content to the memories in the example design. The script branch writes 256 32-bit words in each memory.</p> <p></p> <pre><code># uboot-linux_sdcard.simics\n:\nscript-branch{\n# Wait until we see any message in the Serial Console to be sure the model has been fully initialized\nbp.console_string.wait-for system.board.fpga.soc_inst.hps_subsys.agilex_hps.console0.con \"U-Boot SPL\"\n$idx = 0\nwhile ($idx &lt; 256) {\n$addr = 4*$idx\n$valueMem1 = 0xcafe0000 | $idx\necho \"Set Values \" + (hex($valueMem1)) + \" at address \" + (hex($addr))\nsystem.board.fpga.soc_inst.example_design.design_mem.write $addr $valueMem1    $idx+=1 }\n}\n</code></pre> Procedure <ol> <li> <p>Execute the parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Read the first and last locations written by the CLI script in the memories in the example design using the devmem2 application in Linux. This command receives the physical memory that wants to be accessed (in this case, based on the offset where the HPS2FPGA bridges are mapped to):</p> </li> </ol> <pre><code>dhcp0 login:  root root@dhcp0:~#  devmem2 0x40000000 w /dev/mem opened.\nMemory mapped at address 0xffffa3940000.\nRead at address  0x40000000 (0xffffa3940000): 0xCAFE0000\nroot@dhcp0:~#  devmem2 0x400003fc w /dev/mem opened.\nMemory mapped at address 0xffff91ac1000.\nRead at address  0x400003FC (0xffff91ac13fc): 0xCAFE00FF\n</code></pre> <p>Observe that the values read matches the expected one shown in the figure above.</p> <p>Note: The addresses in parenthesis in the capture above correspond to the virtual address in which Linux maps the physical address corresponding to the location in the memory example design that is being accessed. This virtual address may be different than the one shown in the capture.</p> <ol> <li>Use the <code>devmem2</code> command to write into the memories in the example design and read back the data. For this, the following addresses are selected:</li> </ol> Bridge Address Memory Design Addr Index Value HPS2FPGA 0x40000400 0x400 256 0xcafe0200 <pre><code>root@dhcp0:~#  devmem2 0x40000400 w 0xcafe0200 /dev/mem opened.\nMemory mapped at address 0xffffbd034000.\nRead at address  0x40000400 (0xffffbd034400): 0x00000000\nWrite at address 0x40000400 (0xffffbd034400): 0xCAFE0200, readback 0xCAFE0200\n</code></pre> <ol> <li>Read back to the previous memory location written to confirm the operation was performed successfully.</li> </ol> <pre><code>root@dhcp0:~#  devmem2 0x40000400 w  \n/dev/mem opened.\nMemory mapped at address 0xffffa5ab9000.\nRead at address  0x40000400 (0xffffa5ab9400): 0xCAFE0200\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-excercise-peripheral-components-in-fpga-fabric-example-design","title":"Use Case: Excercise Peripheral Components in FPGA Fabric Example Design","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and exercising:</p> <ul> <li>LED I/O component to write/and read the state of the LED from Simics CLI and from U-Boot shell</li> <li>Dip-Swich and Push-Button I/O components to change the state of the input from Simics CLI and read the state of the input from U-Boot shell. Also configure the triggering of an nterrupts from these component to the HPS.</li> </ul> Setup <p>Complete the procedure described in the Simulation Setup section.</p> Procedure <ol> <li>Start the simulation similar to how it is done in the main use case, but in the serial console stop the U-Boot autoboot by pressing a key on the reception of the message \"Hit any key to stop autoboot:\".</li> <li>Here you are going to exercise the setting of some LEDs. Read the state of the LEDs I/O pins from the U-Boot shell through memory access using the address in which the DATA register of this component is mapped (0x20010080) and turn-on the 3 LEDs associated with the 3 less significative bits in this register. Then read-back the state of these pins to confirm these has been updated. You can confirm that the state of the LED's was updated reading directly into the DATA register of the LED I/O components from the Simics CLI.</li> </ol> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010080 1\n20010080: 00000000                             \u2026.\nSOCFPGA_AGILEX5 # mw 0x20010080 0x7 1\nSOCFPGA_AGILEX5 # md 0x20010080 1\n20010080: 00000007  </code></pre> <pre><code># Simics CLI\nrunning&gt; print-device-reg-info system.board.fpga.soc_inst.periph_subsys.led_pio.bank.regs.DATA [system.board.fpga.soc_inst.periph_subsys.led_pio.bank.regs.DATA]\nBits : 32\nOffset : 0x0\n            Value : 7\nBit Fields:\n    Data @ [31:0] : 00000000000000000000000000000111\n</code></pre> <ol> <li>Next you will exercise the toggling the input pin of the dip-switch component using the Simics CLI through the signal_raise() and signal_lower() and then reading back the state of the pin using the DATA register in this component using the U-Boot shell through the corresponding memory location of this register (0x20010070).</li> </ol> <pre><code># Simics CLI\nrunning&gt; @conf.system.board.fpga.soc_inst.periph_subsys.dipsw_pio.port.input_io[0].iface.signal.signal_raise() None\n</code></pre> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010070 1 \n20010070: 00000001 </code></pre> <pre><code># Simics CLI\nrunning&gt;  @conf.system.board.fpga.soc_inst.periph_subsys.dipsw_pio.port.input_io[0].iface.signal.signal_lower() None\n</code></pre> <pre><code># U-Boot shell\nSOCFPGA_AGILEX5 # md 0x20010070 1 \n20010070: 00000000                             \u2026.\n</code></pre> <ol> <li>Finally you are going to exercise triggering an interrupt and clearing the interrupt generated from the rising edge of the input in the button I/O component. This will be exercised from the Simics CLI. To observe that the interrupt is triggered, the log level of the interrupt controller is increased. First the interrupt needs to be enabled using the INTERRUPT register in this component. Once the interrupt is enabled, we can assert the input signal and observe that the interrupt is triggered and the DATA register gets also updated with the set value ('1'). Finally, you will clear the interrupt using again the INTERRUPT register.</li> </ol> <pre><code># Simics CLI\nrunning&gt; log-level object = system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic level = 4 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic] Changing log level: 1 \u2192 4\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 0\nrunning&gt;  write-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.INTERRUPTMASK 1 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 already low\nrunning&gt;  @conf.system.board.fpga.soc_inst.periph_subsys.button_pio.port.input_io[0].iface.signal.signal_raise() [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 raised\nNone\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 1\nrunning&gt;  write-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.INTERRUPTMASK 0 [system.board.fpga.soc_inst.hps_subsys.agilex_hps.gic.port.spi[49] info] SPI49 lowered\nrunning&gt;  read-device-reg system.board.fpga.soc_inst.periph_subsys.button_pio.bank.regs.DATA 1\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-usb-disk-hot-plug","title":"Use Case: Exercise USB Disk Hot-Plug","text":"<p>This use case is an extension of the main use case and includes attaching a USB image to one of the USB disks available in the Agilex\u2122 5-E Universal virtual platform and exercising the plug-in and plug-out actions as follows:</p> <ol> <li>Boot to the Linux prompt and plug in the USB disk (default), mount the disk and access some of the disk content, and add new content. The disk used in this use case is usb3_disk connected to the USB 3.0 Gen 1 controller.</li> <li>Unmount and plug-out the disk, and verify that this is not seen by Linux anymore.</li> <li>Plug-in and remount the disk, and verify that the content created is still available.</li> </ol> <p>All this is done as part of a single simulation session. The procedure described in the current use case does not allow to keep persistence of the content updated in the USB image after finishing the simulation.</p> <p>For this use case, we require to create an initial USB disk Image for which some information is provided in the Setup section.</p> Setup <p>Start with the setup as the parent use case an continue with next steps. 1. Create a 32 MB USB image (<code>usbImage.img</code>) following the instructions . The image has a <code>ext4</code> type file system in the partition created that includes as  initial content the <code>hello1.txt</code> file:</p> <p>In your Simics project directory, create the <code>usbImage.img</code> image:  </p> <pre><code># Create a dircetory to create the image\nmkdir usbDisk &amp;&amp; cd usbDisk\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\n# remove mkfs.fat parameter which has some issues on Ubuntu 22.04\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir part1 &amp;&amp;  cd part1\necho \"This is my original file in USB image\" &gt; hello1.txt cd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P part1/*,num=1,format=ext4,size=16M \\\n-s 32M \\\n-n usbImage.img\n</code></pre> <ol> <li>Update the target script to attach the image to the USB disk.</li> </ol> <pre><code>#uboot-linux_sdcard.simics   \n$sd_image_filename = \"gsrd-console-image-agilex5.wic\"\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$usb3_image_filename = \"usbDisk/usbImage.img\"\n$hps_boot_core = 0\n$create_hps_sd_card = TRUE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> Procedure <ol> <li>Execute the parent use case to get to the Linux prompt and log in. By default, the USB disks in the virtual platform are plugged in. These can be detected from the Linux using the fdisk -l command and shown next:</li> </ol> <pre><code>root@dhcp0:~# fdisk -l Disk /dev/mmcblk0: 16 GB, 17179869184 bytes, 33554432 sectors\n262144 cylinders, 4 heads, 32 sectors/track\nUnits: sectors of 1 * 512 = 512 bytes\n\nDevice       Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/mmcblk0p1 *  16,0,1      1023,3,32         2048    1026047    1024000  500M  b Win95 FAT32\n/dev/mmcblk0p2    1023,3,32   1023,3,32      1026048    4098047    3072000 1500M 83 Linux\nDisk /dev/sda: 32 MB, 33554432 bytes, 65536 sectors\n37 cylinders, 43 heads, 41 sectors/track\nUnits: sectors of 1 * 512 = 512 bytes\n\nDevice  Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/sda1    0,32,33     2,42,41           2048      34816      32769 16.0M 83 Linux\nPartition 1 has different physical/logical start (non-Linux?):\n     phys=(0,32,33) logical=(1,6,40)\nPartition 1 has different physical/logical end:\n     phys=(2,42,41) logical=(19,32,8)\n</code></pre> <ol> <li> <p>Observe that the usb3_disk corresponds to the /dev/sda device and /dev/sda1 corresponds to the partition created in this disk which size of 16 MB.</p> </li> <li> <p>Mount the partition in usb3_disk, observe the content (hello1.txt file), add new content (hello2.txt), and unmount the disk.</p> </li> </ol> <pre><code>root@dhcp0:~# mkdir /media/usbDrive root@dhcp0:~# mount /dev/sda1 /media/usbDrive [  680.753967] EXT4-fs (sda1): mounted filesystem with ordered data mode. Quota mode: none.\nroot@dhcp0:~# ls /media/usbDrive hello1.txt root@dhcp0:~# more /media/usbDrive/hello1.txt This is my original file in USB image\nroot@dhcp0:~# echo \"This is my new file in the USB image\" &gt; /media/usbDrive/hello2.txt root@dhcp0:~# ls /media/usbDrive hello1.txt  hello2.txt root@dhcp0:~# umount /media/usbDrive/ [ 2403.043825] EXT4-fs (sda1): unmounting filesystem.\n</code></pre> <ol> <li>Unplug the usb3_disk from the Simics CLI and observe that Linux detects this action.</li> </ol> <p>In Simics CLI: <pre><code>running&gt; system.board.usb3_disk.unplug </code></pre></p> <p>In Linux shell: <pre><code>root@dhcp0:~# [ 1115.122439] usb 3-1: USB disconnect, device number 2\n</code></pre></p> <p>You can call fdisk -l command again to observe that /dev/sda device is no longer present.</p> <ol> <li>From the Simics CLI plugin, the usb3_disk again provides the usb3 port. Observe in the Linux shell that the device connection is detected. Remount the device partition and confirm that the new content created before is still present. Finally, unmount the disk.</li> </ol> <p>In Simics CLI:</p> <p><pre><code>running&gt; system.board.usb3_disk.plug port = usb1_typec\n</code></pre> In Linux shell:</p> <pre><code>root@dhcp0:~# [ 1415.994946] usb 3-1: new SuperSpeed USB device number 3 using xhci-hcd\n[ 1416.015078] usb 3-1: LPM exit latency is zeroed, disabling LPM.\n[ 1416.016520] usb-storage 3-1:1.0: USB Mass Storage device detected\n[ 1416.017476] scsi host0: usb-storage 3-1:1.0\n[ 1417.023153] scsi 0:0:0:0: Direct-Access     Vtech    Turbo_Disk(tm)   0001 PQ: 0 ANSI: 2\n[ 1417.024835] sd 0:0:0:0: [sda] 65536 512-byte logical blocks: (33.6 MB/32.0 MiB)\n[ 1417.025818] sd 0:0:0:0: [sda] Test WP failed, assume Write Enabled\n[ 1417.026685] sd 0:0:0:0: [sda] Asking for cache data failed\n[ 1417.027290] sd 0:0:0:0: [sda] Assuming drive cache: write through\n[ 1417.029785]  sda: sda1\n[ 1417.030333] sd 0:0:0:0: [sda] Attached SCSI disk\n\nroot@dhcp0:~# fdisk -l\nDisk /dev/mmcblk0: 16 GB, 17179869184 bytes, 33554432 sectors\n:\nDevice  Boot StartCHS    EndCHS        StartLBA     EndLBA    Sectors  Size Id Type\n/dev/sda1    0,32,33     2,42,41           2048      34816      32769 16.0M 83 Linux\nPartition 1 has different physical/logical start (non-Linux?):\n     phys=(0,32,33) logical=(1,6,40)\nPartition 1 has different physical/logical end:\n     phys=(2,42,41) logical=(19,32,8)\nroot@dhcp0:~# mount /dev/sda1 /media/usbDrive [ 5419.362283] EXT4-fs (sda1): mounted filesystem 0fe6c96c-996c-4659-b7e2-e694076e5aef r/w with ordered data mode. Quota mode: none.\nroot@dhcp0:~# ls  /media/usbDrive hello1.txt  hello2.txt  lost+found\nroot@dhcp0:~# more  /media/usbDrive /media/usbDrive/hello2.txt\nThis is my new file in the USB image\nroot@dhcp0:~# umount /media/usbDrive/ [ 7348.324046] EXT4-fs (sda1): unmounting filesystem 0fe6c96c-996c-4659-b7e2-e694076e5aef.\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-ubifs-qspi-boot-flow-from-fsbl-to-linux","title":"Use Case: Exercise UBIFS QSPI Boot Flow from FSBL to Linux","text":"<p>This use case consists of booting from a QSPI flash device going from U-Boot to Linux prompt passing through U-Boot SPL \u2192 ATF \u2192 U-Boot \u2192 Linux using an image with UBIFS format.</p> Setup <p>Perform steps 1 to 4 described in the [Simulation Setup]#simulation-setup) section.</p> <ol> <li>In the Intel Simics environment at the project directory, generate a compressed version of the .rpd file created (.craff) file using the craff tool provided under the Simics Base installation directory:</li> </ol> <pre><code>&lt;SimicsInstallDir&gt;/simics-6.0.191/bin/craff -o qspi_image.img.craff flash_image_jic.rpd\n</code></pre> <p>The following file is created under the Simics project directory:</p> <ul> <li>qspi_image.img.craff</li> </ul> <ol> <li>In the Intel Simics environment at the project directory, create a customized target script to exercise the FSBL to Linux boot flow from QSPI device with an image with UBIFS format. The file to create is called uboot-linux_qspi.simics. This file will look like this:</li> </ol> <pre><code>#uboot-linux_qspi.simics\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$qspi_image_filename  = \"qspi_image.img.craff\"\n$hps_boot_core = 0\n$create_hps_sd_card = FALSE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> Procedure <p>To exercise this use case, follow the steps below once the Simulation setup is complete:</p> <ol> <li>From the project directory, launch the simulation using the uboot-linux_qspi.simics target script. This script launches the simulator and the current terminal becomes the Simics CLI:</li> </ol> <pre><code>$ ./simics uboot-linux_qspi.simics </code></pre> <ol> <li> <p>From the Simics CLI, start running the simulation with the <code>run</code> command. <pre><code>simics&gt;  run\n</code></pre></p> </li> <li> <p>Wait for the simulation to get to the Linux prompt in the target serial console.</p> </li> <li>Login into the Linux prompt using the root user without a password.</li> </ol> <pre><code>U-Boot SPL 2024.01 (Jun 25 2024 - 09:28:56 +0000)\nReset state: Cold\nMPU           875000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\nio96b_mb_init: num_instance 1\nio96b_mb_init: get memory interface IO96B 0\n:\nDDR: size check success\nDDR: firewall init success\nDDR: init success\nQSPI: Reference clock at 400000 kHz\nTrying to boot from MMC1\nMMC: no card present\nspl: mmc init failed with error: -123\nTrying to boot from SPI\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.10.1  (release):rel_socfpga_v2.10.1_24.05.02_pr-4-g483735669\nNOTICE:  BL31: Built : 08:56:04, Jun 25 2024\nU-Boot 2024.01 (Jun 25 2024 - 09:28:56 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  51 devices, 26 uclasses, devicetree: separate\nWDT:   Not starting watchdog@10d00200\nWDT:   Not starting watchdog@10d00300\nWDT:   Not starting watchdog@10d00400\nWDT:   Not starting watchdog@10d00500\nWDT:   Not starting watchdog@10d00600\nNAND:  4096 MiB\nMMC:   mmc0@10808000: 0\nLoading Environment from FAT... MMC: no card present\n:\nSF: Detected mt25qu02g with page size 256 Bytes, erase size 64 KiB, total 256 MiB\nSelect Environment on UBI: OK\nSaving Environment to UBI... done\nOK\nUBI partition 'root' already selected\nUBI partition 'root' already selected\nNo size specified -&gt; Using max size (196224)\nRead 196224 bytes from volume script to 0000000081000000\nQSPI: Running script from UBIFS\nQSPI: Trying to boot script at 0x81000000\n## Executing script at 81000000\ncrc32+ Trying to boot Linux from device qspi\n\ndevice nor0 &lt;nor0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: u-boot              0x04200000      0x00000000      0\n1: root                0x0be00000      0x04200000      0\ndevice nand0 &lt;nand.0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: nand_uboot          0x00200000      0x00000000      0\n1: nand_root           0x1f400000      0x00200000      0\nactive partition: nor0,0 - (u-boot) 0x04200000 @ 0x00000000\n\n:\nEnabling QSPI at Linux DTB...\nWorking FDT set to ffad7000\nQSPI clock frequency updated\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\n\nStarting kernel ...\n\nDeasserting all peripheral resets\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.22-altera-g6ad76f9ca568 (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240620) #1 SMP PREEMPT Fri Jun 21 09:02:27 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] earlycon: uart0 at MMIO32 0x0000000010c02000 (options '115200n8')\n[\n:\nPoky (Yocto Project Reference Distro) 5.0.2 agilex5dka5e065bb32aes1 ttyS0\n\nagilex5dka5e065bb32aes1 login: [  275.419833] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-0\n[  275.425090] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-1\n[  275.430446] socfpga-dwmac 10830000.ethernet eth0: Register MEM_TYPE_PAGE_POOL RxQ-2\n:\n[  285.755775] audit: type=1334 audit(1709054871.096:12): prog-id=16 op=LOAD\n[  285.756498] audit: type=1334 audit(1709054871.096:13): prog-id=17 op=LOAD\n[  285.757223] audit: type=1334 audit(1709054871.096:14): prog-id=18 op=LOAD\n[  316.819432] audit: type=1334 audit(1709054902.160:15): prog-id=18 op=UNLOAD\n[  316.820175] audit: type=1334 audit(1709054902.160:16): prog-id=17 op=UNLOAD\n[  316.820912] audit: type=1334 audit(1709054902.160:17): prog-id=16 op=UNLOAD\n\nagilex5dka5e065bb32aes1 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for\ntesting and development purposes only. It is recommended that you create your\nown distribution for production use.\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-exercise-nand-boot-flow-from-fsbl-to-linux","title":"Use Case: Exercise NAND Boot Flow from FSBL to Linux","text":"<p>This use case consists of booting from a NAND flash device going from U-Boot to Linux prompt passing through U-Boot SPL \u2192 ATF \u2192 U-Boot \u2192 Linux.</p> Setup <p>Perform steps 1 to 4 described in the Simulation Setup section.</p> <ol> <li>In the Intel Simics environment at the project directory, create a customized target script to exercise the FSBL to Linux boot flow from NAND device. The file to create is called uboot-linux_nand.simics. This file will look like this:</li> </ol> <pre><code>#uboot-linux_nand.simics\n$fsbl_image_filename = \"u-boot-spl-dtb.bin\"\n$nand_data_image_filename = \"nand.img\"\n$hps_boot_core = 0 $create_hps_sd_card = FALSE\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\n</code></pre> <p>Also, in order to have ethernet connectivity, you need to connect the ethernet interface defined in the NAND device tree (eth0). For this,  update the following line in the targets/agilex5e-universal/agilex5e-universal.simics file:</p> <pre><code>if $create_hps_eth0_network {    :\n    # Connect HPS eth0 instead of eth2 to Ethernet Switch\nconnect ($eth_switch.get-free-connector) $system.board.eth0\n    :    }\n</code></pre> Procedure <p>To exercise this use case, follow the below steps once the Simulation setup is complete:</p> <ol> <li>From the project directory, launch the simulation using the <code>uboot-linux_nand.simics</code> target script. This script launches the simulator and the current terminal becomes the Simics CLI:</li> </ol> <pre><code>$ ./simics uboot-linux_nand.simics </code></pre> <ol> <li>From the Simics CLI, start running the simulation with the <code>run</code> command.</li> </ol> <pre><code>simics&gt;  run\n</code></pre> <ol> <li> <p>Wait for the simulation to get to the Linux prompt in the target serial console.</p> </li> <li> <p>Login into the Linux prompt using the root user without a password.</p> </li> </ol> <p><pre><code>U-Boot SPL 2024.01 (Jun 25 2024 - 09:28:56 +0000)\nReset state: Cold\nMPU           875000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\ninit_mem_cal: Initial DDR calibration IO96B_0 succeed\nio96b_mb_init: num_instance 1\nio96b_mb_init: get memory interface IO96B 0\nio96b_mb_req: Write 0x10001 to IOSSM_CMD_REQ_OFFSET 0x1840043c\n:\nMMC: no card present\nspl: mmc init failed with error: -123\nTrying to boot from SPI\nTrying to boot from NAND\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nWARNING: Data cache not enabled\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.10.1  (release):rel_socfpga_v2.10.1_24.05.02_pr-4-g483735669\nNOTICE:  BL31: Built : 08:56:04, Jun 25 2024\nU-Boot 2024.01 (Jun 25 2024 - 09:28:56 +0000)socfpga_agilex5\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A55/A76)\nModel: SoCFPGA Agilex5 SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  51 devices, 26 uclasses, devicetree: separate\nWDT:   Not starting watchdog@10d00200\nWDT:   Not starting watchdog@10d00300\nWDT:   Not starting watchdog@10d00400\nWDT:   Not starting watchdog@10d00500\nWDT:   Not starting watchdog@10d00600\nNAND:  4096 MiB\nMMC:   mmc0@10808000: 0\nLoading Environment from FAT... MMC: no card present\n** Bad device specification mmc 0 **\n:\nQSPI: Trying to boot script at 0x81000000\n## Executing script at 81000000\nWrong image format for \"source\" command\nQSPI: SCRIPT FAILED: continuing...\nSelect Environment on UBI: OK\nSaving Environment to UBI... done\nOK\nUBI partition 'root' already selected\nNo size specified -&gt; Using max size (1032192)\nRead 1032192 bytes from volume script to 0000000081000000\nNAND: Trying to boot script at 0x81000000\n## Executing script at 81000000\ncrc32+ Trying to boot Linux from device nand\nSelect Environment on UBI: OK\nSaving Environment to UBI... UBI partition 'root' already selected\ndone\nOK\n\ndevice nor0 &lt;nor0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: u-boot              0x04200000      0x00000000      0\n1: qspi_root           0x0be00000      0x04200000      0\ndevice nand0 &lt;ffb90000.nand.0&gt;, # parts = 2\n#: name                size            offset          mask_flags\n0: u-boot              0x00200000      0x00000000      0\n1: root                0xffe00000      0x00200000      0\nactive partition: nor0,0 - (u-boot) 0x04200000 @ 0x00000000\n\ndefaults:\nmtdids  : nand0=10b80000.nand.0\nmtdparts: mtdparts=10b80000.nand.0:2m(u-boot),-(root)\nUBI partition 'root' already selected\nNo size specified -&gt; Using max size (25804800)\nRead 25804800 bytes from volume kernel to 0000000082000000\n## Loading kernel from FIT Image at 82000000 ...\n:\nEnabling QSPI at Linux DTB...\nWorking FDT set to ffad7000\nQSPI clock frequency updated\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\nRSU: Firmware or flash content not supporting RSU\n\nStarting kernel ...\n\nDeasserting all peripheral resets\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 6.6.22-altera-g6ad76f9ca568 (oe-user@oe-host) (aarch64-poky-linux-gcc (GCC) 13.3.0, GNU ld (GNU Binutils) 2.42.0.20240620) #1 SMP PREEMPT Fri Jun 21 09:02:27 UTC 2024\n[    0.000000] KASLR disabled due to lack of seed\n[    0.000000] Machine model: SoCFPGA Agilex5 SoCDK\n[    0.000000] efi: UEFI not found.\n[    0.000000] Reserved memory: created DMA memory pool at 0x0000000080000000, size 32 MiB\n[    0.000000] OF: reserved mem: initialized node svcbuffer@0, compatible id shared-dma-pool\n[    0.000000] OF: reserved mem: 0x0000000080000000..0x0000000081ffffff (32768 KiB) nomap non-reusable svcbuffer@0\n[    0.000000] earlycon: uart0 at MMIO32 0x0000000010c02000 (options '115200n8')\n:\nPoky (Yocto Project Reference Distro) 5.0.2 dhcp0 ttyS0\n\n[   15.586539] soc64-hwmon soc@0:firmware:svc:hwmon: Initialized 4 temperature and 6 voltage channels\n[   15.587715] soc64-hwmon soc@0:firmware:svc:hwmon: couldn't get service channel rsu\n[   15.594272] Stratix10 SoC FPGA manager soc@0:firmware:svc:fpga-mgr: couldn't get service channel (fpga)\n[   15.595272] platform soc@0:firmware:svc:hwmon: deferred probe pending\n[   15.595948] platform soc@0:base_fpga_region: deferred probe pending\n[   15.596631] platform soc@0:firmware:svc:fpga-mgr: deferred probe pending\n[   36.588749] audit: type=1334 audit(1709054799.316:15): prog-id=18 op=UNLOAD\n[   36.589487] audit: type=1334 audit(1709054799.316:16): prog-id=17 op=UNLOAD\n[   36.590224] audit: type=1334 audit(1709054799.316:17): prog-id=16 op=UNLOAD\n\ndhcp0 login: root\n\nWARNING: Poky is a reference Yocto Project distribution that should be used for\ntesting and development purposes only. It is recommended that you create your\nown distribution for production use.\n\nroot@dhcp0:~# </code></pre> Note: Most of the same use cases that are exercised from the Exercise SDCard Boot Flow from FSBL to Linux use case can also be exercised from this use case. There are some exceptions due to the limitation in the size of the file system which does not support the required commands.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-debug-bare-metal-code-using-intel-simics-simulator","title":"Use Case: Debug Bare-Metal Code Using Intel Simics Simulator","text":"<p>This use case consists of performing a debug session in a bare-metal environment, which in this case corresponds to a U-Boot application example. In this use case, debugging is performed using only the Simics CLI commands allowing us to navigate on the source code of the application, advance in the execution of this, and observe and modify values of variables. The application is created in the form of a U-Boot command (helloTestApp) that should be executed from the U-Boot shell. The application starts by printing a hello message (Hello Intel SoC FPGA!) and printing the number of times the command has been executed since the last power-up. After this, the application enters into a loop in which it waits for 100 sec and increases an iteration counter by one. The content on the loop is executed as long as the iterator counter is lower than 100000 and also the value of the exitVar variable remains in 0, otherwise, it leaves the loop and continues printing the number of times the content of the loop was executed. After this, the code performs some mathematical operations involving the iterator value and other variables and finally prints the result of the final operation.</p> <p>The source code of the application is shown next. This is included in the do_helloTestApp() function, which then is referenced in the U_BOOT_CMD macro, which converts this into a U-Boot command. This source code must be included in a new file under the U-Boot repository as cmd/socFPGATrainingExamples.c. Also, to be built as part of the U-Boot binaries, update the cmd/Makefile file by adding obj-y += socFPGATrainingExamples.o.</p> <pre><code>/*\n   Training Examples called from a command from U-Boot shell\n*/\n\n#include &lt;stdio.h&gt;\n#include &lt;command.h&gt;\n#include &lt;linux/delay.h&gt;\nstatic char helloTestCmd_help_text[] =\n\"helloTestApp\\t\\n\";\nstatic unsigned int execCount = 0;\nstatic int do_helloTestApp(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])\n{\nvolatile unsigned char exitVar = 0;\nunsigned int waitIter = 0;\nvolatile unsigned int myVarA = 0;\nunsigned int temp = 0;\nunsigned int result;\nif (argc &gt; 1)\n{\nreturn CMD_RET_USAGE;\n}\nprintf(\"Hello Intel SoC FPGA! \\r\\n\");\nexecCount++;\nprintf(\"Executed %d times \\r\\n\", execCount);\nprintf(\"Relocated address of do_helloTestApp: %p and execCount: %p \\r\\n\", &amp;do_helloTestApp, &amp;execCount);\nwhile ((exitVar == 0) &amp;&amp; (waitIter &lt; 100000)){\nudelay(100);\nwaitIter++;\n}\nprintf(\"Exit from loop at iteration: %d \\r\\n\", waitIter);\ntemp = waitIter + myVarA;\nresult = temp % 1000;\nprintf(\"Final result: %d \\r\\n\", result);\nreturn CMD_RET_SUCCESS;\n}\nU_BOOT_CMD(\nhelloTestApp, 1, 1, do_helloTestApp,\n   \"Command used to launch hello application\", helloTestCmd_help_text\n);\n</code></pre> <p>Note: You can perform the build of this application by updating the Yocto recipe. This can be done by creating a patch in which you describe the files that need to be created/updated in the U-Boot repository and then deploy it. This can be done during the Yocto customization stage (Customize the Yocto Build). To create the u-boot patch (<code>myUbootExampleApp.patch</code>), do the following:</p> <pre><code>cd $TOP_FOLDER\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga u-boot-socfpga-patch\ncd u-boot-socfpga-patch/\n - Create cmd/socFPGATrainingExamples.c file with the source code provided of the example application.\n - Edit cmd/Makefile to include the build of socFPGATrainingExamples.c\n\nobj-y += help.o\n    obj-y += panic.o\n    obj-y += version.o\n    obj-y += socFPGATrainingExamples.o\n\ngit add cmd/Makefile cmd/socFPGATrainingExamples.c\ngit diff --patch --staged &gt; myUbootExampleApp.patch\n</code></pre> <p>To deploy the patch in the Yocto build flow do the following:</p> <ol> <li>Copy the <code>myUbootExampleApp.patch</code> file to the $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/files/ directory.</li> <li>Request to deploy the path by adding a patch to the $TOP_FOLDER/gsrd-socfpga/meta-intel-fpga-refdes/recipes-bsp/u-boot/u-boot-socfpga_%.bbappend file:</li> </ol> <pre><code>SRC_URI:append = \" \\ \n        file://0001-arm-Add-dwarf-4-to-compilation-flag.patch \\   \n        file://0001-arm-agilex-add-board-configuration.patch \\    \n        file://0001-arm-stratix10-add-board-configuration.patch \\ \n        file://myUbootExampleApp.patch \\ \n        \"\n</code></pre> <ol> <li>Continue with the rest of the Yocto build flow indicated at Build Yocto section.</li> </ol> <p>After these steps, the application is included in the U-Boot binary file (uboot.itb), which is part of the SDCard image created (gsrd-console-image-agilex5.wic) and a symbol file corresponding to the U-Boot image, located at $TOP_FOLDER/gsrd-socfpga/agilex5_devkit-gsrd-images/u-boot-agilex5_devkit-socdk-gsrd-atf/u-boot. The symbol file is used later during the setup of the debug session.</p> Setup <p>Start with the setup of the main use case defined at [Simulation Setup]#simulation-setup). Modify the target script to add the created symbol file and set a breakpoint at the entry point of the  do_helloTestApp function as indicated in the following:</p> <pre><code># uboot-linux_sdcard.simics\n:\nadd-symbol-file  &lt;path of symbol file&gt;/u-boot  0x7FAF2000 -relative\nbp.source_location.break do_helloTestApp\n</code></pre> <p>Note: The symbol file is being loaded with an offset relocation of 0x7FAF2000. This is needed because in a late stage of the U-Boot execution, this relocates itself into a different SDRAM memory location and this should be indicated to the debugger, so there is a match between the addresses indicated in the symbol file and the real memory address location of the symbols. You can obtain this relocation offset by subtracting the real address of a specific function (which can be obtained from the application being executed) and the original offset from the same function in the symbols file (provided in the u-boot.sym file). This is shown in the following figure:</p> <p></p> Procedure <ol> <li> <p>Start the simulation similar to how it is done in the main use case, but in the serial console stop the U-Boot autoboot by pressing a key on the reception of the message \"Hit any key to stop autoboot:\". </p> </li> <li> <p>Start the U-Boot example application by calling the helloTestApp command from the U-Boot shell. This will make the breakpoint set in the target script trigger and the simulation will be stopped. In the Simics CLI, you will see the following message:</p> <p><pre><code> [tcf] Breakpoint 1 on execution in context board.fpga.soc_inst.hps_subsys.agilex_hps.core[0] </code></pre> 3. From Simics CLI, start a debug session by calling the following command:  <pre><code>simics&gt; (psel).debug dbg0 (the arm-cortex-a55 system.board.fpga.soc_inst.hps_subsys.agilex_hps.core[0]) Now debugging the arm-cortex-a55 system.board.fpga.soc_inst.hps_subsys.agilex_hps.core[0] do_helloTestApp(cmdtp=(struct cmd_tbl *) 0xfffc5788, flag=0, argc=1, argv=(char * const *) 0xffb09520) at /home/tasks/gsrd/agilex5/updateUbootApp/agilex5_gsrd/gsrd-socfpga/agilex5_devkit-gsrd-rootfs/tmp/work/agilex5-poky-linux/u-boot-socfpga/1_v2022.10+gitAUTOINC+59fa161039-r0/git/cmd/socFPGATrainingExamples.c:19 19 volatile unsigned char exitVar = 0; </code></pre> 4. Following the program's logic, if the value of exitVar stays zero and the program is continued, the loop will continue until it reaches 100,000 and then the program ends with output messages in the serial console. You can check the values of the variable using the sym-type  and sym-value features:  <pre><code>simics&gt; dbg0.sym-type exitVar volatile unsigned char simics&gt; dbg0.sym-value exitVar 0 '\\x00' simics&gt; dbg0.sym-type myVarA volatile unsigned int- simics&gt; dbg0.sym-value myVarA 0\n</code></pre></p> </li> <li> <p>Control the program by using breakpoint and value modification. In this section, first insert a breakpoint at Line 34, which is in the loop (You may let the program run for a few seconds before inserting this breakpoint). With that, expect the program to pause when the breakpoint is met and modify the value of exitVar.    <pre><code>//The loop conditions are exitVar and waitIter   32| while ((exitVar == 0) &amp;&amp; (waitIter &lt; 100000)){   33|    udelay(100);   34|    waitIter++;   35| }\n</code></pre></p> <p>In the Simics Serial Console, enter the following line to insert the breakpoint at Line 34:  <pre><code>running&gt; bp.source_line.break filename=socFPGATrainingExamples.c line-number=34\nBreakpoint 2: 0x2 (planted) </code></pre></p> <p>As the breakpoint is planted, continue the program by entering run. The program will stop when the breakpoint is hit. When the program stopped, modify the value of exitVar in the Serial Console by using the sym-write feature.</p> <pre><code>simics&gt; dbg0.sym-write exitVar 1 exitVar = 1 '\\x01'\nsimics&gt; run\n</code></pre> <p>Next, enter run and see the program ends immediately due to exitVar=1.  <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n   Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n   Exit from loop at iteration: 9691\nFinal result: 691\nSOCFPGA_AGILEX5 #\n</code></pre></p> <p>From the output print, it shows that the program iterated for 9691 loops before hitting the Line-34 breakpoint you planted, this number would be bigger if you waited longer before planting the breakpoint. Lastly, the modification of exitVar  ended the program.</p> </li> </ol> <p>Note:     a) You can modify the value of myVarA and exitVar at any time before the looping ends (the test program ends after 99,999 loops).     b) If the loop-ending condition (myVarA and exitVar) changed, the program should exit in the next run.     c) Using the same Simics session, you can enter helloTestApp in U-boot Shell to restart the test program again.</p> <ol> <li> <p>For the first time the program is executed, the output shows \u201cExecuted 1 times\u201d, this value will increase (+1) as you run the program again without ending the Simics session. Meanwhile, in the serial console, the program has ended as soon as it just started because the controlling variable exitVar, having a value of 1, already reached the loop-ending condition. Output on a serial console:</p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n   Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n   Exit from loop at iteration: 2\nFinal result: 2\nSOCFPGA_AGILEX5 #\n</code></pre> </li> <li> <p>If the value exitVar remained zero, the loop counter is allowed to run for 99,999 loops. While the program is looping, you may change the value of myVarA to \u2018345\u2019. The Final result will be 345 when the looping ends. Final result is the modulus value where the <code>Final result = ( (waitIter + myVarA) % 1000 )</code></p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n   Executed 2 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n   Exit from loop at iteration: 100,000\n   Final result: 345\nSOCFPGA_AGILEX5 #\n</code></pre> </li> <li> <p>If both values of exitVar and myVarA remain unchanged, both being zero respectively, the looping continues until it reaches waitIter = 100,000. When the program ends, the Final result would be zero.</p> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nHello Intel SoC FPGA!\n   Executed 1 times\nRelocated address of do_helloTestApp: 00000000fff1a7a8 and execCount: 00000000fffddba0\n   Exit from loop at iteration: 100,000\n   Final result: 0\nSOCFPGA_AGILEX5 #\n</code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-debug-bare-metal-code-using-simics-riscfree","title":"Use Case: Debug Bare-metal Code Using Simics-RiscFree","text":"<p>This use case is an extension to the use case in section Use Case: Debug Bare-metal Code Using Intel Simics Simulator above but the debugging steps are performed in the Simics-RiscFree IDE. The test program used here is the same helloTestApp.c Important: The offset relocation of 0x7FAF2000 in the symbol file is still required and must be done before the symbol file is used to launch Simics-RiscFree.</p> Setup <p>This section requires the simics-riscfree script. It is included in your Intel Simics Simulator project directory.</p> <ol> <li>To launch Simics-RiscFree IDE, use this command:</li> </ol> <pre><code>$  ./simics-riscfree </code></pre> <ol> <li> <p>Following the command, you must set up a RiscFree  workspace. You should use a new directory as a RiscFree workspace different from the Simics project directory. </p> </li> <li> <p>In the RiscFree IDE GUI launched, you should see the current Simics project you selected shown in the Project Explorer window. If this is not shown, you can open it from \"Window &gt; Show View &gt; Project Explorer\" menu. </p> </li> <li> <p>From the Project Explorer window, right-click on the target script you want to launch (uboot-linux_sdcard.simics) and select \u201cDebug As &gt; Simics Session\u201d. </p> </li> <li> <p>When prompted for Switching Perspective, select Yes. The interface switches to the RiscFree Debugger, which is more user-friendly for debugging. </p> </li> </ol> Procedure <ol> <li>In the RiscFree Debugger window, click on the Run button  to launch the Intel Simics Simulator project.</li> <li> <p>As the project is launched, a Simics CLI window appears. When the CLI reaches the Hit any key to stop autoboot message, press any key to stop the autoboot to OS, which will then go into the U-boot Shell. </p> </li> <li> <p>Start the test program by entering helloTestApp in the U-boot Shell.</p> </li> </ol> <pre><code>SOCFPGA_AGILEX5 # helloTestApp\nsimics&gt; [tcf] Breakpoint 1 on execution in context board.fpga.soc_inst.hps_subsys.agilex_hps.core[0]\n</code></pre> <ol> <li>As the first breakpoint is met, the program is halted at the entry point of the do_helloTestApp() function. Use the step into/step-over buttons  to get to the while ((exitVar == 0)  &amp;&amp;  (waitIter &lt; 100000)) line and show a capture of this with list command.</li> </ol> <p></p> <ol> <li>At this point, if you click on the Run button, the test program prints \u201cHello Intel SoC FPGA!\u201d and finishes looping after some time.</li> </ol> <p></p> <p>Note: If the loop already ended, relaunch the test program \"helloTestApp\" to proceed to the next step.</p> <ol> <li>To modify the loop conditions for debugging purposes, you can modify the value of exitVar in the Variable window. For example, changing the value of exitVar from \u2018\\377\u2019 (this is a random value assigned by the system) to \u2018\\001\u2019. As <code>exitVar</code> is no longer zero, the condition of the loop is exceeded, and thus the looping ends.</li> </ol> <p>Before modification:</p> <p></p> <p>After modification:</p> <p>[</p> <ol> <li>The loop exits depending on two conditions: exitVar not equals to zero OR waitIter reached 100,000. As the value of exitVar is modified to 1 in the middle of looping, the loop ends with exitVar = 1 and <code>waitIter</code> at any number less than 100,000. In this example, waitIter is 82251 when the loop ends. Following the code logic, Final result is the modulus value where Final result = ( (waitIter + myVarA) % 1000 ) = 252. </li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/linux-gsrd/ug-linux-gsrd-agilex5-virtual-platforms/#use-case-remote-debugging-of-a-linux-user-mode-program-using-arm-ds-debugger","title":"Use Case: Remote Debugging of a Linux User Mode Program Using ARM DS Debugger","text":"<p>This use case is an extension of the Use Case: Exercise SDCard Boot Flow from FSBL to Linux and consists of performing a debug session in a Linux user mode application using ARM Development Studio. For this, the debugging is done using the GDB server running in the target system. Also, set up the Simics network connectivity with the host PC, which is the one that runs ARM DS through TCP protocol. The application to be debugged is listed next myArmDSDebugExample.c. This application determines the core in which this run started and then enters into a loop counting the number of times the loop is executed and continue observing the execution core. It also counts the number of times the application is executed in each one of the four cores. The application exits from the loop when the iterator reaches a limit or the exitVar variable has a value of '1', which normally never should occur. After the loop, the application assigns the value in x variable to the a and b variables and then adds these variables and assigns the result value in c variable. In the end, the application prints the result of the addition, the number of times the loop was iterated and the final value of exitVar, and the number of times each core executed the application.</p> <pre><code>#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\n#define NUM_CORES 4\nunsigned int coreCount[NUM_CORES];\nunsigned long int read_mpidr(void)\n{\nunsigned long int value;\nasm volatile(\"mrs %[result], mpidr_el1\" : [result] \"=r\" (value));\nreturn value;\n}\nunsigned int getCore(){\nstatic unsigned int corePrev = (unsigned int)(-1);\nunsigned long mpidr;\nunsigned int core;\nmpidr = read_mpidr();\ncore = (mpidr &gt;&gt; 8) &amp; 0xFF;    if (core != corePrev)\n{\ncoreCount[core]++; corePrev = core;\n}\nreturn core;\n}\nint main()\n{\nint x = 1000;\nunsigned int core;    unsigned int iter = 0;\nint a;\nint b;\nint c;\nvolatile int exitVar = 0;\ncore = getCore();\nprintf(\"=== My Debug example started on Core %d ===\\n\", core); while((exitVar==0) &amp;&amp; (iter &lt; 1000000000))\n{\ncore = getCore(); iter++;\n}\na = x;\nb = x;\nc = a + b;\nprintf(\"Count:%d  iter: %d  exitVar:%d \\n\", c, iter, exitVar);\nfor (core = 0; core &lt; NUM_CORES; core++)\nprintf(\"  core[%d]: %d times\\r\\n\", core, coreCount[core]);\nreturn 0;\n}\n</code></pre> Setup <ol> <li>Start with the setup as the parent use case. From the Simics CLI or from the uboot-linux_sdcard.simics Simics script, add the network configuration that allows establishing the GDB server connexion between the target system and the host PC. This configuration creates an incoming forwarding port for TCP traffic from a port in the host PC to port 9123 in the target system. The port in the host PC is shown when calling the list-port-forwarding-setup command (port 4001 will be used in this example).</li> </ol> <pre><code># uboot-linux_sdcard.simics\n:\nconnect-real-network-port-in 9123 ethernet-link = ethernet_switch0 target-ip = 10.10.0.100 -tcp list-port-forwarding-setup\nrunning&gt;  list-port-forwarding-setup NAPT enabled with gateway 10.10.0.1/24 on link ethernet_switch0.link.\nNAPT enabled with gateway fe80::2220:20ff:fe20:2000/64 on link ethernet_switch0.link.\n\nReal DNS enabled at 10.10.0.1/24 on link ethernet_switch0.link.\nReal DNS enabled at fe80::2220:20ff:fe20:2000/64 on link ethernet_switch0.link.\n\nHost TCP port 4001 \u2192 10.10.0.100:9123\n</code></pre> <ol> <li>The Linux example application must be compiled so you can have the executable binary available. This binary is generated with a toolchain and should be built to include debug information (i.e. symbol file). ARM DS does not support the DWARF 5.0 format in the symbols files, so the application must be built with a toolchain that creates this with DWARF 4.0 version. The instructions to build the applications are shown next. This generates the myArmDSDebugExample binary.</li> </ol> <pre><code>mkdir SymDbg &amp;&amp; cd SymDbg\nwget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.2-2020.11/binrel/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\nrm gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz\n\n./gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-gcc -g -o  myArmDSDebugExample myArmDSDebugExample.c\n</code></pre> Procedure <ol> <li> <p>Execute parent use case to get to the Linux prompt and log in.</p> </li> <li> <p>Take the Linux application binary to the target system filesystem using tftp. For this, you will need to do the following. The myArmDSDebugExample binary should be located in the Simics project directory before calling tftp command.</p> </li> </ol> <pre><code>root@dhcp0:~# ethtool -K eth1 tx off tx-checksum-ipv4: off\ntx-checksum-ipv6: off\ntx-tcp-segmentation: off [not requested]\ntx-tcp6-segmentation: off [not requested]\nroot@dhcp0:~# tftp -gr myArmDSDebugExample 10.10.0.1 root@dhcp0:~# chmod +x myArmDSDebugExample </code></pre> <ol> <li>Start a GDB Server debug session over the application from the Linux prompt using the port created in the target system during the port forwarding setup:</li> </ol> <p><pre><code>root@dhcp0:~# gdbserver 10.10.0.1:9123 myArmDSDebugExample Process /home/root/myArmDSDebugExample created; pid = 283\nListening on port 9123\n</code></pre> 4. In ARM Development Studio, create a new debug connection following the next steps:</p> <p>a) Create a New Debug Connection to a Linux Application Connection. Press Next.  </p> <p>b) Give a name to the Debug connection: DebugLinuxAppSimicsGDB . Press Finish. </p> <p>c) Edit the configuration. In the Connection tab, select: - Linux Application Debug \u2192 Application Debug \u2192 Connections via AArch64 gdbserver \u2192 Connect to already running application - Address: localhost (or host PC IP if want to be accessed from a different PC in the same network) - Port: 4001 - Select Terminate gdbserver on disconnect</p> <p></p> <p>d) Edit the configuration. In Files tab, select the application binary loaded as symbol file: </p> <p>e) Edit the configuration. In Debugger tab, select Debug from symbol: main </p> <p>Press Debug button to start the debug.</p> <ol> <li>The application debug can be performed now. ARM DS shows the source code of the test application stopped at the entry point of the main() function and we observe at the left the Debug Control panel with the options to control the execution of the code:</li> </ol> <p></p> <p>Observe that in the target serial console, the gdb server reports that the connection with the host was achieved showing the message: Remote debugging from host 10.10.0.1, port 4097</p> <p>a) Run the code and after a few seconds pause it. Observe that it stops under the while loop (or under the getCore() function which is called under the loop). You can observe the value of the variables using the Variables tab. The iter variable is increased in every iteration in the loop and the current value of exitVar variable is 0. You can also observe that the application is being executed in core 0. The loop will exit whenever the exitVar variable has a value of 1 or the iterator reaches gets greater than 1000000000. At this point, the application already printed the === My Debug example started on Core 0 === message in the serial console.  </p> <p>b) You can change the value of the exitVar variable from the Value column in the Variables tab, use the step-over button to advance in the execution of the application, and confirm that this condition makes it exit from the loop. You can continue advancing in the code execution and observe that the variables a and b gets initialized with the value of x. Observe that the c variable gets updated with the result of the addition of a and b variables.</p> <p></p> <p>c) Proceed to continue the code execution and observe that the application gets finished printing the results. Also, you can get disconnected from the gdb server session and after this, the serial console shows again the Linux prompt.</p> <p></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/","title":"Agilex\u2122 5 Intel Simics Virtual Platform Example User Guide - Zephyr GSRD","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#overview","title":"Overview","text":"<p>Agilex\u2122 5 E-Series devices provide the next generation HPS after those provided with the Agilex\u2122\u00ae 7 and Stratix 10\u00ae SoC FPGA devices. The Agilex\u2122 5 E-Series HPS application processors can run Zephyr RTOS and Linux with scalable performance using from one to four Arm Cortex -A cores that allow for a wide range of applications. The Agilex\u2122 5 E-Series Simics virtual platform models the HPS processor with two Arm Cortex-A55 cores and two Arm Cortex-A76 cores along with the hard processor system (HPS) peripherals. The Agilex\u2122 5 E-Series HPS virtual platform is released as part of the Simics\u00ae Simulator for Agilex\u2122 FPGAs software, which also includes several virtual platforms where the Agilex\u2122 5 E-Series device is instantiated, emulating the concept of having different versions of a development kit or daughter cards. The Agilex\u2122 5 E-Series has the following supported virtual platforms:</p> <ul> <li>Agilex\u2122 5 E-Series Virtual Platform - Universal</li> </ul> <p>The following sections describe the prerequisites for the Simics simulator for Altera FPGA and the available virtual platforms including prebuilt Zephyr binaries. Instructions about how to build these binaries and run the Software stack are provided as well. Additionally, some common use cases that you can exercise with this Zephyr release are discussed.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#prerequisites","title":"Prerequisites","text":"<p>To exercise the instructions presented on this page, the following prerequisites need to be satisfied:</p> <ul> <li>Host PC with Linux. The instructions on this page use Ubuntu 20.04 LTS.  </li> <li>The following package versions are needed to build Zephyr binaries:<ul> <li>cmake - 3.20.5</li> <li>python3 - 3.8</li> <li>dtc - 1.4.6</li> </ul> </li> <li>The following packages are needed to be able to deploy the Simics project: GCC 6.3 compiler or higher, g++ 9.4 or higher, GNU make 4.1 or higher.</li> <li>Agilex\u2122 5 Simics Virtual Platform components are available to be deployed.</li> <li>Quartus\u00ae Prime Pro Edition Programmer and Tools 23.4 or later.</li> </ul> <p>Note: For installation instructions for the Simics Simulator for Altera\u00ae FPGAs and the Agilex\u2122 5 E-Series virtual platforms, refer to the following documents:</p> <ul> <li>Intel\u00ae Simics\u00ae Simulator for Intel\u00ae FPGAs User Guide</li> <li>Agilex\u2122 5 E-Series Virtual Platform User Guide</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#release-contents","title":"Release Contents","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#source-code","title":"Source Code","text":"SW Component Repository Branch/tag ATF https://github.com/altera-opensource/arm-trusted-firmware/ socfpga_v2.9.1/QPDS23.4_REL_GSRD_PR Zephyr https://github.com/altera-opensource/zephyr-socfpga/ socfpga_rel_23.4/QPDS23.4_REL_GSRD_PR <p>Note: For information prior 24.2 release, please refer to Zephyr* GSRD for Intel Agilex\u00ae 5 E-Series Simics Virtual Platform.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#prebuilt-binaries","title":"Prebuilt Binaries","text":"<p>Prebuilt binaries can be found at the following URL: https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/. The prebuilt binaries consist of application programs built to run on the MPU cores in multicore configuration. There are binary files designed for boot devices such as SD cards, NAND flash, and QSPI. Additionally, files used by the recipes to create the binaries to boot from QSPI and NAND are provided in their respective folders. The sample applications provided are:</p> Directory Application Description cli Application to demonstrate Command Line Interface hello_world Application that displays a Hello World! message <p>Within each application directory, you'll find the following files: </p> <pre><code>&lt;application directory&gt; \n    \u251c\u2500\u2500 bl31.bin \n    \u251c\u2500\u2500 bl31.elf \n    \u251c\u2500\u2500 fip.bin \n    \u251c\u2500\u2500 fiptool \n    \u251c\u2500\u2500 nand_boot \n    \u2502   \u251c\u2500\u2500 0001-plat-intel-soc-agilex5-enable-NAND-boot.patch \n    \u2502   \u251c\u2500\u2500 bl2.bin \n    \u2502   \u251c\u2500\u2500 bl2.elf \n    \u2502   \u2514\u2500\u2500 nand_mem.img \n    \u251c\u2500\u2500 qspi_boot\n    \u2502   \u251c\u2500\u2500 0001-plat-intel-soc-agilex5-enable-QSPI-boot.patch\n    \u2502   \u251c\u2500\u2500 agilex5_factory.sof\n    \u2502   \u251c\u2500\u2500 bl2.bin\n    \u2502   \u251c\u2500\u2500 bl2.elf\n    \u2502   \u251c\u2500\u2500 flash_image_jic.rpd\n    \u2502   \u2514\u2500\u2500 qspi_flash_image_agilex5_boot.pfg\n    \u251c\u2500\u2500 sdmmc_boot\n    \u2502   \u251c\u2500\u2500 bl2.bin\n    \u2502   \u251c\u2500\u2500 bl2.elf\n    \u2502   \u251c\u2500\u2500 make_sdimage.sh\n    \u2502   \u2514\u2500\u2500 sdimage.img\n    \u251c\u2500\u2500 usb-msd.craff\n    \u251c\u2500\u2500 zephyr.bin\n    \u251c\u2500\u2500 zephyr.dts\n    \u251c\u2500\u2500 zephyr.elf\n    \u251c\u2500\u2500 zephyr.lst\n    \u251c\u2500\u2500 zephyr.map\n    \u2514\u2500\u2500 zephyr.stat\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#embedded-software-peripheral-zephyr-drivers-availability","title":"Embedded Software Peripheral Zephyr Drivers Availability","text":"HPS Peripheral Supported SD Card driver Yes GPIO Driver Yes I2C Driver Yes UART Driver Yes Timer Driver Yes WatchDog Driver Yes SMP Driver Yes QSPI Driver Yes NAND Driver Yes SDRAM Driver Yes Ethernet Driver Yes SPI Driver Yes SDM Mailbox Driver Yes USB 2.0 Driver Yes HPS DMA Driver Yes I3C driver Yes EDAC/RAS drivers Yes"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#boot-flow","title":"Boot Flow","text":"<p>Starting with this release the Arm Trusted Firmware will act as the FSBL and SSBL bootloader for  Zephyr as described in the following diagram: </p> <p> </p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#agilextm-5-simics-virtual-platform","title":"Agilex\u2122 5 Simics Virtual Platform","text":"<p>This virtual platform is associated with the agilex5e-universal.simics target script. The following figure shows a high-level block diagram of this virtual platform. In this diagram, we can observe the main components that can be exercised during the execution of the use cases described later on this page. The implementation of this virtual platform allows all the peripherals in the HPS to be enabled at the same time, which is not possible in physical hardware implementations. The pinmux and Combo PHY impose restrictions in physical hardware. In the case of the pinmux in physical hardware, only a subset of peripherals can be enabled at the same time because there are not enough pins if all pins are enabled simultaneously. This limitation does not exist in the Agilex 5 E-Series Universal Virtual Platform. For the Combo PHY, the physical hardware allows only one flash controller (NAND or SDMMC) to be enabled at one time. However, the virtual platform allows both to be enabled simultaneously. </p> <p> </p> <p>The architecture of the virtual platform follows a hierarchy that goes from system -&gt; board -&gt; fpga -&gt; hps, which is aligned with the Agilex\u2122 5 Simics virtual platform development philosophy that tries to match with the real hardware system architecture.</p> <p>The target script instantiates the system component, provides the CLI run time commands and creates the network configuration. This script also defines the parameters that configure other components.</p> <p>The system component represents the complete system of the virtual platform and instantiates the board component. This component is implemented in a Python file.</p> <p>The board component represents the model of a PCB (analogous to a development kit). It includes the instance of the FPGA component and all board components connected to the FPGA (for example, flash device, ethernet PHY). The GPIO loopback connection is implemented here. This component is implemented in a Python file.</p> <p>The FPGA component represents a model of the top-level FPGA design. The hierarchy matches the logical hierarchy of a hypothetical GHRD that the virtual platform models. This instantiates the HPS, the external memory interface IP, and the FPGA example design.</p> <p>The embedded software running in this virtual platform is expected to be the same that could be run in the real silicon. Additionally, the ability to exercise the HPS embedded software in this virtual platform allows you to debug the software using the Simics\u00ae Simulator debug capabilities.</p> <p>For more details about Intel Simics\u00ae Simulator please refer to: Linux Simics GSRD</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#key-points-for-zephyr","title":"Key points for Zephyr","text":"<p>The Zephyr GSRD requires a top-level target script that wraps the agilex5e-universal.simics and execute Simics commands to run Zephyr.  The example of the file contents is shown below:</p> <pre><code>#Universal Zephyr simics Script. \nlocal $board_name = \"system.board.fpga\" \n\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\n# Ensure the sdimage.img &amp; bl2.bin paths are relative to the simics executable#\n\n# Enable Console\n$create_hps_serial0_console=TRUE\n\n# Boot from SD Card\n$create_hps_sd_card=TRUE\n$create_hps_mmc=FALSE\n\n# SD Card boot Image file path\n$sd_image_filename = ../bin/sdimage.img\n\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\n\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"  \n\nrun\n</code></pre> <p>In this script, the most relevant parameters to run Zephyr  are the following:</p> Parameter Description Range Default Value $sd_image_filename Sdcard image path Filename string \"\" $fsbl_image_filename Fsbl image path Filename string \"\""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#using-prebuilt-binaries","title":"Using Prebuilt Binaries","text":"<p>The Zephyr GSRD requires a top-level target script that wraps the agilex5e-universal.simics and execute Simics commands to run Zephyr. The example of the file contents is shown below:</p> <pre><code>#Universal Zephyr simics Script. \nlocal $board_name = \"system.board.fpga\" \n\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\n# Ensure the sdimage.img &amp; bl2.bin paths are relative to the simics executable#\n\n# Enable Console\n$create_hps_serial0_console=TRUE\n\n# Boot from SD Card\n$create_hps_sd_card=TRUE\n$create_hps_mmc=FALSE\n\n# SD Card boot Image file path\n$sd_image_filename = ../bin/sdimage.img\n\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\n\nrun-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"  \n\nrun\n</code></pre> <p>In this script, the most relevant parameters to run Zephyr  are the following:</p> Parameter Description Range Default Value $sd_image_filename Sdcard image path Filename string \"\" $fsbl_image_filename Fsbl image path Filename string \"\""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#using-prebuilt-binaries_1","title":"Using Prebuilt Binaries","text":"<p>This section is a guide for you to run the prebuilt sample Zephyr applications.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#setting-up-to-use-prebuilt-binaries","title":"Setting Up to Use Prebuilt Binaries","text":"<p>You will need both the boot image as well the firmware(ATF) binaries. The links below go directly to the directory with binaries corresponding to the application and boot device:</p> <ul> <li>Hello World:<ol> <li>SD Card</li> <li>NAND Flash</li> <li>QSPI Flash</li> </ol> </li> </ul> <ul> <li>CLI:<ol> <li>SD Card </li> <li>NAND Flash</li> <li>QSPI Flash</li> </ol> </li> </ul> <p>The following are the helper instructions to download the prebuilt binaries according to the application and boot device:</p> <ol> <li> <p>This step assumes you have not created the folders as mentioned in Build Instructions or that you want to start afresh. It will remove any prior work! Skip to the next step to retain prior work. Create the !ZephyrGSRD directory. <pre><code>rm -rf agilex5_zgsrd\nmkdir agilex5_zgsrd\ncd agilex5_zgsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre></p> </li> <li> <p>Create a folder to contain the prebuilt binaries. <pre><code>cd $TOP_FOLDER mkdir prebuilt\n</code></pre></p> </li> <li> <p>Specify sample application and boot device</p> <ul> <li>App Application Environment Variable Hello World export app=hello_world CLI export app=cli </li> </ul> <ul> <li>Boot Device Boot Device Environment Variable SDMMC export bootdev=sdmmc_boot bootimg=sdimage.img NAND export bootdev=nand_boot bootimg=nand_mem.img QSPI export bootdev=qspi_boot bootimg=flash_image_jic.rpd </li> </ul> </li> <li> <p>Wget the prebuilt binaries into the prebuilt folder.</p> </li> </ol> <pre><code>cd $TOP_FOLDER/prebuilt\nwget -N https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/$app/$bootdev/$bootimg -P $app/$bootdev/ wget -N https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/$app/$bootdev/bl2.bin -P $app/$bootdev/\n</code></pre> <p>The prebuilt samples for Agilex\u2122 5 would have the following structure:    * prebuilt/hello_world    * prebuilt/cli</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#organizing-the-prebuilt-binaries","title":"Organizing the Prebuilt Binaries","text":"<p>If you've downloaded the prebuilt binaries manually, please place them in the following structure, then refer below to the step \"To boot on Simics\"...</p> <pre><code>agilex5_zgsrd\n\u2514\u2500\u2500 bin\n    \u2502   \u251c\u2500\u2500 atf\n    \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 bl2.bin\n    \u2514\u2500\u2500 sdimage.img OR nand_mem.img OR flash_image_jic.rpd \n</code></pre> <p>If you've followed the helper steps above, follow the next instructions:</p> <ol> <li>Prepare the binaries to run on Simics\u00ae Simulator.</li> </ol> <p><pre><code>cd $TOP_FOLDER rm -rf bin mkdir -p bin/atf ln -s $TOP_FOLDER/prebuilt/$app/$bootdev/$bootimg bin/ ln -s $TOP_FOLDER/prebuilt/$app/$bootdev/bl2.bin bin/atf/bl2.bin\n</code></pre> 2. For the first time run, set up the Agilex\u2122 5 virtual platform. Refer to Simulation Setup.</p> <ul> <li>To boot on Simics, based on the boot device refer to the corresponding sections :  Booting from SD Card Image binaries,  Booting from NAND binaries and Booting from QSPI binaries.</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#build-instructions","title":"Build Instructions","text":""},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#setting-up-environment","title":"Setting up Environment","text":"<ul> <li>Update your system</li> </ul> <pre><code>sudo apt-get update\nsudo apt-get upgrade\n</code></pre> <ul> <li>Install all the required dependencies:</li> </ul> <pre><code>sudo apt-get install --no-install-recommends git cmake ninja-build gperf ccache dfu-util device-tree-compiler wget python3-dev python3-pip python3-setuptools python3-tk python3-wheel python3-venv xz-utils file libpython3-dev make gcc gcc-multilib g++-multilib libsdl2-dev libmagic1 libguestfs-tools  libssl-dev\n</code></pre> Package Zephyr Requirement Ubuntu 20.04 (default versions) command cmake 3.20.5 3.16.3 (below required) cmake --version python 3.8 3.8.10 python3 --version dtc 1.4.6 1.5.0 dtc --version <ul> <li>As a minimum CMake version 3.20.0 is required, if you have an older version, then execute the following commands to add a non-intrusive CMake binary:</li> </ul> <pre><code>CURR_FOLDER=$PWD\nmkdir -p $HOME/bin/cmake &amp;&amp; cd $HOME/bin/cmake\nwget https://github.com/Kitware/CMake/releases/download/v3.21.1/cmake-3.21.1-Linux-x86_64.sh\nyes | sh cmake-3.21.1-Linux-x86_64.sh | cat\necho \"export PATH=$PWD/cmake-3.21.1-linux-x86_64/bin:\\$PATH\" &gt;&gt; $HOME/.zephyrrc\ncd $CURR_FOLDER\n</code></pre> <ul> <li>Load the profile that was created to use the newer CMake (this should be done for every session when Building Zephyr:</li> </ul> <pre><code>source  $HOME/.zephyrrc\n</code></pre> <ul> <li>Create the ZephyrGSRD directories:</li> </ul> <pre><code>rm -rf agilex5_zgsrd\nmkdir agilex5_zgsrd\ncd agilex5_zgsrd\nexport TOP_FOLDER=$(pwd)\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<ul> <li>Download the compiler toolchain. Define environment variables and append the toolchain path in the environment PATH variable. so the toolchain can be used to build the binaries:</li> </ul> <p><pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.3.rel1/binrel/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu/bin:$PATH\necho \"export PATH=`pwd`/arm-gnu-toolchain-11.3.rel1-x86_64-aarch64-none-linux-gnu/bin:\\$PATH\" &gt;&gt; $TOP_FOLDER/.zephyrrc\n</code></pre> - Clone the ATF repository from GitHub and build it</p> <pre><code>git clone -b QPDS23.4_REL_GSRD_PR  https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\ngit switch -c test\nmake realclean\nARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- make PLAT=agilex5 bl2 bl31 PRELOADED_BL33_BASE=0x80100000 -j$(nproc) </code></pre> <ul> <li>Build Fiptool to be able to create the sdimage in later steps.</li> </ul> <pre><code>make fiptool\ncp tools/fiptool/fiptool $TOP_FOLDER\ncd $TOP_FOLDER\n</code></pre> <p>The previous instructions will produce (in the $TOP_FOLDER/arm-trusted-firmware directory): - build/agilex5/release/bl2.bin - build/agilex5/release/bl31.bin - tools/fiptool/fiptool</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#zephyr-build-environment-setup","title":"Zephyr Build Environment Setup","text":"<ul> <li>Create a new virtual environment and activate it</li> </ul> <pre><code>python3 -m venv ~/.zephyrproject/.venv\n#Environment Activation\nsource ~/.zephyrproject/.venv/bin/activate\n</code></pre> <ul> <li>Install west, pull the official Zephyr repository and other Zephyr dependencies:</li> </ul> <pre><code>pip3 install wheel\npip3 install west\nwest init -m https://github.com/zephyrproject-rtos/zephyr --mr v3.4-branch zephyrproject\ncd $TOP_FOLDER/zephyrproject\nwest update\nwest zephyr-export\npip install -r $TOP_FOLDER/zephyrproject/zephyr/scripts/requirements.txt\n</code></pre> <p>Note: If you get a similar error like: <pre><code>ERROR: sphinx-tabs 3.4.1 has requirement docutils~=0.18.0, but you'll have docutils 0.19 which is incompatible.\nERROR: sphinx-rtd-theme 1.2.2 has requirement docutils&lt;0.19, but you'll have docutils 0.19 which is incompatible\n</code></pre></p> <p>Run: <pre><code>pip install sphinx-rtd-theme sphinx\n</code></pre></p> <ul> <li>Install Zephyr SDK in home folder so it can be used on many Zephyr projects:</li> </ul> <pre><code>wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.4/zephyr-sdk-0.16.4_linux-x86_64.tar.xz\nwget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.4/sha256.sum | shasum --check --ignore-missing\nwget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.1/zephyr-sdk-0.16.1_linux-x86_64.tar.xz\nwget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.1/sha256.sum | shasum --check --ignore-missing tar xf zephyr-sdk*.tar.xz -C ~/\nrm zephyr-sdk*.tar.xz\n$HOME/zephyr-sdk*/setup.sh -t aarch64-zephyr-elf -h -c\n</code></pre> <ul> <li>Substitute the official \"Zephyr\" folder for zephyr-socfpga repository:</li> </ul> <pre><code>cd $TOP_FOLDER/zephyrproject\nrm -rf zephyr git clone -b QPDS23.4_REL_GSRD_PR --single-branch https://github.com/altera-opensource/zephyr-socfpga zephyr\nwest update\nwest zephyr-export\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#building-zephyr-application","title":"Building Zephyr Application","text":"<p>Every Zephyr application is composed of several configurable key components that work together in the same executable:</p> <ul> <li>Zephyr Kernel: Manages system resources and task scheduling.</li> <li>Device Drivers: Enable interaction with hardware peripherals.</li> <li>Libraries: Provide additional functionality and utilities.</li> <li>Application Code: Written in C to define application behavior</li> </ul> <p>The following Zephyr sample applications are available to test:</p> <ul> <li>HelloWorld: samples/hello_world/</li> <li>GPIO: samples/basic/blinky/</li> <li>I2C: samples/drivers/i2c_fujitsu_fram/</li> <li>Timer/Counter: samples/drivers/counter/alarm/</li> <li>Watchdog: samples/drivers/watchdog/</li> <li>SD: samples/subsys/fs/fat_fs/</li> <li>UART: samples/drivers/uart/echo_bot/</li> <li>Ethernet: samples/net/sockets/echo_client and samples/net/sockets/ echo_server</li> <li>NAND: samples/drivers/soc_flash_nand/</li> <li>SPI: samples/drivers/jesd216/</li> <li>QSPI : samples/drivers/soc_flash_qspi/</li> <li>SDM Mailbox: sample/subsys/sip_svc/</li> <li>USB 2.0 Host: samples/subsys/fs/fat_fs/</li> <li>HPS DMA: samples/drivers/dma/mem_to_mem/</li> <li>I3C: samples/drivers/i3c_sample_app_simics/</li> </ul> <p>In this regard, we will focus on building the \"Hello World\" sample that will allow us to test our development environment and run it in Simics\u00ae Simulator.</p> <ul> <li>Build the \"Hello World\" Zephyr application binary and place the built outputs in an \"agilex5\" directory in the current active directory.</li> </ul> <pre><code>cd $TOP_FOLDER/zephyrproject/zephyr\nwest build -b intel_socfpga_agilex5_socdk samples/hello_world -d agilex5\n</code></pre> <p>Successful build console output should be similar to the following:</p> <pre><code>Zephyr version: 3.4.0 (/home/msangele/Artifacts/zephyr_samples/agilex5_zgsrd/zephyrproject/zephyr), build: f1571bf6e7e2\n[134/144] Linking C executable zephyr/zephyr_pre0.elf\n\n[138/144] Linking C executable zephyr/zephyr_pre1.elf\n\n[144/144] Linking C executable zephyr/zephyr.elf\nMemory region         Used Size  Region Size  %age Used\n           FLASH:          0 GB         0 GB\n             RAM:      134048 B         8 MB      1.60%\n        IDT_LIST:          0 GB         2 KB      0.00%\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#organizing-the-build-from-source-binaries","title":"Organizing the Build-From-Source Binaries","text":"<ul> <li>Create a folder to contain the ATF firmware and Zephyr RTOS binaries for creating boot source image, and create symlinks to the actual location. (Whenever you are switching from using prebuilt to build-from-source binaries, this step has to be performed)</li> </ul> <pre><code>cd $TOP_FOLDER\n# First, remove any obsolete bin folder(optional)\nrm -rf bin\nmkdir bin\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/ bin/atf\nln -s $TOP_FOLDER/zephyrproject/zephyr/agilex5/zephyr/  bin/zephyr\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#creating-boot-images","title":"Creating Boot Images","text":"<p>Three types of boot devices are supported:</p> <ol> <li>SD Card</li> <li>NAND Flash</li> <li>QSPI Flash</li> </ol>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#sd-card-image-binaries","title":"SD Card Image binaries","text":"<ul> <li>Create FIP(Firmware Image Package) binary. This will pack the Zephyr binary and ATF BL31 binary into one single binary called FIP binary.</li> </ul> <pre><code>./fiptool create --soc-fw $TOP_FOLDER/bin/atf/bl31.bin  --nt-fw $TOP_FOLDER/bin/zephyr/zephyr.bin bin/fip.bin\n</code></pre> <p>To build the \"SDCard Image\" for simics use the following commands:</p> <ul> <li>Obtain the make_sdimage.sh script.</li> </ul> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/sdmmc_boot/make_sdimage.sh\nchmod +x make_sdimage.sh\n</code></pre> <ul> <li>Create the sdimage.img</li> </ul> <pre><code>touch dummy.tar.gz\nsudo ./make_sdimage.sh -k dummy.tar.gz -p bin/fip.bin -o bin/sdimage.img -g 2G -pg 16\n</code></pre> <p>To deactivate the environment when development is done execute:</p> <pre><code>deactivate\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#resulted-files","title":"Resulted Files","text":"<p>After the build is completed successfully the most relevant files are:</p> File Description bl2.bin The FSBL that Simics will launch first bl31.bin The ATF BL31 (similar to legacy SSBL stage) zephyr.bin Zephyr Application/Kernel fip.bin Firmware Image Package sdimage.img Application image <p>If you have not set up Simics Virtual Platform for Agilex\u2122 5, go to Simulation Setup.  For booting on Simics Virtual Platform for Agilex 5, refer Booting from SD Card Image binaries</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#nand-binaries","title":"NAND binaries","text":"<p>To build the \"NAND Image\" for simics use the following commands:</p> <ul> <li>Patch the Arm Trusted Firmware source code to enable nand boot:</li> </ul> <pre><code>cd $TOP_FOLDER/arm-trusted-firmware\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/nand_boot/0001-plat-intel-soc-agilex5-enable-NAND-boot.patch\n</code></pre> <ul> <li>Create alocal branch for nand boot, apply the patch and rebuild ATF:</li> </ul> <pre><code>git branch nand\ngit checkout nand\ngit apply 0001-plat-intel-soc-agilex5-enable-NAND-boot.patch\ngit commit -a -m \"nandboot\"\nARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- make PLAT=agilex5 bl2 bl31 PRELOADED_BL33_BASE=0x80100000 -j$(nproc)\n</code></pre> <ul> <li>Rebuild fip.bin</li> </ul> <pre><code>cd $TOP_FOLDER\n./fiptool create --soc-fw $TOP_FOLDER/bin/atf/bl31.bin  --nt-fw $TOP_FOLDER/bin/zephyr/zephyr.bin bin/fip.bin\n</code></pre> <ul> <li>Create the nand_mem.img image and write the fip.bin within:</li> </ul> <pre><code>dd if=/dev/zero count=8 bs=16MB | tr '\\0' '\\377' &gt; $TOP_FOLDER/bin/nand_mem.img dd if=bin/fip.bin of=bin/nand_mem.img conv=notrunc bs=1 seek=2097152\n</code></pre> <p>To deactivate the environment when development is done and return to the main branch execute:</p> <pre><code>deactivate\ngit checkout test\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#resulted-files_1","title":"Resulted Files","text":"<p>After the build is completed successfully the most relevant files are:</p> File Description bl2.bin The FSBL that Simics will launch first bl31.bin The ATF BL31 (similar to legacy SSBL stage) zephyr.bin Zephyr Application/Kernel fip.bin Firmware Image Package nand_mem.img NAND Application image <p>If you have not set up Simics Virtual Platform for Agilex 5, go to Simulation Setup.  For booting on Simics Virtual Platform for Agilex 5, refer Booting from NAND binaries</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#qspi-binaries","title":"QSPI binaries","text":"<p>To build the \"QSPI Image\" for simics use the following commands:</p> <ul> <li>Patch the Arm Trusted Firmware source code to enable qspi boot:</li> </ul> <pre><code>cd $TOP_FOLDER/arm-trusted-firmware\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/qspi_boot/0001-plat-intel-soc-agilex5-enable-QSPI-boot.patch\n</code></pre> <ul> <li>Create a local branch for qspi boot, apply the patch and rebuild ATF:</li> </ul> <pre><code>cd $TOP_FOLDER/arm-trusted-firmware\ngit branch qspi\ngit checkout qspi\ngit apply 0001-plat-intel-soc-agilex5-enable-QSPI-boot.patch\ngit commit -a -m \"qspiboot\"\nARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- make PLAT=agilex5 bl2 bl31 PRELOADED_BL33_BASE=0x80100000 -j$(nproc)\n</code></pre> <ul> <li>Rebuild fip.bin</li> </ul> <pre><code>cd $TOP_FOLDER\n./fiptool create --soc-fw $TOP_FOLDER/bin/atf/bl31.bin  --nt-fw $TOP_FOLDER/bin/zephyr/zephyr.bin bin/fip.bin\n</code></pre> <ul> <li>Create pfg file: <pre><code>tee qspi_flash_image_agilex5_boot.pfg  &lt;&lt; 'EOF'\n&lt;pfg version=\"1\"&gt;\n  &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n  &lt;output_files&gt;\n      &lt;output_file name=\"flash_image\" directory=\".\" type=\"JIC\"&gt;\n          &lt;file_options/&gt;\n          &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n              &lt;file_options/&gt;\n          &lt;/secondary_file&gt;\n          &lt;secondary_file type=\"SEC_RPD\" name=\"flash_image_jic\"&gt;\n              &lt;file_options bitswap=\"1\"/&gt;\n          &lt;/secondary_file&gt;\n          &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n      &lt;/output_file&gt;\n  &lt;/output_files&gt;\n  &lt;bitstreams&gt;\n      &lt;bitstream id=\"Bitstream_1\"&gt;\n          &lt;path hps_path=\"bin/atf/bl2.hex\"&gt;bin/agilex5_factory.sof&lt;/path&gt;\n      &lt;/bitstream&gt;\n  &lt;/bitstreams&gt;\n  &lt;raw_files&gt;\n      &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;bin/fip.bin&lt;/raw_file&gt;\n  &lt;/raw_files&gt;\n  &lt;flash_devices&gt;\n      &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n          &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n          &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03C00000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"fip\" size=\"0\"/&gt;\n      &lt;/flash_device&gt;\n      &lt;flash_loader&gt;AGFB014R24B2E2V&lt;/flash_loader&gt;\n  &lt;/flash_devices&gt;\n  &lt;assignments&gt;\n      &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n          &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n      &lt;/assignment&gt;\n      &lt;assignment page=\"0\" partition_id=\"fip\"&gt;\n          &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n      &lt;/assignment&gt;\n  &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n</code></pre></li> </ul> <ul> <li>Create bl2.hex from bl2.bin</li> </ul> <pre><code>aarch64-none-linux-gnu-objcopy -v -I binary -O ihex --change-addresses 0xffe00000 bin/atf/bl2.bin  bin/atf/bl2.hex\n</code></pre> <ul> <li>Create flash_image_jic.rpd qspi image from fip.bin and *bl2.hex:</li> </ul> <pre><code>wget  https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/qspi_boot/agilex5_factory.sof -O bin/agilex5_factory.sof\n# The next command assumes Quartus\u00ae Prime Pro Edition Programmer and Tools is installed in the path ~/intelFPGA_pro/ (tested version: 23.4)\n~/intelFPGA_pro/23.4/qprogrammer/quartus/bin/quartus_pfg -c qspi_flash_image_agilex5_boot.pfg\nmv flash* bin\n</code></pre> <p>To deactivate the environment when development is done and return to the main branch execute:</p> <pre><code>deactivate\ngit checkout test\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#resulted-files_2","title":"Resulted Files","text":"<p>After the build is completed successfully the most relevant files are:</p> File Description bl2.bin The FSBL that Simics will launch first bl2.hex The FSBL in hex format bl31.bin The ATF BL31 (similar to legacy SSBL stage) zephyr.bin Zephyr Application/Kernel fip.bin Firmware Image Package flash_image_jic.rpd QSPI Application image <p>If you have not set up Simics Virtual Platform for Agilex 5, go to Simulation Setup. </p> <p>For booting on Simics Virtual Platform for Agilex 5, refer Booting from QSPI binaries</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#simulation-setup","title":"Simulation Setup","text":"<p>We assume that the Simics\u00ae Simulator for Intel\u00ae FPGAs Simulator has been installed in a Linux System.</p> <ul> <li>Lets add the Simics binary to the path to make things easier:</li> </ul> <p><pre><code>export PATH=$PATH:SIMICS_INSTALLATION/simics/bin/\n</code></pre> note: default path is \"~/intelFPGA_pro/intel-fpga-ext_23.4/simics/bin\"</p> <ul> <li>Create a Simics project directory under ZephyrGSRD directory:</li> </ul> <pre><code>cd $TOP_FOLDER\nrm -r project-1\nmkdir project-1\ncd project-1\n</code></pre> <p>Under the new project directory created, deploy the agilex5e-universal virtual platform:</p> <pre><code>simics_intelfpga_cli --deploy agilex5e-universal\n</code></pre> <p>The above will produce the following: <pre><code>Simics(R) Simulator for Intel(R) FPGA CLI:\nINFO: Preparing to initialize /home/simicsUser/SimicsInstallDir/project-1 as a\nSimics workspace\nProject created successfully\n# Observe that the directory has been initialized and the simics and simics-gui\n# commands appears in the project directory. Also the target directory is\n# created. This includes the target script corresponding to the deployed\n# platform.\n</code></pre></p> <ul> <li>Build the virtual platform components:</li> </ul> <pre><code>make\n</code></pre> <p>Example of console output:</p> <pre><code>=== Environment Check ===\n'/home/simicsUser/SimicsInstallDir/project-1' is up-to date\ngcc version 9\n=== Building module agilex5e-universal-board-comp ===\n.\n:\n=== Building module agilex5e-universal-fpga-comp ===\n.\n:\n=== Building module agilex5e-universal-system-comp ===\n.\n:\n</code></pre> <p>Note: You only have to setup the Agilex 5 Virtual Platform once (or until it has been remove)</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#booting-on-simics-virtual-platform-for-agilex-5","title":"Booting On Simics Virtual Platform for Agilex 5","text":"<p>We assume that the following binaries are already available (either from the Prebuilt Binaries package or built from the steps in Build Instructions) :    * bl2.bin    * bl31.bin    * zephyr.bin    * sdimage.img /nand_mem.img / flash_image_jic.rpd</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#booting-from-sd-card-image-binaries","title":"Booting from SD Card Image binaries","text":"<ul> <li> <p>Zephyr's SMP support allow us to select the boot core within simics. Select the boot core as follows:</p> Core Selection Env-variable A55 export cputype=a55 A76 export cputype=a76 </li> </ul> <ul> <li>You will need a Simics script named zephyr.simics with the contents detailed in Key points for Zephyr. Run the following to create the script:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\ncputypestring=\"\"\nif [ $cputype = \"a76\" ]; then\ncputypestring='$hps_boot_core = 2 \n$hps_core0_1_power_on = TRUE \n$hps_core2_power_on = TRUE \n$hps_core3_power_on = TRUE'\nfi;\ntee zephyr.simics &lt;&lt; 'EOF'\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\nlocal $board_name = \"system.board.fpga\"\n# Ensure the sdimage.img &amp; bl2.bin paths are relative to the simics executable#\n# Enable Console\n$create_hps_serial0_console=TRUE\n# Boot from SD Card\n$create_hps_sd_card=TRUE\n$create_hps_mmc=FALSE\n# SD Card boot Image file path\n$sd_image_filename = ../bin/sdimage.img\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\nEOF\necho \"$cputypestring\" &gt;&gt; zephyr.simics echo 'run-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\nrun' &gt;&gt; zephyr.simics </code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#booting-from-nand-binaries","title":"Booting from NAND binaries","text":"<ul> <li> <p>Zephyr's SMP support allow us to select the boot core within simics. Select the boot core by as follows:</p> Core Selection Env-variable A55 export cputype=a55 A76 export cputype=a76 </li> </ul> <ul> <li>You will need a Simics script modified for NAND named zephyr.simics. This will take Key points for Zephyr as base. Run the following to create the script:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\ncputypestring=\"\"\nif [ $cputype = \"a76\" ]; then\ncputypestring='$hps_boot_core = 2 \n$hps_core0_1_power_on = TRUE \n$hps_core2_power_on = TRUE \n$hps_core3_power_on = TRUE '\nfi;\ntee zephyr.simics &lt;&lt; 'EOF'\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\nlocal $board_name = \"system.board.fpga\"\n# Ensure the nand_mem.img &amp; bl2.bin paths are relative to the simics executable\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\n#Boot from NAND\n$nand_data_image_filename = ../bin/nand_mem.img \n# Enable Console\n$create_hps_serial0_console=TRUE\nEOF\necho \"$cputypestring\" &gt;&gt; zephyr.simics echo 'run-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\nrun' &gt;&gt; zephyr.simics </code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#booting-from-qspi-binaries","title":"Booting from QSPI binaries","text":"<ul> <li> <p>Zephyr's SMP support allow us to select the boot core within simics. Select the boot core as follows:</p> Core Selection Env-variable A55 export cputype=a55 A76 export cputype=a76 </li> </ul> <ul> <li>You will need a Simics script modified for QSPI named zephyr.simics. This will take Key points for Zephyr as base. Run the following to create the script:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\ncputypestring=\"\"\nif [ $cputype = \"a76\" ]; then\ncputypestring='$hps_boot_core = 2 \n$hps_core0_1_power_on = TRUE \n$hps_core2_power_on = TRUE \n$hps_core3_power_on = TRUE '\nfi;\ntee zephyr.simics &lt;&lt; 'EOF'\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\nlocal $board_name = \"system.board.fpga\"\n# Ensure the nand_mem.img &amp; bl2.bin paths are relative to the simics executable\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\n#Boot from QSPI\n$qspi_image_filename = ../bin/flash_image_jic.rpd  \n# Enable Console\n$create_hps_serial0_console=TRUE \nEOF\necho \"$cputypestring\" &gt;&gt; zephyr.simics echo 'run-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\nrun' &gt;&gt; zephyr.simics </code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#running-hello-world","title":"Running Hello World!","text":"<p>To exercise this use case, follow the next steps once the Simulation setup has been completed:</p> <ul> <li>From the project directory, launch the simulation using the zephyr.simics target script. This will launch the simulator and the current terminal will become the Simics CLI:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\n./simics zephyr.simics\n</code></pre> <ol> <li>Wait to get \"Hello World!\" message in the target serial console.</li> </ol> <pre><code># Target Serial console&lt;/b&gt;\nNOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):f0d41e37d\nNOTICE:  BL2: Built : 08:55:04, Nov 17 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):f0d41e37d\nNOTICE:  BL31: Built : 08:55:08, Nov 17 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x0) is up\nSecondary CPU core 2 (MPID:0x100) is up\nSecondary CPU core 3 (MPID:0x300) is up\nHello World! intel_socfpga_agilex5_socdk\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#use-cases","title":"Use Cases","text":"<p>The following sections provide instructions on how to exercise some supported use cases through cli using the Intel Agilex\u00ae 5 E-Series Universal virtual platform. The compatible sample for Agilex\u2122 5 can be found at:</p> <ul> <li>{zephyrfolder}/samples/boards/intel_socfpga/cli</li> </ul> <p>The preconditions required to execute them are listed in the following section. To use the application built following the Build Instructions, jump to Simulation_Setup.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#running-zephyr-command-line-application","title":"Running Zephyr Command Line Application","text":"<p>To demonstrate the use of some Zephyr peripherals/zephyr subsystems it supports commands like:</p> <ul> <li>device: Device commands</li> <li>flash: Flash shell commands</li> <li>fs: File system commands</li> <li>gpio: GPIO commands</li> <li>i2c: I2C commands</li> <li>io96b: IO96B information</li> <li>mailbox: Altera SoC FPGA SDM mailbox client commands</li> <li>mdio: MDIO commands</li> <li>net: Networking commands</li> <li>psci: ARM PSCI interface commands</li> <li>sip_svc: ARM SiP services commands</li> <li>spi: spi commands</li> <li>timer: Timer commands</li> <li>i3c: I3C commands</li> </ul>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#cli-application-prebuilt-binaries","title":"CLI application - Prebuilt binaries","text":"<p>Note: The following steps assume you have followed the instructions in Setting Up to Use Prebuilt Binaries</p> <ul> <li>Select the sample based on app and boot device (e.g. nand):</li> </ul> <pre><code>export app=cli\nexport bootdev=sdmmc_boot bootimg=sdimage.img\n</code></pre> <ul> <li>Obtain the prebuilt binaries for the CLI sample app</li> </ul> <pre><code>cd $TOP_FOLDER/prebuilt\nwget -N https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/$app/$bootdev/$bootimg -P $app/$bootdev/ wget -N https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/$app/$bootdev/bl2.bin -P $app/$bootdev/\n</code></pre> <ul> <li>Prepare the binaries to run on Simics\u00ae Simulator</li> </ul> <pre><code>cd $TOP_FOLDER\nrm -rf bin\nmkdir -p bin/atf\nln -s $TOP_FOLDER/prebuilt/$app/$bootdev/$bootimg bin/ ln -s $TOP_FOLDER/prebuilt/$app/$bootdev/bl2.bin bin/atf/bl2.bin\n</code></pre> <p>To run the application, go to the section CLI application - Run</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#cli-application-build-from-source","title":"CLI application - Build-from-source","text":"<p>There is a sample specially made for Agilex\u2122 E-Series that can be found at samples/boards/intel_socfpga/cli/ within the Zephyr folder. The following  instructions show how to build and run:</p> <pre><code>cd $TOP_FOLDER/zephyrproject/zephyr/\nwest build -b intel_socfpga_agilex5_socdk samples/boards/intel_socfpga/cli/ -d agilex5 #If you need to overwrite a previous build you need to add the --pristine flag as follows.\n#west build -b intel_socfpga_agilex5_socdk samples/boards/intel_socfpga/cli/ -d agilex5 --pristine\ncd $TOP_FOLDER\n</code></pre> <p>A. if you were using prebuilt binaries before this, perform this step: Organizing the Build-From-Source Binaries.</p> <p>As the Zephyr application has been changed, you'll to create the bootable image according to the boot device you desire. Refer to Creating Boot Images</p> <p>Run the application following CLI_application - Run.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#cli-application-run","title":"CLI application - Run","text":"<p>Once this sample is ready, you can run it in the same way as the 'hello world' sample, as follows:</p> <pre><code>cd $TOP_FOLDER/project-1\n./simics zephyr.simics\n</code></pre> <p>The following output and agilex5$ prompt will appear:</p> <pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):f0d41e37d\nNOTICE:  BL2: Built : 08:55:04, Nov 17 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):f0d41e37d\nNOTICE:  BL31: Built : 08:55:08, Nov 17 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\n\nagilex5$ Secondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nintel_socfpga_agilex5_socdk: Starting Command Line Interface...\nEnumeration started\nUSB enumeration success\n\nagilex5$\n</code></pre> <p>At this point you can use the interactive command line and execute the following commands: - help -&gt; Show all the available commands\\ - fs -&gt; To interact with file system for storage devices - gpio -&gt; To interact with the gpio ports - i2c -&gt; To send and receive data from the i2c ports - timer -&gt; To interact with the timer interrupts.</p> <pre><code>agilex5$ help\nYou can try to call commands with &lt;-h&gt; or &lt;--help&gt; parameter for more information.\n\nAvailable commands:\n  device   :Device commands\n  edac     :EDAC information\n  flash    :Flash shell commands\n  fs       :File system commands\n  gpio     :GPIO commands\n  help     :Prints the help message.\n  i2c      :I2C commands\n  i3c      :I3C commands\n  mailbox  :Intel SoC FPGA SDM mailbox client commands\n  mdio     :MDIO commands\n  net      :Networking commands\n  psci     :ARM PSCI interface commands\n  sip_svc  :ARM SiP services commands\n  spi      :spi commands\n  timer    :Timer commands\nagilex5$\n</code></pre> <p>Let's execute blink through the gpio command to demonstrate the usage of the CLI(Command line interface):</p> <pre><code>agilex5$ gpio help\ngpio - GPIO commands\nSubcommands:\n  conf   :Configure GPIO: conf &lt;gpio_node_id&gt; &lt;pin&gt; &lt;mode(in/out)&gt;\n  get    :Get GPIO value: get &lt;gpio_node_id&gt; &lt;pin&gt;\n  set    :Set GPIO: set &lt;gpio_node_id&gt; &lt;pin&gt; &lt;value(0/1)&gt;\n  blink  :Blink GPIO: blink &lt;gpio_node_id&gt; &lt;pin&gt;\nagilex5$ gpio conf gpio@10c03300  5 out\nConfiguring gpio@10c03300 pin 5\nagilex5$ gpio blink  gpio@10c03300  5  \nBlinking port gpio@10c03300 pin 5. Hit any key to exit\nagilex5$\n</code></pre> <p>Note: GPIO port gpio@10c03200 pins 0 to 10 are used for sdcard boot and should not be used for other purposes.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#using-i3c","title":"Using I3C","text":"<p>This use case is an extension to the CLI application. The CLI prebuilt or build from source binary can be used directly for this use case.</p> <p>The Zephyr driver enabled 2 I3C devices and 1 I2C device of the modeled board components and attached to the I3C master's bus. To test the I3C read and write operation to a device, set the inverted_loopback parameter to TRUE. This may be done in the zephyr.simics script.</p> <p>Note: </p> <ol> <li>The 2 I3C device enabled have the PIDs 0xFB1122330001 and 0xFB1122330002. You'll have to enable inverted_loopback for the desired devices to read-back the write operation.<ul> <li>Device #1: system.board.i3c0_device1.target-&gt;inverted_loopback=TRUE</li> <li>Device #2: system.board.i3c0_device2.target-&gt;inverted_loopback=TRUE</li> </ul> </li> <li>The 1 I2C device has the address 0x50.</li> <li>The read-back values are inverted(by NOT bit-wise operation) at byte level. (E.g. write 0xAF -&gt; read returns 0x50).</li> <li>For the first usage, the read FIFO will contain a 1-byte value of 0xF0 due to initialization (this is not a driver issue but the device model behaviour). Reads will flush the FIFO.</li> <li>When the FIFO is empty, a read-back will have a default 1-byte value of 0xA5. Data after the 1st byte are random constant value.</li> </ol> <ul> <li>For more details, refer to Intel Agilex\u00ae 5 E-Series Virtual Platform User Guide - I3C Device</li> </ul> <p>Enable the (inverted)loopback in target simics script.</p> <pre><code>cd $TOP_FOLDER/project-1\nsed -i '/^run$/i system.board.i3c0_device1.target-&gt;inverted_loopback=TRUE \\\nsystem.board.i3c0_device2.target-&gt;inverted_loopback=TRUE' zephyr.simics\n</code></pre> <p>If everything was done correctly we can execute \"i3c\" commands after running ./simics zephyr.simics as shown below:</p> <ul> <li>Perform a dummy i3c read for the first use after boot. This is to clear the data in the RX fifo resulting from CCC operation during driver initialization. The output seen will be 0xf0.</li> </ul> <pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):f0d41e37d\nNOTICE:  BL2: Built : 08:55:04, Nov 17 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):f0d41e37d\nNOTICE:  BL31: Built : 08:55:08, Nov 17 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\n\nagilex5$ Secondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nintel_socfpga_agilex5_socdk: Starting Command Line Interface...\nEnumeration started\nUSB enumeration success\n\nagilex5$ %BLUE%i3c read i3c@10DA0000 0xfb11 0x22330001 0x1%ENDCOLOR%\n\nRead 1 bytes from i3c device with address (9)\n\n00000000: f0                                               |.                |\n</code></pre> <ul> <li>Perform i3c commands for write and read test to I3C device.</li> </ul> <pre><code>agilex5$ i3c write i3c@10DA0000 0xfb11 0x22330001 0xf0 0xca 0x14 0x52\nTo be Written data[0]: f0\nTo be Written data[1]: ca\nTo be Written data[2]: 14\nTo be Written data[3]: 52\nWrote 4 bytes: Device Dynamic address (9)\nagilex5$ i3c read i3c@10DA0000 0xfb11 0x22330001 0x4             \n\nRead 4 bytes from i3c device with address (9)\n\n00000000: 0f 35 eb ad                                      |.5..             |\n</code></pre> <ul> <li>Perform i3c commands for write and read test to I2C device.</li> </ul> <pre><code>agilex5$ i3c i2c_write i3c@10DA0000 0x50 0x08 0xb0 0x55 0xca 0xfe   \nagilex5$ i3c i2c_read i3c@10DA0000 0x50 0x08 0x4                    \n00000000: b0 55 ca fe                                      |.U..             |\nagilex5$ \n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#using-usb-20","title":"Using USB 2.0","text":"<p>To test file operations We can load the USB 2.0 device model: \"usb-msd.craff\" in Simics.</p> <ul> <li>Download the USB2.0 model:</li> </ul> <pre><code>cd $TOP_FOLDER/project-1\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/usb-msd.craff\n</code></pre> <p>Then we need to modify our current zephyr.simics script to provide: $usb_otg_image_filename parameter as follows:</p> <pre><code>cd $TOP_FOLDER/project-1\nsed -i '1i$usb_otg_image_filename = \"usb-msd.craff\"' zephyr.simics\n</code></pre> <p>If  everything was done correctly we can execute \"fs\" commands after running =./simics zephyr.simics= as shown below: <pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  QSPI boot\nNOTICE:  BL2: v2.9.1(release):6e6d72e35\nNOTICE:  BL2: Built : 08:50:06, Nov 17 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 800\nNOTICE:  BL31: CPU ID = 81000200\nNOTICE:  BL31: v2.9.1(release):f0d41e37d\nNOTICE:  BL31: Built : 08:55:08, Nov 17 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\n\nagilex5$ Secondary CPU core 1 (MPID:0x0) is up\nSecondary CPU core 2 (MPID:0x100) is up\nSecondary CPU core 3 (MPID:0x300) is up\nintel_socfpga_agilex5_socdk: Starting Command Line Interface...\nEnumeration started\nUSB enumeration success\n\nagilex5$ fs mount fat /USB2: \nSuccessfully mounted fat fs:/USB2:\nagilex5$ fs ls USB2:/ \nagilex5$ fs write USB2:/cafe.txt 0C 0A 0F 0F 0E\nSuccessfully written 5 bytes\nagilex5$ fs read USB2:/cafe.txt                \nFile size: 5\n00000000  0C 0A 0F 0F 0E                                   \u2026..\nSuccessfully read 5 bytes\nagilex5$ fs ls USB2:/ \n      CAFE.TXT  size: 5          bytes\nagilex5$\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#exercising-zephyr-on-a-single-core","title":"Exercising Zephyr on a single core.","text":"<p>By default, SMP is enabled in Zephyr, and all the cores will be up and running. However, the user may choose the specific core on which the Zephyr application should run on a single core. This can be accomplished as follows:</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#prebuilt-binaries-for-a55-and-a76","title":"Prebuilt Binaries for A55 and A76","text":"<p>To execute the binaries prebuilt for A76, change the \"cputype\" in the steps for Organizing the Prebuilt Binaries or CLI application - Prebuilt binaries</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#build-the-zephyr-application","title":"Build the Zephyr Application","text":"<p>The default build configuration targets the A55 core. The following steps will guide you in rebuilding the \"Hello World\" application for A76. It's assumed you have already followed the Build Instructions with default settings.</p> <ul> <li>Load the profile and activate the python virtual environment</li> </ul> <pre><code>source  $TOP_FOLDER/.zephyrrc\nsource ~/.zephyrproject/.venv/bin/activate \n</code></pre> <ul> <li>Pick either core0(a55) or core2(a76):</li> </ul> Core Selection Env-variable A55 export cputype=a55 A76 export cputype=a76 <ul> <li>For demonstration purposes, we will create a new local branch so that we can revert to the default SMP configurations:</li> </ul> <pre><code>cd $TOP_FOLDER/zephyrproject/zephyr\ngit checkout QPDS23.4_REL_GSRD_PR\ngit branch nosmp_$cputype\ngit checkout nosmp_$cputype\n</code></pre> <ul> <li>Modify the file in $TOP_FOLDER/zephyrproject/zephyr/dts/arm64/intel/intel_socfpga_agilex5.dtsi, to remove the rest of the cores:</li> </ul> <pre><code>if [ $cputype = \"a55\" ]; then\nsed -i '27,46d' dts/arm64/intel/intel_socfpga_agilex5.dtsi;\nelse\nsed -i '20,32d' dts/arm64/intel/intel_socfpga_agilex5.dtsi;\nsed -i '28,33d' dts/arm64/intel/intel_socfpga_agilex5.dtsi;\nfi;\n</code></pre> <p>For reference, the device tree should look like this:</p> <p>A55: <pre><code>13: #include &lt;zephyr/dt-bindings/gpio/gpio.h&gt;\n14: \n15: / {\n16:     cpus {\n17:         #address-cells = &lt;1&gt;;\n18:         #size-cells = &lt;0&gt;;\n19: \n20:         cpu@0 {\n21:             device_type = \"cpu\";\n22:             compatible = \"arm,cortex-a55\";\n23:             enable-method = \"psci\";\n24:             reg = &lt;0&gt;;\n25:         };\n26:     };\n};\n</code></pre></p> <p>A76: <pre><code>14: \n15: / {\n16:     cpus {\n17:         #address-cells = &lt;1&gt;;\n18:         #size-cells = &lt;0&gt;;\n19: \n20: \n21:         cpu@200 {\n22:             device_type = \"cpu\";\n23:             compatible = \"arm,cortex-a76\";\n24:             enable-method = \"psci\";\n25:             reg = &lt;0&gt;;\n26:         };\n27: \n28:     };\n};\n</code></pre> Remove CONFIG_SMP=y and CONFIG_MP_MAX_NUM_CPUS=4 within intel_socfpga_agilex5_socdk_defconfig:</p> <pre><code>sed -i '/CONFIG_SMP/d' boards/arm64/intel_socfpga_agilex5_socdk/intel_socfpga_agilex5_socdk_defconfig\nsed -i '/CONFIG_MP_MAX_NUM_CPUS/d' boards/arm64/intel_socfpga_agilex5_socdk/intel_socfpga_agilex5_socdk_defconfig\ngit commit -a -m \"smpremove_$cputype\"\n</code></pre> <ul> <li>Re-build the \"Hello World\" sample.</li> </ul> <pre><code>west build -b intel_socfpga_agilex5_socdk samples/hello_world -d agilex5 --pristine\n</code></pre> <ul> <li> <p>Prepare the binaries to run on Simics\u00ae Simulator</p> <p>a. Remove obsolete folder and create the new fip binary.</p> </li> </ul> <pre><code>cd $TOP_FOLDER\nrm -rf bin\nmkdir bin\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/ bin/atf\nln -s $TOP_FOLDER/zephyrproject/zephyr/agilex5/zephyr/  bin/zephyr\n./fiptool create --soc-fw $TOP_FOLDER/bin/atf/bl31.bin  --nt-fw $TOP_FOLDER/bin/zephyr/zephyr.bin bin/fip.bin\n</code></pre> <p>To create the boot image, we will use the creating SD Card Image binaries section as base. Refer back to Creating Boot Images to boot from other boot devices.</p> <ul> <li>Obtain the make_sdimage.sh script.</li> </ul> <pre><code>cd $TOP_FOLDER\nwget https://releases.rocketboards.org/2023.12/zephyr/gsrd_zephyr/agilex5/cli/sdmmc_boot/make_sdimage.sh\nchmod +x make_sdimage.sh\n</code></pre> <ul> <li>Create the sdimage.img</li> </ul> <pre><code>touch dummy.tar.gz\nsudo ./make_sdimage.sh -k dummy.tar.gz -p bin/fip.bin -o bin/sdimage.img -g 2G -pg 16&lt;/pre&gt;\n</code></pre> <p>Note: To return to QPDS23.4_REL_GSRD_PR tag execute:</p> <pre><code>cd $TOP_FOLDER/zephyrproject/zephyr\ngit checkout QPDS23.4_REL_GSRD_PR\ncd $TOP_FOLDER\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#simulation-setup_1","title":"Simulation Setup","text":"<p>It is assumed you have executed the steps at least once in Simulation Setup with default settings.</p> <ul> <li>Lets add the Simics binary to the path to make things easier:</li> </ul> <pre><code>export PATH=$PATH:&amp;ltSimics installation dir&amp;gt/simics/bin/\n</code></pre> <ul> <li>Configure the Simics top-level target script to run on a single core by adding the following parameters before the run-command-file command:</li> </ul> <p>A55:</p> <pre><code>$hps_core0_power_on = TRUE \n$hps_core1_power_on = FALSE \n$hps_core2_power_on = FALSE \n$hps_core3_power_on = FALSE\n</code></pre> <p>A76:</p> <pre><code>$hps_boot_core = 2 \n$hps_core0_1_power_on = FALSE \n$hps_core2_power_on = TRUE \n$hps_core3_power_on = FALSE\n</code></pre> <p>This can be achieved by executing the following command:</p> <pre><code>cd $TOP_FOLDER/project-1\ncputypestring=\"\"\nif [ $cputype = \"a55\" ]; then\ncputypestring='$hps_boot_core = 0 \n$hps_core0_power_on = TRUE \n$hps_core1_power_on = FALSE \n$hps_core2_power_on = FALSE \n$hps_core3_power_on = FALSE'\nelse\ncputypestring='$hps_boot_core = 2 \n   $hps_core0_1_power_on = FALSE \n   $hps_core2_power_on = TRUE \n   $hps_core3_power_on = FALSE'\nfi;\ntee zephyr.simics &lt;&lt; 'EOF'\n# TOP-LEVEL CONFIG Script TO BOOT ZEPHYR.\nlocal $board_name = \"system.board.fpga\"\n# Ensure the sdimage.img &amp; bl2.bin paths are relative to the simics executable#\n# Enable Console\n$create_hps_serial0_console=TRUE\n# Boot from SD Card\n$create_hps_sd_card=TRUE\n$create_hps_mmc=FALSE\n# SD Card boot Image file path\n$sd_image_filename = ../bin/sdimage.img\n# First stage boot loader, ATF BL2 path\n$fsbl_image_filename = ../bin/atf/bl2.bin\nEOF\necho \"$cputypestring\" &gt;&gt; zephyr.simics echo 'run-command-file \"targets/agilex5e-universal/agilex5e-universal.simics\"\nrun' &gt;&gt; zephyr.simics\n</code></pre> <p>Note: We based our approach on the SDCard script. For NAND boot and QSPI options, refer to Booting from NAND binaries and Booting from QSPI binaries.</p>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#running-hello-world_1","title":"Running Hello World","text":"<ul> <li>Run the hello world example:</li> </ul> <pre><code>./simics zephyr.simics\n</code></pre> <ul> <li>Wait to get \"Hello World!\" message in the target serial console.</li> </ul> <pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 19:41:32, Dec 18 2023\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 800\nNOTICE:  BL31: CPU ID = 81000200\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 19:41:33, Dec 18 2023\n*** Booting Zephyr OS build 33d4a115fbed ***\nHello World! intel_socfpga_agilex5_socdk\n</code></pre>"},{"location":"embedded-designs/agilex-5/common/virtual-platforms/zephyr-gsrd/ug-zephyr-gsrd-agilex5-virtual-platforms/#configuration-reference","title":"Configuration Reference","text":"<p>You may rebuild and run on Simics for the target core based on the following configuration:</p> Config file A55 A76 $TOP_FOLDER/zephyrproject/zephyr/dts/arm64/intel/intel_socfpga_agilex5.dtsi At node cpu@0 : compatible = \"arm,cortex-a75\"  reg = At node cpu@0 :  compatible = \"arm,cortex-a76\" reg = $TOP_FOLDER/project-1/zephyr.simics $hps_boot_core = 0 $hps_boot_core = 2"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/","title":"Agilex 5 E-Series Modular Development Kit GHRD Linux Boot Examples","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#overview","title":"Overview","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The following scenarios are covered:</p> <ul> <li>Boot from SD Card</li> <li>Boot from QSPI</li> </ul> <p>The instructions on this page are based on the GSRD.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Modular Development Kit GSRD:</p> <ul> <li>Altera Agilex 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Intel Quartus Prime Pro Edition version, version 24.2. Used to compile the hardware design, generate programming files and configure the board.</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#component-versions","title":"Component Versions","text":"<p>The instructions on this page use the following component versions:</p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.2_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.22-lts QPDS24.2_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.10.1 QPDS24.2_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.01 QPDS24.2_REL_GSRD_PR Yocto Project: poky https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap QPDS24.2_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#development-kit","title":"Development Kit","text":"<p>Refer to Development Kit for details about the board, including how to install the HPS Boards, and how to set MSEL dispswitches.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#release-notes","title":"Release Notes","text":"<p>Refer to Release Notes for release information.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#boot-from-sd-card","title":"Boot from SD Card","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from SD card.</p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf bootloader.modular\nmkdir bootloader.modular\ncd bootloader.modular\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake BOARD_TYPE=DK-MODULAR DEVICE=A5ED065BB32AE6SR0 DAUGHTER_CARD=mod_som HPS_EMIF_EN=1 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=150 INITIALIZATION_FIRST=hps generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://win32diskimager.org/. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/boot-examples/ug-linux-boot-agx5e-modular/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section demonstrates how to build Linux system from separate components, which boots from QSPI.</p> <p>This section presents how to build the binaries and boot from QSPI with the HPS Enablement Board. While the example is based on the GSRD, it contains the following differences:</p> <ul> <li>U-Boot tries to boot only from QSPI flash, does not try SD card</li> <li>U-Boot does not use a script to boot, instead it used the <code>BOOTCMD</code> environment variable directly</li> <li>kernel.itb file contains only one set of core.rbf, kernel and device tree files, targeted for this scenario</li> </ul> <p>1. Prepare the top folder</p> <pre><code>rm -rf $TOP_FOLDER/qspi-boot\nmkdir $TOP_FOLDER/qspi-boot\n</code></pre> <p>2. Build U-Boot:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from QSPI\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# mtd info\nCONFIG_MTDIDS_DEFAULT=\"nor0=nor0\"\nCONFIG_MTDPARTS_DEFAULT=\"mtdparts=nor0:66m(u-boot),190m(root)\"\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# do not keep env on sd card\nCONFIG_ENV_IS_IN_FAT=n\n# disable NAND related settings from defconfig\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"mtdparts;ubi part root;ubi readvol \\${loadaddr} kernel;ubi detach;setenv bootargs earlycon panic=-1 ubi.mtd=1 root=ubi0:rootfs rootfstype=ubifs rw rootwait;bootm \\${loadaddr}#board-0;\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build <code>kernel.itb</code> FIT file containing kernel, device tree and fpga fabric configuration file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -f core.rbf devicetree.dtb Image.lzma kernel.its kernel.itb\nln -s ../ghrd.core.rbf core.rbf\nln -s ../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb devicetree.dtb\nxz --format=lzma --extreme -k -c ../linux-socfpga/arch/arm64/boot/Image &gt; Image.lzma\ncat &lt;&lt; EOF &gt; kernel.its\n// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2024 Intel Corporation\n *\n */\n/dts-v1/;\n/ {\n    description = \"FIT image with kernel, DTB and FPGA core binary\";\n    #address-cells = &lt;1&gt;;\n    images {\n        kernel {\n            description = \"Linux Kernel\";\n            data = /incbin/(\"./Image.lzma\");\n            type = \"kernel\";\n            arch = \"arm64\";\n            os = \"linux\";\n            compression = \"lzma\";\n            load = &lt;0x86000000&gt;;\n            entry = &lt;0x86000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fdt-0 {\n            description = \"Device Tree\";\n            data = /incbin/(\"./devicetree.dtb\");\n            type = \"flat_dt\";\n            arch = \"arm64\";\n            compression = \"none\";\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fpga-0 {\n            description = \"FPGA bitstream\";\n            data = /incbin/(\"./core.rbf\");\n            type = \"fpga\";\n            arch = \"arm64\";\n            compression = \"none\";\n            load = &lt;0x8A000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n    };\n    configurations {\n        default = \"board-0\";\n        board-0 {\n            description = \"board_0\";\n            kernel = \"kernel\";\n            fdt = \"fdt-0\";\n            fpga = \"fpga-0\";\n            signature {\n                algo = \"crc32\";\n                key-name-hint = \"dev\";\n                sign-images = \"fdt-0\", \"kernel\", \"fpga-0\";\n            };\n        };\n    };\n};\nEOF\n./u-boot-socfpga/tools/mkimage -f kernel.its kernel.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/kernel.itb</code></li> </ul> <p>4. Create U-Boot binary <code>u-boot.bin</code> with a size of exactly 2MB:</p> <pre><code>cp u-boot-socfpga/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Build the <code>rootfs.ubifs</code> file:</p> <pre><code>rm -rf rootfs rootfs.ubifs\nmkdir rootfs tar -xzvf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz -C rootfs mkfs.ubifs -r rootfs -F -e 65408 -m 1 -c 6500 -o rootfs.ubifs </code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/rootfs.ubifs</code></li> </ul> <p>6. Build the <code>root.ubi</code> file:</p> <pre><code>cat &lt;&lt; EOF &gt; ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nvol_id=1\nvol_name=script\nvol_size=128KiB \nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3    \nvol_name=dtb   \nvol_size=256KiB \nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOF\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/root.ubi</code></li> </ul> <p>7. Build the QSPI flash image:</p> <pre><code>ln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof fpga.sof\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\nln -s root.ubi hps.bin\ncat &lt;&lt; EOF &gt; flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n    &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"UBOOT\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"HPS\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"UBOOT\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash_image.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/flash_image.hps.jic</code></li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <p><pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"qspi-boot/flash_image.hps.jic\"\n</code></pre> Note: You need to wipe the micro SD card or remove it from the board before start running.</p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/","title":"Agilex 5 E-Series Modular Development Kit GSRD User Guide","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#gsrd-overview","title":"GSRD Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex 5 E-Series Modular Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Modular Development Kit GSRD:</p> <ul> <li>Altera Agilex 5 FPGA E-Series 065B Modular Development Kit, ordering code MK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>Power supply</li> <li>2 x Micro USB Cable</li> <li>Ethernet Cable</li> <li>Micro SD card and USB card writer</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Intel Quartus Prime Pro Edition version. Used to recompile the hardware design. If only writing binaris is required, then the smaller Intel Quartus Prime Pro Edition Programmer is sufficient.<ul> <li>The prebuilt binaries were built using Quartus version 24.2</li> <li>The instructions for rebuilding the binaries use Quartus version 24.2</li> </ul> </li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#release-contents","title":"Release Contents","text":"<p>This page documents the following:</p> <ul> <li>24.2 Binary Release - see Exercising Prebuilt Binaries section for release content details</li> <li>24.2 Source Code Release - see Rebuilding the GSRD section for release content details</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#release-notes","title":"Release Notes","text":"<p>See https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#development-kit","title":"Development Kit","text":"<p>This release targets the Agilex 5 FPGA E-Series 065B Modular Development Kit. It is composed of a carrier board which offers additional connectivity, and a SOM board which contains the FPGA part, HPS DDRAM and all other required circuitry. Refer to board documentation for more information about the development kit.</p> <p></p> Changing MSEL <p>MSEL signals instruct the FPGA device on which configuration scheme to use. Configuration schemes used by the scenarios presented in this guide are JTAG and ASx4 (QSPI). MSEL is changed through dipswitch S4 on the top left cornet of the SOM board. Only change the settings while the board is powered off.</p> <p>The MSEL settings are:</p> <ul> <li>JTAG: SW4[2:1]=OFF:OFF</li> <li>ASx4 (QSPI): SW4[2:1]=ON:ON</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Dual core Arm Cortex-A76 processor</li> <li>Dual core Arm Cortex-A55 processor</li> <li>HPS Peripherals<ul> <li>Micro SD Card</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>UART</li> <li>I2C    </li> <li>USB 3.1</li> </ul> </li> </ul> </li> <li>Multi-Ported Front End (MPFE) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>One user LED output</li> <li>Two user DIP switch inputs</li> <li>One user push-button input</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <p> </p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>  MPU Address Maps <p>This section presents the address maps as seen from the MPU side.  </p>  HPS-to-FPGA Address Map <p>The three FPGA windows in the MPU address map provide access to 256 GB of FPGA space. First window is 1 GB from 00_4000_0000, second window is 15 GB from 04_4000_0000, third window is 240 GB from 44_0000_0000. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU, which starts at the lightweight HPS-to-FPGA base address of 0x00_2000_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0001_0000 32 Unique system ID button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs led_pio 0x0001_0080 16 LED outputs JTAG Master Address Map <p>There are three JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface and another for FPGA fabric to SDRAM.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0001_0000 32 Unique system ID button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs led_pio 0x0001_0080 16 LED outputs  Interrupt Routing <p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[1] DIP switch input button_pio f2h_irq0[0] Push button input"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#exercising-prebuilt-binaries","title":"Exercising Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#prebuilt-release-contents","title":"Prebuilt Release Contents","text":"Binaries <p>The Agilex 5 Modular Development Kit 24.2 GSRD binaries are located at https://releases.rocketboards.org/2024.07/:</p> Boot Source Link SD Card https://releases.rocketboards.org/2024.07/gsrd/agilex5_modular_gsrd/ QSPI https://releases.rocketboards.org/2024.07/qspi/agilex5_modular_qspi/ Sources <p>Quartus Prime Pro v24.2 and the following software component versions were used to build the provided prebuilt binaries:</p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.2_REL_AGILEX5_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.22-lts QPDS24.2_REL_AGILEX5_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.10.1 QPDS24.2_REL_AGILEX5_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.01 QPDS24.2_REL_AGILEX5_GSRD_PR Yocto Project: poky https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap QPDS24.2_REL_AGILEX5_GSRD_PR Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.2_REL_AGILEX5_GSRD_PR GSRD Build Script: gsrd-socfpga https://github.com/altera-opensource/gsrd-socfpga scarthgap QPDS24.2_REL_AGILEX5_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Connect micro USB cable from bottom left of the carrier board to PC. This will be used for JTAG communication.</p> <p>3. Connect micro USB cable from bottom right of the SOM board to PC. This will be used for HPS UART communication.</p> <p>4. Connect Ethernet cable from SOM board to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>Each of the USB connections listed above will enumerate 4 USB serial ports on your host computer. The HPS UART port is the 3rd one enumerated by the connection to the SOM board.</p> <p>1. Install a serial terminal emulator application on your host PC:  </p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Remove USB cables, and power down your board if powered up. Look at what USB serial ports are enumerated on your computer by default, without board being connected.</p> <p>3. Power up the board.</p> <p>4. Connect micro USB cable from bottom left of the carrier board to PC. This will be used for JTAG communication. Look at what ports are enumerated on your host computer, there should be a series of four.</p> <p>5. Connect micro USB cable from bottom right of the SOM board to PC. This will be used for HPS UART communication. Look at what ports are enumerated on your host computer, there should be a series of four. Use the 3rd one in the list as the HPS serial port.</p> Possible serial port allocation in Windows <ul> <li>COM3: already there before board was installed</li> <li>COM4-7: enumerated by the JTAG connection</li> <li>COM8-11: enumerated by the HPS connection</li> </ul> <p>In the above case, the port to use for HPS serial communication would be COM10.</p> Possible serial port allocation in Linux <ul> <li>/dev/ttyUSB0-3: enumerated by the JTAG connection</li> <li>/dev/ttyUSB4-7:enumerated by the HPS connection</li> </ul> <p>In the above case, the port to use for HPS serial communication would be /dev/ttyUSB6.</p> <p>Notes:</p> <ul> <li>On Windows, the port number may be kept between power cycles, but not always. </li> <li>On Linux, the port numbe may change depending on the order in which cables are inserted.</li> </ul> <p>6. Configure your serial terminal emulator to use the following settings:  </p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>7. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#booting-from-sd-card","title":"Booting from SD Card","text":"Write SD Card <p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2024.07/gsrd/agilex5_modular_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the gsrd-console-image-agilex5_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://win32diskimager.org/. For this, first rename the gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p> </p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI <pre><code>wget https://releases.rocketboards.org/2024.07/gsrd/agilex5_modular_gsrd/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\ntar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> Run Sample Applications <p>1. Boot to Linux</p> <p>2. Change current folder to <code>intelFPGA</code> folder <pre><code>cd intelFPGA\n</code></pre> 3. Run the hello world application <pre><code>./hello\n</code></pre> 4. Run the <code>syscheck</code> application <pre><code>./syscheck\n</code></pre> Press <code>q</code> to exit the <code>syscheck</code> application.</p> Control LED <p>1. Boot to Linux</p> <p>2. Control LED by using the following sysfs entries:</p> <ul> <li>/sys/class/leds/fpga_led0/brightness</li> <li>/sys/class/leds/hps_led1/brightness</li> </ul> <p>using commands such as: <pre><code>cat /sys/class/leds/fpga_led0/brightness\necho 0 &gt; /sys/class/leds/fpga_led0/brightness\necho 1 &gt; /sys/class/leds/fpga_led1/brightness\n</code></pre></p> <p>Because of how the LEDs are connected, for the above commands <code>0</code> means LED is turned on, <code>1</code> means LED is turned off.</p> Connect to Board Using SSH <p>1. Boot to Linux  </p> <p>2. Determine the board IP address using the <code>ifconfig</code> command: <pre><code>root@agilex5devkit:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 192.168.1.153  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 fe80::f0eb:c8ff:fec4:eed7  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether f2:eb:c8:c4:ee:d7  txqueuelen 1000  (Ethernet)\nRX packets 649  bytes 45132 (44.0 KiB)\nRX errors 0  dropped 226  overruns 0  frame 0\nTX packets 56  bytes 8789 (8.5 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 23  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 100  bytes 8408 (8.2 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 100  bytes 8408 (8.2 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> 3. Connect to the board over SSH using <code>root</code> username, no password will be requested: <pre><code>ssh root@192.168.1.153\n</code></pre> Note: Make sure to replace the above IP address to the one matching the output of running <code>ifconfig</code> on youir board.</p> Visit Board Web Page <p>1. Boot to Linux  </p> <p>2. Determine board IP address using <code>ifconfig</code> like in the previous scenario  </p> <p>3. Start a web browser and enter the IP address in the address bar  </p> <p>4. The web browser will display a page served by the web server running on the board.  </p> <p>Note: Current release has a limitation, in that the LEDs are not controllable from the web page. This will be resolved in the next release.</p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#booting-from-qspi","title":"Booting from QSPI","text":"<p>This section presents how to boot from QSPI. One notable aspect is that you need to wipe the SD card partitioning information, as otherwise U-Boot SPL could find a valid SD card image, and try to boot from that first.</p> Wipe SD Card <p>Either write 1MB of zeroes at the beginning of the SD card, or remove the SD card from the HPS Daughter Card. You can use <code>dd</code> on Linux, or <code>Win32DiskImager</code> on Windows to achieve this.</p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to JTAG: OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.07/qspi/agilex5_modular_qspi/agilex_flash_image.hps.jic.tar.gz\ntar xf agilex_flash_image.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;agilex_flash_image.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch S4 on SOM to ASX4 (QSpI): ON-ON</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>Note: On first boot, the UBIFS rootfilesystem is initialized, and that takes a few minutes. This will not happen on next reboots. See a sample log below:</p> <pre><code>[   17.033558] UBIFS (ubi0:4): Mounting in unauthenticated mode\n[   17.039470] UBIFS (ubi0:4): background thread \"ubifs_bgt0_4\" started, PID 130\n[   17.061510] UBIFS (ubi0:4): start fixing up free space\n[   20.644496] random: crng init done\n[   27.120040] platform soc:leds: deferred probe pending\n[  243.190874] UBIFS (ubi0:4): free space fixup complete\n[  243.315909] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[  243.323290] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[  243.332653] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#rebuilding-the-gsrd","title":"Rebuilding the GSRD","text":""},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#component-versions","title":"Component Versions","text":"<p>Quartus Prime Pro v24.2 and the following software component versions were used to build the provided prebuilt binaries:</p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.2_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.22-lts QPDS24.2_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.10.1 QPDS24.2_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.01 QPDS24.2_REL_GSRD_PR Yocto Project: poky https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap QPDS24.2_REL_GSRD_PR Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.2_REL_GSRD_PR GSRD Build Script: gsrd-socfpga https://github.com/altera-opensource/gsrd-socfpga scarthgap QPDS24.2_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#yocto-build-prerequisites","title":"Yocto Build Prerequisites","text":"<p>Make sure you have Yocto system requirements met: Yocto Requirements.</p> <p>The command to install the required packages on Ubuntu 22.04-LTS is: <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to <code>/bin/dash</code>: <pre><code>sudo ln -sf /bin/bash /bin/sh\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#build-sd-card-boot-binaries","title":"Build SD Card Boot Binaries","text":"<p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf gsrd.modular\nmkdir gsrd.modular\ncd gsrd.modular\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake BOARD_TYPE=DK-MODULAR DEVICE=A5ED065BB32AE6SR0 DAUGHTER_CARD=mod_som HPS_EMIF_EN=1 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=150 INITIALIZATION_FIRST=hps generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_modular-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_modular_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_modular_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_modular_gsrd_core</code> with <code>file://agilex5_modular_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_modular_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_modular_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_modular_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_modular_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_modular_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_modular_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Remove reference to patch which was retired after 24.2 tag was applied:</p> <pre><code>sed -i '/fix-potential-signed-overflow-in-pointer-arithmatic.patch/d' meta-intel-fpga-refdes/recipes-connectivity/openssh/openssh_%.bbappend\n</code></pre> <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/modular/gsrd/ug-gsrd-agx5e-modular/#build-qspi-boot-binaries","title":"Build QSPI Boot Binaries","text":"<p>The diagram below shows how booting from QSPI JIC is built. The hardware project compilation and Yocto build remain the same, and the QSPI JIC is built based on the resulted files: </p> <p>1. Create the folder to contain all the files:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf qspi_boot\nmkdir qspi_boot\ncd qspi_boot\n</code></pre> <p>2. Get the <code>ubinize.cfg</code> file which contains the details on how to build the <code>root.ubi</code> volume, and <code>agilex5_devkit_flash_image_hps.pfg</code> which contains the instructions for Programming File Generator on how to create the .jic file:</p> <pre><code>wget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/ubinize.cfg\nwget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>3. Link to the files that are needed from building the hardware design, and yocto:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/console-image-minimal-agilex5_nor.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof .\n</code></pre> <p>4. Process the u-boot.itb file to be exactly 2MB in size:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_modular-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the <code>root.ubi</code> file and rename it to <code>hps.bin</code> as Programming File Generator needs the <code>.bin</code> extension:</p> <pre><code>ubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>6. Create the JIC file:</p> <pre><code>quartus_pfg -c agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi_boot/agilex_flash_image.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/","title":"Agilex 5 E-Series Premium Development Kit GHRD Linux Boot Examples","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#overview","title":"Overview","text":"<p>This page contains instructions on how to build Linux systems from separate components: Hardware Design, U-Boot, Arm Trusted Firmware, Linux kernel and device tree, Linux root filesystem. This is different from the Golden System Reference Design, where all the software is built through Yocto. While the instructions use Yocto for building the root file system, alternatives could be used there, such as the buildroot utility for example.</p> <p>The following scenarios are covered:</p> <ul> <li>HPS Enablement Board: boot from SD card, and boot from QSPI</li> <li>HPS NAND Board: boot from eMMC flash</li> <li>HPS Test Board: boot from SD card</li> </ul> <p>The instructions on this page are based on the GSRD.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the guides from this page:</p> <ul> <li>Altera Agilex 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.<ul> <li>HPS Enablement  Expansion Board. Included with the development kit</li> <li>HPS NAND Board. Enables eMMC storage for HPS. Orderable separately</li> <li>HPS Test Board. Supports SD card boot, and external Arm tracing. Orderable separately</li> <li>Mini USB Cable. Included with the development kit</li> <li>Micro USB Cable. Included with the development kit</li> <li>Ethernet Cable. Included with the development kit</li> <li>Micro SD card and USB card writer. Included with the development kit</li> </ul> </li> <li>Host PC with<ul> <li>64 GB of RAM or more</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Intel Quartus Prime Pro Edition version 24.2. Used to recompile the hardware design, generate programming files and configure the FPGA device.</li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> </ul> </li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files.</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#component-versions","title":"Component Versions","text":"<p>The instructions on this page use the following component versions:</p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.2_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.22-lts QPDS24.2_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.10.1 QPDS24.2_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.01 QPDS24.2_REL_GSRD_PR Yocto Project: poky https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap QPDS24.2_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#development-kit","title":"Development Kit","text":"<p>Refer to Development Kit for details about the board, including how to install the HPS Boards, and how to set MSEL dispswitches.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>Refer to Release Notes for release readiness information and known issues.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-enablement-board","title":"HPS Enablement Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS Enablement Board. Both booting from SD card and booting from QSPI are covered.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-sd-card","title":"Boot from SD Card","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf bootloader.enablement\nmkdir bootloader.enablement\ncd bootloader.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://win32diskimager.org/. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-qspi","title":"Boot from QSPI","text":"<p>This section presents how to build the binaries and boot from QSPI with the HPS Enablement Board. While the example is based on the GSRD, it contains the following differences:</p> <ul> <li>U-Boot tries to boot only from QSPI flash, does not try SD card</li> <li>U-Boot does not use a script to boot, instead it used the <code>BOOTCMD</code> environment variable directly</li> <li>kernel.itb file contains only one set of core.rbf, kernel and device tree files, targeted for this scenario</li> </ul> <p>1. Prepare the top folder</p> <pre><code>rm -rf $TOP_FOLDER/qspi-boot\nmkdir $TOP_FOLDER/qspi-boot\n</code></pre> <p>2. Build U-Boot:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from QSPI\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# mtd info\nCONFIG_MTDIDS_DEFAULT=\"nor0=nor0\"\nCONFIG_MTDPARTS_DEFAULT=\"mtdparts=nor0:66m(u-boot),190m(root)\"\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# do not keep env on sd card\nCONFIG_ENV_IS_IN_FAT=n\n# disable NAND related settings from defconfig\nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"mtdparts;ubi part root;ubi readvol \\${loadaddr} kernel;ubi detach;setenv bootargs earlycon panic=-1 ubi.mtd=1 root=ubi0:rootfs rootfstype=ubifs rw rootwait;bootm \\${loadaddr}#board-0;\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/qspi-boot/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build <code>kernel.itb</code> FIT file containing kernel, device tree and fpga fabric configuration file:</p> <pre><code>cd $TOP_FOLDER/qspi-boot\nrm -f core.rbf devicetree.dtb Image.lzma kernel.its kernel.itb\nln -s ../ghrd.core.rbf core.rbf\nln -s ../linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk.dtb devicetree.dtb\nxz --format=lzma --extreme -k -c ../linux-socfpga/arch/arm64/boot/Image &gt; Image.lzma\ncat &lt;&lt; EOF &gt; kernel.its\n// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2024 Intel Corporation\n *\n */\n/dts-v1/;\n/ {\n    description = \"FIT image with kernel, DTB and FPGA core binary\";\n    #address-cells = &lt;1&gt;;\n    images {\n        kernel {\n            description = \"Linux Kernel\";\n            data = /incbin/(\"./Image.lzma\");\n            type = \"kernel\";\n            arch = \"arm64\";\n            os = \"linux\";\n            compression = \"lzma\";\n            load = &lt;0x86000000&gt;;\n            entry = &lt;0x86000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fdt-0 {\n            description = \"Device Tree\";\n            data = /incbin/(\"./devicetree.dtb\");\n            type = \"flat_dt\";\n            arch = \"arm64\";\n            compression = \"none\";\n            hash {\n                algo = \"crc32\";\n            };\n        };\n        fpga-0 {\n            description = \"FPGA bitstream\";\n            data = /incbin/(\"./core.rbf\");\n            type = \"fpga\";\n            arch = \"arm64\";\n            compression = \"none\";\n            load = &lt;0x8A000000&gt;;\n            hash {\n                algo = \"crc32\";\n            };\n        };\n    };\n    configurations {\n        default = \"board-0\";\n        board-0 {\n            description = \"board_0\";\n            kernel = \"kernel\";\n            fdt = \"fdt-0\";\n            fpga = \"fpga-0\";\n            signature {\n                algo = \"crc32\";\n                key-name-hint = \"dev\";\n                sign-images = \"fdt-0\", \"kernel\", \"fpga-0\";\n            };\n        };\n    };\n};\nEOF\n./u-boot-socfpga/tools/mkimage -f kernel.its kernel.itb\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/kernel.itb</code></li> </ul> <p>4. Create U-Boot binary <code>u-boot.bin</code> with a size of exactly 2MB:</p> <pre><code>cp u-boot-socfpga/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Build the <code>rootfs.ubifs</code> file:</p> <pre><code>rm -rf rootfs rootfs.ubifs\nmkdir rootfs tar -xzvf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz -C rootfs mkfs.ubifs -r rootfs -F -e 65408 -m 1 -c 6500 -o rootfs.ubifs </code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/rootfs.ubifs</code></li> </ul> <p>6. Build the <code>root.ubi</code> file:</p> <pre><code>cat &lt;&lt; EOF &gt; ubinize.cfg\n[env]\nmode=ubi\nvol_id=0\nvol_name=env\nvol_size=256KiB\nvol_type=dynamic\n[script]\nmode=ubi\nvol_id=1\nvol_name=script\nvol_size=128KiB \nvol_type=dynamic\n[kernel]\nmode=ubi\nimage=kernel.itb\nvol_id=2\nvol_name=kernel\nvol_size=24MiB\nvol_type=dynamic\n[dtb]\nmode=ubi\nvol_id=3    \nvol_name=dtb   \nvol_size=256KiB \nvol_type=dynamic\n[rootfs]\nmode=ubi\nimage=rootfs.ubifs\nvol_id=4\nvol_name=rootfs\nvol_type=dynamic\nvol_size=160MiB\nvol_flag=autoresize\nEOF\nubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/root.ubi</code></li> </ul> <p>7. Build the QSPI flash image:</p> <pre><code>ln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof fpga.sof\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\nln -s root.ubi hps.bin\ncat &lt;&lt; EOF &gt; flash_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash_image\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n    &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;hps.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE6SR0&lt;/flash_loader&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"UBOOT\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"HPS\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"UBOOT\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"HPS\"&gt;\n            &lt;raw_file_id&gt;Raw_File_2&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash_image.pfg\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/qspi-boot/flash_image.hps.jic</code></li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <p><pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"qspi-boot/flash_image.hps.jic\"\n</code></pre> Note: You need to wipe the micro SD card or remove it from the board before start running.</p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-nand-board","title":"HPS NAND Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS NAND Board. Boot source is eMMC Flash.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-emmc","title":"Boot from eMMC","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf bootloader.emmc\nmkdir bootloader.emmc\ncd bootloader.emmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 DAUGHTER_CARD=devkit_dc_emmc generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk_emmc.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk_emmc.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_emmc.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create eMMC Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_emmc.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Create Helper JIC <p>In this section we are building a helper JIC which will boot from QSPI and will allow us to program the eMMC from U-Boot.</p> <p>1. Create the jic helper folder to contain all related build artifacts:</p> <pre><code>rm -rf $TOP_FOLDER/helper-jic\nmkdir $TOP_FOLDER/helper-jic\n</code></pre> <p>2. Build a modified U-Boot, which boots from QSPI and stops at command line prompt:</p> <pre><code>cd $TOP_FOLDER/helper-jic\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"echo hello\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\n# boot from QSPI\nCONFIG_ENV_IS_IN_FAT=n\nCONFIG_ENV_IS_NOWHERE=y\nCONFIG_SYS_SPI_U_BOOT_OFFS=0x00300000\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> <p>3. Build the helper JIC:</p> <pre><code>cd $TOP_FOLDER/helper-jic\nrm -f flash.pfg fpga.sof u-boot.bin spl.hex *.jic *.rbf\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof fpga.sof\nln -s u-boot-socfpga/u-boot.itb u-boot.bin\nln -s u-boot-socfpga/spl/u-boot-spl-dtb.hex spl.hex\ncat &lt;&lt; EOF &gt; flash.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"flash\" hps=\"1\" directory=\"./\" type=\"PERIPH_JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"flash_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"spl.hex\"&gt;fpga.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;raw_files&gt;\n        &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU128\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x001FFFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x00300000\" e_addr=\"0x004CFFFF\" fixed_e_addr=\"1\" id=\"u-boot\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;A5ED065BB32AE5SR0&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"0\" partition_id=\"u-boot\"&gt;\n            &lt;raw_file_id&gt;Raw_File_1&lt;/raw_file_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\nquartus_pfg -c flash.pfg\n</code></pre> <p>The following file will be created:</p> <ul> <li><code>$TOP_FOLDER/helper-jic/flash.hps.jic</code></li> </ul> Write eMMC Image <p>1. Write the helper JIC to QSPI:</p> <ul> <li>Power down board</li> <li>Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</li> <li>Power up the board</li> <li>Write JIC image to QSPI: <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;helper-jic/flash.hps.jic\"\n</code></pre> </li></ul> <p>2. Boot to U-Boot prompt with the helper JIC:</p> <ul> <li>Power down board</li> <li>Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</li> <li>Power up the board</li> <li>Wait for U-Boot to boot, press any key to get to U-Boot console</li></ul> <p>3. Use <code>ifconfig</code> on your host machine to determine the IP of your TFTP server</p> <p>4. Copy the eMMC image <code>$TOP_FOLDER/sd_card/sdcard.img</code> to your TFTP server folder</p> <p>5. Use the following U-Boot commands to download and write the eMMC image:</p> <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;your_tftp_server_ip&gt;\ntftp ${loadaddr} sdcard.img\nsetexpr blkcnt ${filesize} / 0x200\nmmc write ${loadaddr} 0 ${blkcnt}\n</code></pre> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#hps-test-board","title":"HPS Test Board","text":"<p>This section demonstrates how to build a Linux system from separate components, targetting the HPS Test Board. Boot source is SD Card.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/boot-examples/ug-linux-boot-agx5e-premium/#boot-from-sd-card_1","title":"Boot from SD Card","text":"Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf bootloader.test\nmkdir bootloader.test\ncd bootloader.test\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 DAUGHTER_CARD=debug2 generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Arm Trusted Firmware <pre><code>cd $TOP_FOLDER\nrm -rf arm-trusted-firmware\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/arm-trusted-firmware\ncd arm-trusted-firmware\nmake -j 48 PLAT=agilex5 bl31 cd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/arm-trusted-firmware/build/agilex5/release/bl31.bin</code></li> </ul> Build U-Boot <pre><code>cd $TOP_FOLDER\nrm -rf u-boot-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/u-boot-socfpga\ncd u-boot-socfpga # enable dwarf4 debug info, for compatibility with arm ds\nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk\n# only boot from SD, do not try QSPI and NAND\nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# disable NAND in the device tree\nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex5_socdk-u-boot.dtsi\n# swap gmac0 and gmac2\nsed -i '/&amp;gmac2/ { N; s/status = \"okay\"/status = \"disabled\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\nsed -i '/&amp;gmac0/ { N; s/status = \"disabled\"/status = \"okay\"/; }' arch/arm/dts/socfpga_agilex5_socdk.dts\n# link to atf\nln -s ../arm-trusted-firmware/build/agilex5/release/bl31.bin # create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment\n# use Image instead of kernel.itb\nCONFIG_BOOTFILE=\"Image\"\n# disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n\nCONFIG_SPL_NAND_SUPPORT=n\nCONFIG_CMD_NAND_TRIMFFS=n\nCONFIG_CMD_NAND_LOCK_UNLOCK=n\nCONFIG_NAND_DENALI_DT=n\nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n\nCONFIG_SPL_NAND_FRAMEWORK=n\nCONFIG_CMD_NAND=n\nCONFIG_MTD_RAW_NAND=n\nCONFIG_CMD_UBI=n\nCONFIG_CMD_UBIFS=n\nCONFIG_MTD_UBI=n\nCONFIG_ENV_IS_IN_UBI=n\nCONFIG_UBI_SILENCE_MSG=n\nCONFIG_UBIFS_SILENCE_MSG=n\n# disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n\nCONFIG_HUSH_PARSER=y\nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \"\nCONFIG_USE_BOOTCOMMAND=y\nCONFIG_BOOTCOMMAND=\"load mmc 0:1 \\${loadaddr} ghrd.core.rbf; fpga load 0 \\${loadaddr} \\${filesize};bridge enable; mmc rescan; fatload mmc 0:1 82000000 Image;fatload mmc 0:1 86000000 socfpga_agilex5_socdk_debug.dtb;setenv bootargs console=ttyS0,115200 root=\\${mmcroot} rw rootwait;booti 0x82000000 - 0x86000000\"\nCONFIG_CMD_FAT=y\nCONFIG_CMD_FS_GENERIC=y\nCONFIG_DOS_PARTITION=y\nCONFIG_SPL_DOS_PARTITION=y\nCONFIG_CMD_PART=y\nCONFIG_SPL_CRC32=y\nCONFIG_LZO=y\nCONFIG_CMD_DHCP=y\n# enable more QSPI flash manufacturers\nCONFIG_SPI_FLASH_MACRONIX=y\nCONFIG_SPI_FLASH_GIGADEVICE=y\nCONFIG_SPI_FLASH_WINBOND=y\nCONFIG_SPI_FLASH_ISSI=y\nEOF\n# build U-Boot\nmake clean &amp;&amp; make mrproper\nmake socfpga_agilex5_defconfig # use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O . -m .config config-fragment\nmake -j 64\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/u-boot-socfpga/u-boot.itb</code></li> <li><code>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd.rbf \\\n-o hps_path=$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li>`$TOP_FOLDER/ghrd.hps.rbf</li> </ul> Build Linux <pre><code>cd $TOP_FOLDER\nrm -rf linux-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/linux-socfpga\ncd linux-socfpga\nmake defconfig make -j 64 Image &amp;&amp; make intel/socfpga_agilex5_socdk_debug.dtb </code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_debug.dtb</code></li> <li><code>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image</code></li> </ul> Build Rootfs <pre><code>cd $TOP_FOLDER\nrm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto\ngit clone -b scarthgap https://git.yoctoproject.org/poky\ngit clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga\ngit clone -b scarthgap https://github.com/openembedded/meta-openembedded\nsource poky/oe-init-build-env ./build\necho 'MACHINE = \"agilex5_dk_a5e065bb32aes1\"' &gt;&gt; conf/local.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf\necho 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz</code></li> </ul> Create SD Card Image <pre><code>cd $TOP_FOLDER\nsudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card\nwget https://releases.rocketboards.org/release/2020.11/gsrd/tools/make_sdimage_p3.py\nsed -i 's/\\\"\\-F 32\\\",//g' make_sdimage_p3.py\nchmod +x make_sdimage_p3.py\nmkdir fatfs &amp;&amp;  cd fatfs\ncp $TOP_FOLDER/ghrd.core.rbf .\ncp $TOP_FOLDER/u-boot-socfpga/u-boot.itb .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image .\ncp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex5_socdk_debug.dtb .\ncd ..\nmkdir rootfs &amp;&amp; cd rootfs\nsudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex5_dk_a5e065bb32aes1/core-image-minimal-agilex5_dk_a5e065bb32aes1.rootfs.tar.gz\ncd ..\nsudo python3 make_sdimage_p3.py -f \\\n-P fatfs/*,num=1,format=fat32,size=64M \\\n-P rootfs/*,num=2,format=ext3,size=64M \\\n-s 140M \\\n-n sdcard.img\ncd ..\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/sd_card/sdcard.img</code></li> </ul> Write SD Card <p>Write the SD card image <code>sd_card/sdcard.img</code> to the micro SD card using the included USB writer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code>    # Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n    # This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=sdcard.img of=/dev/sdx bs=1M\n    # Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://win32diskimager.org/. Write the image as shown in the next figure:  </li> </ul> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Write JIC image to QSPI:</p> <pre><code>cd $TOP_FOLDER\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd.hps.jic\"\n</code></pre> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/","title":"Agilex 5 E-Series Premium Development Kit GSRD User Guide","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#introduction","title":"Introduction","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#gsrd-overview","title":"GSRD Overview","text":"<p>The Golden System Reference Design (GSRD) is a reference design running on the Agilex 5 E-Series Premium  Development Kit.</p> <p>The GSRD is comprised of the following components:</p> <ul> <li>Golden Hardware Reference Design (GHRD)</li> <li>Reference HPS software including:<ul> <li>Arm Trusted Firmware</li> <li>U-Boot</li> <li>Linux Kernel</li> <li>Linux Drivers</li> <li>Sample Applications</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#prerequisites","title":"Prerequisites","text":"<p>The following are required to be able to fully exercise the Agilex 5 Premium Development Kit GSRD:</p> <ul> <li> <p>Altera Agilex 5 FPGA E-Series 065B Premium Development Kit, ordering code DK-A5E065BB32AES1. Refer to board documentation for more information about the development kit.</p> <ul> <li>HPS Enablement Expansion Board. Included with the development kit.</li> <li>HPS NAND Board. Enables eMMC storage for HPS. Orderable separately.</li> <li>HPS Test Board. Supports SD card boot, and external Arm tracing. Orderable separately.</li> <li>Mini USB Cable. Included with the development kit.</li> <li>Micro USB Cable. Included with the development kit.</li> <li>Ethernet Cable. Included with the development kit.</li> <li>Micro SD card and USB card writer. Included with the development kit.</li> <li>Host PC with:</li> </ul> <ul> <li>64 GB of RAM. Less will be fine for only exercising the binaries, and not rebuilding the GSRD.</li> <li>Linux OS installed. Ubuntu 22.04LTS was used to create this page, other versions and distributions may work too</li> <li>Serial terminal (for example GtkTerm or Minicom on Linux and TeraTerm or PuTTY on Windows)</li> <li>Intel Quartus Prime Pro Edition version. Used to recompile the hardware design. If only writing binaris is required, then the smaller Intel Quartus Prime Pro Edition Programmer is sufficient.</li> <li>The prebuilt binaries were built using Quartus version 24.1</li> <li>The instructions for rebuilding the binaries use Quartus version 24.2</li> <li>TFTP server. This used to download the eMMC binaries to board to be flashed by U-Boot</li> <li>Local Ethernet network, with DHCP server</li> <li>Internet connection. For downloading the files, especially when rebuilding the GSRD.</li> </ul> </li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#release-contents","title":"Release Contents","text":"<p>This page documents the following:</p> <ul> <li>24.1 Binary Release - see Exercising Prebuilt Binaries section for release content details</li> <li>24.2 Source Code Release - see Rebuilding the GSRD section for release content details</li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#release-notes","title":"Release Notes","text":"<p>See https://www.rocketboards.org/foswiki/Documentation/IntelFPGAHPSEmbeddedSoftwareRelease</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#development-kit","title":"Development Kit","text":"<p>This release targets the Agilex 5 FPGA E-Series 065B Premium Development Kit. Refer to board documentation for more information about the development kit.</p> <p></p> Installing HPS Daughtercard <p>This section shows how to install the included HPS Enablement Daughtercard.  The installation for the other optional HPS Boards is similar.</p> <p>1. Identify the correct thumb screws and washers needed, they are in a plastic bag: </p> <p>2. Locate the area on the development board where the HPS Daughtercard needs to be installed: </p> <p>3. Place the plastic washers on top of the three hex mounting posts: </p> <p>4. Place HPS Board on top of the posts and washers: </p> <p>5. Place the hex thumb screws on the two posts, as shown below. Note the 3rd one on the bottom is best unplaced as fully screwing that in may move the board. Also note the thumb screw close to the Ethernet connector is hard to screw, recommend to use small pliers and patience to make it secure. It is important that the HPS Board is secure, and does not move: </p> <p>Note: If you need to swap HPS Boards frequently,  it is recommended to remove the hex posts, and install the plastic washers between the PCB and the posts. This way you do not need to be careful for the washers not to move when you place the HPS Board on top of the posts. Note there are also plastic washers underneath the development board PCB, make sure to leave those in place when performing this operation</p> Changing MSEL <p>MSEL signals instruct the FPGA device on which configuration scheme to use. Configuration schemes used by the scenarios presented in this guide are JTAG and QSPI. MSEL is changed through dipswitch SW27. Only change the settings while the board is powered off.</p> <p>Configuration OFF-OFF-OFF-OFF corresponds to JTAG:</p> <p></p> <p>Configuration OFF-ON-ON-OFF corresponds to JTAG:</p> <p></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#ghrd-overview","title":"GHRD Overview","text":"<p>The Golden Hardware Reference Design is an important part of the GSRD and consists of the following components:</p> <ul> <li>Hard Processor System (HPS)<ul> <li>Dual core Arm Cortex-A76 processor</li> <li>Dual core Arm Cortex-A55 processor</li> <li>HPS Peripherals connected to HPS Enablement Expansion Board:<ul> <li>Micro SD Card</li> <li>EMAC</li> <li>HPS JTAG debug</li> <li>I3C</li> <li>UART</li> <li>USB 3.1</li> </ul> </li> </ul> </li> <li>Multi-Ported Front End (MPFE) for HPS External Memory Interface (EMIF)</li> <li>FPGA Peripherals connected to Lightweight HPS-to-FPGA (LWH2F) AXI Bridge and JTAG to Avalon Master Bridge<ul> <li>Three user LED outputs</li> <li>Four user DIP switch inputs</li> <li>Four user push-button inputs</li> <li>System ID</li> </ul> </li> <li>FPGA Peripherals connected to HPS-to-FPGA (H2F) AXI Bridge<ul> <li>256KB of FPGA on-chip memory</li> </ul> </li> </ul> <p> </p> <p>The GHRD allows hardware designers to access each peripheral in the FPGA portion of the SoC with System Console, through the JTAG master module. This signal-level access is independent of the driver readiness of each peripheral.</p>  MPU Address Maps <p>This section presents the address maps as seen from the MPU side.  </p>  HPS-to-FPGA Address Map <p>The three FPGA windows in the MPU address map provide access to 256 GB of FPGA space. First window is 1 GB from 00_4000_0000, second window is 15 GB from 04_4000_0000, third window is 240 GB from 44_0000_0000. The following table lists the offset of each peripheral from the HPS-to-FPGA bridge in the FPGA portion of the SoC.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0 256K On-chip RAM as scratch pad Lightweight HPS-to-FPGA Address Map <p>The the memory map of system peripherals in the FPGA portion of the SoC as viewed by the MPU, which starts at the lightweight HPS-to-FPGA base address of 0x00_2000_0000, is listed in the following table.</p> Peripheral Address Offset Size (bytes) Attribute sysid 0x0001_0000 32 Unique system ID led_pio 0x0001_0080 16 LED outputs button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs JTAG Master Address Map <p>There are three JTAG master interfaces in the design, one for accessing non-secure peripherals in the FPGA fabric, and another for accessing secure peripheral in the HPS through the FPGA-to-HPS Interface and another for FPGA fabric to SDRAM.</p> <p>The following table lists the address of each peripheral in the FPGA portion of the SoC, as seen through the non-secure JTAG master interface.</p> Peripheral Address Offset Size (bytes) Attribute onchip_memory2_0 0x0004_0000 256K On-chip RAM sysid 0x0001_0000 32 Unique system ID led_pio 0x0001_0080 16 LED outputs button_pio 0x0001_0060 16 Push button inputs dipsw_pio 0x0001_0070 16 DIP switch inputs  Interrupt Routing <p>The HPS exposes 64 interrupt inputs for the FPGA logic. The following table lists the interrupt connections from soft IP peripherals to the HPS interrupt input interface.</p> Peripheral Interrupt Number Attribute dipsw_pio f2h_irq0[0] 4 DIP switch inputs button_pio f2h_irq0[1] 4 Push button inputs"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#exercising-prebuilt-binaries","title":"Exercising Prebuilt Binaries","text":"<p>This section presents how to use the prebuilt binaries included with the GSRD release.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#prebuilt-release-contents","title":"Prebuilt Release Contents","text":"Binaries <p>The Agilex 5 Premium Development Kit 24.1 GSRD binaries are located at https://releases.rocketboards.org/2024.05/:</p> HPS Daughter Card Boot Source Link Enablement Board SD Card https://releases.rocketboards.org/2024.05/gsrd/agilex5_dk_a5e065bb32aes1_gsrd Enablement Board QSPI https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi NAND Board eMMC https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc Test Board SD Card https://releases.rocketboards.org/2024.05/debug/agilex5_dk_a5e065bb32aes1_debug Sources <p>Quartus Prime Pro v24.1 and the following software component versions were used to build the provided prebuilt binaries:</p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.1_REL_AGILEX5_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.1.68-lts QPDS24.1_REL_AGILEX5_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.10.0 QPDS24.1_REL_AGILEX5_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2023.10 QPDS24.1_REL_AGILEX5_GSRD_PR Yocto Project: poky https://git.yoctoproject.org/poky nanbield latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga nanbield QPDS24.1_REL_AGILEX5_GSRD_PR Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes nanbield QPDS24.1_REL_AGILEX5_GSRD_PR GSRD Build Script: gsrd-socfpga https://github.com/altera-opensource/gsrd-socfpga nanbield QPDS24.1_REL_AGILEX5_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#configure-board","title":"Configure Board","text":"<p>1. Leave all jumpers and switches in their default configuration.</p> <p>2. Install the appropriate HPS Daughtercard.</p> <p>3. Connect mini USB cable from vertical connector on HPS Daughtercard to host PC. This is used for the HPS serial console.</p> <p>4. Connect micro USB cable from development board to host PC. This is used by the tools for JTAG communication.</p> <p>5. Connect Ethernet cable from HPS Board to an Ethernet switch connected to local network. Local network must provide a DCHP server.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#configure-serial-console","title":"Configure Serial Console","text":"<p>All the scenarios included in this release require a serial connection. This section presents how to configure the serial connection.</p> <p>1. Install a serial terminal emulator application on your host PC:  </p> <ul> <li>For Windows: TeraTerm or PuTTY are available</li> <li>For Linux: GtkTerm or Minicom are available</li> </ul> <p>2. Power down your board if powered up. This is important, as once powered up, with the micro USB JTAG cable connected, a couple more USB serial ports will enumerate, and you may choose the wrong port.</p> <p>3. Connect mini-USB cable from the vertical mini-USB connector on the HPS Board to the host PC</p> <p>4. On the host PC, an USB serial port will enumerate. On Windows machines it will be something like <code>COM4</code>, while on Linux machines it will be something like <code>/dev/tty/USB0</code>.</p> <p>5. Configure your serial terminal emulator to use the following settings:  </p> <ul> <li>Serial port: as mentioned above</li> <li>Baud rate: 115,200</li> <li>Data bits: 8</li> <li>Stop bits: 1</li> <li>CRC: disabled</li> <li>Hardware flow control: disabled</li> </ul> <p>6. Connect your terminal emulator</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-enablement-board","title":"HPS Enablement Board","text":"<p>This section presents how to use HPS Enablement Board to boot from SD card, and also from QSPI.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-sd-card","title":"Booting from SD Card","text":"Write SD Card <p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2024.05/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the gsrd-console-image-agilex5_devkit.wic. SD card image to the micro SD card using the included USB writer in the host computer:</p> <ul> <li>On Linux, use the <code>dd</code> utility as shown next: <pre><code># Determine the device asociated with the SD card on the host computer. \ncat /proc/partitions\n# This will return for example /dev/sdx\n# Use dd to write the image in the corresponding device\nsudo dd if=gsrd-console-image-agilex5_devkit.wic of=/dev/sdx bs=1M\n# Flush the changes to the SD card\nsync\n</code></pre></li> <li>On Windows, use the Win32DiskImager program, available at https://win32diskimager.org/. For this, first rename the gsrd-console-image-agilex5_devkit.wic to an .img file (sdcard.img for example) and write the image as shown in the next figure:</li> </ul> <p> </p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI <pre><code>wget https://releases.rocketboards.org/2024.05/gsrd/agilex5_dk_a5e065bb32aes1_gsrd/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\ntar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> Run Sample Applications <p>1. Boot to Linux</p> <p>2. Change current folder to <code>intelFPGA</code> folder <pre><code>cd intelFPGA\n</code></pre> 3. Run the hello world application <pre><code>./hello\n</code></pre> 4. Run the <code>syscheck</code> application <pre><code>./syscheck\n</code></pre> Press <code>q</code> to exit the <code>syscheck</code> application.</p> Control LEDs <p>1. Boot to Linux</p> <p>2. Control LEDs by using the following sysfs entries:</p> <ul> <li>/sys/class/leds/fpga_led0/brightness</li> <li>/sys/class/leds/fpga_led1/brightness</li> <li>/sys/class/leds/fpga_led2/brightness</li> <li>/sys/class/leds/hps_led1/brightness</li> </ul> <p>using commands such as: <pre><code>cat /sys/class/leds/fpga_led0/brightness\necho 0 &gt; /sys/class/leds/fpga_led0/brightness\necho 1 &gt; /sys/class/leds/fpga_led1/brightness\n</code></pre></p> <p>Because of how the LEDs are connected, for the above commands <code>0</code> means LED is turned on, <code>1</code> means LED is turned off.</p> Connect to Board Using SSH <p>1. Boot to Linux  </p> <p>2. Determine the board IP address using the <code>ifconfig</code> command: <pre><code>root@agilex5devkit:~# ifconfig\neth0: flags=-28605&lt;UP,BROADCAST,RUNNING,MULTICAST,DYNAMIC&gt;  mtu 1500\ninet 192.168.1.153  netmask 255.255.255.0  broadcast 192.168.1.255\n        inet6 fe80::f0eb:c8ff:fec4:eed7  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether f2:eb:c8:c4:ee:d7  txqueuelen 1000  (Ethernet)\nRX packets 649  bytes 45132 (44.0 KiB)\nRX errors 0  dropped 226  overruns 0  frame 0\nTX packets 56  bytes 8789 (8.5 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\ndevice interrupt 23  lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\ninet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\nRX packets 100  bytes 8408 (8.2 KiB)\nRX errors 0  dropped 0  overruns 0  frame 0\nTX packets 100  bytes 8408 (8.2 KiB)\nTX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> 3. Connect to the board over SSH using <code>root</code> username, no password will be requested: <pre><code>ssh root@192.168.1.153\n</code></pre> Note: Make sure to replace the above IP address to the one matching the output of running <code>ifconfig</code> on youir board.</p> Visit Board Web Page <p>1. Boot to Linux  </p> <p>2. Determine board IP address using <code>ifconfig</code> like in the previous scenario  </p> <p>3. Start a web browser and enter the IP address in the address bar  </p> <p>4. The web browser will display a page served by the web server running on the board.  </p> <p>Note: Current release has a limitation, in that the LEDs are not controllable from the web page. This will be resolved in the next release.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-qspi","title":"Booting from QSPI","text":"<p>This section presents how to boot from QSPI. One notable aspect is that you need to wipe the SD card partitioning information, as otherwise U-Boot SPL could find a valid SD card image, and try to boot from that first.</p> Wipe SD Card <p>Either write 1MB of zeroes at the beginning of the SD card, or remove the SD card from the HPS Daughter Card. You can use <code>dd</code> on Linux, or <code>Win32DiskImager</code> on Windows to achieve this.</p> Write QSPI Flash <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download and extract the JIC image, then write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/agilex_flash_image.hps.jic.tar.gz\ntar xf agilex_flash_image.hps.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;agilex_flash_image.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down board</p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Wait for Linux to boot, use <code>root</code> as user name, and no password wil be requested.</p> <p>Note: On first boot, the UBIFS rootfilesystem is initialized, and that takes a few minutes. This will not happen on next reboots. See a sample log below:</p> <pre><code>[   17.033558] UBIFS (ubi0:4): Mounting in unauthenticated mode\n[   17.039470] UBIFS (ubi0:4): background thread \"ubifs_bgt0_4\" started, PID 130\n[   17.061510] UBIFS (ubi0:4): start fixing up free space\n[   20.644496] random: crng init done\n[   27.120040] platform soc:leds: deferred probe pending\n[  243.190874] UBIFS (ubi0:4): free space fixup complete\n[  243.315909] UBIFS (ubi0:4): UBIFS: mounted UBI device 0, volume 4, name \"rootfs\"\n[  243.323290] UBIFS (ubi0:4): LEB size: 65408 bytes (63 KiB), min./max. I/O unit sizes: 8 bytes/256 bytes\n[  243.332653] UBIFS (ubi0:4): FS size: 167117440 bytes (159 MiB, 2555 LEBs), max 6500 LEBs, journal size \n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-nand-board","title":"HPS NAND Board","text":"<p>This section presents how to use HPS NAND Board to boot from eMMC.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-emmc","title":"Booting from eMMC","text":"Configure Board <p>For this scenario, we are using the HPS NAND Board, which can be configured through dipswitch SW3 to enable either eMMC or NAND. Set SW3 to ON to enable eMMC.</p> Write eMMC Flash <p>We are writing the eMMC Flash by using U-Boot commands. We are getting to U-Boot prompt by booting from QSPI using a JIC image which contains U-Boot, thereby not relying on what is already in eMMC.</p> <p>1. Download, and extract the eMMC image <pre><code>wget https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc/sdimage.tar.gz\ntar xf sdimage.tar.gz\n</code></pre> 2. Split the eMMC image into 1GB chunks and copy them to your TFT folder: <pre><code>split --bytes=1G gsrd-console-image-agilex5_devkit.wic\nmv xa* &lt;your_tfp_folder&gt;\n</code></pre> This will put the two chunks called <code>xaa</code> and <code>xab</code> on your TFTP folder. 3. Power down the board. </p> <p>4. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>5. Power up the board</p> <p>6. Download the helper JIC used to write the eMMC image, extract it and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc/uboot.jic.tar.gz\ntar xf uboot.jic.tar.gz\nquartus_pgm -c 1 -m jtag -o \"pvi;uboot.jic\"\n</code></pre> 7. Determine your host IP address using <code>ifconfig</code> to use it as the IP address of the TFTP server</p> <p>8. Power down the board</p> <p>9. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>10. Power up the board</p> <p>11. Stop U-Boot at the boot countdown, to drop to U-Boot console</p> <p>12. At the U-Boot console, run the following commands to write the SD card image: <pre><code>setenv autoload no\ndhcp\nsetenv serverip &lt;tftp_server_ip_address&gt;\ntftp ${loadaddr} xaa\nsetexpr blkcnt1 ${filesize} / 0x200\nmmc write ${loadaddr} 0 ${blkcnt1}\ntftp ${loadaddr} xab\nsetexpr blkcnt2 ${filesize} / 0x200\nmmc write ${loadaddr} ${blkcnt1} ${blkcnt2}\n</code></pre> Note: If you already have a valid image in eMMC, the U-Boot SPL which runs from QSPI will be able to see that and load it instead of the U-Boot from QSPI. To prevent this from happening, you can wipe out the eMMC card partitioning, then issue a reset for U-Boot to reboot into the QSPI helper JIC:</p> <pre><code>mw.w ${loadaddr} 0x0 0x80000\nmmc rescan\nmmc write ${loadaddr} 0x0 0x400\nreset\n</code></pre> Write QSPI Flash <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download the JIC and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz tar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Board will boot to Linux. Enter <code>root</code> as username, no password will be requested</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-test-board","title":"HPS Test Board","text":"<p>This section presents how to use HPS Test Board to boot from SD card.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#booting-from-sd-card_1","title":"Booting from SD Card","text":"Configure Board <p>For this scenario we are using the HPS Test Board. There is single dipswitch on that board called SW1, which needs to be set to the ON position.</p> Write SD Card <p>1. Download SD card image from the prebuilt binaries https://releases.rocketboards.org/2024.05/debug/agilex5_dk_a5e065bb32aes1_debug/sdimage.tar.gz and extract the archive, obtaining the file <code>gsrd-console-image-agilex5_devkit.wic</code>.</p> <p>2. Write the SD card image to the micro SD card using the included USB writer in the host computer, and <code>dd</code> utility on Linux, or  Win32DiskImager on Windows, available at https://win32diskimager.org/. Please refer to the Booting from SD Card section for more details about this.</p> Write QSPI Flash <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to JTAG: OFF-OFF-OFF-OFF</p> <p>3. Power up the board</p> <p>4. Download the JIC and write it to QSPI: <pre><code>wget https://releases.rocketboards.org/2024.05/debug/agilex5_dk_a5e065bb32aes1_debug/ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz tar xf ghrd_a5ed065bb32ae6sr0.hps.jic.tar.gz quartus_pgm -c 1 -m jtag -o \"pvi;ghrd_a5ed065bb32ae6sr0.hps.jic\"\n</code></pre></p> Boot Linux <p>1. Power down the board. </p> <p>2. Set MSEL dipswitch SW27 to ASX4 (QSPi): OFf-ON-ON-OFF</p> <p>3. Power up the board</p> <p>4. Board will boot to Linux. Enter <code>root</code> as username, no password will be requested</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#rebuilding-the-gsrd","title":"Rebuilding the GSRD","text":""},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#component-versions","title":"Component Versions","text":"<p>Quartus Prime Pro v24.2 and the following software component versions were used to build the provided prebuilt binaries:</p> Component Location Branch Commit ID/Tag GHRD https://github.com/altera-opensource/ghrd-socfpga master QPDS24.2_REL_GSRD_PR Linux https://github.com/altera-opensource/linux-socfpga socfpga-6.6.22-lts QPDS24.2_REL_GSRD_PR Arm Trusted Firmware https://github.com/altera-opensource/arm-trusted-firmware socfpga_v2.10.1 QPDS24.2_REL_GSRD_PR U-Boot https://github.com/altera-opensource/u-boot-socfpga socfpga_v2024.01 QPDS24.2_REL_GSRD_PR Yocto Project: poky https://git.yoctoproject.org/poky scarthgap latest Yocto Project: meta-intel-fpga https://git.yoctoproject.org/meta-intel-fpga scarthgap QPDS24.2_REL_GSRD_PR Yocto Project: meta-intel-fpga-refdes https://github.com/altera-opensource/meta-intel-fpga-refdes scarthgap QPDS24.2_REL_GSRD_PR GSRD Build Script: gsrd-socfpga https://github.com/altera-opensource/gsrd-socfpga scarthgap QPDS24.1_REL_GSRD_PR"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#yocto-build-prerequisites","title":"Yocto Build Prerequisites","text":"<p>Make sure you have Yocto system requirements met: Yocto Requirements.</p> <p>The command to install the required packages on Ubuntu 22.04-LTS is: <pre><code>sudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\\nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\\npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd \\\nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\\ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\\ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y\n</code></pre> On Ubuntu 22.04 you will also need to point the /bin/sh to /bin/bash, as the default is a link to <code>/bin/dash</code>: <pre><code>sudo ln -sf /bin/bash /bin/sh\n</code></pre></p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-enablement-board_1","title":"HPS Enablement Board","text":"<p>This section presents how to build the binaries for HPS Enablement Board.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-sd-card-boot-binaries","title":"Build SD Card Boot Binaries","text":"<p>The following diagram shows an overview of how the build process works for this use case:</p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf gsrd.enablement\nmkdir gsrd.enablement\ncd gsrd.enablement\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf</code></p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_gsrd_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_gsrd_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_gsrd_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_gsrd_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_gsrd_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_gsrd_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Remove reference to patch which was retired after 24.2 tag was applied:</p> <pre><code>sed -i '/fix-potential-signed-overflow-in-pointer-arithmatic.patch/d' meta-intel-fpga-refdes/recipes-connectivity/openssh/openssh_%.bbappend\n</code></pre> <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-qspi-boot-binaries","title":"Build QSPI Boot Binaries","text":"<p>The diagram below shows how booting from QSPI JIC is built. The hardware project compilation and Yocto build remain the same, and the QSPI JIC is built based on the resulted files: </p> <p>1. Create the folder to contain all the files:</p> <pre><code>cd $TOP_FOLDER\nsudo rm -rf qspi_boot\nmkdir qspi_boot\ncd qspi_boot\n</code></pre> <p>2. Get the <code>ubinize.cfg</code> file which contains the details on how to build the <code>root.ubi</code> volume, and <code>agilex5_devkit_flash_image_hps.pfg</code> which contains the instructions for Programming File Generator on how to create the .jic file:</p> <pre><code>wget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/ubinize.cfg\nwget https://releases.rocketboards.org/2024.05/qspi/agilex5_dk_a5e065bb32aes1_qspi/agilex5_devkit_flash_image_hps.pfg\n</code></pre> <p>3. Link to the files that are needed from building the hardware design, and yocto:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/console-image-minimal-agilex5_nor.ubifs rootfs.ubifs\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/kernel.itb .\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/boot.scr.uimg\nln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof .\n</code></pre> <p>4. Process the u-boot.itb file to be exactly 2MB in size:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the <code>root.ubi</code> file and rename it to <code>hps.bin</code> as Programming File Generator needs the <code>.bin</code> extension:</p> <pre><code>ubinize -o root.ubi -p 65536 -m 1 -s 1 ubinize.cfg\nln -s root.ubi hps.bin\n</code></pre> <p>6. Create the JIC file:</p> <pre><code>quartus_pfg -c agilex5_devkit_flash_image_hps.pfg\n</code></pre>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-nand-board_1","title":"HPS NAND Board","text":"<p>This section presents how to build the binaries for HPS NAND Board, for booting from eMMC.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-emmc-binaries","title":"Build eMMC binaries","text":"<p>The following diagram shows how to build the eMMC binaries that target the HPS NAND Daughtercard: </p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf gsrd.emmc\nmkdir gsrd.emmc\ncd gsrd.emmc\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path:</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 DAUGHTER_CARD=devkit_dc_emmc generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>1. Save the <code>core.rbf</code> as <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf</code> </p> <p>2. Update the recipe <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb</code> as follows:  </p> <ul> <li>Replace the entry <code>${GHRD_REPO}/agilex5_dk_a5e065bb32aes1_emmc_${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_emmc_core</code> with <code>file://agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf;sha256sum=&lt;CORE_SHA&gt;</code> where <code>CORE_SHA</code> is the sha256 checksum of the file</li> <li>Delete the line <code>SRC_URI[agilex5_dk_a5e065bb32aes1_emmc_core.sha256sum] = \"bf11c8cb3b6d9487f93ce0e055b1e5256998a25b25ac4690bef3fcd6225ee1ae\"</code> The above are achieved by the following instructions:</li> </ul> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\nOLD_URI=\"\\${GHRD_REPO}\\/agilex5_dk_a5e065bb32aes1_emmc_\\${ARM64_GHRD_CORE_RBF};name=agilex5_dk_a5e065bb32aes1_emmc_core\"\nCORE_SHA=$(sha256sum $CORE_RBF | cut -f1 -d\" \")\nNEW_URI=\"file:\\/\\/agilex5_dk_a5e065bb32aes1_emmc_ghrd.core.rbf;sha256sum=$CORE_SHA\"\nsed -i \"s/$OLD_URI/$NEW_URI/g\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\nsed -i \"/agilex5_dk_a5e065bb32aes1_emmc_core\\.sha256sum/d\" $WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/hw-ref-design.bb\n</code></pre> Build Yocto <p>Remove reference to patch which was retired after 24.2 tag was applied:</p> <pre><code>sed -i '/fix-potential-signed-overflow-in-pointer-arithmatic.patch/d' meta-intel-fpga-refdes/recipes-connectivity/openssh/openssh_%.bbappend\n</code></pre> <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot.itb</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul> Building QSPI Helper JIC <p>We are writing the eMMC Flash by using U-Boot commands. We are getting to U-Boot prompt by booting from QSPI using a helper JIC image which contains U-Boot, thereby not relying on what is already in eMMC. The following diagram illustrates how the helper JIC is built, base on the GHRD and Yocto compilation results: </p> <p>1. Create folder to contain the helper JIC artifacts</p> <pre><code>cd $TOP_FOLDER\nrm -rf jic-helper\nmkdir jic-helper\n</code></pre> <p>2. Retrieve the .pfg file instructing the Quartus Programming File Generator on how to create the JIC file, and tweak it a little bit to make it smaller:</p> <pre><code>cd jic-helper\nwget https://releases.rocketboards.org/2024.05/emmc/agilex5_dk_a5e065bb32aes1_emmc/uboot-only.pfg\nsed -i 's/directory=/hps=\"1\" directory=/g' uboot-only.pfg\nsed -i 's/type=\"JIC\"/type=\"PERIPH_JIC\"/g' uboot-only.pfg\nsed -i 's/MT25QU02G/MT25QU01G/g' uboot-only.pfg\n</code></pre> <p>3. Bring in the files that are needed:</p> <pre><code>ln -s $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex .\nln -s $TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof .\n</code></pre> <p>4. Process <code>u-boot.itb</code> file to be exactly 2MB in size, and have a <code>.bin</code> extension as needed by Quartus Programming File Generator:</p> <pre><code>cp $TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot.itb .\nuboot_part_size=2*1024*1024\nuboot_size=`wc -c &lt; u-boot.itb`\nuboot_pad=\"$((uboot_part_size-uboot_size))\"\ntruncate -s +$uboot_pad u-boot.itb\nmv u-boot.itb u-boot.bin\n</code></pre> <p>5. Create the JIC file:</p> <pre><code>quartus_pfg -c uboot-only.pfg\n</code></pre> <p>The following file will be created:</p> <ul> <li><code>$TOP_FOLDER/jic-helper/agilex_flash_image.hps.jic</code></li> </ul>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#hps-test-board_1","title":"HPS Test Board","text":"<p>This section presents how to build the binaries for HPS Test Board.</p>"},{"location":"embedded-designs/agilex-5/e-series/premium/gsrd/ug-gsrd-agx5e-premium/#build-sd-card-binaries","title":"Build SD Card Binaries","text":"<p>The following diagram shows how the binaries are built for the HPS Test Daughtercard:  </p> <p></p> Setup Environment <p>1. Create the top folder to store all the build artifacts:</p> <pre><code>sudo rm -rf gsrd.test\nmkdir gsrd.test\ncd gsrd.test\nexport TOP_FOLDER=`pwd`\n</code></pre> <p>2. Download and setup the build toolchain. It will be used only by the GHRD makefile to build the debug HPS FSBL, to build the _hps_debug.sof file:</p> <pre><code>cd $TOP_FOLDER\nwget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel\\\n/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\ntar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nrm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz\nexport PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH\nexport ARCH=arm64\nexport CROSS_COMPILE=aarch64-none-linux-gnu-\n</code></pre> <p>3. Set up the Quartus tools in the PATH, so they are accessible without full path</p> <pre><code>export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre> Build Hardware Design <pre><code>cd $TOP_FOLDER\nrm -rf ghrd-socfpga agilex5_soc_devkit_ghrd\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga\nmv ghrd-socfpga/agilex5_soc_devkit_ghrd .\nrm -rf ghrd-socfpga\ncd agilex5_soc_devkit_ghrd\nmake config\nmake DEVICE=A5ED065BB32AE6SR0 HPS_EMIF_MEM_CLK_FREQ_MHZ=800 HPS_EMIF_REF_CLK_FREQ_MHZ=100 DAUGHTER_CARD=debug2 generate_from_tcl\nmake all\ncd ..\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof</code></li> <li><code>$TOP_FOLDER/agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof</code></li> </ul> Build Core RBF <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.rbf\nquartus_pfg -c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0_hps_debug.sof ghrd_a5ed065bb32ae6sr0.rbf -o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf</code></li> </ul> Set Up Yocto <p>1. Clone the Yocto script and prepare the build:</p> <pre><code>cd $TOP_FOLDER\nrm -rf gsrd-socfpga\ngit clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/gsrd-socfpga\ncd gsrd-socfpga\n. agilex5_dk_a5e065bb32aes1-gsrd-build.sh\nbuild_setup\n</code></pre> Customize Yocto <p>Replace the file <code>$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_debug2_ghrd.core.rbf</code> with the rebuilt core.rbf file:</p> <pre><code>CORE_RBF=$WORKSPACE/meta-intel-fpga-refdes/recipes-bsp/ghrd/files/agilex5_dk_a5e065bb32aes1_debug2_ghrd.core.rbf\nrm -f $CORE_RBF\nln -s $TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.core.rbf $CORE_RBF\n</code></pre> Build Yocto <p>Remove reference to patch which was retired after 24.2 tag was applied:</p> <pre><code>sed -i '/fix-potential-signed-overflow-in-pointer-arithmatic.patch/d' meta-intel-fpga-refdes/recipes-connectivity/openssh/openssh_%.bbappend\n</code></pre> <p>Build Yocto:</p> <pre><code>bitbake_image\n</code></pre> <p>Gather files:</p> <pre><code>package\n</code></pre> <p>The following files are created:</p> <ul> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex</code></li> <li><code>$TOP_FOLDER/gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/sdimage.tar.gz</code></li> </ul> Build QSPI Image <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.jic ghrd_a5ed065bb32ae6sr0.core.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof ghrd_a5ed065bb32ae6sr0.jic \\\n-o device=MT25QU128 \\\n-o flash_loader=A5ED065BB32AE6SR0 \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o mode=ASX4 \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.jic</code></li> </ul> Build HPS RBF <p>This is an optional step, in which you can build an HPS RBF file, which can be used to configure the HPS through JTAG instead of QSPI though the JIC file.</p> <pre><code>cd $TOP_FOLDER\nrm -f ghrd_a5ed065bb32ae6sr0.hps.rbf\nquartus_pfg \\\n-c agilex5_soc_devkit_ghrd/output_files/ghrd_a5ed065bb32ae6sr0.sof  ghrd_a5ed065bb32ae6sr0.rbf \\\n-o hps_path=gsrd-socfpga/agilex5_dk_a5e065bb32aes1-gsrd-images/u-boot-agilex5-socdk-gsrd-atf/u-boot-spl-dtb.hex \\\n-o hps=1\n</code></pre> <p>The following file is created:</p> <ul> <li><code>$TOP_FOLDER/ghrd_a5ed065bb32ae6sr0.hps.rbf</code></li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/","title":"Agilex\u2122 7 SoC HPS Remote System Update Example","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on the Agilex\u2122 7 Transceiver-SoC Development kit P-Tile E-Tile production Linear power solution (DK-SI-AGF014EB), including the following.</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> </ul> <ul> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> </ul> <ul> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>Refer to Agilex\u2122 7 Hard Processor System Remote System Update User Guide for details about the Remote System Update. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#component-versions","title":"Component Versions","text":"<p>This example was created with Quartus Prime Pro 24.2 and the following component versions.</p> Repository Branch/Tag ghrd-socfpga releases/24.2/QPDS24.2_REL_GSRD_PR linux-socfpga socfpga-6.6.22-lts/QPDS24.2_REL_GSRD_PR arm-trustedfirmware socfpga_v2.10.1/QPDS24.2_REL_GSRD_PR u-boot-socfpga socfpga_v2024.01/QPDS24.2_REL_GSRD_PR intel-rsu master <p>For RSU example previous 24.2 version, please refer to Agilex 7 SoC HPS Remote System Update.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus Prime Pro Edition software version 24.2  for compiling the hardware projects, generating the flash images and writing to flash </li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li>Agilex 7 Transceiver-SoC Development kit P-Tile E-Tile Production Linear power solution(DK-SI-AGF014EB)  for running the example. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are these.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul> <p>Note: ** To build binaries for a different development kit than the one used in this page, please refer to the **Building the Hardware Projects section in the corresponding  GSRD page for that development kit, which is the section that may differ from the instructions presented here.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf agilex-rsu mkdir agilex-rsu cd agilex-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download build toolchain and setup environment.</p> <pre><code>cd $TOP_FOLDER wget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\ \ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz tar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz rm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz export PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH export ARCH=arm64 export CROSS_COMPILE=aarch64-none-linux-gnu- export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next.</p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below.</p> <pre><code>cd $TOP_FOLDER # compile hardware designs: 0-factory, 1,2-applications, 3-factory update \nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw git clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/agilex_soc_devkit_ghrd . rm -rf ghrd-socfpga # boot from FPGA \nexport BOOTS_FIRST=fpga # enable watchdog \nexport ENABLE_WATCHDOG_RST=1 # treat watchdog timeout as configuration failure to trigger RSU \nexport WATCHDOG_RST_ACTION=remote_update\n# Select Linal regulator\nexport BOARD_PWRMGT=linear\n# disable SGMII to build faster \nexport HPS_ENABLE_SGMII=0 # disable PR to build faster \nexport ENABLE_PARTIAL_RECONFIGURATION=0 for version in {0..3} do rm -rf ghrd.$version cp -r agilex_soc_devkit_ghrd ghrd.$version cd ghrd.$version # update sysid to make binaries slightly different \nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' create_ghrd_qsys.tcl make scrub_clean_all\nmake generate_from_tcl echo \"set_global_assignment -name RSU_MAX_RETRY_COUNT 3\" &gt;&gt; ghrd_agfb014r24b2e2v.qsf # Change the board id to be zero - the one used when booting from SD card \nsed -i 's/set_global_assignment -name STRATIX_JTAG_USER_CODE .*/set_global_assignment -name STRATIX_JTAG_USER_CODE 4/g' ghrd_agfb014r24b2e2v.qsf make all\ncd .. done rm -rf agilex_soc_devkit_ghrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created.</p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/socfpga_v2.10.1 \nmake bl31 PLAT=agilex DEPRECATED=1 cd .. </code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga # comment out next line to use the latest default branch \n# git checkout -b test -t origin/socfpga_v2024.01 \n# enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk # use 'Image' for kernel image instead of 'kernel.itb' \nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi # link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/agilex/release/bl31.bin . # Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment-agilex \n# - Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n \nCONFIG_SPL_NAND_SUPPORT=n \nCONFIG_CMD_NAND_TRIMFFS=n \nCONFIG_CMD_NAND_LOCK_UNLOCK=n \nCONFIG_NAND_DENALI_DT=n \nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n \nCONFIG_SPL_NAND_FRAMEWORK=n \nCONFIG_CMD_NAND=n \nCONFIG_MTD_RAW_NAND=n \nCONFIG_CMD_UBI=n \nCONFIG_CMD_UBIFS=n \nCONFIG_MTD_UBI=n \nCONFIG_ENV_IS_IN_UBI=n \nCONFIG_UBI_SILENCE_MSG=n \nCONFIG_UBIFS_SILENCE_MSG=n \n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"bridge enable;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_SPL_DOS_PARTITION=y \nCONFIG_CMD_PART=y \nCONFIG_SPL_CRC32=y \nCONFIG_LZO=y \nCONFIG_CMD_DHCP=y \nCONFIG_SYS_PROMPT=\"SOCFPGA # \" \nEOF # build U-Boot \nmake clean &amp;&amp; make mrproper make socfpga_agilex_defconfig # Use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-agilex make -j 48 cd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux.</p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone https://github.com/altera-opensource/linux-socfpga cd linux-socfpga # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/socfpga-6.6.22-lts \n# configure the RSU driver to be built into the kernel \nmake clean &amp;&amp; make mrproper make defconfig ./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y make oldconfig make -j 48 Image dtbs cd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is provided below so and you can easily create the initial flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER # Create automatically the .pfg file\ncat &lt;&lt; EOF &gt; initial_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.0/output_files/ghrd_agfb014r24b2e2v.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n        &lt;bitstream id=\"Bitstream_2\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;hw/ghrd.0/output_files/ghrd_agfb014r24b2e2v.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0020FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00210000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x02000000\" e_addr=\"0x02FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03000000\" e_addr=\"0x03FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;AGFB014R24B&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/intelFPGA_pro/24.1/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg </code></pre> <p>Here are the complete instructions on how to manually create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER qpfgw &amp; </code></pre> </li> <li> <p>Select the Device family as Agilex 7, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bitswap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file ghrd_agfb014r24b2e2v.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/output_files/ghrd_agfb014r24b2e2v.sof image. This is the initial application image. The tab now looks like below.</p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. This opens the window to browse for the FSBL and select authentication and encryption settings. </p> <p> </p> </li> <li> <p>Click the Bootloader  (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the MT25QU02G in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (ghrd_agfb014r24b2e2v.sof). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0090FFFF in order to reserve 7MB for the factory image. This end address was calculated by adding 8MB to the end of the BOOT_INFO partition. Click OK. </p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be trieed after all the application images failed. </p> </li> <li> <p>Select the MT25QU02G flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(ghrd_agfb014r24b2e2v.sof). This becomes the initial application image. Select the Page as 1. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x01000000 and End Address = 0x01FFFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.   The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image</p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions) and set the start and end addresses as follows. </p> <p>* P2: Start Address = 0x02000000 and End Address = 0x02FFFFFF.    * P3: Start Address = 0x03000000 and End Address = 0x03FFFFFF. </p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER quartus_pfg -c initial_image.pfg </code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -rf images/application2.rpd quartus_pfg -c hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof \\ \nimages/application2.rpd \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o bitswap=ON </code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/factory_update.rpd quartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\ \nimages/factory_update.rpd \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o bitswap=ON \\ \n-o rsu_upgrade=ON </code></pre> <p>The following factory update image is created. </p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/decision_firmware_update.rpd quartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\ \nimages/decision_firmware_update.rpd \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o bitswap=ON \\ \n-o rsu_upgrade=ON \\ \n-o firmware_only=ON </code></pre> <p>The following decision firmware update image is created. </p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/combined_application.rpd quartus_pfg -c hw/ghrd.3/output_files/ghrd_agfb014r24b2e2v.sof \\ \nimages/combined_application.rpd \\ \n-o app_image=hw/ghrd.2/output_files/ghrd_agfb014r24b2e2v.sof \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o bitswap=ON \\ \n-o rsu_upgrade=ON \\ \n-o app_image_only=ON </code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <ol> <li> <p>Various packages may be needed by the build system. On a Ubuntu 22.04 machine the following command was used to install the required packages.</p> <pre><code>sudo apt-get update sudo apt-get upgrade sudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\ \nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\ \npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd \\ \nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\ \ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\ \ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y </code></pre> </li> <li> <p>Run the following commands to build the root file system.</p> <p><pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b scarthgap https://git.yoctoproject.org/poky git clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga git clone -b scarthgap https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"agilex7_dk_si_agf014eb\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal </code></pre> </p> </li> </ol> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf zlib-1.3.1 wget http://zlib.net/zlib-1.3.1.tar.gz tar xf zlib-1.3.1.tar.gz rm zlib-1.3.1.tar.gz cd zlib-1.3.1/ export CROSS_PREFIX=${CROSS_COMPILE} ./configure make export ZLIB_PATH=`pwd` cd .. </code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.3.1/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.3.1/libz.so* - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application. </p> <pre><code>cd $TOP_FOLDER rm -rf intel-rsu git clone https://github.com/altera-opensource/intel-rsu cd intel-rsu # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/master \ncd lib # add -I$(ZLIB_PATH) to CFLAGS \nsed -i 's/\\(CFLAGS := .*\\)$/\\1 -I\\$\\(ZLIB_PATH\\)/g' makefile make cd .. cd example # add -L$(ZLIB_PATH) to LDFLAGS \nsed -i 's/\\(LDFLAGS := .*\\)$/\\1 -L\\$\\(ZLIB_PATH\\)/g' makefile make cd .. cd .. </code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/intel-rsu/lib/librsu.so - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/intel-rsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/intel-rsu/example/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example.</p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2021.04/gsrd/\\ \ntools/make_sdimage_p3.py chmod +x make_sdimage_p3.py # prepare the fat contents \nmkdir fat &amp;&amp; cd fat cp $TOP_FOLDER/u-boot-socfpga/u-boot.itb . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/intel/socfpga_agilex_socdk.dtb . cp $TOP_FOLDER/images/*.rpd . cd .. # prepare the rootfs partition contents \nmkdir rootfs &amp;&amp; cd rootfs sudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/agilex7_dk_si_agf014eb/core-image-minimal-agilex7_dk_si_agf014eb.rootfs.tar.gz\nsudo sed -i 's/agilex7_dk_si_agf014eb/linux/g' etc/hostname\nsudo rm -rf lib/modules/* sudo cp $TOP_FOLDER/images/*.rpd home/root sudo cp $TOP_FOLDER/intel-rsu/example/rsu_client home/root/ sudo cp $TOP_FOLDER/intel-rsu/lib/librsu.so lib/ sudo cp $TOP_FOLDER/intel-rsu/etc/qspi.rc etc/librsu.rc sudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/ cd .. # create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\ \n-P fat/*,num=1,format=vfat,size=100M \\ \n-P rootfs/*,num=2,format=ext3,size=100M \\ \n-s 256M \\ \n-n sdcard_rsu.img cd .. </code></pre> <p>This creates the SD card image as </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card. </p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Agilex SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to JTAG. </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer.</p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\" </code></pre> </li> <li> <p>Configure the Agilex SoC Development Kit switches to have MSEL set to QSPI. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Agilex SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <ol> <li> <p>Power up the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2024.01-33547-g098abd8f13-dirty (Aug 19 2024 - 12:15:42 -0500)\nReset state: Cold\nMPU          1200000 kHz\nL4 Main       400000 kHz\nL4 sys free   100000 kHz\nL4 MP         200000 kHz\nL4 SP         100000 kHz\nSDMMC          50000 kHz\nDDR: 8192 MiB\nSDRAM-ECC: Initialized success with 1722 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nNOTICE:  BL31: v2.10.1  (release):QPDS24.2_REL_GSRD_PR\nNOTICE:  BL31: Built : 12:14:02, Aug 19 2024\nU-Boot 2024.01-33547-g098abd8f13-dirty (Aug 19 2024 - 12:15:42 -0500)socfpga_agilex\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Agilex SoCDK\nDRAM:  2 GiB (effective 8 GiB)\nCore:  28 devices, 23 uclasses, devicetree: separate\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:   Warning: ethernet@ff800000 (eth0) using random MAC address - 86:c6:bd:7c:4f:7d\neth0: ethernet@ff800000\nHit any key to stop autoboot:  0 SOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options. </p> <pre><code>SOCFPGA # rsu \nrsu - Agilex SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name lt;namegt; - find slot by name and display the slot number slot_count - display the slot count slot_disable lt;slotgt; - remove slot from CPB slot_enable lt;slotgt; - make slot the highest priority slot_erase lt;slotgt; - erase slot slot_get_info lt;slotgt; - display slot information slot_load lt;slotgt; - load slot immediately slot_load_factory - load factory immediately slot_priority lt;slotgt; - display slot priority slot_program_buf lt;slotgt; lt;buffergt; lt;sizegt; - program buffer into slot, and make it highest priority slot_program_buf_raw lt;slotgt; lt;buffergt; lt;sizegt; - program raw buffer into slot slot_program_factory_update_buf lt;slotgt; lt;buffergt; lt;sizegt; - program factory update buffer into slot, and make it highest priority slot_rename lt;slotgt; lt;namegt; - rename slot slot_delete lt;slotgt; - delete slot slot_create lt;namegt; lt;addressgt; lt;sizegt; - create slot slot_size lt;slotgt; - display slot size slot_verify_buf lt;slotgt; lt;buffergt; lt;sizegt; - verify slot contents against buffer slot_verify_buf_raw lt;slotgt; lt;buffergt; lt;sizegt; - verify slot contents against raw buffer status_log - display RSU status update lt;flash_offsetgt; - Initiate firmware to load bitstream as specified by flash_offset notify lt;valuegt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt lt;addressgt; - restore SPT from an address save_spt lt;addressgt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb lt;addressgt; - restore CPB from an address save_cpb lt;addressgt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00920000 RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00210000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000210000 Length: 0x00700000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code> SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 24.2.0 DCMF1 version = 24.2.0 DCMF2 version = 24.2.0 DCMF3 version = 24.2.0 SOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 16777216. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 16777216. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 16777216. </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased. SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n2248704 bytes read in 103 ms (20.8 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000002000000 size=2248704. SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Power cycle the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting the specific image to be loaded, in this case using the following command.</p> <pre><code>rsu slot_load 1 </code></pre> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands. </p> <pre><code>SOCFPGA # rsu update 0x01000000 \nRSU: RSU update to 0x0000000001000000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log to confirm it.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202:  both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report.</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code>SOCFPGA # mw.l 0xffd00204 0 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value. </p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf0061234 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it. </p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n2478080 bytes read in 113 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nSlot 2 was programmed with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=2478080. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2. </p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, stop U-Boot and check the RSU status log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x02000000 0x10000 \nSF: 16384 bytes @ 0x2000000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf004d003 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status. </p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 512 KB). </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x10000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d00f Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot. </p> <p><pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> 6. Pass control to the decision firmware update image. </p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs. </p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <p><pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK </code></pre> 4. Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <p><pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image : 0x01000000 Last Fail Image : 0x00100000 State : 0xf004d010 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre>   The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <p><pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> 6. Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted Current Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d011 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected. </p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created. </p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <p><pre><code>SOCFPGA # rsu clear_error_status \n</code></pre>   Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds. </p> <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. </p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x918000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status. </p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF Bad SPT0 magic number 0xFFFFFFFF no valid SPT0 and SPT1 found Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the highest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails. </p> <pre><code>SOCFPGA # rsu slot_count \ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <ol> <li> <p>Power up the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message. </p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 21.2.0 DCMF1 version = 21.2.0 DCMF2 version = 21.2.0 DCMF3 version = 21.2.0 Operation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status.  It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Important Note: Causing the newly written application image to be loaded can also be done without a power cycle, by requesting a specific image to be loaded, using the following commands.</p> <pre><code>./rsu_client --request 1 reboot </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following. </p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202:both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report .</p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux.</p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number. </p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power up the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power up the board, boot Linux and display the status:  It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB. </p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot.</p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB. </p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is required to have the status available in Linux. </p> <ol> <li> <p>Power up the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions. </p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x200000 0x10000 \nSF: 4096 bytes @ 0x200000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --    slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image. </p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is not rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status: </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash.</p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status. </p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> </li> </ol> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.  Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> <ol> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails. </p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created. </p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine. </p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#using-separate-ssbl-per-bitstream-example","title":"Using Separate SSBL Per Bitstream Example","text":"<p>When using Remote System Update on Stratix 10, Agilex 7, Agilex 5 and N5X devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/agilex-7/f-series/soc/rsu/ug-rsu-agx7f-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/","title":"Rsu separate ssbl","text":""},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#using-separate-ssbl-per-bitstream-example","title":"Using Separate SSBL Per Bitstream Example","text":"<p>When using Remote System Update on Stratix 10, Agilex 7, Agilex 5 and N5X devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/doc_modules/rsu/rsu-separate-ssbl/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/","title":"Stratix 10 SoC HPS Remote System Update Example","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#intro","title":"Intro","text":"<p>This page presents a complete Remote System Update example, running on Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D), including the following.</p> <ul> <li>Creating the initial flash image containing the following components.<ul> <li>Bitstreams for a factory image </li> <li>One application image </li> <li>Two empty slots to contain additional application images </li> </ul> </li> </ul> <ul> <li>Creating an SD card with the following components.<ul> <li>U-Boot </li> <li>Arm* Trusted Firmware </li> <li>Linux </li> <li>LIBRSU </li> <li>RSU client </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul> </li> </ul> <ul> <li>Exercising the Linux RSU client application. </li> <li>Exercising the U-Boot RSU commands. </li> </ul> <p>Refer to Stratix\u00ae 10 Hard Processor System Remote System Update User Guide for details about the Remote System Update. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#component-versions","title":"Component Versions","text":"<p>This example was created with Quartus Prime Pro 24.2 and the following component versions.</p> Repository Branch/Tag ghrd-socfpga releases/24.2/QPDS24.2_REL_GSRD_PR linux-socfpga socfpga-6.6.22-lts/QPDS24.2_REL_GSRD_PR arm-trustedfirmware socfpga_v2.10.1/QPDS24.2_REL_GSRD_PR u-boot-socfpga socfpga_v2024.01/QPDS24.2_REL_GSRD_PR intel-rsu master <p>For RSU example previous 24.2 version, please refer to Stratix 10 HPS Remote System Update.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#prerequisites","title":"Prerequisites","text":"<p>The following items are required to run the RSU example.</p> <ul> <li>Host PC running Ubuntu 22.04 LTS (other Linux versions may work too) </li> <li>Minimum 48 GB of RAM, required for compiling the hardware designs </li> <li>Quartus Prime Pro Edition software version 24.2  for compiling the hardware projects, generating the flash images and writing to flash </li> <li>Access to Internet to download the hardware project archive, clone the git trees for U-Boot, Arm Trusted Firmware, Linux, zlib and LIBRSU and to build the Linux rootfs using Yocto. </li> <li> Stratix 10 SX SoC Development Kit H-Tile (DK-SOC-1SSX-H-D) production version  for running the example. </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-binaries","title":"Building Binaries","text":"<p>The diagram below illustrates the build flow used for this example.</p> <p> </p> <p>The end results of the build flow are listed next.</p> <ul> <li>Initial flash image: contains the factory image, an application image and two empty application image partitions aka slots. </li> <li>SD card image: contains SSBL (U-Boot), ATF (Arm Trusted Firmware), Linux device tree, Linux kernel, Linux rootfs with the Intel RSU driver, LIBRSU, RSU Client, an application image, a factory update image and a decision firmware update image. </li> </ul> <p>Note: ** To build binaries for a different development kit than the one used in this page, please refer to the **Building the Hardware Projects section in the corresponding  GSRD page for that development kit, which is the section that may differ from the instructions presented here.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#setting-up-the-environment","title":"Setting up the Environment","text":"<p>Create a top folder to store the example files.</p> <pre><code>sudo rm -rf s10-rsu mkdir s10-rsu cd s10-rsu export set TOP_FOLDER=`pwd` </code></pre> <p>Download build toolchain and setup environment.</p> <pre><code>cd $TOP_FOLDER wget https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/\\ \ngcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz tar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz rm -f gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz export PATH=`pwd`/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:$PATH export ARCH=arm64 export CROSS_COMPILE=aarch64-none-linux-gnu- export QUARTUS_ROOTDIR=~/intelFPGA_pro/24.2/quartus/\nexport PATH=$QUARTUS_ROOTDIR/bin:$QUARTUS_ROOTDIR/linux64:$QUARTUS_ROOTDIR/../qsys/bin:$PATH\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-hardware-projects","title":"Building the Hardware Projects","text":"<p>Create four different hardware projects, based on the GHRD from GitHub with a few changes listed next. </p> <ul> <li>Change the boot mode to FPGA first </li> <li>Use a different ID in the SystemID component, to make the binaries for each project slightly different. </li> <li>Change the behavior of watchdog timeout, to trigger an RSU event. </li> <li>Set the max retry parameter to 3, so that each application image and the factory image are tried up to three time when configuration failures occur. </li> </ul> <p>The commands to create and compile the projects are listed below. </p> <pre><code>cd $TOP_FOLDER # compile hardware designs: 0-factory, 1,2-applications, 3-factory update \nrm -rf hw &amp;&amp; mkdir hw &amp;&amp; cd hw rm -rf ghrd-socfpga s10_soc_devkit_ghrd git clone -b QPDS24.2_REL_GSRD_PR https://github.com/altera-opensource/ghrd-socfpga mv ghrd-socfpga/s10_soc_devkit_ghrd . rm -rf ghrd-socfpga # use fpga configuration first mode \nexport BOOTS_FIRST=fpga # enable watchdog operation \nexport ENABLE_WATCHDOG_RST=1 # configure watchdog to trigger remote update \nexport WATCHDOG_RST_ACTION=remote_update # disable sgmii and partial reconfiguration - to decrease build time \nexport HPS_ENABLE_SGMII=0 export ENABLE_PARTIAL_RECONFIGURATION=0\n# Select device for S10 H-Tile\nexport QUARTUS_DEVICE=1SX280HU2F50E1VGAS\n\nfor version in {0..3} do rm -rf ghrd.$version cp -r s10_soc_devkit_ghrd ghrd.$version cd ghrd.$version # change sysid to make binaries slightly different \nsed -i 's/0xACD5CAFE/0xABAB000'$version'/g' create_ghrd_qsys.tcl make scrub_clean_all make generate_from_tcl echo \"set_global_assignment -name RSU_MAX_RETRY_COUNT 3\" &gt;&gt; ghrd_1sx280hu2f50e1vgas.qsf # change the board id to ha a simple boot from sd \nsed -i 's/set_global_assignment -name STRATIX_JTAG_USER_CODE .*/set_global_assignment -name STRATIX_JTAG_USER_CODE 0/g' ghrd_1sx280hu2f50e1vgas.qsf make all cd .. done rm -rf s10_soc_devkit_ghrd cd .. </code></pre> <p>After completing the above steps, the following SOF files are created are listed next. </p> <ul> <li>$TOP_FOLDER/hw/ghrd.0/output_files/ghrd_1sx280hu2f50e1vgas.sof </li> <li>$TOP_FOLDER/hw/ghrd.1/output_files/ghrd_1sx280hu2f50e1vgas.sof </li> <li>$TOP_FOLDER/hw/ghrd.2/output_files/ghrd_1sx280hu2f50e1vgas.sof </li> <li>$TOP_FOLDER/hw/ghrd.3/output_files/ghrd_1sx280hu2f50e1vgas.sof </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-arm-trusted-firmware","title":"Building Arm Trusted Firmware","text":"<p>The following commands are used to retrieve the Arm Trusted Firmware (ATF) and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf arm-trusted-firmware git clone https://github.com/altera-opensource/arm-trusted-firmware cd arm-trusted-firmware # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/socfpga_v2.10.1 \nmake bl31 PLAT=stratix10 DEPRECATED=1 cd .. </code></pre> <p>After completing the above steps, the Arm Trusted Firmware binary file is created and is located here.</p> <ul> <li>$TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-linux","title":"Building Linux","text":"<p>The following commands can be used to obtain the Linux source code and build Linux. </p> <pre><code>cd $TOP_FOLDER rm -rf linux-socfpga git clone https://github.com/altera-opensource/linux-socfpga cd linux-socfpga # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/socfpga-6.6.22-lts \n# configure the RSU driver to be built into the kernel \nmake clean &amp;&amp; make mrproper make defconfig ./scripts/config --set-val CONFIG_INTEL_STRATIX10_RSU y make oldconfig make -j 48 Image dtbs cd .. </code></pre> <p>After completing the above steps, the following files are created. </p> <ul> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image - kernel image </li> <li>$TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb - kernel device tree </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-u-boot","title":"Building U-Boot","text":"<p>The following commands can be used to get the U-Boot source code and compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf u-boot-socfpga git clone https://github.com/altera-opensource/u-boot-socfpga cd u-boot-socfpga # comment out next line to use the latest default branch \n# git checkout -b test -t origin/socfpga_v2024.01 \n# enable dwarf4 debug info, for compatibility with arm ds \nsed -i 's/PLATFORM_CPPFLAGS += -D__ARM__/PLATFORM_CPPFLAGS += -D__ARM__ -gdwarf-4/g' arch/arm/config.mk # use 'Image' for kernel image instead of 'kernel.itb' \nsed -i 's/kernel\\.itb/Image/g' arch/arm/Kconfig\n# only boot from SD, do not try QSPI and NAND \nsed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;mmc;/g' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # disable NAND in the device tree \nsed -i '/&amp;nand {/!b;n;c\\\\tstatus = \"disabled\";' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # remove the NAND configuration from device tree \nsed -i '/images/,/binman/{/binman/!d}' arch/arm/dts/socfpga_stratix10_socdk-u-boot.dtsi # link to atf \nln -s $TOP_FOLDER/arm-trusted-firmware/build/stratix10/release/bl31.bin . # Create configuration custom file. \ncat &lt;&lt; EOF &gt; config-fragment-stratix10 \n# - Disable NAND/UBI related settings from defconfig. \nCONFIG_NAND_BOOT=n \nCONFIG_SPL_NAND_SUPPORT=n \nCONFIG_CMD_NAND_TRIMFFS=n \nCONFIG_CMD_NAND_LOCK_UNLOCK=n \nCONFIG_NAND_DENALI_DT=n \nCONFIG_SYS_NAND_U_BOOT_LOCATIONS=n \nCONFIG_SPL_NAND_FRAMEWORK=n \nCONFIG_CMD_NAND=n \nCONFIG_MTD_RAW_NAND=n \nCONFIG_CMD_UBI=n \nCONFIG_CMD_UBIFS=n \nCONFIG_MTD_UBI=n \nCONFIG_ENV_IS_IN_UBI=n \nCONFIG_UBI_SILENCE_MSG=n \nCONFIG_UBIFS_SILENCE_MSG=n \n# - Disable distroboot and use specific boot command. \nCONFIG_DISTRO_DEFAULTS=n \nCONFIG_HUSH_PARSER=y \nCONFIG_SYS_PROMPT_HUSH_PS2=\"&gt; \" \nCONFIG_USE_BOOTCOMMAND=y \nCONFIG_BOOTCOMMAND=\"bridge enable;run mmcload;run linux_qspi_enable;run rsu_status;run mmcboot\" \nCONFIG_CMD_FAT=y \nCONFIG_CMD_FS_GENERIC=y \nCONFIG_DOS_PARTITION=y \nCONFIG_SPL_DOS_PARTITION=y \nCONFIG_CMD_PART=y \nCONFIG_SPL_CRC32=y \nCONFIG_LZO=y \nCONFIG_CMD_DHCP=y \nCONFIG_SYS_PROMPT=\"SOCFPGA # \" \nEOF # build U-Boot \nmake clean &amp;&amp; make mrproper make socfpga_stratix10_defconfig # Use created custom configuration file to merge with the default configuration obtained in .config file. \n./scripts/kconfig/merge_config.sh -O ./ ./.config ./config-fragment-stratix10 make -j 48 cd .. </code></pre> <p>After completing the above steps, the following files are created.</p> <ul> <li>$TOP_FOLDER/u-boot-socfpga/spl/u-boot-spl-dtb.hex - FSBL (U-boot SPL) hex file </li> <li>$TOP_FOLDER/u-boot-socfpga/u-boot.itb - FIT image file containing SSBL (U-Boot) and ATF (Arm Trusted Firmware) binaries </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-initial-flash-image","title":"Creating the Initial Flash Image","text":"<p>This section presents detailed instructions on how to create the initial flash image, by using the Programming File Generator. </p> <p>For reference, an example of the  Programming File Generator configuration file is provided below so and you can easily create the initial flash image by passing it to the Programming File Generator as shown below.</p> <pre><code>cd $TOP_FOLDER cat &lt;&lt; EOF &gt; initial_image.pfg\n&lt;pfg version=\"1\"&gt;\n    &lt;settings custom_db_dir=\"./\" mode=\"ASX4\"/&gt;\n    &lt;output_files&gt;\n        &lt;output_file name=\"initial_image\" directory=\"./\" type=\"JIC\"&gt;\n            &lt;file_options/&gt;\n            &lt;secondary_file type=\"MAP\" name=\"initial_image_jic\"&gt;\n                &lt;file_options/&gt;\n            &lt;/secondary_file&gt;\n            &lt;secondary_file type=\"SEC_RPD\" name=\"initial_image_jic\"&gt;\n                &lt;file_options bitswap=\"1\"/&gt;\n            &lt;/secondary_file&gt;\n            &lt;flash_device_id&gt;Flash_Device_1&lt;/flash_device_id&gt;\n        &lt;/output_file&gt;\n    &lt;/output_files&gt;\n    &lt;bitstreams&gt;\n        &lt;bitstream id=\"Bitstream_1\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.0/output_files/ghrd_1sx280hu2f50e1vgas.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n        &lt;bitstream id=\"Bitstream_2\"&gt;\n            &lt;path signing=\"OFF\" finalize_encryption=\"0\" hps_path=\"./u-boot-socfpga/spl/u-boot-spl-dtb.hex\"&gt;./hw/ghrd.1/output_files/ghrd_1sx280hu2f50e1vgas.sof&lt;/path&gt;\n        &lt;/bitstream&gt;\n    &lt;/bitstreams&gt;\n    &lt;flash_devices&gt;\n        &lt;flash_device type=\"MT25QU02G\" id=\"Flash_Device_1\"&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"0x00000000\" e_addr=\"0x0010FFFF\" fixed_e_addr=\"1\" id=\"BOOT_INFO\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" extra_space=\"262144\" fixed_s_addr=\"1\" s_addr=\"0x00110000\" e_addr=\"0x0090FFFF\" fixed_e_addr=\"0\" id=\"FACTORY_IMAGE\" size=\"0\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"SPT1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB0\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"1\" fixed_s_addr=\"1\" s_addr=\"auto\" e_addr=\"auto\" fixed_e_addr=\"1\" id=\"CPB1\" size=\"65536\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x01000000\" e_addr=\"0x01FFFFFF\" fixed_e_addr=\"0\" id=\"P1\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x02000000\" e_addr=\"0x02FFFFFF\" fixed_e_addr=\"0\" id=\"P2\" size=\"0\"/&gt;\n            &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x03000000\" e_addr=\"0x03FFFFFF\" fixed_e_addr=\"0\" id=\"P3\" size=\"0\"/&gt;\n        &lt;/flash_device&gt;\n        &lt;flash_loader&gt;1SX280HU2F50E1VGAS&lt;/flash_loader&gt;\n    &lt;/flash_devices&gt;\n    &lt;assignments&gt;\n        &lt;assignment page=\"0\" partition_id=\"FACTORY_IMAGE\"&gt;\n            &lt;bitstream_id&gt;Bitstream_1&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n        &lt;assignment page=\"1\" partition_id=\"P1\"&gt;\n            &lt;bitstream_id&gt;Bitstream_2&lt;/bitstream_id&gt;\n        &lt;/assignment&gt;\n    &lt;/assignments&gt;\n&lt;/pfg&gt;\nEOF\n# Create Initial Image for previous release (in case needed to test  combined application)\n~/intelFPGA_pro/24.1/quartus/bin/quartus_pfg -c initial_image.pfg\nmv initial_image.jic initial_image_prev.jic\nmv initial_image_jic.rpd initial_image_jic_prev.rpd\nmv initial_image_jic.map initial_image_jic_prev.map\n\n# Create Initial Image for this release\nquartus_pfg -c initial_image.pfg </code></pre> <p>Here are the complete instructions on how to create the initial flash image, without relying on the provided Programming File Generator configuration file.</p> <ol> <li> <p>Start the Programming File Generator tool by running the qpfgw command.</p> <pre><code>cd $TOP_FOLDER qpfgw &amp; </code></pre> </li> <li> <p>Select the Device family as Stratix 10, and Configuration mode as Active Serial x4. </p> </li> <li> <p>Change the Name to initial_image. </p> </li> <li> <p>Select the output file type as JTAG Indirect Configuration File (. jic ), which is the format used by the Quartus Prime Programmer tool for writing to the QSPI flash. </p> </li> <li> <p>Select the optional Memory Map File (.map ) file so that it is also generated. The .map file contains information about the resulted flash layout. </p> </li> <li> <p>Select the optional Raw Programming Data File (.rpd ) file so that it is also generated. This file contains the binary flash content, without anything else added. </p> <p>The window looks similar to this.</p> <p> </p> </li> <li> <p>Click the Raw Programming Data File (.rpd ) file to select it. Then click the Edit ... button and select the Bitswap option to be \"On\". This enables the RPD file to be usable by HPS software like U-Boot and Linux if needed. </p> </li> <li> <p>Once the output type was selected, click the Input Files tab. </p> </li> <li> <p>In the Input Files tab click the Add Bitstream button, then browse to $TOP_FOLDER/hw/ghrd.0/output_files, select the file ghrd_1sx280hu2f50e1vgas.sof, and then click Open. This is the initial factory image. Do the same for the $TOP_FOLDER/hw/ghrd.1/output_files/ghrd_1sx280hu2f50e1vgas.sof image. This is the initial application image. The tab now looks like below. </p> <p> </p> </li> <li> <p>Click the first .sof file, then click the Properties button on the right side. This opens the window to browse for the FSBL and select authentication and encryption settings. </p> <p> </p> </li> <li> <p>Click the Bootloader (Browse) button and select the file $TOP_FOLDER/uboot-socfpga/spl/u-boot-spl-dtb.hex, then click OK. </p> </li> <li> <p>Click the second .sof file and add the same FSBL file to it. The Input Files tab now looks like shown below.</p> <p> </p> </li> <li> <p>Click the Configuration Device tab. Note that the tab is only enabled once at least one input file was added in the Input Files tab. </p> </li> <li> <p>Because more than one input file was added in the Input Files tab, it displays the options for remote system update. Otherwise, it only enables the standard configuration flow. </p> </li> <li> <p>In the Configuration Device tab, click Add Device, select the MT25QU02G in the dialog box window, then click OK. Once that is done, the window displays the default initial partitioning for RSU.</p> <p> </p> </li> <li> <p>Select the FACTORY_IMAGE entry, and click the Edit button. The Edit Partition window pops up. Select the Input file as Bitstream_1 (ghrd_1sx280hu2f50e1vgas). Change Address Mode to Block because you want to make sure you are leaving enough space for the biggest factory image you anticipate using. Set the End Address to 0x0090FFFF in order to reserve 8MB for the factory image. This end address was calculated by adding 8MB to the end of the BOOT_INFO partition. Click OK. </p> <p> </p> <p>Note: The Page property for FACTORY_IMAGE partition must always be set to 0. This means that the FACTORY_IMAGE will be trieed after all the application images failed. </p> </li> <li> <p>Select the MT25QU02G flash device in the Configuration Device tab by clicking it, then click the Add Partition button to open the Add Partition window. Leave the Name as P1 and select the Input file as Bitstream_2(ghrd_1sx280hu2f50e1vgas.sof). This becomes the initial application image. Select the Address Mode as Block and allocate 16MB of data by setting Start Address = 0x01000000 and End Address = 0x01FFFFFF. Since this is the first partition defined, this becomes the initial application image to be loaded and has the highest priority of all application images that may be defined later.</p> <p>The actual priority in which an application in a partition is loaded is defined based on the order in which the partition is defined when creating the initial flash image as shown above in this step.   The Programming File Generator issues an error if there are multiple partitions with the same page number, or if there are any \u201cgaps\u201d as in having a Page=1 then a Page=3, without a Page=2 for example.</p> <p>Only up to seven partitions can contain application images at initial flash image creation time. This limitation does not have adverse effects, as typically at creation time it is expected to have just a factory image and one application image. </p> </li> <li> <p>Create two more partitions P2 and P3 using the same procedure as for the previous step, except set the Input file to None, leave Page unchanged (it does not matter for empty partitions) and set the start and end addresses as follows.</p> <p>* P2: Start Address = 0x02000000 and End Address = 0x02FFFFFF.    * P3: Start Address = 0x03000000 and End Address = 0x03FFFFFF. </p> </li> <li> <p>Click Select to select the Flash loader. The flash loader becomes part of the JIC file and is used by the Flash Programmer tool. Select the desired Device family and Device name as shown below.</p> <p> </p> <p>The Configuration Device tab now looks like as shown below.</p> <p> </p> </li> <li> <p>You require to change the size of the SPTs and CPBs to 64 KB hence the HPS software uses now this size. This is done by selecting any of the components and pressing the Edit button. Expect to see a menu where you can select the option desired. Select the 64 KB size. You only need to update the size of one of these components and can expect to see the rest updated automatically with the same value chosen. </p> <p> </p> </li> <li> <p>Click File &gt; Save As .. and save the file as $TOP_FOLDER/initial_image.pfg. This file can be useful later, if you wanted to re-generate the initial image by using the command.</p> <pre><code>cd $TOP_FOLDER quartus_pfg -c initial_image.pfg </code></pre> <p>Note: The created pfg file is actually an XML file which can be manually edited to replace the absolute file paths with relative file paths. You cannot directly edit the .pfg file for other purposes. The .pfg file can be opened from Programming File Generator, if changes are needed. </p> </li> <li> <p>Click the Generate button to generate the initial flash image as $TOP_FOLDER/initial_image.jic and the map file as $TOP_FOLDER/initial_image_jic.map. A dialog box opens indicating the files were generated successfully. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-application-image","title":"Creating the Application Image","text":"<p>The following commands are used to create the application image used in this example. </p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -rf images/application2.rpd quartus_pfg -c hw/ghrd.2/output_files/ghrd_1sx280hu2f50e1vgas.sof \\ \nimages/application2.rpd \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o bitswap=ON </code></pre> <p>The following application image is created.</p> <ul> <li>$TOP_FOLDER/images/application2.rpd. </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-factory-update-image","title":"Creating the Factory Update Image","text":"<p>The following commands are used to create the factory update image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/factory_update.rpd quartus_pfg -c hw/ghrd.3/output_files/ghrd_1sx280hu2f50e1vgas.sof \\ \nimages/factory_update.rpd \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o bitswap=ON \\ \n-o rsu_upgrade=ON </code></pre> <p>The following factory update image is created.</p> <ul> <li>$TOP_FOLDER/images/factory_update.rpd </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-decision-firmware-update-image","title":"Creating the Decision Firmware Update Image","text":"<p>The following commands are used to create the decision firmware update image used in this example. </p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/decision_firmware_update.rpd quartus_pfg -c hw/ghrd.3/output_files/ghrd_1sx280hu2f50e1vgas.sof \\ \nimages/decision_firmware_update.rpd \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o bitswap=ON \\ \n-o rsu_upgrade=ON \\ \n-o firmware_only=ON </code></pre> <p>The following decision firmware update image is created.</p> <ul> <li>$TOP_FOLDER/images/decision_firmware_update.rpd </li> </ul> <p>Note: The provided SOF file is used by the quartus_pfg to determine the parameters that are writen to the decision firmware data structure. This includes QSPI clock and pin settings, the value of max_retry parameter, and the selected behavior of the HPS watchdog. The actual configuration data from the SOF file is not used. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#creating-the-combined-application-image","title":"Creating the Combined Application Image","text":"<p>The following commands are used to create the combined application image used in this example.</p> <pre><code>cd $TOP_FOLDER mkdir -p images rm -f images/combined_application.rpd quartus_pfg -c hw/ghrd.3/output_files/ghrd_1sx280hu2f50e1vgas.sof \\ \nimages/combined_application.rpd \\ \n-o app_image=hw/ghrd.2/output_files/ghrd_1sx280hu2f50e1vgas.sof \\ \n-o hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o app_image_hps_path=u-boot-socfpga/spl/u-boot-spl-dtb.hex \\ \n-o mode=ASX4 \\ \n-o bitswap=ON \\ \n-o rsu_upgrade=ON \\ \n-o app_image_only=ON </code></pre> <p>The following file is created.</p> <ul> <li>$TOP_FOLDER/images/combined_application.rpd </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-root-file-system","title":"Building the Root File System","text":"<p>A root file system is required to boot Linux. There are a lot of ways to build a root file system, depending on your specific needs. This section shows how to build a small root file system using Yocto. </p> <ol> <li> <p>Various packages may be needed by the build system. On a Ubuntu 22.04 machine the following command was used to install the required packages.</p> <pre><code>sudo apt-get update sudo apt-get upgrade sudo apt-get install openssh-server mc libgmp3-dev libmpc-dev gawk wget git diffstat unzip texinfo gcc \\ \nbuild-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping \\ \npython3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd \\ \nliblz4-tool git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison xinetd \\ \ntftpd tftp nfs-kernel-server libncurses5 libc6-i386 libstdc++6:i386 libgcc++1:i386 lib32z1 \\ \ndevice-tree-compiler curl mtd-utils u-boot-tools net-tools swig -y </code></pre> </li> <li> <p>Run the following commands to build the root file system. </p> <p> <pre><code>cd $TOP_FOLDER rm -rf yocto &amp;&amp; mkdir yocto &amp;&amp; cd yocto git clone -b scarthgap https://git.yoctoproject.org/poky git clone -b scarthgap https://git.yoctoproject.org/meta-intel-fpga git clone -b scarthgap https://github.com/openembedded/meta-openembedded source poky/oe-init-build-env ./build echo 'MACHINE = \"stratix10\"' &gt;&gt; conf/local.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-intel-fpga \"' &gt;&gt; conf/bblayers.conf echo 'BBLAYERS += \" ${TOPDIR}/../meta-openembedded/meta-oe \"' &gt;&gt; conf/bblayers.conf echo 'IMAGE_FSTYPES = \"tar.gz\"' &gt;&gt; conf/local.conf\necho 'CORE_IMAGE_EXTRA_INSTALL += \"openssh gdbserver\"' &gt;&gt; conf/local.conf\nbitbake core-image-minimal </code></pre> </p> </li> </ol> <p>After the build completes, which can take a few hours depending on your host system processing power and Internet connection speed, the following root file system archive is created.</p> <ul> <li>$TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/core-image-minimal-stratix10.rootfs.tar.gz </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-zlib","title":"Building ZLIB","text":"<p>The ZLIB is required by LIBRSU. The following steps can be used to compile it.</p> <pre><code>cd $TOP_FOLDER rm -rf zlib-1.3.1 wget http://zlib.net/zlib-1.3.1.tar.gz tar xf zlib-1.3.1.tar.gz rm zlib-1.3.1.tar.gz cd zlib-1.3.1/ export CROSS_PREFIX=${CROSS_COMPILE} ./configure make export ZLIB_PATH=`pwd` cd .. </code></pre> <p>After the above steps are completed, the following items are available.</p> <ul> <li>$TOP_FOLDER/zlib-1.2.11/zlib.h - header file, used to compile files using zlib services </li> <li>$TOP_FOLDER/zlib-1.2.11/libz.so - shared objects, used to run executables linked against zlib APIs </li> </ul> <p>Note: The version of zlib mentioned above is the one that was tested with this release. You may want to use the latest zlib version, as it may contain updates and bug fixes. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-librsu-and-rsu-client","title":"Building LIBRSU and RSU Client","text":"<p>The following commands can be used to build the LIBRSU and the example client application.</p> <pre><code>cd $TOP_FOLDER rm -rf intel-rsu git clone https://github.com/altera-opensource/intel-rsu cd intel-rsu # checkout the branch used for this document, comment out to use default \n# git checkout -b test -t origin/master \ncd lib # add -I$(ZLIB_PATH) to CFLAGS \nsed -i 's/\\(CFLAGS := .*\\)$/\\1 -I\\$\\(ZLIB_PATH\\)/g' makefile make cd .. cd example # add -L$(ZLIB_PATH) to LDFLAGS \nsed -i 's/\\(LDFLAGS := .*\\)$/\\1 -L\\$\\(ZLIB_PATH\\)/g' makefile make cd .. cd .. </code></pre> <p>The following files are created.</p> <ul> <li>$TOP_FOLDER/intel-rsu/lib/librsu.so - shared object required at runtime for running applications using librsu </li> <li>$TOP_FOLDER/intel-rsu/etc/qspi.rc - resource file for librsu configuration </li> <li>$TOP_FOLDER/intel-rsu/example/rsu_client - example client application using librsu </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#building-the-sd-card","title":"Building the SD Card","text":"<p>The following commands can be used to create the SD card image used in this example. </p> <pre><code>cd $TOP_FOLDER sudo rm -rf sd_card &amp;&amp; mkdir sd_card &amp;&amp; cd sd_card wget https://releases.rocketboards.org/release/2021.04/gsrd/\\ \ntools/make_sdimage_p3.py chmod +x make_sdimage_p3.py # prepare the fat contents \nmkdir fat &amp;&amp; cd fat cp $TOP_FOLDER/u-boot-socfpga/u-boot.itb . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/Image . cp $TOP_FOLDER/linux-socfpga/arch/arm64/boot/dts/altera/socfpga_stratix10_socdk.dtb . cp $TOP_FOLDER/images/*.rpd . cd .. # prepare the rootfs partition contents \nmkdir rootfs &amp;&amp; cd rootfs sudo tar xf $TOP_FOLDER/yocto/build/tmp/deploy/images/stratix10/\\ \ncore-image-minimal-stratix10.rootfs.tar.gz sudo sed -i 's/stratix10/linux/g' etc/hostname sudo rm -rf lib/modules/* sudo cp $TOP_FOLDER/images/*.rpd home/root sudo cp $TOP_FOLDER/intel-rsu/example/rsu_client home/root/ sudo cp $TOP_FOLDER/intel-rsu/lib/librsu.so lib/ sudo cp $TOP_FOLDER/intel-rsu/etc/qspi.rc etc/librsu.rc sudo cp $TOP_FOLDER/zlib-1.3.1/libz.so* lib/ cd .. # create sd card image \nsudo python3 ./make_sdimage_p3.py -f \\ \n-P fat/*,num=1,format=vfat,size=100M \\ \n-P rootfs/*,num=2,format=ext3,size=100M \\ \n-s 256M \\ \n-n sdcard_rsu.img cd .. </code></pre> <p>This creates the SD card image as. </p> <ul> <li>$TOP_FOLDER/sd_card/sdcard_rsu.img. </li> </ul> <p>The following items are included in the rootfs on the SD card.</p> <ul> <li>U-Boot </li> <li>ATF </li> <li>Linux kernel, including RSU driver </li> <li>ZLIB shared objects </li> <li>LIBRSU shared objects and resource files </li> <li>RSU client application </li> <li>Application image </li> <li>Factory update image </li> <li>Decision firmware update image </li> <li>Combined application image </li> </ul>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#flashing-binaries","title":"Flashing Binaries","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#writing-initial-rsu-image-to-qspi","title":"Writing Initial RSU Image to QSPI","text":"<ol> <li> <p>Make sure to install the QSPI SDM bootcard on the Stratix 10 SoC Development Kit </p> </li> <li> <p>Power down the board if powered up </p> </li> <li> <p>Configure the Stratix 10 SoC Development Kit as follows, to have MSEL set to JTAG:</p> <p>- SW1: 1:OFF, rest:ON    - SW2: 1:ON 2:ON 3: ON 4:N/A (SW2.4 is is not connected)    - SW3: all OFF    - SW4: 1:ON 2:OFF 3:OFF 4:ON </p> </li> <li> <p>Run the following command to write the image to SDM QSPI by using the command line version of the Quartus Prime Programmer. </p> <pre><code>cd $TOP_FOLDER quartus_pgm -c 1 -m jtag -o \"pvi;./initial_image.jic\" </code></pre> </li> <li> <p>Configure the Stratix 10 SoC Development Kit tas follows, to have MSEL set to QSPI.</p> <p>- SW2: 1:ON 2:OFF 3:OFF 4: OFF </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#writing-the-sd-card-image","title":"Writing the SD Card Image","text":"<ol> <li> <p>Write the SD card image $TOP_FOLDER/sd_card/sdcard_rsu.img to a microSD card. You can use an USB micro SD card writer and the Linux dd command on your host PC to achieve this. Exercise caution when using the dd command, as incorrect usage can lead to your host Linux system becoming corrupted and non-bootable. </p> </li> <li> <p>Insert the micro SD card in the slot on the Stratix 10 SoC Development kit HPS daughtercard. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#exercising-u-boot-rsu-commands","title":"Exercising U-Boot RSU Commands","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#basic-rsu-operations","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use U-Boot to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that an application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI . </p> <ol> <li> <p>Power cycle the board and press any key when prompted, to get to the U-Boot command prompt.</p> <pre><code>U-Boot SPL 2024.01-33547-g098abd8f13-dirty (Aug 19 2024 - 17:09:51 -0500)\nReset state: Cold\nMPU         1200000 kHz\nL3 main     400000 kHz\nMain VCO    2400000 kHz\nPer VCO     2000000 kHz\nEOSC1       25000 kHz\nHPS MMC     50000 kHz\nUART        100000 kHz\nDDR: 4096 MiB\nSDRAM-ECC: Initialized success with 986 ms\nQSPI: Reference clock at 400000 kHz\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nTrying to boot from MMC1\n## Checking hash(es) for config board-0 ... OK\n## Checking hash(es) for Image atf ... crc32+ OK\n## Checking hash(es) for Image uboot ... crc32+ OK\n## Checking hash(es) for Image fdt-0 ... crc32+ OK\nNOTICE:  BL31: v2.10.1  (release):QPDS24.2_REL_GSRD_PR\nNOTICE:  BL31: Built : 17:01:57, Aug 19 2024\nU-Boot 2024.01-33547-g098abd8f13-dirty (Aug 19 2024 - 17:09:51 -0500)socfpga_stratix10\n\nCPU:   Intel FPGA SoCFPGA Platform (ARMv8 64bit Cortex-A53)\nModel: SoCFPGA Stratix 10 SoCDK\nDRAM:  2 GiB (effective 4 GiB)\nCore:  26 devices, 21 uclasses, devicetree: separate\nWDT:   Started watchdog@ffd00200 with servicing every 1000ms (10s timeout)\nMMC:   dwmmc0@ff808000: 0\nLoading Environment from FAT... Unable to read \"uboot.env\" from mmc0:1...\nIn:    serial0@ffc02000\nOut:   serial0@ffc02000\nErr:   serial0@ffc02000\nNet:   Warning: ethernet@ff800000 (eth0) using random MAC address - 66:b9:e3:95:2d:82\neth0: ethernet@ff800000\nHit any key to stop autoboot:  0 SOCFPGA # \n</code></pre> </li> <li> <p>Run the rsu command without parameters, to display its help message, and usage options.</p> <pre><code>SOCFPGA # rsu \nrsu - Stratix 10 SoC Remote System Update Usage: rsu dtb - Update Linux DTB qspi-boot parition offset with spt0 value list - List down the available bitstreams in flash slot_by_name &lt;name&gt; - find slot by name and display the slot number slot_count - display the slot count slot_disable &lt;slot&gt; - remove slot from CPB slot_enable &lt;slot&gt; - make slot the highest priority slot_erase &lt;slot&gt; - erase slot slot_get_info &lt;slot&gt; - display slot information slot_load &lt;slot&gt; - load slot immediately slot_load_factory - load factory immediately slot_priority &lt;slot&gt; - display slot priority slot_program_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program buffer into slot, and make it highest priority slot_program_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program raw buffer into slot slot_program_factory_update_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - program factory update buffer into slot, and make it highest priority slot_rename &lt;slot&gt; &lt;name&gt; - rename slot slot_delete &lt;slot&gt; - delete slot slot_create &lt;name&gt; &lt;address&gt; &lt;size&gt; - create slot slot_size &lt;slot&gt; - display slot size slot_verify_buf &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against buffer slot_verify_buf_raw &lt;slot&gt; &lt;buffer&gt; &lt;size&gt; - verify slot contents against raw buffer status_log - display RSU status update &lt;flash_offset&gt; - Initiate firmware to load bitstream as specified byflash_offset notify &lt;value&gt; - Let SDM know the current state of HPS software clear_error_status - clear the RSU error status reset_retry_counter - reset the RSU retry counter display_dcmf_version - display DCMF versions and store them for SMC handler usage display_dcmf_status - display DCMF status and store it for SMC handler usage display_max_retry - display max_retry parameter, and store it for SMC handler usage restore_spt &lt;address&gt; - restore SPT from an address save_spt &lt;address&gt; - save SPT to an address create_empty_cpb - create a empty CPB restore_cpb &lt;address&gt; - restore CPB from an address save_cpb &lt;address&gt; - save CPB to an address check_running_factory - check if currently running the factory image </code></pre> </li> <li> <p>Run the rsu list command to display the RSU partitions, CPBs, the currently running image and the status.</p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> <p>Note: The rsu list U-Boot command does not have a RSU client equivalent. Instead, the same information can be retrieved using other commands, as shown next. </p> </li> <li> <p>Run the rsu status_log command to display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 LastFail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>Application image P1 is loaded, as it is the highest priority in the CPB. There are no errors. </p> </li> <li> <p>Run the rsu display_dcmf_version to query and display the decision firmware versions.</p> <pre><code>SOCFPGA # rsu display_dcmf_version \nDCMF0 version = 24.2.0 DCMF1 version = 24.2.0 DCMF2 version = 24.2.0 DCMF3 version = 24.2.0 </code></pre> </li> <li> <p>Display information about the slots:      <pre><code>SOCFPGA # rsu slot_count \nNumber of slots = 3. SOCFPGA # rsu slot_get_info 0 \nNAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_size 0 \nSlot 0 size = 16777216. SOCFPGA # rsu slot_size 1 \nSlot 1 size = 16777216. SOCFPGA # rsu slot_size 2 \nSlot 2 size = 16777216. </code></pre></p> </li> <li> <p>Erase slot 1 and add the application2.rpd image to slot 1.</p> <pre><code>SOCFPGA # rsu slot_erase 1 \nSlot 1 erased SOCFPGA # load mmc 0:1 $loadaddr application2.rpd \n3358720 bytes read in 153 ms (20.9 MiB/s) SOCFPGA # rsu slot_program_buf 1 $loadaddr $filesize \nSlot 1 was programmed with buffer=0x0000000002000000 size=3358720. </code></pre> </li> <li> <p>Verify that the application image was written correctly: </p> <pre><code>SOCFPGA # rsu slot_verify_buf 1 $loadaddr $filesize \nSlot 1 was verified with buffer=0x0000000002000000 size=3358720. </code></pre> </li> <li> <p>Confirm that slot 1 (partition P2) contains now the highest priority image:      <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre></p> </li> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Load the application image from slot 0 (partition P1) by running any of the following two commands.</p> <pre><code>SOCFPGA # rsu update 0x01000000 \nRSU: RSU update to 0x0000000001000000 or SOCFPGA # rsu slot_load 0 \n</code></pre> </li> <li> <p>Load the newly requested image. Stop at U-Boot prompt and check the status log      to confirm it:      <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre></p> <p>Note: In U-Boot, the effect of requesting a specific image is immediate. On Linux, it only takes effect on the next reboot command. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#watchdog-and-max-retry-operation","title":"Watchdog and Max Retry Operation","text":"<p>This section uses U-Boot to demonstrate the following.</p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image to be tried to be loaded up to three times. </li> <li>RSU notify, which allows the HPS software state to be reported before and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, since it is marked as the highest priority in the CPB. What do the fields mean is described next. </p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>SOCFPGA # rsu display_max_retry \nmax_retry = 3 </code></pre> </li> <li> <p>Cause a watchdog timeout by setting the timeout value to lowest possible. This prevents U-Boot from being able to service it in time.</p> <pre><code>SOCFPGA # mw.l 0xffd00204 0 \n</code></pre> </li> <li> <p>The watchdog immediately times out, and SDM reloads the same application image, since the max retry parameter is set to three. Look at the U-Boot console and check the status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from SPL loading U-Boot (0x0001). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared.</p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Cause another watchdog timeout. At the U-Boot prompt, query the RSU log and observe that the retry counter is now two. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x02000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000002 </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Use the notify command to let SDM know the state of HPS software as a 16bit value.</p> <pre><code>SOCFPGA0 # rsu notify 0x1234 \n</code></pre> </li> <li> <p>Cause a watchdog timeout one more time and display the RSU status log after the restart.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 State : 0xf0061234 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the errors and display the status - it shows no errors. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> <li> <p>Cause a watchdog timeout, boot to U-Boot, and display the status - it shows the retry counter is one. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000001 </code></pre> </li> <li> <p>Reset the current retry counter value to zero and query the status again to confirm it.</p> <pre><code>SOCFPGA # rsu reset_retry_counter \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x01000000 State : 0xf0060001 Version : 0x0acf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#updating-the-factory-image","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use U-Boot to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. </p> </li> <li> <p>Confirm that slot 2 is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] SOCFPGA # rsu slot_erase 2 \nCPBs are GOOD!!! Slot 2 erased. SOCFPGA # load mmc 0:1 $loadaddr factory_update.rpd \n3485696 bytes read in 158 ms (21 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 $loadaddr $filesize \nCPBs are GOOD!!! Slot 2 was programmed with buffer=0x0000000002000000 size=3485696. SOCFPGA # rsu slot_verify_buf 2 $loadaddr $filesize \nSlot 2 was verified with buffer=0x0000000002000000 size=3485696. </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB:      <pre><code>SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre></p> </li> <li> <p>Instruct the SDM to load the factory update image from slot 2.</p> <pre><code>SOCFPGA # rsu slot_load 2 \nSlot 2 loading. </code></pre> </li> <li> <p>The factory update image runs for a few seconds, and updates the decision firmware, decision firmware data and factory image in flash. Then it removes itself from the CPB and loads the now highest priority image in the CPB. At the U-Boot prompt, confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#fallback-on-flash-corruption-of-application-images","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses U-Boot to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power-cycle the board, stop U-Boot and check the RSU status log.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x02000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The application image from slot 1 (partition P2) was loaded, because it is marked as the highest priority in the CPB. What do the fields mean is described next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report </p> </li> <li> <p>Corrupt the image in the slot 1 by erasing some of it. </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x02000000 0x10000 \nSF: 16384 bytes @ 0x2000000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop at U-Boot prompt, and query the RSU log. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x02000000 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The current image is P1, and the P2 shows as a failure. Note that SDM tried to load the image three times from flash, as specified by the max retry option. The top 16 bits of the version field are set as 0x0DCF which means the error was caused reported by the decision firmware, as it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicate an internal error. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared. </p> <pre><code>SOCFPGA # rsu clear_error_status \nSOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#additional-flash-corruption-detection-and-recovery","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the U-Boot RSU commands. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware","title":"Corrupted Decision Firmware","text":"<p>This example uses U-Boot commands to demonstrate detecting that a decision firmware copy is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display the decision firmware status.</p> <pre><code>SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK </code></pre> <p>The command compares the currently used decision firmware copy 0 with the other copies, and displays that all decision firmware copies are fine. </p> </li> <li> <p>Corrupt decision firmware copies 0 and 2 (each copy is 256KB).</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB,     total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x80000 0x10000 \nSF: 4096 bytes @ 0x80000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status and decision firmware status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x10000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware copies are all good, the decision firmware update image was removed from CPB, and the highest priority image is running. </p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu display_dcmf_status \nDCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK SOCFPGA # rsu slot_get_info 2 \nNAME P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware-data","title":"Corrupted Decision Firmware Data","text":"<p>This example uses U-Boot commands to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to U-Boot prompt. </p> </li> <li> <p>Display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>There are no errors. </p> </li> <li> <p>Corrupt decision firmware data.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB,    total 256 MiB SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt, display the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d00f Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State contains the special error code 0xf004d00f indictating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xdcf, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>SOCFPGA # rsu slot_erase 2 \nSlot 2 erased. SOCFPGA # fatload mmc 0:1 ${loadaddr} decision_firmware_update.rpd \n151552 bytes read in 9 ms (16.1 MiB/s) SOCFPGA # rsu slot_program_factory_update_buf 2 ${loadaddr} ${filesize} \nSlot 2 was programmed with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_verify_buf 2 ${loadaddr} ${filesize} \nSlot 2 was verified with buffer=0x0000000002000000 size=151552. SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>SOCFPGA # rsu slot_load 2 \n</code></pre> </li> <li> <p>The decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remve itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>Stop at U-Boot prompt and confirm the decision firmware data is fine, the decision firmware update image was removed from CPB, and the highest priority image is running.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 SOCFPGA # rsu slot_get_info 2 \nNAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-configuration-pointer-block","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses U-Boot commands to demonstrate how configuration pointer block corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was writtento flash, with no other changes. </p> <ol> <li> <p>Power up board, stop at U-Boot prompt. </p> </li> <li> <p>Run the rsu list command to display a detailed status, including all the partitions, to determine the location of the SPTs.</p> <pre><code>SOCFPGA # rsu list \nRSU: Remote System Update Status Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 RSU: Sub-partition table 0 offset 0x00910000 RSU: Sub-partition table 1 offset 0x00918000 SF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB RSU: Sub-partition table content BOOT_INFO Offset: 0x0000000000000000 Length: 0x00110000 Flag : 0x00000003 FACTORY_IMAGE Offset: 0x0000000000110000 Length: 0x00800000 Flag : 0x00000003 P1 Offset: 0x0000000001000000 Length: 0x01000000 Flag : 0x00000000 SPT0 Offset: 0x0000000000910000 Length: 0x00010000 Flag : 0x00000001 SPT1 Offset: 0x0000000000920000 Length: 0x00010000 Flag : 0x00000001 CPB0 Offset: 0x0000000000930000 Length: 0x00010000 Flag : 0x00000001 CPB1 Offset: 0x0000000000940000 Length: 0x00010000 Flag : 0x00000001 P2 Offset: 0x0000000002000000 Length: 0x01000000 Flag : 0x00000000 P3 Offset: 0x0000000003000000 Length: 0x01000000 Flag : 0x00000000 RSU: CMF pointer block offset 0x00930000 RSU: CMF pointer block's image pointer list Priority 1 Offset: 0x0000000001000000 nslot: 0 </code></pre> </li> <li> <p>Corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, the stop to U-Boot prompt and query the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 Current Image : 0x01000000 Last Fail Image : 0x00100000 State : 0xf004d010 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The State field has the special error code 0xf004d010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an UBoot RSU command is executed detected the CPB corruption and recovered CPB0 from CPB1. </p> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. </p> <pre><code>SOCFPGA # rsu save_cpb ${loadaddr} \n4100 bytes CPB data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} cpb-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both CPBs by erasing the flash at their location: </p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nFW detects both CPBs corrupted Current Image : 0x00110000 Last Fail Image : 0x00100000 State : 0xf004d011 Version : 0x0dcf0202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xf004d011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The rsu_init function which is called first time an U-Boot RSU command is executed detected and reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - it is rejected.</p> <pre><code>SOCFPGA # rsu slot_get_info 0 \ncorrupted CPB --run rsu create_empty_cpb or rsu restore_cpb &lt;address&gt; first </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} cpb-backup.bin \n4100 bytes read in 3 ms (1.3 MiB/s) SOCFPGA # rsu restore_cpb ${loadaddr} \n</code></pre> </li> <li> <p>Clear the errors reported by firmware, as the CPB was restored. </p> <pre><code>SOCFPGA # rsu clear_error_status \n</code></pre> <p>Alternatively you can also power cycle or assert nCONFIG to clear the errors reported by firmware. </p> </li> <li> <p>Try again to run a command which require a valid CPB - it succeeds.</p> <pre><code>SOCFPGA # rsu slot_get_info 1 \nNAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-sub-partition-table","title":"Corrupted Sub-Partition Table","text":"<p>This example uses U-Boot commands to demonstrate how sub-partition table corruptions can be detected and recovered. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power up the board, boot up to the U-Boot prompt and query the RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nCurrent Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The highest priority image is running, and there are no errors. </p> </li> <li> <p>Corrupt SPT0 file by erasing the flash at its location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status: </p> <pre><code>SOCFPGA # rsu status_log \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed, it detects that the SPT0 is corrupted, and it recovers it from SPT1. </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes.</p> <pre><code>SOCFPGA # rsu save_spt ${loadaddr} \n4100 bytes SPT data saved SOCFPGA # fatwrite mmc 0:1 ${loadaddr} spt-backup.bin ${filesize} \n4100 bytes written </code></pre> </li> <li> <p>Corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, stop to U-Boot prompt and query RSU status.</p> <pre><code>SOCFPGA # rsu status_log \nBad SPT1 magic number 0xFFFFFFFF Bad SPT0 magic number 0xFFFFFFFF no valid SPT0 and SPT1 found Current Image : 0x01000000 Last Fail Image : 0x00000000 State : 0x00000000 Version : 0x00000202 Error location : 0x00000000 Error details : 0x00000000 Retry counter : 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The rsu_init function is called when the first RSU U-Boot command is executed and it detects that both SPTs are corrupted. </p> <p>Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU command which requires a valid SPT - it fails.</p> <pre><code>SOCFPGA # rsu slot_count \ncorrupted SPT --run rsu restore_spt &lt;address&gt; first </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>SOCFPGA # fatload mmc 0:1 ${loadaddr} spt-backup.bin \n4100 bytes read in 2 ms (2 MiB/s) SOCFPGA # rsu restore_spt ${loadaddr} \n</code></pre> </li> <li> <p>Power cycle the board, the highest priority image loads, and all functionality is available. This power cycle is needed to cause the rsu_init function to be called in U-Boot, as it is only called once when the first RSU command is called. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#exercising-rsu-client","title":"Exercising RSU Client","text":""},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#basic-rsu-operations_1","title":"Basic RSU Operations","text":"<p>This section demonstrates how to use the RSU client to perform the following basic operations.</p> <ul> <li>Querying the RSU status. </li> <li>Querying the number of slots and the information about them. </li> <li>Adding a new application image. </li> <li>Verifying that the application image was written correctly. </li> <li>Requesting a specific application image to be loaded. </li> </ul> <p>Note: This section assumes that the flash contains the initial RSU image. If that is not true, you need to re-flash the initial image, as shown in the Flashing the Initial RSU Image to QSPI section. </p> <ol> <li> <p>Power cycle the board and let Linux boot. </p> </li> <li> <p>Log in using root as user name, no password is required. </p> </li> <li> <p>Run the rsu_client without parameters, to display its help message.</p> <pre><code>root@linux:~# ./rsu_client -- RSU app usage -- -c|--count get the number of slots -l|--list slot_num list the attribute info from the selected slot -z|--size slot_num get the slot size in bytes -p|--priority slot_num get the priority of the selected slot -E|--enable slot_num set the selected slot as the highest priority -D|--disable slot_num disable selected slot but to not erase it -r|--request slot_num request the selected slot to be loaded after the next reboot -R|--request-factory request the factory image to be loaded after the next reboot -e|--erase slot_num erase app image from the selected slot -a|--add file_name -s|--slot slot_num add a new app image to the selected slot -u|--add-factory-update file_name -s|--slot slot_num add a new factory update image to the selected slot -A|--add-raw file_name -s|--slot slot_num add a new raw image to the selected slot -v|--verify file_name -s|--slot slot_num verify app image on the selected slot -V|--verify-raw file_name -s|--slot slot_num verify raw image on the selected slot -f|--copy file_name -s|--slot slot_num read the data in a selected slot then write to a file -g|--log print the status log -n|--notify value report software state -C|--clear-error-status clear errors from the log -Z|--reset-retry-counter reset current retry counter -m|--display-dcmf-version print DCMF version -y|--display-dcmf-status print DCMF status -x|--display-max-retry print max_retry parameter -t|--create-slot slot_name -S|--address slot_address -L|--length slot_size create a new slot using unallocated space -d|--delete-slot slot_num delete selected slot, freeing up allocated space -W|--restore-spt file_name restore spt from a file -X|--save-spt file_name save spt to a file -b|--create-empty-cpb create a empty cpb -B|--restore-cpb file_name restore cpb from a file -P|--save-cpb file_name save cpb to a file -k|--check-running-factory check if currently running the factory image -h|--help show usage message </code></pre> </li> <li> <p>Exercise the rsu_client command that displays the current status, it shows the application image from slot 0 (partition P1) is loaded with no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Run the RSU client commands that display information about the slots.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Display the decision firmware version information.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-version DCMF0 version = 21.2.0 DCMF1 version = 21.2.0 DCMF2 version = 21.2.0 DCMF3 version = 21.2.0 Operation completed </code></pre> </li> <li> <p>Erase slot 1 and add the application2.rpd application image to slot 1 (partition P2).</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed root@linux:~# ./rsu_client --add application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Verify that the application image was written correctly to flash.</p> <pre><code>root@linux:~# ./rsu_client --verify application2.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>List again the slots, it shows the most recently written partition P2 image having the highest priority (lowest priority number that is).</p> <pre><code>root@linux:~# ./rsu_client --list 0 NAME: P1 OFFSET: 0x0000000001000000 SIZE: 0x01000000 PRIORITY: 2 Operation completed root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux, and display the status. It shows the image from partition P2 running.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 0 (partition P1) from SDM on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 0 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Log into Linux and display the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The status shows that the image from partition P1 was loaded, as requested. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#watchdog-and-max-retry-operation_1","title":"Watchdog and Max Retry Operation","text":"<p>This section uses the RSU client to demonstrate the following.</p> <ul> <li>RSU handling of watchdog timeouts. </li> <li>max retry feature, which allows each image up to three times to load. </li> <li>RSU notify, which allows the HPS software state to be reported and retrieved after a watchdog timeout. </li> <li>Clearing the RSU status error fields. </li> <li>Resetting the current retry counter value. </li> </ul> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power cycle the board, boot Linux, and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is described next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.    - State is 0x00000000: No errors to report. </p> </li> <li> <p>Query and display the max_retry value.</p> <pre><code>root@linux:~# ./rsu_client --display-max-retry max_retry = 3 Operation completed </code></pre> <p>Note: The max_retry option must be queried from U-Boot first, in order for it to be available on Linux. </p> </li> <li> <p>Enable the watchdog but do not service it, as this produces a timeout, and restarts Linux. </p> <pre><code>root@linux:~# echo \"something\" &gt; /dev/watchdog [ 603.649746] watchdog: watchdog0: watchdog did not stop! </code></pre> </li> <li> <p>Wait for Linux to restart after the watchdog timeout, then display the log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> <p>The same P2 image is loaded, but the retry counter value is now one, which means this is the second retry for this image to be loaded. The version field shows the last failure was by an application image (0xACF). The state field shows the last error was a watchdog timeout (0xF006) and that the latest notify value from HPS software was from U-Boot loading Linux (0x0002). </p> </li> <li> <p>Clear the error status so we can see the next errors. Query the status to show the errors were cleared. </p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and wait for Linux to restart. After the restart, query the RSU log and observe that the retry counter is now two.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000002 Operation completed </code></pre> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Notify the SDM of the HPS execution stage as a 16bit number.</p> <pre><code>root@linux:~# ./rsu_client --notify 0x1234 Operation completed </code></pre> </li> <li> <p>Cause another watchdog timeout and watch for Linux to restart. After the restart, query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0061234 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The SDM loaded the next application image in the CPB (P1), and it reports that the image P2 failed. The state indicates that a watchdog timeout occurred (upper 16 bits = 0xF006) and that the notify value reported by HPS software was 0x1234. The upper 16 bits of the version are set to 0x0ACF which means the previous error was reported by the application image firmware. </p> </li> <li> <p>Clear the error status so we can see the next errors. </p> </li> <li> <p>Cause a watchdog timeout and display the status - it shows a retry counter value of one.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000001 Operation completed </code></pre> </li> <li> <p>Use the RSU client to reset the current retry counter value to zero, and query the status again to confirm it.</p> <pre><code>root@linux:~# ./rsu_client --reset-retry-counter Operation completed root@linux:~# ./rsu_client --log VERSION: 0x0ACF0202 STATE: 0xF0060002 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000001000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#updating-the-factory-image_1","title":"Updating the Factory Image","text":"<p>This section demonstrates how to use the RSU client to update the factory image. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding an application image to the P2 flash partition. </p> <ol> <li> <p>Power cycle the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 (partition P3) is not used, erase slot 2, write the factory update image to it, and verify it was written correctly.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update factory_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify factory_update.rpd --slot 2 Operation completed </code></pre> </li> <li> <p>Confirm that slot 2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Instruct the RSU client to request slot 2 (partition P3) to be loaded on next reboot command.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed </code></pre> </li> <li> <p>Restart Linux by running the reboot command.</p> <pre><code>root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the factory update image updates the decision firmware, decision firmware data and factory image in flash. This takes a few seconds, and there is no activity on the serial console during this time. Then it removes itself from the CPB and loads the now highest priority image in the CPB. Confirm that P2 is now loaded and P3 is disabled.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#fallback-on-flash-corruption-of-application-images_1","title":"Fallback on Flash Corruption of Application Images","text":"<p>This section uses the RSU client to demonstrate falling back in case of configuration errors caused by flash corruption of application images. </p> <p>Note: The commands listed in this section rely on the commands from the Basic Operation section running first, specifically adding image P2 to the flash. </p> <ol> <li> <p>Power cycle the board, boot Linux and display the status. It shows the P2 image running, as it is the highest priority.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000002000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>What do the version fields mean is indicated next.</p> <p>- Version field is 0x00000202: both decision firmware and application firmware RSU interface versions are 2, and the system supports the max retry feature.    - Retry counter is 0x00000000: first attempt to load this image.   - State is 0x00000000: No errors to report </p> </li> <li> <p>Erase slot 1, which also takes it out of CPB.</p> <pre><code>root@linux:~# ./rsu_client --erase 1 Operation completed </code></pre> </li> <li> <p>Create a file with random data, and write it to the P2 slot. </p> <pre><code>root@linux:~# dd if=/dev/urandom of=corrupt.rpd bs=1M count=1 1+0 records in 1+0 records out root@linux:~# ./rsu_client --add-raw corrupt.rpd --slot 1 Operation completed </code></pre> </li> <li> <p>Enable the P2 slot, which puts it as the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --enable 1 Operation completed </code></pre> </li> <li> <p>Confirm that P2 is now the highest priority in the CPB.</p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot Linux and query the RSU log.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D003 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000002000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The current image is P1, and the P2 shows as failed. The top 4 bits of the version field are set to 0x0which means the currently used DCMF index is zero. Th next 12bit of the version field are set as 0xDCF which means the error was caused by the decision firmware, because it was not able to load the image. The top 16 bits of the state field are set to 0xF004, which indicates an internal error. For more information, refer to RSU Status and Error Codes on the RSU User Guide. </p> </li> <li> <p>Clear the error status and display the log again to confirm it was cleared.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#additional-flash-corruption-detection-and-recovery_1","title":"Additional Flash Corruption Detection and Recovery","text":"<p>This section presents examples of detecting and recovering corrupted decision firmware, decision firmware data, configuration pointer blocks and sub-partition tables with the aid of the RSU client. </p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware_1","title":"Corrupted Decision Firmware","text":"<p>This example uses the RSU client to demonstrate detecting that some decision firmware copies are corrupted, and recovering them by running a decision firmware update image. The task uses U-Boot to corrupt flash, as it is the only component which has direct access to decision firmware. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes.</p> <p>Note: The rsu display_dcmf_version command is called automatically by current U-Boot before booting Linux. This is requried to have the status availabe in Linux. </p> <ol> <li> <p>Power cycle the board, boot up to Linux. </p> </li> <li> <p>Query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The top four bits of the state field are 0x0 which means the currently used decision firmware index is zero. There are no errors. </p> </li> <li> <p>Display decision firmware status, it shows no corruptions.</p> <pre><code>root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> </li> <li> <p>Power cycle board, stop to U-Boot, corrupt decision firmware copies 0 and 2.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0 0x10000 \nSF: 4096 bytes @ 0x0 Erased: OK SOCFPGA # sf erase 0x80000 0x10000 \nSF: 4096 bytes @ 0x80000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, query the RSU status and decision firmware status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x10000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: Corrupted DCMF1: OK DCMF2: Corrupted DCMF3: OK Operation completed </code></pre> <p>The currently used copy of the decision firmware is 1, as indicated by top four bits of the version field. There are no errors reported by firmware. The decision firmware copies 0 and 2 are detected as corrupted. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. Let it boot to Linux. </p> </li> <li> <p>In Linux, query the RSU status and display the DCMF status. </p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed root@linux:~# ./rsu_client --display-dcmf-status DCMF0: OK DCMF1: OK DCMF2: OK DCMF3: OK Operation completed </code></pre> <p>All decision firmware copies are reported as fine, and copy 0 is the one currently used, as expected. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-decision-firmware-data_1","title":"Corrupted Decision Firmware Data","text":"<p>This example uses the RSU client to demonstrate detecting that the decision firmware data is corrupted, and recovering it by running a decision firmware update image. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed There are no errors. </code></pre> </li> <li> <p>Reboot power cycle the board, stop at U-Boot prompt, and corrupt decision firmware data.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x100000 0x10000 \nSF: 4096 bytes @ 0x100000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query the status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x0DCF0202 STATE: 0xF004D00F CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State contains the special error code 0xF004D00F indicating that the decision firmware data was corrupted. The current image is listed as the factory image. The error source is listed as 0xDCF, meaning the error was reported by the decision firmware. The Last Fail Image is set to 0x00100000, which is a special value indicating an error was reported by the decision firmware. </p> </li> <li> <p>Erase an unused slot, add the decision firmware update image to the slot, verify it was written fine, and confirm it is now the highest priority running slot.</p> <pre><code>root@linux:~# ./rsu_client --erase 2 Operation completed root@linux:~# ./rsu_client --add-factory-update decision_firmware_update.rpd --slot 2 Operation completed root@linux:~# ./rsu_client --verify decision_firmware_update.rpd --slot 2 Operation completed rootlinux:~# ./rsu_client --list 2 NAME: P3 OFFSET: 0x0000000003000000 SIZE: 0x01000000 PRIORITY: 1 Operation completed </code></pre> </li> <li> <p>Pass control to the decision firmware update image.</p> <pre><code>root@linux:~# ./rsu_client --request 2 Operation completed root@linux:~# reboot </code></pre> </li> <li> <p>Linux shuts down, then the decision firmware update image writes new decision firmware copies and new decision firmware data to flash, remove itself from CPB, then pass control to the highest priority image. </p> </li> <li> <p>In Linux, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The highest priority image is loaded, and there are no errors. The decision firmware data was restored. </p> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-configuration-pointer-block_1","title":"Corrupted Configuration Pointer Block","text":"<p>This section uses the RSU client to demonstrate how configuration pointer block corruptions can be detected and recovered. It also uses U-Boot to corrupt the CPB, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt CPB0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before starting Linux, it executes a few RSU commands, which causes rsu_init to be called, and that restores CPB0 from the CPB1 copy.</p> <pre><code>FW detects corrupted CPB0 but CPB1 is fine Restoring CPB0 </code></pre> </li> <li> <p>Once Linux has booted, query the RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D010 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The State field has the special error code 0xF004D010 which indicates that CPB0 was corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). Although the U-Boot already recovered CPB0 from CPB1, the firmware still reports CPB0 as corrupted, and LibRSU recovers it again. </p> </li> <li> <p>Clear the error status, so that the firmware stops reporting CPB0 corrupted, and query RSU status again to verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects corrupted CPB0, fine CPB1 [LOW] librsu: load_cpb(): warning: Restoring CPB0 [LOW] Operation completed root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status. Verify there are no errors.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Save the CPB contents to a file, to be used later for recovery. Also call sync command to make sure the file is saved to storage.</p> <pre><code>root@linux:~# ./rsu_client --save-cpb cpb-backup.bin Operation completed root@linux:~# sync </code></pre> </li> <li> <p>Reboot or power cycle, stop in U-Boot and corrupt both CPBs by erasing the flash at their location.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0930000 0x10000 \nSF: 4096 bytes @ 0x930000 Erased: OK SOCFPGA # sf erase 0x0940000 0x10000 \nSF: 4096 bytes @ 0x940000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_cpb(): FW detects both CPBs corrupted [LOW] VERSION: 0x0DCF0202 STATE: 0xF004D011 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000100000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>The Current Image is reported as being the factory image, as expected. The State field has the special error code 0xF004D011 which indicates that both CPBs were corrupted. The Last Fail Image has the special value 0x00100000 which is used in this case. The Version field indicates that the eror was reported by the decision firmware (0xDCF). The LibRSU reported that both CPBs are corrupted. </p> </li> <li> <p>Try to run a command which requires a valid CPB - verify it is rejected.</p> <pre><code>root@linux:~# ./rsu_client --list 1 librsu: load_cpb(): FW detects both CPBs corrupted [LOW] librsu: rsu_cpb_corrupted_info(): corrupted CPB -- [LOW] librsu: rsu_cpb_corrupted_info(): run rsu_client create-empty-cpb or     [LOW] librsu: rsu_cpb_corrupted_info(): rsu_client restore_cpb first [LOW] ERROR: Failed to get slot attributes </code></pre> </li> <li> <p>Clear errors, so that the CPBs are not reported as corrupted by the firmware anymore.</p> <pre><code>root@linux:~# ./rsu_client --clear-error-status librsu: load_cpb(): FW detects both CPBs corrupted [LOW] Operation completed root@linux:~# ./rsu_client --log librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Restore the saved CPB from the backup file that we created.</p> <pre><code>root@linux:~# ./rsu_client --restore-cpb cpb-backup.bin librsu: load_cpb(): Bad CPB1 is bad [MED] librsu: load_cpb(): Bad CPB0 is bad [MED] librsu: load_cpb(): error: found both corrupted CPBs [LOW] Operation completed </code></pre> </li> <li> <p>Query again RSU status, there should be no errors signaled now.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000000110000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> </li> <li> <p>Try to run a command which requries a valid CPB - verify it is not rejected. </p> <pre><code>root@linux:~# ./rsu_client --list 1 NAME: P2 OFFSET: 0x0000000002000000 SIZE: 0x01000000 PRIORITY: [disabled] Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#corrupted-sub-partition-table_1","title":"Corrupted Sub-Partition Table","text":"<p>This example uses the RSU client to demonstrate how sub-partition table corruptions can be detected and recovered. It also uses U-Boot to corrupt the SPT, as it's more conveniently done there. </p> <p>Note: The commands listed in this example assume the initial flash image (JIC) was written to flash, with no other changes. </p> <ol> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>Ther are no errors. </p> </li> <li> <p>Reboot or power cycle the board, stop at U-Boot prompt, and corrupt SPT0 by erasing the corresponding flash area.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x0910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board. U-Boot runs, and before booting Linux it runs a few RSU commands. Running the first one causes rsu_init to be called, which detects corrupted SPT0 and recovers it from SPT1.</p> <pre><code>Bad SPT0 magic number 0xFFFFFFFF Restoring SPT0 </code></pre> </li> <li> <p>Boot to Linux and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 Operation completed </code></pre> <p>There are no errors </p> </li> <li> <p>Save the currently used SPT to a file for backup purposes. Also call sync command to make sure the file is committed to flash. </p> <pre><code>root@linux:~# ./rsu_client --save-spt spt-backup.bin \nOperation completed \nroot@linux:~# sync \n</code></pre> </li> <li> <p>Reboot or power cycle, stop to U-Boot and corrupt both SPTs by erasing the flash at their locations.</p> <pre><code>SOCFPGA # sf probe \nSF: Detected mt25qu02g with page size 256 Bytes, erase size 4 KiB, total 256 MiB SOCFPGA # sf erase 0x910000 0x10000 \nSF: 4096 bytes @ 0x910000 Erased: OK SOCFPGA # sf erase 0x920000 0x10000 \nSF: 4096 bytes @ 0x920000 Erased: OK </code></pre> </li> <li> <p>Power cycle the board, boot to Linux, and query RSU status.</p> <pre><code>root@linux:~# ./rsu_client --log librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] VERSION: 0x00000202 STATE: 0x00000000 CURRENT IMAGE: 0x0000000001000000 FAIL IMAGE: 0x0000000000000000 ERROR LOC: 0x00000000 ERROR DETAILS: 0x00000000 RETRY COUNTER: 0x00000000 </code></pre> <p>The decision firmware loads the higest priority image, and it does not look at the SPTs. The LibRSU detects that both SPTs are corrupted.    Note: In the case of having multiple SSBLs, corrupting both SPTs will make that U-Boot fail to be launched since without SPTs there is no way to identify the partitions available so it's not possible to determine which SSBL needs to be launched. </p> </li> <li> <p>Try to run an RSU client command which requires a valid SPT - it fails.</p> <pre><code>root@linux:~# ./rsu_client --count librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] librsu: rsu_spt_corrupted_info(): corrupted SPT -- [LOW] librsu: rsu_spt_corrupted_info(): run rsu_client restore-spt &lt;file_name&gt; first [LOW] ERROR: Failed to get number of slots </code></pre> </li> <li> <p>Restore the SPT from the backup copy that we have created.</p> <pre><code>root@linux:~# ./rsu_client --restore-spt spt-backup.bin librsu: load_spt(): Bad SPT1 magic number 0xFFFFFFFF [MED] librsu: load_spt(): Bad SPT0 magic number 0xFFFFFFFF [MED] librsu: load_spt(): error: No valid SPT0 or SPT1 found [LOW] Operation completed </code></pre> </li> <li> <p>Try again running RSU client commands which require a valid SPT - the commands work fine.</p> <pre><code>root@linux:~# ./rsu_client --count number of slots is 3 Operation completed </code></pre> </li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#using-separate-ssbl-per-bitstream-example","title":"Using Separate SSBL Per Bitstream Example","text":"<p>When using Remote System Update on Stratix 10, Agilex 7, Agilex 5 and N5X devices, each configuration bitstream from QSPI contains the HPS FSBL (First Stage Bootloader), specifically U-Boot SPL. In order to allow the most flexibility and compatibility, you must design your system so that each bitstream loads its own copy of the HPS SSBL, specifically U-Boot image.</p> <p>This page presents details on how to achieve this for both the cases when U-Boot images are stored in QSPI flash, and when they are stored in SD card. </p> <p>Refer to the following documents for details about the Remote System Update.</p> <ul> <li>Stratix\u00ae 10 Hard Processor System Remote System Update User Guide</li> <li>Agilex\u2122 Hard Processor System Remote System Update User Guide </li> </ul> <p>Note: In the scenario in which both SPTs tables are corrupted, U-Boot will fail to be launched because the FSBL won't be able to identify which SSBL needs to be launched since the partition information is kept in SPT tables.</p>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#configuring-u-boot-for-separate-u-boot-images","title":"Configuring U-Boot for Separate U-Boot Images","text":"<p>In order to configure U-Boot to support one U-Boot image per bitstream, the following configuration option must be enabled.</p> <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\n</code></pre> <p>This configuration option is defined in https://github.com/altera-opensource/u-boot-socfpga/blob/socfpga_v2023.04/arch/arm/mach-socfpga/Kconfig as follows.</p> <pre><code>config SOCFPGA_RSU_MULTIBOOT\n    bool \"Enable RSU Multiboot Selection Feature\"\ndepends on TARGET_SOCFPGA_SOC64 &amp;&amp; SPI_FLASH\n    default n\n    help\nMultiboot u-boot proper image (SSBL) selection feature for RSU.\n     SPL will select the respective SSBL based on the partition it resides\n     inside RSU QSPI flash layout.\n</code></pre>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#storing-u-boot-images-on-sd-card","title":"Storing U-Boot Images on SD Card","text":"<p>When booting U-Boot from SD card, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the u-boot.itb or u-boot.img image, it loads the u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img file.</li> <li>Instead of U-Boot using the environment stored in one location on SD card, it loads it from uboot_&lt;partition_name&gt;.env file</li> </ul> <p>The &lt;partition_name&gt; is the partition name as defined in the Quartus Programming File Generator PFG file (using the id for the corresponding partition). For the factory image that is \"FACTORY_IMAGE\".</p> <p>On the SD card, the following files will need to be stored, for each bitstream and the factory image.</p> <ul> <li>u-boot_&lt;partition_name&gt;.itb or u-boot_&lt;partition_name&gt;.img </li> <li>uboot_&lt;partition_name&gt;.env </li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Replace the corresponding U-Boot image file on the FAT partition with the new version.</li> <li>Replace the corresponding U-Boot environment file on the FAT partition with the new version</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as the highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>If you do not need to have a modifiable environment, you will not need the uboot_&lt;partition_name&gt;.env files.</li> <li>You can ommit explicitly creating the uboot_&lt;partition_name&gt;.env  files. They will be created when  you run the 'saveenv' command. If they are not present U-Boot will just use its default environment.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li>U-Boot is build adding CONFIG_SOCFPGA_RSU_MULTIBOOT=y to the config-fragment-&lt;device&gt; file. An independent U-Boot build is performed for each application. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.itb, u-boot_P1.itb, u-boot_P2.itb and u-boot_P3.itb.</li> <li>Modify initial_image.pfg to include the proper new FSBLs for Bitstream 1 (FACTORY_IMAGE application) and Bitstream 2 (P1 application). </li> <li>Generate the new initial_image.jic using the modified initial_image.pfg file.</li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application).</li> <li>Generate the SD Card image copying to the fat partition the new .itb and .rpd files created. Also copy the new .rpd files to the rootfs partition at home/root directory. Adjust the size of the image to match the new size of the fat directory (fat partition will be larger as this includes now the SSBLs for each application).</li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#storing-u-boot-images-in-qspi","title":"Storing U-Boot Images in QSPI","text":"<p>When booting U-Boot from QSPI, the effects of enabling CONFIG_SOCFPGA_RSU_MULTIBOOT=y are these.</p> <ul> <li>Instead of SPL loading the U-Boot from a fixed address as defined by the CONFIG_SYS_SPI_U_BOOT_OFFS configuration option, it loads U-Boot from a partition called SSBL.&lt;partition_name&gt;.</li> <li>Instead of U-Boot loading the environment from a fixed location as defined by the CONFIG_ENV_OFFSET configuration option, it loads it from the last CONFIG_ENV_SIZE of the same partition called SSBL.&lt;partition_name&gt;.</li> </ul> <p>On the QSPI PFG file, the following additional partition will need to be defined, for each bitstream and the factory image.</p> <ul> <li>SSBL.&lt;partition_name&gt;: containing the U-Boot image, and the environment at the end.</li> </ul> <p>Application image update procedure needs to be updated as follows.</p> <ol> <li>Use LIBRSU or U-Boot to erase the application image partition. This also disables it, removing it from the CPB.</li> <li>Use LIBRSU or U-Boot to erase SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new contents of the SSBL partition.</li> <li>Use LIBRSU or U-Boot to write the new application image. This also enables it, putting it as highest priority in the CPB.</li> </ol> <p>Notes:</p> <ul> <li>The total lenght of a partition name cannot exceed 15 characters, not including the zero line terminator. Because of that the SSBL partition names will have to be truncated to 15 characters. For example for factory image you will need to define it as \"SSBL.FACTORY_IM\".</li> <li>By default both U-Boot and Linux uses 64KB QSPI erase sectors. Make sure to configure your initial RSU QSPI flash image with SPT/CPB sizes=64KB, unless you change the default to 4KB for example, in which case you can leave the default of 32KB for SPT/CBP sizes</li> <li>The U-Boot environment must be stored in an individually erasable QSPI area. You need to define CONFIG_ENV_OFFSET=CONFIG_ENV_SECT_SIZE=qspi_erase_size, where that is either 64KB or 4KB depending on the above selection</li> <li>The partition will have to be large enough to contain both the U-Boot image (currently ~900KB) and the U-Boot environment (64KB or 4KB). It is reccomended it to set to at least 1.5MB to allow room for expansion in the future.</li> <li>Initially the environment part of the partition can be left empty, as the default U-Boot environment will be used by U-Boot. Then when you run 'saveenv' command, the updated environment will be saved and used.</li> </ul> <p>Steps to Rebuild Binaries compared with regular RSU build flow</p> <ol> <li>GHRD, ATF, Linux, File System are built in the same way.</li> <li> <p>U-Boot is build adding the following setting to the config-fragment-&lt;device&gt; file. <pre><code>CONFIG_SOCFPGA_RSU_MULTIBOOT=y\nCONFIG_ENV_OFFSET=0x10000\nCONFIG_ENV_SECT_SIZE=0x10000\n</code></pre> and updating arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi file to find the U-Boot FSBL in QSPI as indicated next. <pre><code>sed -i 's/u-boot,spl-boot-order.*/u-boot\\,spl-boot-order = \\&amp;flash0;/g' arch/arm/dts/socfpga_agilex_socdk-u-boot.dtsi\n</code></pre> For each application, a specific U-Boot is required to be built. Name corresponding u-boot.itb as u-boot_FACTORY_IMAGE.bin, u-boot_P1.bin, u-boot_P2.bin and u-boot_P3.bin.</p> </li> <li> <p>Modify initial_image.pfg to create new partitions for each one of the SSBLs and loading the corresponding binary into this. An example of the new sections created in the file is shown next. <pre><code>&lt;pfg version=\"1\"&gt;\n   :\n    &lt;raw_files&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_1\"&gt;u-boot_FACTORY_IMAGE.bin&lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_2\"&gt;u-boot_P1.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_3\"&gt;u-boot_P2.bin &lt;/raw_file&gt;\n       &lt;raw_file bitswap=\"1\" type=\"RBF\" id=\"Raw_File_4\"&gt;u-boot_P3.bin&lt;/raw_file&gt;\n    &lt;/raw_files&gt;\n    &lt;flash_devices&gt;\n     :\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04000000\" e_addr=\"0x041FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.FACTORY_IM\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04200000\" e_addr=\"0x043FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P1\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04400000\" e_addr=\"0x045FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P2\" size=\"0\"/&gt;\n       &lt;partition reserved=\"0\" fixed_s_addr=\"0\" s_addr=\"0x04600000\" e_addr=\"0x047FFFFF\" fixed_e_addr=\"0\" id=\"SSBL.P3\" size=\"0\"/&gt;\n    &lt;/flash_device&gt;\n    &lt;assignments&gt;\n       &lt;assignment partition_id=\"SSBL.FACTORY_IM\"&gt;\n             &lt;raw_file_id&gt;Raw_File_1 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P1\"&gt;\n             &lt;raw_file_id&gt;Raw_File_2 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P2\"&gt;\n             &lt;raw_file_id&gt;Raw_File_3 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n       &lt;assignment partition_id=\"SSBL.P3\"&gt;\n             &lt;raw_file_id&gt;Raw_File_4 &lt;/raw_file_id&gt;\n       &lt;/assignment&gt;\n    &lt;/assignments&gt;\n &lt;/pfg&gt;\n</code></pre></p> </li> <li> <p>Generate the new initial_image.jic using the modified initial_image.pfg file.</p> </li> <li>Generate new .rpd applications using the new FSBLs created (application2, decision_firmware_update, factory_update and combined_application). </li> <li>Generate the SD Card image copying to the fat partition the new .rpd files created. The .itb in fat partition are not required anymore. Also, copy the new .rpd files to the rootfs partition at home/root directory.</li> </ol>"},{"location":"embedded-designs/stratix-10/sx/soc/rsu/ug-rsu-s10sx-soc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"host-attach-util/fpgaconf/fpgaconf/","title":"fpgaconf","text":""},{"location":"host-attach-util/fpgaconf/fpgaconf/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgaconf [-hvVn] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] &lt;gbs&gt;</code></p>"},{"location":"host-attach-util/fpgaconf/fpgaconf/#description","title":"DESCRIPTION","text":"<p><code>fpgaconf</code> configures the FPGA with the accelerator function (AF). It also checks the AF for compatibility with  the targeted FPGA and the FPGA Interface Manager (FIM). <code>fpgaconf</code> takes the following arguments: </p> <p><code>-h, --help</code></p> <pre><code>Prints usage information.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-V, --verbose</code></p> <pre><code>Prints more verbose messages while enumerating and configuring. Can be\nrequested more than once.\n</code></pre> <p><code>-n, --dry-run</code></p> <pre><code>Performs enumeration. Skips any operations with side-effects such as the\nactual AF configuration.\n</code></pre> <p><code>-S, --segment</code></p> <pre><code>PCIe segment number of the target FPGA.\n</code></pre> <p><code>-B, --bus</code></p> <pre><code>PCIe bus number of the target FPGA.\n</code></pre> <p><code>-D, --device</code></p> <pre><code>PCIe device number of the target FPGA.\n</code></pre> <p><code>-F, --function</code></p> <pre><code>PCIe function number of the target FPGA.\n</code></pre> <p><code>--force</code></p> <pre><code>Reconfigure the AFU even if it is in use.\n</code></pre> <p><code>fpgaconf</code> enumerates available FPGA devices in the system and selects compatible FPGAs for configuration. If more than one FPGA is compatible with the AF, <code>fpgaconf</code> exits and asks you to be more specific in selecting the target FPGAs by specifying a a PCIe BDF.</p>"},{"location":"host-attach-util/fpgaconf/fpgaconf/#examples","title":"EXAMPLES","text":"<p><code>fpgaconf my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to a compatible FPGA.\n</code></pre> <p><code>fpgaconf -V -B 0x3b my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA in bus 0x3b, if compatible,\nwhile printing out slightly more verbose information.\n</code></pre> <p><code>fpgaconf 0000:3b:00.0 my_af.gbs</code></p> <pre><code>Program \"my_af.gbs\" to the FPGA at address 0000:3b:00.0.\n</code></pre>"},{"location":"host-attach-util/fpgad/fpgad/","title":"fpgad","text":""},{"location":"host-attach-util/fpgad/fpgad/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgad --daemon [--version] [--directory=&lt;dir&gt;] [--logfile=&lt;file&gt;] [--pidfile=&lt;file&gt;] [--umask=&lt;mode&gt;] [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code> <code>fpgad [--socket=&lt;sock&gt;] [--null-bitstream=&lt;file&gt;]</code></p>"},{"location":"host-attach-util/fpgad/fpgad/#description","title":"DESCRIPTION","text":"<p>fpgad monitors the device sensors, checking for sensor values that are out of the prescribed range. </p> <p>When any of the sensors is detected to be out of bounds, fpgad will focus on keeping the server from rebooting by masking PCIE AER, and send a message to system administrator. System administrator can take further actions like stop the application and stop the FPGA, but fpgad just focus on monitor the sensors and will not take any cooling actions. </p> <p>Note: fpgad must be running (as root) and actively monitoring devices when a sensor anomaly occurs in order to initiate Graceful Shutdown.  If fpgad is not loaded during such a sensor anomaly, the out-of-bounds scenario will not be detected, and the resulting effect on the hardware is undefined.</p>"},{"location":"host-attach-util/fpgad/fpgad/#arguments","title":"ARGUMENTS","text":"<p><code>-v, --version</code></p> <pre><code>Prints version information and exits.\n</code></pre> <p><code>-d, --daemon</code></p> <pre><code>When specified, fpgad executes as a system daemon process.\n</code></pre> <p><code>-D, --directory &lt;dir&gt;</code></p> <pre><code>When running in daemon mode, run from the specified directory.\nIf omitted when daemonizing, `fpgad` uses /tmp.\n</code></pre> <p><code>-l, --logfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, send output to file. When not in daemon mode, the output goes to stdout.\nIf omitted when daemonizaing, fpgad uses /tmp/fpgad.log.\n</code></pre> <p><code>-p, --pidfile &lt;file&gt;</code></p> <pre><code>When running in daemon mode, write the daemon's process id to a file.\nIf omitted when daemonizing, fpgad uses /tmp/fpgad.pid.\n</code></pre> <p><code>-m, --umask &lt;mode&gt;</code></p> <pre><code>When running in daemon mode, use the mode value as the file mode creation mask passed to umask.\nIf omitted when daemonizing, fpgad uses 0.\n</code></pre> <p><code>-s, --socket &lt;sock&gt;</code></p> <pre><code>Listen for event API registration requests on the UNIX domain socket on the specified path. \nThe default=/tmp/fpga_event_socket.\n</code></pre> <p><code>-n, --null-bitstream &lt;file&gt;</code></p> <pre><code>Specify the NULL bitstream to program when an AP6 event occurs. This option may be specified multiple\ntimes. The AF, if any, that matches the FPGA's PR interface ID is programmed when an AP6\nevent occurs.\n</code></pre>"},{"location":"host-attach-util/fpgad/fpgad/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>If you encounter any issues, you can get debug information in two ways:</p> <ol> <li>By examining the log file when in daemon mode.</li> <li>By running in non-daemon mode and viewing stdout.</li> </ol>"},{"location":"host-attach-util/fpgad/fpgad/#examples","title":"EXAMPLES","text":"<p><code>fpgad --daemon --null-bitstream=my_null_bits.gbs</code></p> <p>This command starts fpgad as a system daemon process: <pre><code>sudo systemctl start fpgad\n</code></pre></p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/","title":"fpgainfo","text":""},{"location":"host-attach-util/fpgainfo/fpgainfo/#synopsis","title":"SYNOPSIS","text":"<pre><code>   fpgainfo [-h] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR]\n            {errors,power,temp,fme,port,bmc,mac,phy,security}\n</code></pre>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#description","title":"DESCRIPTION","text":"<p>fpgainfo displays FPGA information derived from sysfs files. The command argument is one of the following: <code>errors</code>, <code>power</code>, <code>temp</code>, <code>port</code>, <code>fme</code>, <code>bmc</code>, <code>phy</code> or <code>mac</code>,<code>security</code>,<code>events</code>. Some commands may also have other arguments or options that control their behavior.</p> <p>For systems with multiple FPGA devices, you can specify the BDF to limit the output to the FPGA resource with the corresponding PCIe configuration. If not specified, information displays for all resources for the given command.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#fpgainfo-commands","title":"FPGAINFO COMMANDS","text":"<p><code>errors</code></p> <p>Show/clear errors of an FPGA resource that the first argument specifies. <code>fpgainfo</code> displays information in human readable form.</p> <p><code>power</code></p> <p>Show total the power in watts that the FPGA hardware consumes.</p> <p><code>temp</code></p> <p>Show FPGA temperature values in degrees Celcius.</p> <p><code>port</code></p> <p>Show information about the port such as the AFU ID of currently loaded AFU.</p> <p><code>fme</code></p> <p>Show information about the FPGA platform including the partial reconfiguration (PR) Interface ID, the OPAE version, and the FPGA Interface Manager (FIM) ID.</p> <p><code>bmc</code></p> <p>Show all Board Management Controller sensor values for the FPGA resource, if available.</p> <p><code>phy</code></p> <p>Show information about the PHY integrated in the FPGA, if available.</p> <p><code>mac</code></p> <p>Show information about the MAC address in ROM attached to the FPGA, if available.</p> <p><code>security</code></p> <p>Show information about the security keys, hashs and flash count, if available.</p> <p><code>events</code></p> <p>Show information about events and sensors, if available.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p> <p><code>--version, -v</code></p> <p>Prints version information and exit.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#common-arguments","title":"COMMON ARGUMENTS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-S, --segment</code></p> <p>PCIe segment number of resource.</p> <p><code>-B, --bus</code></p> <p>PCIe bus number of resource.</p> <p><code>-D, --device</code></p> <p>PCIe device number of resource.</p> <p><code>-F, --function</code></p> <p>PCIe function number of resource.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#errors-arguments","title":"ERRORS ARGUMENTS","text":"<p>The first argument to the <code>errors</code> command specifies the resource type. It must be one of the following:    <code>fme</code>,<code>port</code>,<code>all</code></p> <p><code>fme</code></p> <p>Show/clear FME errors. </p> <p><code>port</code></p> <p>Show/clear PORT errors.</p> <p><code>all</code></p> <p>Show/clear errors for all resources.</p> <p>The optional <code>&lt;command-args&gt;</code> arguments are:</p> <p><code>--clear, -c</code></p> <p>Clear errors for the given FPGA resource.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#phy-arguments","title":"PHY ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--group, -G</code></p> <p>Select which PHY group(s) information to show.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#events-arguments","title":"EVENTS ARGUMENTS","text":"<p>The optional <code>&lt;command-args&gt;</code> argument is:</p> <p><code>--list,-l</code></p> <p>List boots (implies --all).</p> <p><code>--boot,-b</code></p> <p>Boot index to use, i.e: \u00a0\u00a0\u00a0\u00a00 for current boot (default). \u00a0\u00a0\u00a0\u00a01 for previous boot, etc.</p> <p><code>--count,-c</code></p> <p>Number of events to print.</p> <p><code>--all,-a</code></p> <p>Print all events.</p> <p><code>--sensors,-s</code></p> <p>Print sensor data too.</p> <p><code>--bits,-i</code></p> <p>Print bit values too.</p> <p><code>--help,-h</code></p> <p>Print this help.</p>"},{"location":"host-attach-util/fpgainfo/fpgainfo/#examples","title":"EXAMPLES","text":"<p>This command shows the current power telemetry: <pre><code>./fpgainfo power\n</code></pre></p> <p>This command shows the current temperature readings: <pre><code>./fpgainfo temp\n</code></pre></p> <p>This command shows FME resource errors: <pre><code>./fpgainfo errors fme\n</code></pre> This command clears all errors on all resources: <pre><code>./fpgainfo errors all -c\n</code></pre> This command shows information of the FME on bus 0x5e <pre><code>./fpgainfo fme -B 0x5e\n</code></pre> This command shows information of the FPGA security on bus 0x5e <pre><code>./fpgainfo security -B 0x5e\n</code></pre> This command shows all events and sensors information including sensor bits: <pre><code>./fpgainfo events -asi\n</code></pre></p>"},{"location":"host-attach-util/fpgaport/fpgaport/","title":"fpgaport","text":""},{"location":"host-attach-util/fpgaport/fpgaport/#synopsis","title":"SYNOPSIS","text":"<pre><code>fpgaport [-h] [-N NUMVFS] [-X] [--debug] {assign,release} device [port]\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#description","title":"DESCRIPTION","text":"<p>The <code>fpgaport</code> enables and disables virtualization. It assigns and releases control of the port to the virtual function (VF). By default, the driver assigns the port to the physical function (PF) in the non-virtualization use case.</p>"},{"location":"host-attach-util/fpgaport/fpgaport/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{assign, release}</code></p> <pre><code>Action to perform.\n</code></pre> <p><code>device</code></p> <pre><code>The FPGA device being targeted with this action.\n</code></pre> <p><code>port</code></p> <pre><code>The number of the port.\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-N NUMVFS, --numvfs NUMVFS</code></p> <pre><code>Create NUMVFS virtual functions. The typical value is 1.\n</code></pre> <p><code>-X, --destroy-vfs</code></p> <pre><code>Destroy all virtual functions prior to assigning.\n</code></pre> <p><code>--debug</code></p> <pre><code>Display additional log information.\n</code></pre> <p><code>-h, --help</code></p> <pre><code>Print usage information.\n</code></pre>"},{"location":"host-attach-util/fpgaport/fpgaport/#example","title":"EXAMPLE","text":"<p><code>fpgaport release /dev/dfl-fme.0 0</code></p> <pre><code>Release port 0 from physical function control.\n</code></pre> <p><code>fpgaport assign /dev/dfl-fme.0 0</code></p> <pre><code>Assign port 0 to physical function control.\n</code></pre>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/","title":"fpgasupdate","text":""},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#synopsis","title":"SYNOPSIS","text":"<p><code>fpgasupdate [--log-level=&lt;level&gt;] file [bdf]</code></p>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#description","title":"DESCRIPTION","text":"<p>The <code>fpgasupdate</code> command implements a secure firmware update for the following programmable accelerator cards (PACs): * Intel\u00ae PAC with Intel Arria\u00ae 10 GX FPGA * Intel\u00ae FPGA PAC D5005 * Intel\u00ae PAC N3000 * Intel\u00ae FPGA SmartNIC N6001-PL with Intel&amp;reg Agilex&amp;reg FPGA * Intel\u00ae FPGA IPU F2000X-PL</p> <p><code>--log-level &lt;level&gt;</code></p> <pre><code>Specifies the `log-level` which is the level of information output to your command tool.\nThe following seven levels  are available: `state`, `ioctl`, `debug`, `info`, `warning`,\n`error`, `critical`. Setting `--log-level=state` provides the most verbose output.\nSetting `--log-level=ioctl` provides the second most information, and so on. The default\nlevel is `info`.\n</code></pre> <p><code>file</code></p> <pre><code>Specifies the secure update firmware file to be programmed. This file may be to program a\nstatic region (SR), programmable region (PR), root entry hash, key cancellation, or other\ndevice-specific firmware.\n</code></pre> <p><code>bdf</code></p> <pre><code>The PCIe&amp;reg; address of the PAC to program. `bdf` is of the form `[ssss:]bb:dd:f`,\ncorresponding to PCIe segment, bus, device, function. The segment is optional. If\nyou do not specify a segment, the segment defaults to `0000`. If the system has only\none PAC you can omit the `bdf` and let `fpgasupdate`  determine the address\nautomatically.\n</code></pre>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#troubleshooting","title":"TROUBLESHOOTING","text":"<p>To gather more debug output, decrease the <code>--log-level</code> parameter. </p>"},{"location":"host-attach-util/fpgasupdate/fpgasupdate/#examples","title":"EXAMPLES","text":"<p><code>fpgasupdate firmware.bin</code> <code>fpgasupdate firmware.bin 05:00.0</code> <code>fpgasupdate firmware.bin 0001:04:02.0 --log-level=ioctl</code></p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/","title":"host_exerciser","text":""},{"location":"host-attach-util/host_exerciser/host_exerciser/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: host_exerciser [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=warning\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mode UINT:value in {lpbk-&gt;0,read-&gt;1,trput-&gt;3,write-&gt;2} OR {0,1,3,2}=lpbk\n                              host exerciser mode {lpbk,read, write, trput}\n  --cls UINT:value in {cl_1-&gt;0,cl_2-&gt;1,cl_4-&gt;2,cl_8-&gt;3} OR {0,1,2,3}=cl_1\n                              number of CLs per request{cl_1, cl_2, cl_4, cl_8}\n  --continuousmode BOOLEAN=false\n                              test rollover or test termination\n  --atomic UINT:value in {cas_4-&gt;9,cas_8-&gt;11,fadd_4-&gt;1,fadd_8-&gt;3,off-&gt;0,swap_4-&gt;5,swap_8-&gt;7} OR {9,11,1,3,0,5,7}=off\n                              atomic requests (only permitted in combination with lpbk/cl_1)\n  --encoding UINT:value in {default-&gt;0,dm-&gt;1,pu-&gt;2,random-&gt;3} OR {0,1,2,3}=default\n                              data mover or power user encoding -- random interleaves both in the same stream\n  -d,--delay BOOLEAN=false    Enables random delay insertion between requests\n  --interleave UINT=0         Interleave requests pattern to use in throughput mode {0, 1, 2}\n                              indicating one of the following series of read/write requests:\n                              0: rd-wr-rd-wr\n                              1: rd-rd-wr-wr\n                              2: rd-rd-rd-rd-wr-wr-wr-wr\n  --interrupt UINT:INT in [0 - 3]\n                              The Interrupt Vector Number for the device\n  --contmodetime UINT=1       Continuous mode time in seconds\n  --testall BOOLEAN=false     Run all tests\n  --clock-mhz UINT=0          Clock frequency (MHz) -- when zero, read the frequency from the AFU\nSubcommands:\n  lpbk                        run simple loopback test\n  mem                         run simple mem test\n</code></pre>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#description","title":"DESCRIPTION","text":"<p>A host exerciser is used to exercise and characterize the various host-FPGA interactions eg. MMIO, Data transfer from host to FPGA , PR, host to FPGA memory etc.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-loopback-he-lb","title":"Host Exerciser Loopback (HE-LB)","text":"<p>The HE-LB module is responsible for generating traffic with the intention of exercising the path from the AFU to the Host at full bandwidth.  Host Exerciser Loopback (HE-LB) AFU can move data between host memory and FPGA.</p> <p>HE-LB IP supports: 1. Latency (AFU to Host memory read) 2. MMIO latency (Write+Read) 3. MMIO BW (64B MMIO writes) 4. BW (Read/Write, Read only, Wr only)</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-memory-he-mem","title":"Host Exerciser Memory (HE-MEM)","text":"<p>The HE-MEM module is used to exercise use of FPGA connected DDR; data read from the host is  written to DDR, and the same data is read from DDR before sending it back to the  host. HE-MEM uses external DDR memory (i.e. EMIF) to store data. It has a customized version of the AVMM interface to communicate with the EMIF memory controller.</p> <p>Execution of these exercisors requires the user to bind specific VF endpoint to vfio-pci Bind the correct endpoint for a device with B/D/F 0000:b1:00.0</p> <p><code>[user@localhost]: sudo opae.io init -d 0000:b1:00.2 user:user</code></p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#host-exerciser-sub-commands","title":"HOST EXERCISER SUB COMMANDS","text":"<p><code>lpbk</code></p> <p>run host exerciser loopback test</p> <p><code>mem</code></p> <p>run host exerciser memory test</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set host exerciser tool log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>host exerciser tool time out, by default time out 60000</p> <p><code>-m,--mode</code></p> <p>host exerciser test modes are lpbk, read, write, trput</p> <p><code>--cls</code></p> <p>Number of cachelines per request 1, 2, 3, 4.</p> <p><code>--continuousmode</code></p> <p>Configures test rollover or test termination mode.</p> <p><code>--atomic</code></p> <p>atomic requests.</p> <p><code>--encoding</code></p> <p>select data mover mode or power user mode or random.</p> <p><code>-d,--delay</code></p> <p>Enables random delay insertion between requests.</p> <p><code>--interleave</code></p> <p>Enables interleave requests in throughput mode. Value:3'b000-Rd,Wr,Rd,Wr Value:3'b001-Rd,Rd,Wr,Wr Value:3'b010-Rd,Rd,Rd,Rd,Wr,Wr,Wr,Wr Value:3'b011-Not supported</p> <p><code>--interrupt</code></p> <p>Accelerator interrupt vector Number.</p> <p><code>--contmodetime</code></p> <p>Continuous mode time in seconds.</p> <p><code>--testall</code></p> <p>Run all host exerciser tests.</p> <p><code>--clock-mhz</code></p> <p>pcie clock frequency, default value 350Mhz.</p>"},{"location":"host-attach-util/host_exerciser/host_exerciser/#examples","title":"EXAMPLES","text":"<p>This command exerciser Loopback afu: <pre><code>host_exerciser lpbk\n</code></pre></p> <p>This command exerciser memory afu: <pre><code>host_exerciser mem\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0: <pre><code>host_exerciser --pci-address 000:3b:00.0    lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run in write mode: <pre><code>host_exerciser --pci-address 000:3b:00.0   --mode write lpbl\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run 2 cache lines per request: <pre><code>host_exerciser --pci-address 000:3b:00.0   --cls cl_2  lpbk\n</code></pre></p> <p>This command exerciser Loopback afu on pcie 000:3b:00.0 and run continuous mode for 10 seconds: <pre><code>host_exerciser --pci-address 000:3b:00.0   -cls cl_1   -m 0 --continuousmode true --contmodetime 10 lpbk\n</code></pre></p>"},{"location":"host-attach-util/hssi/hssi/","title":"hssi","text":""},{"location":"host-attach-util/hssi/hssi/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi COMMON_OPTIONS MODE MODE_OPTIONS</code></p>"},{"location":"host-attach-util/hssi/hssi/#description","title":"DESCRIPTION","text":"<p>The <code>hssi</code> application provides a means of interacting with the 10G, 100G, and 200G/400F HE-HSSI AFUs. In all operating modes, the application initializes the AFU and completes the desired transfer as described by the mode- specific options.</p> <p>COMMON_OPTIONS - application options common to the 10G, 100g, and 200G/400G modes.</p> <p><code>-h, --help</code></p> <pre><code>Display common command-line help and exit.\n</code></pre> <p><code>-p, --pci-address ADDR</code></p> <pre><code>The PCIe address of the desired accelerator in ssss:bb:dd.f format.\n</code></pre> <p><code>-s, --shared on|off</code></p> <pre><code>Whether to open the accelerator in shared mode. The default is off.\n</code></pre> <p><code>-t, --timeout VALUE</code></p> <pre><code>The application timeout value in milliseconds. The default timeout is 60000 msec.\n</code></pre> <p>MODE - select AFU. Valid values are hssi_10g, hssi_100g, hssi_200g_400g.</p> <p>MODE_OPTIONS [hssi_10g] - application options specific to the 10G AFU.</p> <p><code>-h, --help</code></p> <pre><code>Display 10G AFU specific command-line help and exit.\n</code></pre> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--random-length fixed|random</code></p> <pre><code>Specify packet length randomization. Valid values are fixed and\nrandom. The default is fixed (no randomization).\n</code></pre> <p><code>--random-payload incremental|random</code></p> <pre><code>Specify payload randomization. Valid values are incremental and\nrandom. The default is incremental.\n</code></pre> <p><code>--packet-length LENGTH</code></p> <pre><code>Specify packet length. The default is 64 bytes.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--rnd-seed0 SEED0</code></p> <pre><code>Specify the prbs generator bits [31:0]. The default is 1592590336.\n</code></pre> <p><code>--rnd-seed1 SEED1</code></p> <pre><code>Specify the prbs generator bits [47:32]. The default is 1592590337.\n</code></pre> <p><code>--rnd-seed2 SEED2</code></p> <pre><code>Specify the prbs generator bits [91:64]. The default is 155373.\n</code></pre> <p>MODE_OPTIONS [hssi_100g] - application options specific to the 100G AFU.</p> <p><code>--port PORT</code></p> <pre><code>Select the QSFP port in the range 0-7. The default is port 0.\n</code></pre> <p><code>--eth-loopback on|off</code></p> <pre><code>Whether to enable loopback on the ethernet interface. Valid values are\non and off. The default is on.\n</code></pre> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. The default is 1 packet.\n</code></pre> <p><code>--gap random|none</code></p> <pre><code>Inter-packet gap. Valid values are random and none. The default is none.\n</code></pre> <p><code>--pattern random|fixed|increment</code></p> <pre><code>Pattern mode. Valid values are random, fixed, or increment. The default\nis random.\n</code></pre> <p><code>--src-addr ADDR</code></p> <pre><code>Specify the source MAC address. The default value is 11:22:33:44:55:66.\n</code></pre> <p><code>--dest-addr ADDR</code></p> <pre><code>Specify the destination MAC address. The default value is 77:88:99:aa:bb:cc.\n</code></pre> <p><code>--start-size SIZE</code></p> <pre><code>Specify the packet size in bytes, or the first packet size for --pattern increment.\n</code></pre> <p><code>--end-size SIZE</code></p> <pre><code>Specify the end packet size in bytes.\n</code></pre> <p><code>--end-select pkt_num|gen_idle</code></p> <pre><code>Specify packet generation end mode.\n</code></pre> <p>MODE_OPTIONS [pkt_filt_10g] - application options specific to the Packet Filter 10G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.0\n</code></pre> <p>MODE_OPTIONS [pkt_filt_100g] - application options specific to the Packet Filter 100G AFU.</p> <p><code>--dfl-dev DFL_DEV</code></p> <pre><code>Packet Filter DFL device, eg --dfl-dev dfl_dev.1\n</code></pre> <p>MODE_OPTIONS [hssi_200g_400g] - application options specific to the 200G/400G AFU.</p> <p><code>--num-packets PACKETS</code></p> <pre><code>The number of packets to transfer. Must be a multiple of 32. Default value is 32. Increasing the timeout (--timeout) may be necessary if specifying a large number of packets.\n</code></pre>"},{"location":"host-attach-util/hssi/hssi/#examples","title":"EXAMPLES","text":"<p><code>hssi -h</code> <code>hssi hssi_10g -h</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_10g --eth-loopback=on --num-packets=500</code> <code>sudo hssi --pci-address=0000:3b:00.0 hssi_100g --pattern=increment</code> <code>sudo hssi --pci-address=0000:0d:00.6 hssi_200g_400g --num-packets=640000</code></p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/","title":"HSSI ethernet loopback","text":""},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssiloopback [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS] --loopback [{enable,disable}]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#description","title":"DESCRIPTION","text":"<p>The <code>hssiloopback</code>  tool enables and disable ethernet loopback.</p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p> <p><code>--loopback [{enable,disable}]</code></p> <p>Ethernet enable or disable loopback.</p>"},{"location":"host-attach-util/hssi_ethernet/hssiloopback/#examples","title":"EXAMPLES","text":"<p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback enable</code></p> <p>Enables ethernet loopback</p> <p><code>hssiloopback --pcie-address  0000:04:00.0 --loopback disable</code></p> <p>Disable ethernet loopback</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/","title":"HSSI ethernet mac","text":""},{"location":"host-attach-util/hssi_ethernet/hssimac/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssimac [-h] --pcie-address PCIE_ADDRESS [--port PORT]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#description","title":"DESCRIPTION","text":"<p>The <code>hssimac</code>  tool provides Maximum TX and RX frame size.</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga  in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0).</p> <p><code>--port PORT</code></p> <p>hssi port number.</p>"},{"location":"host-attach-util/hssi_ethernet/hssimac/#examples","title":"EXAMPLES","text":"<p><code>hssimac --pcie-address  0000:04:00.0 --port 1</code></p> <p>prints Maximum TX and RX frame size for port 1.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/","title":"HSSI ethernet statistics","text":""},{"location":"host-attach-util/hssi_ethernet/hssistats/#synopsis","title":"SYNOPSIS","text":"<pre><code>hssistats [-h] [--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS]\n</code></pre>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#description","title":"DESCRIPTION","text":"<p>The <code>hssistats</code>  tool provides the MAC statistics.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code></p> <p>Prints usage information</p> <p><code>--pcie-address PCIE_ADDRESS, -P PCIE_ADDRESS</code></p> <p>The PCIe address of the desired fpga in ssss:bb:dd.f format. sbdf of device to program (e.g. 04:00.0 or 0000:04:00.0). Optional when one device in system.</p>"},{"location":"host-attach-util/hssi_ethernet/hssistats/#examples","title":"EXAMPLES","text":"<p><code>hssistats --pcie-address  0000:04:00.0</code></p> <p>prints the MAC statistics </p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/","title":"hssi_loopback","text":""},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#name","title":"NAME","text":"<p>hssi_loopback - Software utility to run HSSI loopback tests on FPGA</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#synopsis","title":"SYNOPSIS","text":"<p><code>hssi_loopback [[--bus|-b &lt;bus number&gt;] [--device | -d &lt;device number&gt;] [--function | -f &lt;function number&gt;]]|[--socket-id &lt;socket-id&gt;]       [--mode|-m auto|e40|e10]        [send [&lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]] |status [clear] | stop | readmacs</code></p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#description","title":"DESCRIPTION","text":"<p>The <code>hssi_loopback</code> utility works in conjunction with a packet generator accelerator function unit (AFU) to test high-speed serial interface (HSSI) cards. The <code>hssi_loopback</code> utility tests both external and internal loopbacks. <code>hssi_loopback</code> runs an external loopback test when the command line arguments include both source and destination ports. <code>hssi_loopback</code> runs an internal loopback test when command line arguments include a single port. <code>hssi_loopback</code> only runs on the Intel Xeon with Arria 10 FPGA. You cannot run it on the Intel PAC (programmable accelerator card).</p> <p>NOTE: The following limitations apply to the current version of hssi_loopback:</p> <ul> <li>For the external loopback the two port arguments can be the same. For the e10 design, the ports should be the same.</li> <li>The <code>hssi_loopback</code> test supports only the e40 and e10 E2E AFUs.  The e10 E2E AFU tests HSSI with a retimer card.</li> <li>The <code>hssi_loopback</code> test uses the control and status registers (CSRs) defined in the AFU.</li> </ul>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#options","title":"OPTIONS","text":"<p><code>-S SOCKET_ID, --socket-id SOCKET_ID</code></p> <p>Socket ID FPGA resource.</p> <p><code>-B BUS, --bus BUS</code></p> <p>Bus ID of FPGA resource.</p> <p><code>-D DEVICE, --device DEVICE</code></p> <p>Device ID of FPGA resource.</p> <p><code>-F FUNCTION, --function FUNCTION</code></p> <p>Function ID of FPGA resource.</p> <p><code>-G, --guid</code></p> <p>Specifies guid for the resource enumeration.</p> <p><code>-m, --mode</code></p> <p>One of the following: [<code>auto</code>, <code>e40</code>, <code>e10</code>] <code>auto</code> is the default and indicates that the software runs the mode based on the first accelerator functional unit it identifies.</p> <p><code>-t, --timeout</code></p> <p>Timeout (in seconds) before the application terminates in continuous mode. Continuous mode is the default when you do not specify the number of packets.</p> <p><code>-y, --delay</code></p> <p>Delay (in seconds) between printing out a simple status line. Default is 0.100 seconds (100 milliseconds).</p> <p><code>-c, --packet-count</code></p> <p>The number of packets to send.</p> <p><code>-d, --packet-delay</code></p> <p>The delay in between packets. This delay is the number of 100 MHz clock cycles, roughly 10 nanoseconds.</p> <p><code>-s, --packet-size</code></p> <p>The packet size to send. The minimum is 46 bytes and the maximum is 1500 bytes. The default is 46 bytes.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#commands","title":"COMMANDS","text":"<p><code>send &lt;source port&gt; [&lt;destination port&gt;] [--packet-count|-c &lt;count&gt;] [--packet-delay|-d &lt;delay&gt;] [--packet-length|-l &lt;length&gt;]</code></p> <p>Send packets from one port to the other. If the command line does not specify a destination port, the test runs an internal  loopback. Otherwise, the test runs an external loopback from the source port to the destination port.</p> <p><code>status [clear]</code></p> <p>Read and interpret the status registers and print to the screen. <code>clear</code> clears the status registers.</p> <p><code>stop</code></p> <p>Issue a stop command to all Ethernet controllers in the AFU.</p> <p><code>readmacs</code></p> <p>Read and display the port MAC addresses. An EEPROM stores the MAC addresses.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#exit-codes","title":"EXIT CODES","text":"<p>0    Success - Number of packets received are equal to the number of packets sent and no errors           are reported.</p> <p>-1    Loopback failure - Either number of packets does not match or the test detected errors.</p> <p>-2    Errors parsing arguments.</p>"},{"location":"host-attach-util/hssi_loopback/hssi_loopback/#examples","title":"EXAMPLES","text":"<p>Read the MAC addresses of the AFU loaded on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback readmacs -B 0x5e\n</code></pre> <p>Run an external loopback, sending 100 packets from port 0 to port 1. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 1 -c 100\n</code></pre> <p>Run an internal loopback until a timeout of 5 seconds is reached. The AFU is on bus 0x5e:</p> <pre><code>&gt;sudo hssi_loopback -B 0x5e send 0 -t 5\n</code></pre>"},{"location":"host-attach-util/mem_tg/mem_tg/","title":"mem_tg","text":""},{"location":"host-attach-util/mem_tg/mem_tg/#synopsis","title":"SYNOPSIS","text":"<pre><code>Usage: mem_tg [OPTIONS] SUBCOMMAND\nOptions:\n  -h,--help                   Print this help message and exit\n  -g,--guid TEXT=4DADEA34-2C78-48CB-A3DC-5B831F5CECBB\n                              GUID\n  -p,--pci-address TEXT       [&lt;domain&gt;:]&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;\n  -l,--log-level TEXT:{trace,debug,info,warning,error,critical,off}=info\n                              stdout logging level\n  -s,--shared                 open in shared mode, default is off\n  -t,--timeout UINT=60000     test timeout (msec)\n  -m,--mem-channel UINT=0     Target memory bank for test to run on (0 indexed)\n  --loops UINT=1              Number of read/write loops to be run\n  -w,--writes UINT=1          Number of unique write transactions per loop\n  -r,--reads UINT=1           Number of unique read transactions per loop\n  -b,--bls UINT=1             Burst length of each request\n  --stride UINT=1             Address stride for each sequential transaction\n  --data UINT:value in {fixed-&gt;0,prbs15-&gt;2,prbs31-&gt;3,prbs7-&gt;1,rot1-&gt;3} OR {0,2,3,1,3}=fixed\n                              Memory traffic data pattern: fixed, prbs7, prbs15, prbs31, rot1\n  -f,--mem-frequency UINT=0   Memory traffic clock frequency in MHz\nSubcommands:\n  tg_test                     configure &amp; run mem traffic generator test\n</code></pre>"},{"location":"host-attach-util/mem_tg/mem_tg/#description","title":"DESCRIPTION","text":"<p>The memory traffic generator (TG) used to exercise and test available memory channels with a configurable traffic pattern.</p> <p>Execution of this application requires the user to bind the specific VF endpoint containing the mem_tg AFU id to vfio-pci</p> <p>In the TG, read responses are checked against a specified pattern. If the application is configured to perform a read only test on a region of memory that has not previously been initialized to contain that pattern it will flag a test failure.</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>--help, -h</code></p> <p>Prints help information and exit.</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#common-arguments-options","title":"COMMON ARGUMENTS / OPTIONS","text":"<p>The following arguments are common to all commands and are optional.</p> <p><code>-p,--pci-address</code></p> <p>PCIe domain, bus, device, function number of fpga resource.</p> <p><code>-l,--log-level</code></p> <p>set application log level, trace, debug, info, warning, error, critical, off</p> <p><code>-s,--shared</code></p> <p>open FPGA PCIe resource in shared mode</p> <p><code>-t,--timeout</code></p> <p>mem_tg application time out, by default time out 60000</p> <p><code>-m,--mem-channel</code></p> <p>Target memory bank for test to run on (0 indexed)  default: 0</p> <p><code>--loops</code></p> <p>Number of read/write loops to be run  default: 1</p> <p><code>-w,--writes</code></p> <p>Number of unique write transactions per loop.  default: 1</p> <p><code>-r,--reads</code></p> <p>Number of unique read transactions per loop  default: 1</p> <p><code>-b,--bls</code></p> <p>AXI4 burst length of each request.  Supports 1-256 transfers beginning from 0. default: 0</p> <p><code>--stride</code></p> <p>Address stride for each sequential transaction (&gt;= burst length)  default: 1</p> <p><code>--data</code></p> <p>Memory traffic data pattern. 0 = fixed {0xFF, 0x00} 1 = prbs7 2 = prbs15 3 = prbs31 4 = rot1</p> <p>default: fixed</p> <p><code>-f, --mem-frequency</code></p> <p>Memory traffic clock frequency in MHz  default: 300 MHz</p>"},{"location":"host-attach-util/mem_tg/mem_tg/#examples","title":"EXAMPLES","text":"<p>This command will run a basic read/write test on the channel 0 traffic generator: <pre><code>mem_tg tg_test\n</code></pre></p> <p>This command will run the application for an afu on pcie 000:b1:00.7: <pre><code>mem_tg --pci-address 000:b1:00.7 tg_test\n</code></pre></p> <p>This command will test channel 2 write bandwidth: <pre><code>mem_tg -loops 1000 -w 1000 -r 0 -m 2 tg_test\n</code></pre></p> <p>This command will perform a read bandwidth test with a burst of 16 on channel 1 and perform a data comparison with the prbs7 pattern: <pre><code>mem_tg -loops 1000 -w 0 -r 1000 -b 0xF --data prbs7 -m 1 tg_test\n</code></pre></p> <p>This command will perform a read/write test with 1 MB strided access to channel 0 memory: <pre><code>mem_tg -loops 10000 --stride 0x100000 tg_test\n</code></pre></p>"},{"location":"host-attach-util/mmlink/mmlink/","title":"mmlink","text":""},{"location":"host-attach-util/mmlink/mmlink/#synopsis","title":"Synopsis","text":"<p><code>mmlink [-v] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [-S &lt;socket&gt;] [-P &lt;TCP port&gt;] [-I &lt;IP Address&gt;]</code></p>"},{"location":"host-attach-util/mmlink/mmlink/#description","title":"Description","text":"<p>The Remote Signal Tap logic analyzer provides real-time hardware debugging for the Accelerator Function Unit (AFU).  It provides a signal trace capability that the Quartus Prime software adds to the AFU. The Remote Signal Tap logic analyzer provides access to the Remote Signal Tap part of the Port MMIO space and then runs the remote protocol.</p>"},{"location":"host-attach-util/mmlink/mmlink/#examples","title":"Examples","text":"<p><code>./mmlink  -B 0x5e -P 3333</code></p> <p>MMLink app starts and listens for connection.</p>"},{"location":"host-attach-util/mmlink/mmlink/#options","title":"Options","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-S,--socket</code> </p> <p>FPGA socket number.</p> <p><code>-P,--port</code> </p> <p>TCP port number.</p> <p><code>-I,--ip</code> </p> <p>IP address of FPGA system. </p>"},{"location":"host-attach-util/mmlink/mmlink/#notes","title":"Notes","text":"<p>Driver privilege:</p> <p>Change AFU driver privilege to user:</p> <pre><code>$ chmod 777 /dev/intel-fpga-port.0\n</code></pre> <p>Change locked memory size:</p> <p>edit the file /etc/security/limits.conf</p> <pre><code>$ sudo vi /etc/security/limits.conf\n\nuser    hard   memlock           10000\n\nuser    soft   memlock           10000\n</code></pre> <p>Exit terminal and log into a new terminal.</p> <p>Verify that the locked memory is now set:  ``` $ ulimit -l 10000</p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/","title":"ofs.uio","text":""},{"location":"host-attach-util/ofs_uio/ofs_uio/#synopsis","title":"SYNOPSIS","text":"<p><code>ofs.uio [-h] [--pcie-address PCIE_ADDRESS] [--uio uiox] [--feature-id FEATURE_ID] [--region-index REGION_INDEX]                   [--mailbox-cmdcsr offset] [--bit-size {8,16,32,64}] [--peek offset] [--poke offset value]                   [--mailbox-read offset] [--mailbox-dump address size] [--mailbox-write address value]</code></p> <p><code>ofs.uio [--uio uiox] [--peek offset]</code> <code>ofs.uio [--uio uiox] [--poke offset value]</code> <code>ofs.uio [--uio uiox] [--mailbox-read address]</code> <code>ofs.uio [--uio uiox] [--mailbox-write address value]</code> <code>ofs.uio [--uio uiox] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#description","title":"DESCRIPTION","text":"<p><code>ofs.uio</code> is a tool that provides user space access to DFL UIO devices, command line options like peek, poke, mailbox-read, mailbox-write, mailbox-dump to  access Configuration and Status Registers (CSRs).</p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#options","title":"OPTIONS","text":""},{"location":"host-attach-util/ofs_uio/ofs_uio/#peek","title":"Peek","text":"<p>Peek/Read UIO CSR offset <code>ofs.uio [--uio uio] [--peek offset]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#poke","title":"Poke","text":"<p>Poke/Write value to UIO CSR offset <code>ofs.uio [--uio uio] [--poke offset value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--poke offset value]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-read","title":"Mailbox Read","text":"<p>Read CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-read address]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-write","title":"Mailbox Write","text":"<p>Write value to CSR address using mailbox  <code>ofs.uio [--uio uio] [--mailbox-write address value]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-write address value]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-dump","title":"Mailbox Dump","text":"<p>Reads/Dumps block size of CSR address using mailbox <code>ofs.uio [--uio uio] [--mailbox-dump address size]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--mailbox-dump address size]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#bit-size","title":"Bit size","text":"<p>Read/Write bit-field 8,16,32,64 sizes <code>ofs.uio [--uio uio] --bit-size 8 [--peek offset]</code> <code>ofs.uio [--uio uio] --bit-size 32 [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#pcie-address","title":"PCIe Address","text":"<p>PCIE_ADDR PCIe address of FPGA device <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#uio-region-index","title":"UIO region index","text":"<p>UIO region index, default region index is 0  <code>ofs.uio [--uio uio] --region-index 0 [--peek offset]</code> <code>ofs.uio [--uio uio] --region-index 1 [--peek offset]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#mailbox-command-status-csr-offset","title":"Mailbox command status csr offset","text":"<p>Mailbox command status csr offset,  default value set to dfl pcie subsystem system feature mailbox command status register offset 0x28  <code>ofs.uio [--uio uio] --mailbox-cmdcsr 0xa8 [--mailbox-read address]</code> <code>ofs.uio [--pcie-address PCIE_ADDRESS] [--feature-id FEATURE_ID] --mailbox-cmdcsr 0xa8  [--mailbox-read address]</code></p>"},{"location":"host-attach-util/ofs_uio/ofs_uio/#examples","title":"EXAMPLES","text":"<p>Peek/Read <pre><code>ofs.uio --uio uio0 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio6 --peek 0x0\npeek(0x0): 0x3000000100000020\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x0): 0x3000000010002015\n\nofs.uio --uio uio0 --peek 0x0 --bit-size 32\npeek(0x0): 0x10002015\n</code></pre></p> <p>Poke/Write <pre><code>ofs.uio --uio uio6 --peek 0x8\npeek(0x8): 0x0\nofs.uio --uio uio6 --poke  0x8 0xabcdd12345\npoke(0x8):0xabcdd12345\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --peek 0x0\npeek(0x8): 0x0\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x15 --poke  0x8 0x1234\npoke(0x8):0x1234\n</code></pre></p> <p>Mailbox Read <pre><code>ofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --uio uio6 --mailbox-read 0x8\nMailboxRead(0x8): 0x110c000\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0\nMailboxRead(0x0): 0x1000000\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x8 \nMailboxRead(0x8): 0x110c000\n</code></pre></p> <p>Mailbox Write <pre><code>ofs.uio --uio uio6 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --uio uio6 --mailbox-read 0x0\nMailboxRead(0x0):0x1234\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-write 0x0 0x1234\nMailboxWrite(0x0):0x1234\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-read 0x0 \nMailboxRead(0x0):0x1234\n</code></pre></p> <p>Mailbox Dump <pre><code>ofs.uio --uio uio6 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n\nofs.uio --pcie-address 0000:b1:00.0 --feature-id 0x20 --mailbox-dump 0x0 0x10\nMailboxDump(0x0): 0x1000000\nMailboxDump(0x4): 0x1000000\nMailboxDump(0x8): 0x110c000\nMailboxDump(0xc): 0x110c000\nMailboxDump(0x10): 0x0\nMailboxDump(0x14): 0x0\nMailboxDump(0x18): 0x0\nMailboxDump(0x1c): 0x0\nMailboxDump(0x20): 0x0\nMailboxDump(0x24): 0x0\nMailboxDump(0x28): 0x0\nMailboxDump(0x2c): 0x0\nMailboxDump(0x30): 0x0\nMailboxDump(0x34): 0x0\nMailboxDump(0x38): 0x0\nMailboxDump(0x3c): 0x0\n</code></pre></p>"},{"location":"host-attach-util/opae_io/opae_io/","title":"opae.io","text":""},{"location":"host-attach-util/opae_io/opae_io/#synopsis","title":"SYNOPSIS","text":"<p><code>opae.io ls [-v,--viddid VIDDID] [-s,--sub-viddid SUB_VIDDID] [--all] [--system-class]</code> <code>opae.io init [-d,--device PCI_ADDR] [USER[:GROUP]]</code> <code>opae.io release [-d,--device PCI_ADDR]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] walk [--offset [OFFSET]] [-u,--show-uuid] [-D,--dump] [-c,--count COUNT] [-y,--delay DELAY] [-s,--safe]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] dump [--offset [OFFSET]] [-o,--output OUTPUT] [-f,--format {bin,hex}] [-c,--count COUNT]</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] peek OFFSET</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] poke OFFSET VALUE</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION] script SCRIPT ARG1 ARG2 ... ARGN</code> <code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION]</code></p>"},{"location":"host-attach-util/opae_io/opae_io/#description","title":"DESCRIPTION","text":"<p><code>opae.io</code> is an interactive Python environment packaged on top of <code>libopaevfio.so</code>, which provides user space access to PCIe devices via the vfio-pci driver. The main feature of opae.io is its built-in Python command interpreter, along with some Python bindings that provide a means to access Configuration and Status Registers (CSRs) that reside on the PCIe device.</p> <p><code>opae.io</code> has two operating modes: command line mode and interactive mode.</p>"},{"location":"host-attach-util/opae_io/opae_io/#command-line-mode","title":"COMMAND LINE MODE","text":"<p>To view the accelerator devices that are present on the system, <code>opae.io</code> provides the <code>ls</code> command option.</p> <p><code>opae.io ls [-v,--viddid VIDDID] [-s,--sub-viddid SUB_VIDDID] [--all] [--system-class]</code></p> <p>Each accelerator device is listed along with the PCIe address, the PCIe vendor/device ID, a brief description of the device, and the driver to which the device is currently bound.</p> <p>Device filtering is available by providing a Vendor ID:Device ID pair, eg -v 8086:bcce. Further filtering can be done by providing a sub- Vendor ID:sub-Device ID pair, eg -s 8086:1771. The --all option provides a list of all of the PCIe devices in the system, which an be quite verbose. The --system-class option prints the PCIe database class of the accelerator device, rather than the product name.</p> <p><code>opae.io</code> provides an option to initialize a PCIe device for use with the vfio-pci driver. In order for the device CSRs to be accessed from user space, the device must first be bound to the vfio-pci driver. This is the job of the <code>init</code> command option.</p> <p><code>opae.io init [-d,--device PCI_ADDR] [USER[:GROUP]]</code></p> <p>The <code>init</code> command unbinds the specified device from its current driver and binds it to vfio-pci. This creates a new vfio group under /dev/vfio. This group path is then used by the <code>libopaevfio.so</code> library to interact with the device.</p> <p>To release the PCIe device from vfio-pci and return it to use with its previous driver, the <code>release</code> command option is used.</p> <p><code>opae.io release [-d,--device PCI_ADDR]</code></p> <p>The <code>release</code> command option reverses the actions of the last <code>init</code> command, releasing the device from vfio-pci and binding it to the driver which was bound at the time the <code>init</code> command was issued.</p> <p>The <code>walk</code> command option traverses and displays the Device Feature List of the given region.</p> <p><code>opae.io walk [--offset [OFFSET]] [-u,--show-uuid] [-D,--dump] [-c,--count COUNT] [-y,--delay DELAY] [-s,--safe]</code></p> <p>The various fields of each Device Feature Header are displayed. The <code>--show-uuid</code> option additionally displays the GUID for each feature. OFFSET can be used to specify the beginning of the DFL in the MMIO region. --dump displays the raw DFH contents in hex format. COUNT limits the number of DFH entries traversed. DELAY causes a pause between each printout. --safe examines each DFH offset for proper alignment.</p> <p>The <code>dump</code> command provides a means to dump the MMIO space in ASCII hex or binary format.</p> <p><code>opae.io dump [--offset [OFFSET]] [-o,--output OUTPUT] [-f,--format {bin,hex}] [-c,--count COUNT]</code></p> <p>OFFSET specifies the starting MMIO offset. OUTPUT gives the name of a file to capture the dump output, where sys.stdout is used by default. --format allows changing the output format. COUNT specifies the number of qwords to dump.</p> <p>The <code>peek</code> command option reads and displays a CSR value.</p> <p><code>opae.io peek OFFSET</code></p> <p>The <code>poke</code> command option writes a given value to a CSR.</p> <p><code>opae.io poke OFFSET VALUE</code></p> <p><code>opae.io</code> can also execute Python scripts from the command line. These Python scripts may contain calls to the device built-in functions that are available during an interactive session. Refer to the description of interactive mode for details.</p> <p><code>opae.io script myscript.py a b c</code></p> <p>In order to enter the interactive mode of <code>opae.io</code>, simply invoke it and optionally pass the desired device address and MMIO region options.</p> <p><code>opae.io [-d,--device PCI_ADDR] [-r,--region REGION]</code></p>"},{"location":"host-attach-util/opae_io/opae_io/#interactive-mode","title":"INTERACTIVE MODE","text":"<p>Upon entering interactive mode, <code>opae.io</code> begins a Python interpreter session and displays the command prompt shown below:</p> <p>0000:3f:00.0[0]&gt;&gt;</p> <p>The first portion of the prompt shows the address of the active PCIe device, here 0000:3f:00.0. The part in square brackets shows the active MMIO region, here [0].</p> <p>The interpreter waits for a valid Python command, then attempts to execute the given command in the usual way. The only differences between the traditional Python command intepreter and <code>opae.io</code> are that opae.io provides 1) the notion of an active PCIe device and MMIO region and 2) several built-in functions and objects that allow manipulating the active device and MMIO region.</p>"},{"location":"host-attach-util/opae_io/opae_io/#built-in-functions","title":"BUILT-IN FUNCTIONS","text":"<p>The <code>opae.io</code> built-in functions assume an active device and MMIO region. Attempting to use the built-in functions without first opening a device and region will result in errors.</p> <p><code>peek(OFFSET)</code></p> <p>The <code>peek</code> built-in function reads and displays a CSR value from the active device and region, at the offset supplied by its argument.</p> <p>0000:3f:00.0[0]&gt;&gt; peek(0x28) 0xdeadbeef</p> <p><code>poke(OFFSET, VALUE)</code></p> <p>The <code>poke</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; poke(0x28, 0xdeadbeef)</p> <p><code>read_csr(OFFSET)</code></p> <p>The <code>read_csr</code> built-in function returns the value of the CSR at the active MMIO region and the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; print('0x{:0x}'.format(read_csr(0x28))) 0xdeadbeef</p> <p><code>write_csr(OFFSET, VALUE)</code></p> <p>The <code>write_csr</code> built-in function writes the given VALUE to the current MMIO region at the given OFFSET.</p> <p>0000:3f:00.0[0]&gt;&gt; write_csr(0x28, 0xdeadbeef)</p> <p><code>device(PCI_ADDR)</code></p> <p>The <code>device</code> built-in function allows changing the active PCIe device.</p> <p>0000:3f:00.0[0]&gt;&gt; device('0000:2b:00.0') 0000:2b:00.0&gt;&gt;</p> <p><code>region(REGION)</code></p> <p>The <code>region</code> built-in function allows changing the active MMIO region.</p> <p>0000:2b:00.0&gt;&gt; region(0) 0000:2b:00.0[0]&gt;&gt;</p> <p><code>allocate_buffer(SIZE)</code></p> <p>The <code>allocate_buffer</code> built-in function creates and returns a DMA buffer object. The underlying buffer will be SIZE bytes in length.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = allocate_buffer(4096) 0000:2b:00.0[0]&gt;&gt; print(b1.size, '0x{:0x}'.format(b1.address), b1.io_address) 4096 0x7f9361c66000 0</p> <p><code>version()</code></p> <p>The <code>version</code> built-in function returns a tuple containing the four components used to identify the opae.io version:</p> <p>0000:2b:00.0[0]&gt;&gt; print(version()) ('opae.io', 0, 2, 0)</p>"},{"location":"host-attach-util/opae_io/opae_io/#built-in-objects","title":"BUILT-IN OBJECTS","text":"<p><code>opae.io</code> interactive mode provides two global objects corresponding to the current device and that device's current MMIO region. These objects are referred to by global variables <code>the_device</code> and <code>the_region</code>, respectively.</p> <p>The <code>device</code> class:</p> <p>the_device.descriptor() : method that returns the integer file descriptor of the <code>VFIO container</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.descriptor()) 5</p> <p>the_device.repr() : method that is invoked when a <code>device</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device) 0000:2b:00.0</p> <p>the_device.allocate(SIZE) : method that allocates and returns a <code>system_buffer</code> object. The buffer will be mapped into the DMA space of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; b1 = the_device.allocate(4096)</p> <p>the_device.pci_address() : read-only property that returns the PCIe address of <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.pci_address) 0000:2b:00.0</p> <p>the_device.num_regions : read-only property that returns the number of MMIO regions in <code>the_device</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.num_regions) 2</p> <p>the_device.regions : read-only property that returns a list of the active MMIO regions of <code>the_device</code>:</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_device.regions) [0, 2]</p> <p>The <code>region</code> class:</p> <p>the_region.write32(OFFSET, VALUE) : method that writes a 32-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read32(OFFSET) : method that returns a 32-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write32(0x28, 0xdeadbeef) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read32(0x28))) 0xdeadbeef</p> <p>the_region.write64(OFFSET, VALUE): method that writes a 64-bit VALUE to the CSR at OFFSET.</p> <p>the_region.read64(OFFSET): method that returns a 64-bit CSR at the given OFFSET.</p> <p>0000:2b:00.0[0]&gt;&gt; the_region.write64(0x28, 0xbaddecaf) 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(the_region.read64(0x28))) 0xbaddecaf</p> <p>the_region.index(): method that returns the MMIO index of <code>the_region</code>.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region.index()) 0</p> <p>the_region.repr(): method that is invoked when a <code>region</code> object is printed.</p> <p>0000:2b:00.0[0]&gt;&gt; print(the_region) 0</p> <p>the_region.len(): method that is invoked to determine the MMIO region size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(len(the_region)) 524288</p> <p>The <code>allocate_buffer()</code> built-in function and the <code>device.allocate()</code> method return objects of type <code>system_buffer</code>.</p> <p>The <code>system_buffer</code> class is as follows:</p> <p><code>buf.size</code>: read-only property that gives the buffer size.</p> <p>0000:2b:00.0[0]&gt;&gt; print(b1.size) 4096</p> <p><code>buf.address</code>: read-only property that gives the buffer's user mode virtual address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.address)) 0x7f2c15d8200</p> <p><code>buf.io_address</code>: read-only property that gives the buffer's IO address.</p> <p>0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1.io_address)) 0x0</p> <p><code>buf.__getitem__</code> and <code>buf.__setitem__</code>: indexing get/set of 64-bit data item.</p> <p>0000:2b:00.0[0]&gt;&gt; b1[0] = 0xdecafbad 0000:2b:00.0[0]&gt;&gt; print('0x{:0x}'.format(b1[0])) 0xdecafbad</p> <p><code>buf.read8(OFFSET)</code> <code>buf.read16(OFFSET)</code> <code>buf.read32(OFFSET)</code> <code>buf.read64(OFFSET)</code> : methods that read the given size data item from the given buffer OFFSET.</p> <p><code>buf.fill8(VALUE)</code> <code>buf.fill16(VALUE)</code> <code>buf.fill32(VALUE)</code> <code>buf.fill64(VALUE)</code> : methods that fill the buffer with the given VALUE, using the given size.</p> <p><code>b1.compare(b2)</code>: method that compares buffers. The method returns the index of the first byte that miscompares, or the length of b1.</p>"},{"location":"host-attach-util/opaeuio/opaeuio/","title":"opaeuio","text":""},{"location":"host-attach-util/opaeuio/opaeuio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaeuio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-v] [device]</code></p>"},{"location":"host-attach-util/opaeuio/opaeuio/#description","title":"DESCRIPTION","text":"<p>The <code>opaeuio</code> command enables the binding/unbinding of a DFL device to/from the dfl-uio-pdev device driver. See https://kernel.org/doc/html/v4.14/driver-api/uio-howto.html for a description of uio.</p>"},{"location":"host-attach-util/opaeuio/opaeuio/#options","title":"OPTIONS","text":"<p><code>device</code>     The DFL device name, eg dfl_dev.10</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given device for uio.\nUsed in conjunction with -u, -g, and -d.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given device from uio.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when binding to uio.\nThe default value is dfl-uio-pdev.\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to uio. A new device node is created in\n/dev when the device is bound to uio. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to uio. Use this option to specify the\nnew device group for the device created in /dev.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/opaeuio/opaeuio/#examples","title":"EXAMPLES","text":"<p><code>opaeuio -h</code> <code>opaeuio -v</code> <code>sudo opaeuio -i -u lab -g labusers dfl_dev.10</code> <code>sudo opaeuio -r dfl_dev.10</code></p>"},{"location":"host-attach-util/opaevfio/opaevfio/","title":"opaevfio","text":""},{"location":"host-attach-util/opaevfio/opaevfio/#synopsis","title":"SYNOPSIS","text":"<p><code>opaevfio [-h] [-i] [-r] [-d DRIVER] [-u USER] [-g GROUP] [-n] [-v] [addr]</code></p>"},{"location":"host-attach-util/opaevfio/opaevfio/#description","title":"DESCRIPTION","text":"<p>The <code>opaevfio</code> command enables the binding/unbinding of a PCIe device to/from the vfio-pci device driver. See https://kernel.org/doc/Documentation/vfio.txt for a description of vfio-pci.</p>"},{"location":"host-attach-util/opaevfio/opaevfio/#options","title":"OPTIONS","text":"<p><code>addr</code>     The PCIe address of the device in ssss:bb:dd.f format, eg 0000:7f:00.0</p> <p><code>-h, --help</code></p> <pre><code>Display command-line help and exit.\n</code></pre> <p><code>-i, --init</code></p> <pre><code>Specifies binding mode operation - initialize the given addr for vfio.\nUsed in conjunction with -u, -g, and -n.\n</code></pre> <p><code>-r, --release</code></p> <pre><code>Specifies unbinding mode operation - release the given addr from vfio.\nUsed in conjunction with -d.\n</code></pre> <p><code>-d DRIVER, --driver DRIVER</code></p> <pre><code>Specifies the device driver to bind to when releasing from vfio.\nWhen omitted, the device is not rebound to a driver (default).\n</code></pre> <p><code>-u USER, --user USER</code></p> <pre><code>The user ID to assign when binding to vfio. A new device node is created in\n/dev/vfio when the device is bound to vfio-pci. Use this option to specify\nthe new device owner.\n</code></pre> <p><code>-g GROUP, --group GROUP</code></p> <pre><code>The group ID to assign when binding to vfio. Use this option to specify the\nnew device group for the device created in /dev/vfio.\n</code></pre> <p><code>-n, --no-sriov</code></p> <pre><code>Do not enable SR-IOV when binding to vfio. The default value for this option\nis FALSE, ie the script should specify SR-IOV functionality when binding to\nthe vfio-pci driver. When omitted, the modprobe command which loads the vfio-pci\ndriver will contain the `enable_sriov=1` option. When given, it will not.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/opaevfio/opaevfio/#examples","title":"EXAMPLES","text":"<p><code>opaevfio -h</code> <code>opaevfio -v</code> <code>sudo opaevfio -i -u lab -g labusers 0000:7f:00.0</code> <code>sudo opaevfio -r 0000:7f:00.0</code></p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/","title":"pac_hssi_config","text":"<pre><code># pac_hssi_config #\n\n## SYNOPSIS ##\n```console\npac_hssi_config.py [-h] subcommand [subarg] [bdf]\n</code></pre>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#description","title":"DESCRIPTION","text":"<p>The <code>pac_hssi_config.py</code> tool exercises the Ethernet 10 Gbps (10GbE) and 40GbE transceivers for designs using the Intel\u00ae Programmable Acceleration Card (PAC) with Intel Arria\u00ae 10 GX FPGA. This tool does not support the  Intel Xeon\u00ae Processor with Integrated FPGA. </p> <p></p> <p>The two required arguments to the <code>pac_hssi_config.py</code> tool specify the subcommand and bus, device, and function (BDF) for the PCIe device under test. You must provide the BDF parameter for systems with more than one PCIe card. </p> <pre><code>.. note::\n    If you do not provide the BDF when required, the command prints a list of valid BDFs for the system. You can also\n    determine the BDF using the ``lspci`` command.\n</code></pre> <p>For usage help, type the following at a command prompt:</p> <p><code>pac_hssi_config.py [-h|--help]</code></p> <p>To configure the network ports, send data, and read statistics, use the following form of the <code>pac_hssi_config.py</code> script:</p> <p><code>pac_hssi_config.py subcommand [subarg] [bdf]</code></p> <p>Only a subset of subcommand arguments support <code>subarg</code>. </p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-1-general-subcommands","title":"Table 1. General Subcommands","text":"Subcommand Subarg Description <code>stat</code> N/A Prints high speed serial interface (HSSI) controller statistics. <code>eeprom</code> N/A Reads the 128-bit unique board ID, MAC address, and board-specific IDs from EEPROM."},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-2-1040-gbe-traffic-generation-subcommands","title":"Table 2. 10/40 GbE Traffic Generation Subcommands","text":"Subcommand Subarg Description <code>e10init</code> and <code>e40init</code> N/A Initializes HSSI PHY to 10GbE or 40GbE mode.  Clears statistics and enable internal HSSI transceiver loopback. <code>e10loop</code> and <code>e40loop</code> On/Off Turns on or off internal HSSI transceiver loopback. <code>e10reset</code> and <code>e40reset</code> On/Off Asserts or deasserts AFU reset.  Clears packet statistics and disables internal HSSI transceiver loopback. <code>e10send</code> and <code>e40send</code> N/A Sends 1,000,000 1500-byte packets. For 10GbE sends packets on all four ports. 40GbE has a single port. <code>e10stat</code> and <code>e40stat</code> N/A Prints packet statistics. <code>e10statclr</code> and <code>e40statclr</code> N/A Clears packet statistics.  Use this command after switching loopback modes to clear any transient statistics accumulated during the mode switch. <p>The transceiver equalization <code>eqwrite</code> and <code>eqread</code> subcommands write and read transceiver equalization settings.  These subcommands require you to specify the transceiver channel, the equalization setting, and the value (for writes).  Use the following form for the <code>eqwrite</code> command:</p> <p><code>pac_hssi_config.py eqwrite [transceiver channel number] [equalization setting] [equalization value] [bdf]</code></p> <p>Use the following form for the <code>eqread</code>command:</p> <p><code>pac_hssi_config.py eqread [transceiver channel number] [equalization setting] [bdf]</code> </p>"},{"location":"host-attach-util/pac_hssi_config/pac_hssi_config/#table-3-transceiver-equalization-subcommands","title":"Table 3. Transceiver Equalization Subcommands","text":"Subcommand Channel Number Equalization Setting Value <code>eqwrite</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) Specifies the value for the specified equalization setting. <code>eqread</code> 0-3 0 = Continuous time-linear equalization (CTLE)  1 = Variable gain amplifier (VGA)  2 = DCGAIN  3 = Pre-emphasis first post-tap  4 = Pre-emphasis second post-tap  5 = Pre-emphasis first pre-tap  6 = Pre-emphasis second pre-tap  7 = Differential output voltage (VOD) N/A <p>For more information about reconfiguring transceiver analog parameter settings In Arria\u00ae 10 devices, refer to \"Changing PMA Analog Parameters\" in the  Intel\u00ae Arria\u00ae 10 Transceiver PHY User Guide.</p>"},{"location":"host-attach-util/packager/packager/","title":"packager","text":""},{"location":"host-attach-util/packager/packager/#synopsis","title":"SYNOPSIS","text":"<p><code>packager &lt;cmd&gt; [arguments]</code></p>"},{"location":"host-attach-util/packager/packager/#description","title":"Description","text":"<p>The packager provides tools that Accelerator Functional Unit (AFU) developers use to create Accelerator Function (AF)  files. The AF file is the programming file for an AFU on Intel\u00ae FPGA platforms. The packager tool concatenates the metadata from the JSON file to a raw binary file <code>(.rbf)</code> that the Intel Quartus\u00ae Prime software generates. </p> <p>The packager's only function is to create an AF file. Refer to Packager Command Syntax for more information about invoking the packager. The packager depends on a JSON file to describe AFU metadata. Refer to  Accelerator Description File for more information about the JSON file.</p> <p>The packager requires Python 2.7.1 and Python 2.7.3. The tool indicates if it is being called with a compatible  of Python.</p>"},{"location":"host-attach-util/packager/packager/#packager-command-syntax","title":"Packager Command Syntax","text":"<p>The packager is a command line tool with the following syntax:</p> <p><code>$ packager &lt;cmd&gt; [arguments]</code></p> <p>The following table describes the <code>&lt;CMD&gt;</code> arguments:</p> Command Arguments Description <code>create-gbs</code> <code>--rbf=&lt;RBF_PATH&gt;</code> <code>--afu=&lt;AFU_JSON_PATH&gt;</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> Creates the AF file. The engineering name for this file is the green bit stream, abbreviated gbs. The <code>--rbf</code> and <code>--afu</code>   arguments are required.  <code>&lt;RBF_PATH&gt;</code> is the path to the RBF file for the AFU. The Quartus\u00ae Prime software generates this RBF by compiling the AFU design. <code>&lt;AFU_JSON_PATH&gt;</code> is the path to the Accelerator Description file. This is a JSON file that describes the metadata that <code>create-gbs</code> appends to the RBF. <code>&lt;GBS_PATH&gt;</code> is the path to the RBF file for the FPGA Interface Manager (FIM) that contains the FPGA interface unit and other interfaces. If you do not specify the <code>--gbs</code>, the command defaults to <code>&lt;rbf_name&gt;.gbs</code>. You can use the optional <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>modify-gbs</code> <code>--gbs=&lt;gbs_PATH&gt;</code> Modifies the AF file. The <code>--input-gbs</code>argument is required. If you do not provide the <code>--output-gbs</code> argument, <code>modify-gbs</code> overwrites the <code>--input-gbs</code> file. Use the <code>--set-value=&lt;key&gt;.&lt;value&gt;</code> argument to set values for JSON metadata. To set more than one JSON value, list a series of <code>&lt;key&gt;.&lt;value&gt;</code>  pairs. <code>gbs-info</code> <code>--input-gbs=&lt;gbs_PATH&gt;</code> Prints information about the AF file. The <code>--input-gbs</code> argument is required. <code>get-rbf</code> <code>--gbs=&lt;GBS_PATH&gt;</code> <code>--rbf=&lt;RBF_PATH&gt;</code> Creates the RBF by extracting it from the AF file. The <code>--gbs</code>argument is required. If you do not specify the <code>--rbf</code> argument, the command defaults to <code>&lt;gbs_name.rbf</code> . None, or any <code>&lt;CMD&gt;</code> <code>--help</code> Summarizes the <code>&lt;CMD&gt;</code> options. Typing <code>packager --help</code> gives a list of <code>&lt;CMD&gt;</code> values. Typing <code>packager &lt;CMD&gt; --help</code> provides detailed help for <code>&lt;CMD&gt;</code>"},{"location":"host-attach-util/packager/packager/#examples","title":"Examples","text":"<p>To generate an AF file, run:</p> <p><code>$ packager create-gbs --rbf=&lt;RBF_PATH&gt; --afu=&lt;AFU_JSON_PATH&gt; --gbs=&lt;GBS_PATH&gt;</code></p> <p>TIP: JSON files are very particular about syntax such as trailing commas. If you are getting errors, use <code>jsonlint.com</code> to validate that your JSON is formatted correctly. </p> <p>To modify metadata in an existing AF, run the following command:</p> <p><code>$ packager modify-gbs --input-gbs=&lt;PATH_TO_GBS_TO_BE_MODIFIED&gt; --outputgbs=&lt;NAME_FOR_NEW_GBS&gt; --set-value &lt;key&gt;:&lt;value&gt;</code></p> <p>You can pass in a number of : pairs with --set-value to update values in an AF.  <p>To print the metadata of an existing AF: </p> <p><code>$ packager get-info --gbs=&lt;GBS_PATH&gt;</code> </p> <p>To extract the RBF from the AF:</p> <p><code>$ packager get-rbf --gbs=&lt;GBS_PATH&gt; --rbf=&lt;NAME_FOR_RBF&gt;</code></p>"},{"location":"host-attach-util/packager/packager/#accelerator-description-file","title":"Accelerator Description File","text":"<p>The Accelerator Description File is a JSON file that describes the metadata associated with an AFU. The Open Progammable Accelerator Engine (OPAE) uses this metadata during reconfiguration. Here is an example file:</p> <p><pre><code>{\n   \"version\": 1,\n   \"platform-name\": \"DCP\",\n   \"afu-image\": {\n      \"magic-no\": 488605312,\n      \"interface-uuid\": \"01234567-89AB-CDEF-0123-456789ABCDEF\",\n      \"power\": 0,\n      \"accelerator-clusters\": [{\n         \"name\": \"dma_test_afu\",\n         \"total-contexts\": 1,   \n         \"accelerator-type-uuid\": \"331DB30C-9885-41EA-9081-F88B8F655CAA\"\n      }\n      ]  \n   }\n}\n</code></pre> The packager stores these parameter values in the resultant AF. After reprogramming the AFU using partial reconfiguration (PR), the  software driver reconfigures the PLLs by writing the clock-frequency-high and clock-frequency-low values (if present) over the  PCIe\u00ae and CCI interfaces. </p> <p>.. note:: <pre><code>The JSON file format may change as the architecture evolves. Any changes to the current format trigger an update\nto the version number.  \n</code></pre></p> <p>CATEGORY | NAME | TYPE | DESCRIPTION | MANDATORY ---------|------|------|-------------|:----------:| Per-AFU  | version | Integer | Version of the metadata format. | Yes Per-AFU  | magic-no (to be deprecated)| Integer | Magic no. Associated with the FPGA Interface Manager. | No Per-AFU  | platform-name | String | Name of the platform for which the metadata is intended. The field value is \u201cDCP\u201d for Intel  Acceleration Stack for FPGAs. | No Per-AFU  | interface-uuid | UUID | Interface id associated with the FPGA Interface Manager. | Yes Per-AFU  | power | Integer | Accelerator Function power consumption, in watts. Set to 0 for Intel Acceleration Stack for FPGAs platforms. | Yes Per-AFU  | clock-frequency-low | Float | Clock frequency for 1st PLL (Clock network)1 in MHz. | No Per-AFU  | clock-frequency-high | Float | Clock frequency for 2nd PLL (0 if absent) in MHz. | No Per-AFC Cluster | total-contexts | Integer | Number of AFCs in this cluster. Always be 1 in current architectures. | Yes Per-AFC Cluster | afc-type-uuid |  UUID | AFC type = AFU ID in current architectures. | Yes Per-AFC Cluster | name | string | AFC name = AFU name in current architectures. | Yes</p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"host-attach-util/pci_device/pci_device/","title":"pci_device","text":""},{"location":"host-attach-util/pci_device/pci_device/#synopsis","title":"SYNOPSIS","text":"<p><code>pci_device [-h] [-E] device-filter [{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}]</code></p>"},{"location":"host-attach-util/pci_device/pci_device/#description","title":"DESCRIPTION","text":"<p>pci_device is a tool to aid in common operations for managing PCIe devices and drivers.</p>"},{"location":"host-attach-util/pci_device/pci_device/#options","title":"OPTIONS","text":""},{"location":"host-attach-util/pci_device/pci_device/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<pre><code>`device filter`\n\nPCIe address of a device or vendor/device ID pair.\nThe PCIe address follows the format of [segment:]bus:device.function\nwhile the vendor/device ID pair follows the format [vendor ID]:[device ID]\nwhere at least one of these must be present.\n\n`{aer,bind,plug,remove,rescan,topology,unbind,unplug,vf}`\n\naction to perform on device\n\n`aer`\nPerform AER (Advanced Error Reporting) operations.\nThe aer action has its own sub-commands which are listed below:\n\n* `dump` sub-command will print out the AER error counters as reported\n   by the sysfs files for the device.\n* `mask` can either print out the current AER mask bits or set them\n  * If `show` or `print` (or nothing) is given after the `mask`\n    command, it will show the current mask bits for AER.\nBy default output will be written in stdout but can be written to an\noutput file if `-o|--output FILENAME` argument is given.\n  * If `all` is given after the `mask` command, it will mask all bits\n    (by setting the values to 0xffffffff and 0xffffffff).\n  * If `off` is given after the `mask` command, it will unmask all\n    bits (by setting the values to 0x0 and 0x0).\n  * If two numbers are present after the `mask` command, those two\n    numbers will be used to set the mask bits.\nValues for setting the mask can also be read in from an input file if\n`-i|--input FILENAME` argument is given.\n\n_NOTE_: mask related operations require root privileges\n\n`bind`\n\nAssociate a device with its driver.\n\n`plug`\n\nRestore a device that was previously given to `pci_device &lt;device&gt; unplug`\n\n`remove`\n\nRemove the pci device from the pci bus\n\n`rescan`\n\nRescan the bus as identified by the bus component of the PCIe device address\n\n'topology`\n\nPrint the PCIe topology from the root port to the PCIe device.\nThis shows the PCIe tree rooted at the PCIe root port.\nEach line shows the the PCIe address, vendor ID, and device ID along with\nthe driver bound to the device. The indentation is used to show\nparent/child relationship of devices.\n\nThe line listing the target PCIe device as identified by the given PCIe\naddress will be highlighted in green while the endpoints will be\nhighlighted in cyan.\n\nThe example below shows the topology of an N3000 device with eight virtual\nfunctions created from one of the Ethernet controllers:\n\n```console\n[pci_address(0000:3a:00.0), pci_id(0x8086, 0x2030)] (pcieport)\n    [pci_address(0000:3b:00.0), pci_id(0x10b5, 0x8747)] (pcieport)\n        [pci_address(0000:3c:09.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3f:00.0), pci_id(0x8086, 0x0b30)] (dfl-pci)\n        [pci_address(0000:3c:11.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:43:00.0), pci_id(0x8086, 0x0b32)] (no driver)\n    [pci_address(0000:3c:08.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:3d:02.0), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.7), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.5), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.3), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.1), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:3d:02.6), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.4), pci_id(0x8086, 0x154c)] (iavf)\n            [pci_address(0000:3d:02.2), pci_id(0x8086, 0x154c)] (iavf)\n        [pci_address(0000:3c:10.0), pci_id(0x10b5, 0x8747)] (pcieport)\n            [pci_address(0000:41:00.0), pci_id(0x8086, 0x0d58)] (i40e)\n            [pci_address(0000:41:00.1), pci_id(0x8086, 0x0d58)] (i40e)\n\n```\n\n`unbind`\n\nUnbind the driver bound to the device.\n\n`unplug`\n\nRemove device from PCI bus in anticipation of a RSU event by configuring its root port and associated endpoints.\n\n`vf`\n\nCreate/destroy VFs (virtual functions) by setting the number here.\nThe number given here will be written to sriov_numvfs sysfs file triggering\nthe PCIe subsystem to create/destroy VFs so that the current number of VFs\nwill be equal to the given number. If the number given is outside of the total VFs supported, an error message will be displayed to indicate this.\n</code></pre>"},{"location":"host-attach-util/pci_device/pci_device/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<pre><code>`-h, --help`\n\nshow this help message and exit\n\n`-E, --other-endpoints`\n\nperform action on peer PCIe devices\n</code></pre>"},{"location":"host-attach-util/pci_device/pci_device/#examples","title":"EXAMPLES","text":"<pre><code>pci_device 0000:3d:00.0 remove\npci_device 0000:3d:00.0 rescan\npci_device 3d:00.0 topology\npci_device :0b30 topology\npci_device :0b30 aer\npci_device :0b30 aer mask\npci_device :0b30 aer mask all\npci_device :0b30 aer mask -o mask.dat\npci_device :0b30 aer mask -i mask.dat\n</code></pre>"},{"location":"host-attach-util/rsu/rsu/","title":"rsu","text":""},{"location":"host-attach-util/rsu/rsu/#synopsis","title":"SYNOPSIS","text":"<pre><code>rsu [-h] [-d] {bmc,bmcimg,retimer,fpga,sdm,fpgadefault} [PCIE_ADDR]\n</code></pre>"},{"location":"host-attach-util/rsu/rsu/#description","title":"DESCRIPTION","text":""},{"location":"host-attach-util/rsu/rsu/#mode-1-rsu","title":"Mode 1: RSU","text":"<pre><code>rsu bmc --page=(user|factory) [PCIE_ADDR]\nrsu retimer [PCIE_ADDR]\nrsu fpga --page=(user1|user2|factory) [PCIE_ADDR]\nrsu sdm --type=(sr|pr|sr_cancel|pr_cancel) [PCIE_ADDR]\n</code></pre> <p>Perform RSU (remote system update) operation on PAC device given its PCIe address. An RSU operation sends an instruction to the device to trigger a power cycle of the card only. This will force reconfiguration from flash for either BMC, Retimer, SDM, (on devices that support these) or the FPGA.</p>"},{"location":"host-attach-util/rsu/rsu/#mode-2-default-fpga-image","title":"Mode 2: Default FPGA Image","text":"<pre><code>rsu fpgadefault --page=(user1|user2|factory) --fallback=&lt;csv&gt; [PCIE_ADDR]\n</code></pre> <p>Set the default FPGA boot sequence. The --page option determines the primary FPGA boot image. The --fallback option allows a comma-separated list of values to specify fallback images.</p>"},{"location":"host-attach-util/rsu/rsu/#positional-arguments","title":"POSITIONAL ARGUMENTS","text":"<p><code>{bmc,bmcimg,retimer,fpga,sdm,fpgadefault}</code></p> <p>type of RSU operation or set Default FPGA Image operation.</p> <p><code>PCIE_ADDR</code>  PCIe address of device to do rsu (e.g. 04:00.0 or 0000:04:00.0) </p>"},{"location":"host-attach-util/rsu/rsu/#optional-arguments","title":"OPTIONAL ARGUMENTS","text":"<p><code>-h, --help</code> show this help message and exit</p> <p><code>-d, --debug</code> log debug statements</p> <p><code>--force</code> force rsu operation</p>"},{"location":"host-attach-util/rsu/rsu/#example","title":"EXAMPLE","text":"<pre><code># rsu bmc --page=user 25:00.0\n</code></pre> <p>Triggers a boot of the BMC image (user page) for the device with PCIe  address 25:00.0.</p> <pre><code># rsu bmc --page=factory 25:00.0\n</code></pre> <p>Triggers a factory boot of the BMC image for the device with  PCIe address 25:00.0.</p> <pre><code># rsu fpga --page=user2 25:00.0\n</code></pre> <p>Triggers a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0.</p> <pre><code># rsu --force fpga --page=user2 25:00.0\n</code></pre> <p>Forces a reconfiguration of the FPGA (user2 page) for the  device with PCIe address 25:00.0. Default behavior is to not perform  the rsu operation if DPC (downstream port containment) is not supported  and AER (advanced error reporting) is also not supported. Using --force  changes this behavior to perform rsu operation regardless but may result  in a surprise removal of pci devices which may cause the Linux kernel  to panic.</p> <pre><code># rsu fpga --page=factory 25:00.0\n</code></pre> <p>Triggers a factory reconfiguration of the FPGA for the device  with PCIe address 25:00.0.</p> <pre><code># rsu sdm --type=sr 25:00.0\n</code></pre> <p>Triggers Static Region key programming for the device with  PCIE address 25:00.0.</p> <pre><code># rsu fpgadefault --page=factory --fallback=user1,user2 25:00.0\n</code></pre> <p>Sets the FPGA boot sequence to factory with fallbacks user1, user2.</p>"},{"location":"host-attach-util/userclk/userclk/","title":"userclk","text":""},{"location":"host-attach-util/userclk/userclk/#synopsis","title":"SYNOPSIS","text":"<p><code>userclk [-hv] [-S &lt;segment&gt;] [-B &lt;bus&gt;] [-D &lt;device&gt;] [-F &lt;function&gt;] [PCI_ADDR] [-H &lt;User clock high frequency&gt;] -L &lt;User clock low frequency&gt;]</code></p>"},{"location":"host-attach-util/userclk/userclk/#description","title":"DESCRIPTION","text":"<p>userclk sets the frequency range for an AFU. </p>"},{"location":"host-attach-util/userclk/userclk/#examples","title":"EXAMPLES","text":"<p><code>./userclk -B 0x5e -H 400 -L 200</code></p> <p>Sets AFU frequency.</p>"},{"location":"host-attach-util/userclk/userclk/#options","title":"OPTIONS","text":"<p><code>-v,--version</code></p> <p>Prints version information and exits.</p> <p><code>-S,--segment</code> </p> <p>FPGA segment number.</p> <p><code>-B,--bus</code> </p> <p>FPGA Bus number.</p> <p><code>-D,--device</code> </p> <p>FPGA Device number.</p> <p><code>-F,--function</code> </p> <p>FPGA function number.</p> <p><code>-H,--freq-high</code> </p> <p>User clock high frequency. </p> <p><code>-L,--freq-low</code> </p> <p>User clock low frequency. </p> Date Intel Acceleration Stack Version Changes Made 2018.05.21 DCP 1.1 Beta (works with Quartus Prime Pro 17.1.1) Fixed typos."},{"location":"host-attach-util/vabtool/vabtool/","title":"vabtool","text":""},{"location":"host-attach-util/vabtool/vabtool/#synopsis","title":"SYNOPSIS","text":"<p><code>vabtool [-r RETRIES] [-d] [-y] [-v] &lt;ACTION&gt;</code></p> <p>Where ACTION is defined as one of the following:</p> <p><code>vabtool sr_key_provision PCIE_ADDRESS SR_RKH_FILE FPGA_IMG_FILE</code> <code>vabtool sr_status PCIE_ADDRESS</code> <code>vabtool pr_key_provision PCIE_ADDRESS PR_AUTH_CERT_FILE PR_RKH_FILE</code> <code>vabtool pr_status PCIE_ADDRESS</code> <code>vabtool sr_key_cancel PCIE_ADDRESS SR_RKH_CANCEL_FILE</code> <code>vabtool sr_cancel_status PCIE_ADDRESS</code> <code>vabtool pr_key_cancel PCIE_ADDRESS PR_RKH_CANCEL_FILE</code> <code>vabtool pr_cancel_status PCIE_ADDRESS</code></p>"},{"location":"host-attach-util/vabtool/vabtool/#description","title":"DESCRIPTION","text":"<p>The <code>vabtool</code> command helps perform Vendor Authenticated Boot provisioning of Static Region and Partial Reconfiguration Region key hashes and helps perform SR and PR hash cancellation and status reporting.</p>"},{"location":"host-attach-util/vabtool/vabtool/#options","title":"OPTIONS","text":"<p><code>-r RETRIES, --retries RETRIES</code></p> <pre><code>Specifies the number of times a failed SR or PR key provision is to be\nretried. The default value for RETRIES is 3.\n</code></pre> <p><code>-d, --dry-run</code></p> <pre><code>Don't execute the actual fpgasupdate and rsu commands, but only print\nthe commands that would be executed during a normal run of the script.\n</code></pre> <p><code>-y, --yes</code></p> <pre><code>The tool will respond with an automatic Yes answer to all confirmation\nprompts posed by the sub-tools.\n</code></pre> <p><code>-v, --version</code></p> <pre><code>Display script version information and exit.\n</code></pre>"},{"location":"host-attach-util/vabtool/vabtool/#examples","title":"EXAMPLES","text":"<p><code>sudo vabtool -y sr_key_provision 0000:bc:00.0 my_sr_rkh.bin my_fpga.bin</code> <code>sudo vabtool sr_status 0000:bc:00.0</code> <code>sudo vabtool -y pr_key_provision 0000:bc:00.0 pr_auth_cert.bin my_pr_rkh.bin</code> <code>sudo vabtool pr_status 0000:bc:00.0</code> <code>sudo vabtool sr_key_cancel 0000:bc:00.0 my_sr_rhk_cancel.bin</code> <code>sudo vabtool sr_cancel_status 0000:bc:00.0</code> <code>sudo vabtool pr_key_cancel 0000:bc:00.0 my_pr_rhk_cancel.bin</code> <code>sudo vabtool pr_cancel_status 0000:bc:00.0</code></p>"},{"location":"linux-dfl/dfl/dfl/","title":"Device Feature List Driver","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl/dfl/#introduction","title":"Introduction","text":"<p>This driver defines a feature list structure that creates a linked list of feature headers (DFHs) within the MMIO space to provide an extensible way of adding features for FPGA. The driver can walk through feature headers to enumerate feature devices (e.g. FPGA Management Engine, Port and Accelerator Function Unit) and their private features for FPGA devices that support the DFL structure. This linked list is then itself traversed and each feature/private feature is associated with a driver.</p> Driver Mapping Source(s) Required for DFL dfl.ko Device Feature List Driver drivers/fpga/dfl.c Y <p>An example DFL:</p> <p></p> <p>Also known as the DFL \"walker\", <code>dfl-ko</code> walks the DFL and instantiates other DFL-enabled drivers. The same driver is used on both host-attach and in HPS, assuming they are connected by either a soft or hard PCIe IP. The same DFL walker is used regardless of the chosen OFS attach method (PCIe Attach, Direct Attach). This driver is required for all DFL-enabled FPGA designs.</p> <p>The following chart visualizes DFL discovery:</p> <p></p>"},{"location":"linux-dfl/dfl/dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl.c</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl.c?h=master.</p>"},{"location":"linux-dfl/dfl/dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Access PCIe BAR to create a linked list within MMIO for all DFL features</li> </ul>"},{"location":"linux-dfl/dfl/dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL</p> <p></p>"},{"location":"linux-dfl/dfl/dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl/dfl/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl/dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/","title":"Accelerator Functional Unit (aka workload) Driver For Host Attach","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#introduction","title":"Introduction","text":"<p>This driver extends the capability of the Accelerator Functional Unit or application workload by implementing management features. You can connect to FPGA infrastructure through the AFU's port interface. An application layer, called Open Programmable Acceleration Engine (OPAE) is built on top of the AFU driver group and can directly communicate with the AFU port regardless of whether the workload sits in a partial reconfiguration region or not. The AFU driver is composed of 4 source files that define its core functionality.</p> Driver Mapping Source(s) Required or Optional DFL Driver? dfl-afu.ko AFU Driver drivers/fpga/dfl-afu.h Optional <p><code>dfl-afu-dma-region.c</code> (Upstream) provides DMA region management. It can pin/unpin pages in memory for transfers to occur, create/destroy/find DMA regions, and map/unmap regions of memory.</p> <p><code>dfl-afu-error.c</code> (Upstream) handles error reporting from the AFU / Port. It can mask/unmask port errors, clear errors, and show various errors associated with the AFU.</p> <p><code>dfl-afu-region.c</code> (Upstream) provides the portion of the driver responsible for MMIO Region Management. It can add/destroy MMIO regions, and find regions by offset or index.</p> <p><code>dfl-afu-main.c</code> (Upstream) handles management capabilities of the AFU / Port. It can enable/disable/reset AFU ports, open/close/probe access to AFU devices, and show the current state of the AFU's power consumption, <code>userclk</code> frequency, and AFU ID, and provides various other capabilities related to port management.</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#accelerator-functional-unit","title":"Accelerator Functional Unit","text":"<p>The AFU region is the region where a user can put their custom application logic.  It can optionally contain a Partial Reconfiguration region for dynamic workload updates.</p> <p></p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga.</p> <p>The Upstream source code for this driver can be found at [(https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga?h=master]((https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga?h=master).</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Create AFU MMIO Regions, DMAs</li> <li>Report on AFU related errors</li> <li>Create Memory Mappings and pin memory between device and host</li> </ul>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_AFU</p> <p></p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs that support an AFU region. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_afu/dfl_afu/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/","title":"Host Attach Memory Subsystem IP Driver","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#introduction","title":"Introduction","text":"<p>This driver is for the Memory Subsystem IP private feature implemented under FPGA Device Feature List (DFL) framework. It is used to expose memory interface status information as well as memory clearing control.</p> Driver Mapping Source(s) Required or Optional DFL Driver? dfl-emif.ko FPGA DFL EMIF Driver drivers/memory/dfl-emif.c Optional"},{"location":"linux-dfl/dfl_emif/dfl_emif/#agilex-7-f-series-and-i-series-fpga-memory-subsystem-ip","title":"Agilex 7 F-Series and I-Series FPGA Memory Subsystem IP","text":"<p>The memory subsystem IP is a high-level solution on top of the External Memory Interfaces Agilex\u00ae 7 FPGA IP, providing an easy way to instantiate up to 8 external memory interfaces (EMIFs) with application-level optimizations.  The memory subsystem IP provides the following components:</p> <ul> <li>Up to 8 lookup IP instances.</li> <li>Up to 8 EMIF instances.</li> <li>A memory controller that implements all the memory commands and protocol-level requirements.</li> <li>A soft logic adapter to boost memory throughput by traffic shaping.</li> </ul> <p>The memory subsystem supports DDR4 and DIMMs. For more information about this IP, please refer to the Agilex 7 F-Series and I-Series FPGA Memory Subsystem IP User Guide.</p> <p></p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#stratix-10-external-memory-interface","title":"Stratix 10 External Memory Interface","text":"<p>The External Memory Interfaces Stratix 10 FPGA IP provides an physical later interface which builds the data path and manages timing transfers between the FPGA and the memory device.  It also includes a memory controller which implements all the memory commands and protocol level requirements.  This IP supports a variety of memory types including DDR4, QDR-IV and DIMMs.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/memory/dfl-emif.c#L4</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/memory/dfl-emif.c?h=master.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Access status of memory calibration</li> <li>Memory clearing control</li> </ul>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_EMIF</p> <p></p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#example-designs","title":"Example Designs","text":"<p>This driver is used in the PCIe Attach shell designs for Agilex 7 and in the PCIe Attach shell design for Stratix 10 FPGA.  Please refer to the Open FPGA Documentation site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_emif/dfl_emif/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/","title":"Host Attach DFL FPGA Management Engine IP Driver","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#introduction","title":"Introduction","text":"<p>This set of drivers is designed to support FME functionality, as implemented under FPGA Device Feature List (DFL) framework. It is used to expose FME capabilities.</p> Driver Mapping Source(s) Required for DFL dfl-fme.ko FPGA Management Engine IP drivers/fpga/ - dfl-fme.h, dfl-fme-main.c, dfl-fme-pr.c, dfl-fme-error.c, dfl-fme-perf.c Y dfl-fme-mgr.ko PR IP drivers/fpga/dfl-fme-mgr.c N dfl-fme-br.ko SW Dependency drivers/fpga/dfl-fme-br.c N dfl-fme-region.ko SW Dependency drivers/fpga/dfl-fme-region.c N <pre><code>graph TD;\n    A[dfl-fme]--&gt;B[dfl-fme-mgr];\n    A[dfl-fme]--&gt;C[dfl-fme-br];\n    A[dfl-fme]--&gt;D[dfl-fme-region]; </code></pre>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#fpga-management-engine-ip","title":"FPGA Management Engine IP","text":"<p>The FPGA Management Engine IP provides management features for the platform and controls reset and loading of the AFU into the partial reconfiguration region of the FPGA. Implementation of a PR region is optional.</p> <p>Each FME feature exposes its capability to host software drivers through a device feature header (DFH) register found at the beginning of its control status register (CSR) space. The FME CSR maps to physical function 0 (PF0) Base address register 0 (BAR0) so that software can access it through a single PCIe link. For more information about DFHs, refer to the Device Feature Header (DFH) structure.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for these drivers can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/fpga, where branches labelled fpga-ofs-dev-*-lts correspond with the latest developmental versions of the DFL driver suite on that specific kernel version.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/fpga?h=master.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#driver-capabilities","title":"Driver Capabilities","text":"<p>This driver set is a DFL specific implementation of generic FPGA drivers available in the kernel. <code>dfl-fme-mgr</code> is a DFL specific instantiation of the generic FPGA manager (drivers/linux/fpga/fpga-mgr.c), <code>dfl-fme-br</code> builds on top of a generic FPGA bridge (drivers/fpga/fpga-bridge.c), and <code>dfl-fme-region</code> instantiates an FPGA region. All three supplementary DFL Drivers depend on <code>dfl-fme</code>.</p> <p>The DFL FME driver is a feature device implemented under the Device Feature List (DFL) framework. It enables the platform driver for the FME IP and implements all FPGA platform level management features. Only one FME is created per DFL based FPGA device. The DFL Bridge, Manager, and Region drivers are only required when attempting to configure a PR region in the FIM.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_FME</p> <p></p> <p>FPGA_DFL_FME_MGR</p> <p></p> <p>FPGA_DFL_FME_BRIDGE</p> <p></p> <p>FPGA_DFL_FME_REGION</p> <p></p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#example-designs","title":"Example Designs","text":"<p>The FPGA Management Engine IP is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_fme/dfl_fme/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/","title":"FPGA DFL NIOS Driver for Intel PAC N3000","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Arria 10 GX</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#introduction","title":"Introduction","text":"<p>This is the driver for the N3000 Nios private feature on Intel PAC (Programmable Acceleration Card) N3000. It communicates with the embedded Nios processor to configure the retimers on the card. It also instantiates the SPI master (spi-altera) for the card's BMC (Board Management Controller). It matches and probes based on the Nios private feature node on a DFL from an Intel N3000 device. This driver also depends on the generic DFL driver.</p> Driver Mapping Source(s) Required for DFL dfl-n3000-nios.ko FPGA DFL NIOS Driver for Intel PAC N3000 drivers/fpga/dfl-n3000-nios.c N"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl-n3000-nios.c#L4.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl-n3000-nios.c.</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Instantiate the SPI interface for an N3000</li> <li>Communicate with N3000 retimers</li> </ul>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_NIOS_INTEL_PAC_N3000</p> <p></p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/dfl_n3000_nios/dfl_n3000_nios/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/","title":"DFL PCI Express Subsystem IP Driver","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#introduction","title":"Introduction","text":"<p>This driver enables PCIe functionality for PCIe based FPGA solutions that implement the DFL. This driver provides interfaces for user-space applications to configure, enumerate, open and access FPGA accelerators on the FPGA DFL devices, enables system level management functions such as FPGA partial reconfiguration, power management and virtualization with DFL framework.</p> <p>The <code>dfl-pci</code> driver is a DFL specific instantiation of the generic <code>pci.ko</code> driver.</p> Driver Mapping Source(s) Required for DFL dfl-pci.ko FPGA DFL PCIe Device Driver drivers/fpga/dfl-pci.c Y"},{"location":"linux-dfl/dfl_pci/dfl_pci/#agilex-7-pcie-susbystem","title":"Agilex 7 PCIe Susbystem","text":"<p>The PCIe Subsystem is one of three subsystems supported by the OFS FIM. It contains configuration registers for the Vendor, Device and Subsystem Vendor IDs. These registers are used in PCIe add-in cards to uniquely identify the card for assignment to software drivers.</p> <p>The host-side PCIe SS supports PCIe Gen 4x16 speeds using an AXI-ST Data mover interface across a hardened P-Tile. Is natively supports multiple configurations - including 2 PFs, and 1 PF with multiple VFs. It contains optional support for DMA engines and Single-root I/O Virtualization (SR-IOV). Full documentation on the FPGA IP Subsystem for PCI Express IP User Guide can be found on the Open FPGA Stack Git site.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/fpga/dfl-pci.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl-pci.c?h=master.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize DFL-enabled PCIe SS instances</li> <li>Probe for DFLs in PCIe BAR space, and enumerate their features</li> <li>Configure SR-IOV</li> </ul>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#kernel-configurations","title":"Kernel Configurations","text":"<p>FPGA_DFL_PCI</p> <p></p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#example-designs","title":"Example Designs","text":"<p>The PCIe SS is included as a part of the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/dfl_pci/dfl_pci/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/","title":"Max\u00ae 10 Board Management Controller Driver","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <ul> <li><code>intel-m10-bmc-log</code> is not upstreamed.</li> </ul> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#introduction","title":"Introduction","text":"<p>This driver is designed to support the core functionality of the Max 10 Board Management Controller. It provides support for accessing the BMC, and supports all operations that are in turn supported by the BMC itself including configuring non-volatile FPGA flash, reading telemetry data, and remotely updating the FPGA and BMC images.</p> Driver Mapping Source(s) Required for DFL intel-m10-bmc-core.ko MAX 10 Board Management Controller drivers/mfd/intel-m10-bmc-core.c N intel-m10-bmc-pmci.ko MAX 10 Board Management Controller with PMCI drivers/mfd/intel-m10-bmc-pmci.c N intel-m10-bmc-spi.ko MAX 10 Board Management Controller with SPI drivers/mfd/intel-m10-bmc-spi.c N intel-m10-bmc-sec-update.ko MAX10 BMC Secure Update driver drivers/fpga/intel-m10-bmc-sec-update.c N intel-m10-bmc-hwmon.ko MAX10 BMC Hardware Monitoring drivers/hwmon/intel-m10-bmc-hwmon.c N <pre><code>graph TD;\n    A[intel-m10-bmc-core]--&gt;B[intel-m10-bmc-spi] \n    A[intel-m10-bmc-core]--&gt;C[intel-m10-bmc-pmci]\n    A[intel-m10-bmc-core]--&gt;E[intel-m10-bmc-hwmon]\n    A[intel-m10-bmc-core]--&gt;F[intel-m10-bmc-sec-update]</code></pre> <p><code>intel-m10-bmc-core</code> provides common code for the Board Management Controller chip. It polls the M10 handshake register, can access and update BMC CSRs, display version information, and read MAC statistics.</p> <p>Either <code>intel-m10-bmc-spi</code> or <code>intel-m10-bmc-pmci</code> are required for a given BMC, depending on which communication standard is supported by the board as provide by its DFH. D5005 uses SPI, Agilex 7 devices use PMCI. Both of these drivers assist in communicating across the connection between the FPGA fabric and the Max 10 by acting as a master device. As the SPI master the driver will covert SPI messages to Avalon transactions. Both drivers consume the common code present in <code>intel-m10-bmc-core</code>.</p> <p><code>intel-m10-bmc-hwmon</code> hooks into the generic Linux <code>hwmon</code> framework already present in the Kernel and instantiations the Max 10 BMC instance. This includes support for all on-board sensors for voltage, current, and temperature.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#board-management-controller","title":"Board Management Controller","text":"<p>The Board Management Controller (BMC) supports features such as board power management, flash management, configuration management, and board telemetry monitoring and protection. The majority of the BMC logic is in a separate Max\u00ae 10 device; a small portion of the BMC known as the PMCI resides in the main Agilex FPGA.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver suite can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/, and under the <code>fpga</code>, <code>mfd</code>, and <code>hwmon</code> directories.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mfd?h=master.</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Communicate with BMC handshake register, issue supported commands</li> <li>Read / write to BMC attached flash</li> <li>Register on-board sensors with kernel hwmon framework</li> </ul>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#kernel-configurations","title":"Kernel Configurations","text":"<p>MFD_INTEL_M10_BMC_CORE</p> <p></p> <p>MFD_INTEL_M10_BMC_SPI</p> <p></p> <p>MFD_INTEL_M10_BMC_PMCI</p> <p></p> <p>FPGA_M10_BMC_SEC_UPDATE</p> <p></p> <p>SENSORS_INTEL_M10_BMC_HWMON</p> <p></p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/intel_m10_bmc_core/intel_m10_bmc_core/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/","title":"Intel HSSI configurable ethernet phy driver","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#introduction","title":"Introduction","text":"<p>This is the Intel HSSI configurable ethernet phy driver. It provides the ability to view and change some of the transceiver tuner parameters for a QSFP interface on legacy D5005 designs.</p> Driver Mapping Source(s) Required for DFL intel-s10-phy.ko Intel HSSI configurable ethernet phy driver drivers/net/phy/intel-s10-phy.c N"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/fpga-ofs-dev-6.1-lts/drivers/net/phy/intel-s10-phy.c.</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Read and write XCVR status and statistics</li> </ul>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#kernel-configurations","title":"Kernel Configurations","text":"<p>INTEL_S10_PHY</p> <p></p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/intel_s10_phy/intel_s10_phy/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/","title":"Ethernet IEEE 1588 Time of Day Clock FPGA IP Driver for Host Attach","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#introduction","title":"Introduction","text":"<p>This page provides an overview of the Time-of-day driver for the Time of Day Clock FPGA IP that is used in the 1588PTP Design examples.  The Time of Day Clock FPGA IP is exposed as PTP Hardware Clock (PHC) device to the Linux PTP stack to synchronize the system clock to its ToD information using phc2sys utility of the Linux PTP stack.</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#time-of-day-clock-fpga-ip","title":"Time of Day Clock FPGA IP","text":"<p>The Time-of-day (TOD) Clock streams 96-bit and 64-bit time-of-day to one or more timestamping units in an IEEE 1588v2 solution. For information regarding this soft IP core, please refer to the Ethernet Design Example Components User Guide.</p> <p></p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/ptp/ptp_dfl_tod.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/ptp/ptp_dfl_tod.c?h=master.</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Reads and writes time in Time of Day timestamp registers.</li> <li>Performs fine and course clock offset adjustment.</li> <li>Periodic time drift adjustment.</li> <li>Only tested on Host attach Agilex 7</li> </ul>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_PTP_DFL_TOD</p> <p></p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/ptp_dfl_tod/ptp_dfl_tod/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/","title":"Memory Based QSFP Support Driver for Host Attach","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10, Arria 10 GX</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#introduction","title":"Introduction","text":"<p>This legacy driver builds on top of the QSFP Module and Ethernet IP drivers and enables them in a DFL design. This DFL-based driver will shadow the QSFP module's memory pages in memory. It leverages the core driver code from <code>qsfp-mem-core.ko</code>.</p> Driver Mapping Source(s) Required for DFL qsfp-mem-dfl.ko Memory Based QSFP Support for DFL drivers/net/phy/qsfp-mem-dfl.c N qsfp-mem-platform.ko Memory based QSFP support drivers/net/phy/qsfp-mem-platform.c N qsfp-mem-core.ko Memory based QSFP support drivers/net/phy/qsfp-mem-core.c N <pre><code>graph TD;\n    A[regmap-mmio]--&gt;B[qsfp-mem-core];\n    B[qsfp-mem-core]--&gt;C[qsfp-mem-platform];\n    B[qsfp-mem-core]--&gt;D[qsfp-mem-dfl];</code></pre>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/fpga-ofs-dev-6.1-lts/drivers/net/phy.</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probe and match the corresponding DFL Device</li> <li>Init a QSFP Device</li> <li>Send data over I2C</li> </ul>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>QSFP_MEM_CORE</p> <p></p> <p>QSFP_MEM</p> <p></p> <p>QSFP_MEM_DFL</p> <p></p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/qsfp_mem_dfl/qsfp_mem_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/s10hssi/s10hssi/","title":"Control Plane Driver for Stratix 10 HSSI","text":"<p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Stratix 10</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#introduction","title":"Introduction","text":"<p>This driver provides control plane support for a Stratix 10 High Speed Serial Interface. The Stratix 10 High Speed Serial Interface provides a data path between the FPGA and the external QSFP interfaces. This data path does not involve packets transferred between host memory and the fpga. As such a very limited set of networking functionality is provided.</p> Driver Mapping Source(s) Required for DFL s10hssi.ko Control Plane Driver for Stratix 10 HSSI drivers/net/ethernet/s10hssi.c N"},{"location":"linux-dfl/s10hssi/s10hssi/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/fpga-ofs-dev-6.1-lts/drivers/net/ethernet/intel/s10hssi.c.</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Read and write XCVR status and statistics</li> <li>Set MAC address</li> <li>Enable loopback</li> </ul>"},{"location":"linux-dfl/s10hssi/s10hssi/#kernel-configurations","title":"Kernel Configurations","text":"<p>S10HSSI</p> <p></p>"},{"location":"linux-dfl/s10hssi/s10hssi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/s10hssi/s10hssi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/","title":"Generic Serial Flash Interface Intel FPGA IP Driver","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Stratix 10, Agilex 7</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#introduction","title":"Introduction","text":"<p>This driver is the DFL specific implementation of the Generic Serial Flash Interface Intel FPGA IP driver, which provides access to Serial Peripheral Interface (SPI) flash devices. This is a DFL bus driver for the Altera SPI master controller, which is connected to a SPI slave to Avalon bridge in an Intel Max10 BMC. It handles the probing for available DFL-enabled SPI devices, will initialize any discovered SPI devices, and allows you to read and write over an available interface. The driver supports writing both Configuration memory (configuration data for Active Serial configuration schemes) and General purpose memory. Generic Serial Flash Interface Intel\u00ae FPGA IP User Guide. This driver also depends on the generic DFL driver.</p> Driver Mapping Source(s) Required for DFL spi-altera-core.ko Altera SPI Controller core code drivers/spi/spi-altera-core.c N spi-altera-platform.ko Device Feature List Driver drivers/spi/spi-altera-platform.c N spi-altera-dfl.ko Device Feature List Driver drivers/spi/spi-altera-dfl.c N <pre><code>graph TD;\n    A[spi-altera-core]--&gt;B[spi-altera-platform];\n    A[spi-altera-core]--&gt;C[spi-altera-dfl];\n    D[dfl]--&gt;C[spi-altera-dfl]; </code></pre>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/tree/master/drivers/spi.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/fpga/dfl.c?h=master.</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Match and probe DFL-enabled SPI interfaces on the DFL</li> <li>Read / write into memory over a given interface</li> </ul>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>SPI_ALTERA</p> <p></p> <p>SPI_ALTERA_CORE</p> <p></p> <p>SPI_ALTERA_DFL</p> <p></p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#example-designs","title":"Example Designs","text":"<p>This driver is found in all DFL enabled OFS designs. Examples include the the FIM design for PCIe Attach supporting DFL, Stratix 10 PCIe Attach, and SoC Attach. Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/spi_altera_dfl/spi_altera_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/uart_16550/uart_16550/","title":"Altera 16550 Compatible UART Core Driver for Host Attach","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#introduction","title":"Introduction","text":"<p>This driver for the 16550 Compatible UART Core to establish TTY communications to FPGA through PCIe.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#16550-compatible-uart-core","title":"16550 Compatible UART Core","text":"<p>The 16550 UART (Universal Asynchronous Receiver/Transmitter) soft IP core with Avalon\u00ae interface is designed to be register space compatible with the de-facto standard 16550 found in the PC industry. The core provides RS-232 Signaling interface, False start detection, Modem control signal and registers, Receiver error detection and Break character generation/detection. The core also has an Avalon\u00ae Memory-Mapped ( Avalon\u00ae -MM) agent interface that allows Avalon\u00ae -MM host peripherals (such as Nios\u00ae II and Nios\u00ae V processors) to communicate with the core simply by reading and writing control and data registers. For information regarding this soft IP core, please refer to the Embedded Peripherals IP User Guide.</p> <p></p>"},{"location":"linux-dfl/uart_16550/uart_16550/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/tty/serial/8250/8250_dfl.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/serial/8250/8250_dfl.c?h=master.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Establishes serial connection with FPGA.</li> </ul>"},{"location":"linux-dfl/uart_16550/uart_16550/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SERIAL_8250_DFL</p> <p></p>"},{"location":"linux-dfl/uart_16550/uart_16550/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#example-designs","title":"Example Designs","text":"<p>This driver is used in the PCIe Attach shell designs for Agilex 7.  Please refer to site for more information about these designs.</p>"},{"location":"linux-dfl/uart_16550/uart_16550/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/","title":"Generic DFL driver for Userspace I/O devices","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Stratix 10</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#introduction","title":"Introduction","text":"<p>This DFL based driver provides direct access to DFL devices from userspace. A sample userspace application using this driver is available for download in a git repository: git clone https://github.com/OPAE/opae-sdk.git It can be found at: opae-sdk/libraries/libopaeuio/.</p> Driver Mapping Source(s) Required for DFL uio_dfl.ko Generic DFL driver for Userspace I/O devices drivers/uio/uio_dfl.c Y <pre><code>graph TD;\n    A[uio]--&gt;C[uio-dfl];\n    B[dfl]--&gt;C[uio-dfl];</code></pre>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#driver-sources","title":"Driver Sources","text":"<p>The GitHub source code for this driver can be found at https://github.com/OFS/linux-dfl/blob/master/drivers/uio/uio_dfl.c.</p> <p>The Upstream source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/uio/uio_dfl.c.</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probe and match DFL UIO device(s)</li> </ul>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#kernel-configurations","title":"Kernel Configurations","text":"<p>UIO_DFL</p> <p></p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#example-designs","title":"Example Designs","text":"<p>N/A</p>"},{"location":"linux-dfl/uio_dfl/uio_dfl/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/apb_timers/apb_timers/","title":"General-Purpose Timers Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Device Supported: Agilex 5 , Agilex 7</p>"},{"location":"linux-embedded/apb_timers/apb_timers/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides four 32-bit general-purpose timers connected to the level 4 (L4) peripheral bus. The timers optionally generate an interrupt when the 32-bit binary count-down timer reaches zero.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/apb_timers/apb_timers/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/clocksource/dw_apb_timer.c.</p>"},{"location":"linux-embedded/apb_timers/apb_timers/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supports interrupt generation</li> <li>Supports free-running mode</li> <li>Supports user-defined count mode</li> </ul>"},{"location":"linux-embedded/apb_timers/apb_timers/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_APB_TIMER</p> <p></p>"},{"location":"linux-embedded/apb_timers/apb_timers/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/apb_timers/apb_timers/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/apb_timers/apb_timers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/clock_manager/clock_manager/","title":"Clock Manager Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: No</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/clock_manager/clock_manager/#introduction","title":"Introduction","text":"<p>Hard Processor System (HPS) clock generation is centralized in the clock manager. The clock manager is responsible for providing software-programmable clock control to configure all clocks generated in the HPS. Clocks are organized into clock groups.</p> <p>A clock group is a set of clock signals that originate from the same clock source which may be synchronous to each other. The Clock Manager has a two Phase-Locked Loop (PLL) clock group where the clock source is a common PLL voltage-controlled oscillator (VCO). A clock group which is independent and asynchronous to other clocks may only have a single clock, also known as clock slice. Peripheral clocks are a group of independent clock slices.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/clock_manager/clock_manager/#features","title":"Features","text":"<ul> <li>Generates and manages clocks in the HPS.</li> <li>Contains two flexible PLL blocks Main PLL and Peripheral PLL.</li> <li>Generates clock gate controls for enabling and disabling most of the clocks.</li> <li>Allows software to program clock characteristics.</li> <li>Supports interrupting the Cortex-A53 MPCore on PLL-lock and loss-of-lock.</li> </ul>"},{"location":"linux-embedded/clock_manager/clock_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/clk/socfpga/clk-agilex5.c.</p>"},{"location":"linux-embedded/clock_manager/clock_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Support to configure peripherals clock through common clock framework.</li> <li>Support to enable or disable software-managed clocks.</li> </ul>"},{"location":"linux-embedded/clock_manager/clock_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_CLK_INTEL_SOCFPGA64</p> <p></p>"},{"location":"linux-embedded/clock_manager/clock_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p> <p>Also dt-bindings can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/include/dt-bindings/clock/agilex5-clock.h</p>"},{"location":"linux-embedded/clock_manager/clock_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/clock_manager/clock_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/dma/dma/","title":"Direct Memory Access Controller (DMAC) Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/dma/dma/#introduction","title":"Introduction","text":"<p>The DMAC driver supports two DMACs with a maximum of four channels each. This driver transfers data between memory and peripherals and other memory locations in the system.</p>"},{"location":"linux-embedded/dma/dma/#hps-direct-memory-access-controller-dmac","title":"HPS Direct Memory Access Controller (DMAC)","text":"<p>The DMAC is part of the Hard Processor System (HPS) of the FPGA.  The HPS provides two DMACs to handle the data transfer between memory-mapped peripherals and memories, off-loading this work from the MPU system complex. Some common features are listed below.</p> <ul> <li>Software programmable with dedicated register field</li> <li>Supports multiple transfer types</li> <li>Each DMAC channels supports four channels</li> <li>Each DMAC supports interrupt interface to the Generic Interrupt Controller (GIC)</li> <li>Supports up to 48 peripheral request interfaces</li> </ul> <p></p> <p>For more information please refer to the following guide: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"linux-embedded/dma/dma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c</p>"},{"location":"linux-embedded/dma/dma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>DMA bus width configuration</li> <li>Transaction configuration</li> <li>Interrupt control and handling</li> </ul>"},{"location":"linux-embedded/dma/dma/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_AXI_DMAC</p> <p></p>"},{"location":"linux-embedded/dma/dma/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the dma: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/dma/dma/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/dma/dma/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/edac/edac/","title":"Error Detection and Correction (EDAC) Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/edac/edac/#introduction","title":"Introduction","text":"<p>The Error Detection and Correction (EDAC) driver supports use of the Error Checking and Correction (ECC) Controller in the HPS.  The ECC controllers are implemented in the on-chip RAM, USB OTG 2.0 and 3.1 and Ethernet MACs in the HPS.  To find out more about the ECC controller please refer to the Hard Processor Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/edac/edac/#driver-sources","title":"Driver Sources","text":"<p>The source code for the driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/edac/altera_edac.c.</p>"},{"location":"linux-embedded/edac/edac/#driver-capabilities","title":"Driver Capabilities","text":"<p>The Error Detection and Correction (EDAC) driver comprises the ECC manager main component and sub-components of the supported EDAC SoC components.</p> <p>The driver's main functions are to register the EDAC platform drivers in Linux, initialize the EDAC sub-components by performing initial setup of the IRQ interrupt handlers and soft-error handling for uncorrected error events, and to support debugging features like soft-error injections and reads of the error counters.</p> <p>The data flow diagram of EDAC is shown below:</p> <p></p>"},{"location":"linux-embedded/edac/edac/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_EDAC_ALTERA</p> <p></p>"},{"location":"linux-embedded/edac/edac/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/edac/edac/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/emac/emac/","title":"Ethernet Media Access Controller (EMAC) Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/emac/emac/#introduction","title":"Introduction","text":"<p>The Ethernet Media Access Controller (EMAC) Driver controls initialization, configuration and traffic shaping of the three EMACs in the Hard Processor System (HPS).</p> Driver Capability /drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c Sets PHY layer configuration such as GMII, RGMII, RMII and speed. /drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c Obtains the features EMAC features supported to main driver /drivers/net/ethernet/stmicro/stmmac/stmmac_main.c Sets ethtool operations Initializes hardware Initializes traffic control Calls networking API (NAPI) Registers IP as netdev Initialize PHY, DMA, MAC Transaction Layer, Management MAC counters, Precision Time Protocol, Watchdog Timer, Ring Length, PCS protocol and TCP Segmentation Offload /drivers/net/ethernet/stmicro/stmmac/hwif.c Initializes hardware interface and obtains device ID and IP version /drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c Configures filters, link speed, MDIO/MII bus /drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c Provides bus interface for MII registers <p>The following group of drivers is required to support EMAC functionality:</p> <pre><code>graph TD;\n    A[dwmac-socfpga.c]--&gt;B[stmmac_platform.c];\n    B[stmmac_platform.c]--&gt;C[stmmac_main.c];\n    C[stmmac_main.c]--&gt;D[hwif.c]; \n    D[hwif.c]--&gt;E[dwxgmac2_core.c];\n    E[dwxgmac2_core.c]--&gt;F[stmmac_mdio.c];  </code></pre>"},{"location":"linux-embedded/emac/emac/#emac-ip","title":"EMAC IP","text":"<p>The hard processor system (HPS) provides three Ethernet media access controller (EMAC) peripherals. Each EMAC can be used to transmit and receive data at 10M/100M/1G/2.5G speeds over Ethernet connections in compliance with the IEEE 802.3-2018 specification and enable support for Time Sensitive Networking (TSN) applications.</p> <p>The EMAC has an extensive memory-mapped Control and Status Register (CSR) set, which can be accessed by the on-board Arm processors.</p> <p>The EMAC is an integration of the Synopsys Ethernet XGMAC IP with the SMTG hub and external memory. The EMAC can be accessed from HPS or FPGA fabric over an AXI interface. For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <ul> <li>IEEE 1588-2008 Advanced Timestamp: Precision Time Protocol (PTP), 2-steps, PTP offload and timestamping</li> <li>IEEE 802.1AS: Timing and synchronization</li> <li>IEEE 802.1Qav: Time-sensitive streams forwarding queuing</li> <li>The XGMAC supports the following features<ul> <li>Full-duplex operation at 10M/100M/1G/2.5 Gbps (GMII)</li> <li>Full-duplex RGMII support (10M/100M/1 G)</li> <li>Half-duplex operation in 10/100 Mbps modes</li> <li>Separate transmission, reception, and configuration (control and status register) interfaces to the application</li> <li>MDIO interface for multiple PHY devices and their configuration and management</li> <li>Programmable frame length, supporting standard or jumbo Ethernet frames up to 9 KB</li> </ul> </li> </ul> <p></p>"},{"location":"linux-embedded/emac/emac/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/net/ethernet/stmicro/stmmac/.  </p>"},{"location":"linux-embedded/emac/emac/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Set PHY layer configurations such as GMII, RGMII, RMII and speed.</li> <li>Initializes hardware, traffic control, calls networking API (NAPI), registers IP as netdev, initializes PHY, DMA, MAC Transaction Layer, Management MAC Counters, Precision Time Protocol, Watchdog Timer, Ring Length, PCS Protocol, and TCP Segmentation Offload.</li> <li>Initializes the hardware interface and obtains the device ID and IP version.</li> <li>Configures filters, link speed, MDIO/MII bus.</li> <li>Provides a bus interface for MII registers.</li> </ul>"},{"location":"linux-embedded/emac/emac/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_STMMAC_ETH</p> <p></p>"},{"location":"linux-embedded/emac/emac/#device-tree","title":"Device Tree","text":"<p>Example Device tree location: https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/emac/emac/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/emac/emac/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/gpio/gpio/","title":"General Purpose I/O Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5, Agilex 7</p>"},{"location":"linux-embedded/gpio/gpio/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides two General-Purpose I/O (GPIO) interface modules.</p> <p>The GPIO interface supports Digital debounce, configurable interrupt mode, and has up to 48 dedicated I/O pins. For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p>The figure below shows a block diagram of the GPIO interface:</p> <p></p>"},{"location":"linux-embedded/gpio/gpio/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpio/gpio-dwapb.c.</p>"},{"location":"linux-embedded/gpio/gpio/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>GPIO muxed between I2C and SPI.</li> <li>Interrupt propagation between the device and logic on board.</li> <li>Control other circuitry on board.</li> <li>Digital debounce.</li> <li>Configurable interrupt mode.</li> </ul>"},{"location":"linux-embedded/gpio/gpio/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_GPIO_DWAPB</p> <p></p>"},{"location":"linux-embedded/gpio/gpio/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/gpio/gpio/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/gpio/gpio/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/hssi/hssi/","title":"Ethernet Subsystem (HSSI) Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/hssi/hssi/#introduction","title":"Introduction","text":"<p>The Ethernet Subsystem FPGA IP driver acts as a bridge between the software operating in the HPS and the Ethernet Subsystem within the FPGA. It provides various levels of abstraction to simplify communication with the underlying Ethernet Subsystem IP. The Ethernet Subsystem driver exposes Ethernet <code>netdev</code> driver APIs that higher-level software layers can utilize to interact with the Ethernet Subsystem IP</p>"},{"location":"linux-embedded/hssi/hssi/#ethernet-subsystem-fpga-ip","title":"Ethernet Subsystem FPGA IP","text":"<p>The Ethernet Subsystem FPGA IP is a subsystem IP that includes a configurable, Media Access Control (MAC) and Physical Coding Sublayer (PCS) presenting a consistent interface to user logic. It consists of 20 ports. Depending on the tile chosen, each port is implemented based on either the Agilex\u00ae 7 E-Tile Hard IP for Ethernet FPGA IP Core or the F-Tile Hard IP for Ethernet FPGA IP core.</p> <p>This IP provides a seamless and fast way to instantiate a multi-port design, given that it integrates the required discrete Hard IP and Soft IP ingredients. Furthermore, the Subsystem IP provides a user interface to facilitate enabling required features and parameters of operation.</p> <p>For E-Tile, this subsystem IP provides Ethernet data rate profiles of 10Gbps, 25Gbps, and 100Gbps with optional RS-FEC and 1588 Precision Time Protocol (PTP). The subsystem also provides profiles for PCS, OTN, FlexE and CPRI.</p> <p>For F-Tile, this subsystem IP provides Ethernet data rate profiles of 10Gbps, 25Gbps, 40Gbps, 50Gbps, 100Gbps, 200Gbps, and 400Gbps with optional RS-FEC and 1588 Precision Time Protocol (PTP). Quartus\u00ae Prime software version 23.2 supports only Media Access Control (MAC) and Physical Coding Sublayer (PCS) sub-profile.</p> <p>For more information please refer to the Ethernet Subsystem FPGA IP User Guide.</p> <p></p>"},{"location":"linux-embedded/hssi/hssi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_fpga_hssiss.c</p>"},{"location":"linux-embedded/hssi/hssi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Get Link state.</li> <li>Get MAC stats. These abstractions are used by the HSSI ethernet netdev driver to provide ethernet functionality to the above layers.</li> </ul>"},{"location":"linux-embedded/hssi/hssi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_HSSISS</p> <p></p>"},{"location":"linux-embedded/hssi/hssi/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the HSSI:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/hssi/hssi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/hssi/hssi/#example-designs","title":"Example Designs","text":"<p>HSSI SS driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/hssi/hssi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/","title":"Ethernet Subsystem Intel FPGA IP Tile Specific Ethernet MAC Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#introduction","title":"Introduction","text":"<p>The Ethernet MAC driver is used to manage the configuration parameters of the particular tile. It currently supports F-tile and E-tile of the Ethernet Subsystem Intel FPGA IP</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#f-tile-and-e-tile-fpga-ip","title":"F-tile and E-tile FPGA IP","text":"<p>To get more information on F-tile Hard IP please refer to the F-tile Architecture and PMA and FEC Direct PHY IP User Guide.</p> <p>And for E-tile Hard IP please refer to the E-Tile Hard IP User Guide: E-Tile Hard IP for Ethernet and E-Tile CPRI PHY IPs.</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#driver-sources","title":"Driver Sources","text":"<p>The source code to generate <code>intel_fpga_hssi_xtile.o</code> can be found at the following directory location:</p> <p>https://github.com/altera-opensource/linux-socfpga/tree/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera</p> <pre><code>graph TD;\n    A[intel_fpga_hssi_xtile.o]--&gt;B[intel_fpga_eth_main.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;C[intel_fpga_hssi_etile_fec.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;D[intel_fpga_etile_driver.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;E[intel_fpga_hssi_etile_ethtool.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;F[intel_fpga_ftile_driver];\n    A[intel_fpga_hssi_xtile.o]--&gt;G[intel_fpga_hssi_ftile_fec.c];\n    A[intel_fpga_hssi_xtile.o]--&gt;H[intel_fpga_hssi_ftile_ethtool.c];</code></pre>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>To set the tile specific parameters, like enable support for interrupts, DMA and also the ethtool related configuration.</li> </ul>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_HSSI_XTILE</p> <p></p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#device-tree","title":"Device Tree","text":"<p>Example of Device tree location to configure the hssi_xtile: </p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#example-designs","title":"Example Designs","text":"<p>HSSI xtile (E-tile/F-tile) driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP </p> <p></p>"},{"location":"linux-embedded/hssi_xtile/hssi_xtile/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/i2c/i2c/","title":"I2C Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Agilex 5</p>"},{"location":"linux-embedded/i2c/i2c/#introduction","title":"Introduction","text":"<p>The I2C controller provides support for a communication link between integrated circuits on a board. It is a simple two-wire bus which consists of a serial data line (SDA) and a serial clock (SCL).</p> <p>The hard processor system (HPS) provides five I2C controllers to enable system software to communicate serially with I2C buses. Each I2C controller can operate in master or slave mode and support standard mode of up to 100 Kbps or fast mode of up to 400 Kbps. These I2C controllers are instances of the Synopsys DesignWare controller.</p> <p>Each I2C controller must be programmed to operate in either master or slave mode only. Operating as a master and slave simultaneously is not supported.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/i2c/i2c/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/i2c/busses.</p> <pre><code>graph TD;\n    A[i2c-core-base]--&gt;B[i2c_designware_core];\n    B[i2c_designware_core]--&gt;C[i2c_designware_master]\n    C[i2c_designware_master]--&gt;E[i2c_designware_slave]</code></pre>"},{"location":"linux-embedded/i2c/i2c/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the communication for I2C Master buses as well as Slave.</li> <li>Handle the data transfer between connected devices over the I2C bus.</li> </ul>"},{"location":"linux-embedded/i2c/i2c/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_I2C_DESIGNWARE_CORE</p> <p></p> <p>CONFIG_I2C_DESIGNWARE_SLAVE</p> <p></p>"},{"location":"linux-embedded/i2c/i2c/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the i2c:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/i2c/i2c/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/i2c/i2c/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/i3c/i3c/","title":"I3C Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/i3c/i3c/#introduction","title":"Introduction","text":"<p>The I3C controller device driver only supports running as a master. The main master is a specialized master that comes up after power-on-reset, and is responsible for assigning dynamic addresses to the I3C devices. The secondary master is an I3C instance capable of both master and slave functionality. It comes up as a slave upon power-on-reset. The secondary master must get ownership of the I3C bus to become a current master before initiating any transfer to its associated slaves.</p> <p>I3C slave controller is not supported. The latest Linux kernel does not support the slave I3C framework.</p> <p>I3C master controller slave DMA is not be supported even though I3C also supports external DMA. The latest Linux kernel does not support DMA.</p>"},{"location":"linux-embedded/i3c/i3c/#i3c-fpga-ip","title":"I3C FPGA IP","text":"<p>The I3C interface is a high-bandwidth bus interface for connecting peripherals to HPS. The I3C interface is intended to improve upon the features of the I2C interface, while preserving backward compatibility. This interface is targeted for applications such as event camera sensors which require I3C interface capability.</p> <p>The hard processor system (HPS) provides two I3C controllers to enable system software to communicate serially with I3C buses. For information regarding this soft IP core, please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/i3c/i3c/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/i3c/master/dw-i3c-master.c.</p>"},{"location":"linux-embedded/i3c/i3c/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configure the I3C Controller driver at system boot-up.</li> <li>Provide support for device detection and enumeration for compatible I3C devices.</li> <li>Support the Dynamic address assignment.</li> </ul>"},{"location":"linux-embedded/i3c/i3c/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_I3C</p> <p></p>"},{"location":"linux-embedded/i3c/i3c/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the I3C:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/i3c/i3c/#known-issues","title":"Known Issues","text":"<ul> <li>I3C slave controller shall not be supported. The latest Linux kernel does not support the slave i3c framework.</li> <li>I3C master controller slave DMA shall not be supported even-though I3C also supports external DMA. The latest Linux kernel does not support DMA</li> </ul>"},{"location":"linux-embedded/i3c/i3c/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/","title":"Interrupt controller (GICv3) Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#introduction","title":"Introduction","text":"<p>The interrupt controller driver handles general initialization of the interrupt controller in the HPS.</p> <p>The Arm\u00ae Generic Interrupt Controller (GIC) handles interrupts from peripherals to the cores and between cores. To find out more about the features and functions of the GIC controller, please refer to Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/irqchip/irq-gic-v3.c</p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configure the GICv3 interrupt controller hardware during system boot-up.</li> <li>Handles interrupts generated by various sources in the system.</li> <li>Routes interrupt from their sources to the appropriate CPU cores.</li> <li>Provides generic API to manage interrupts.</li> <li>Support distributed interrupts across multiple GIC instances.</li> </ul>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ARM_GIC_V3</p> <p></p> <p>CONFIG_ARM_GIC_V3_ITS</p> <p></p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the irq_gic_v3:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/interrupt_controller_GICv3/irq_gic_v3/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/msgdma/msgdma/","title":"A Modular Scatter-Gather DMA (mSGDMA) Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/msgdma/msgdma/#introduction","title":"Introduction","text":"<p>In a processor subsystem, data transfers between two memory spaces can happen frequently. In order to offload the processor from moving data around a system, a Direct Memory Access (DMA) engine is introduced to perform this function instead. The Modular Scatter-Gather DMA (mSGDMA) is capable of performing data movement operations with preloaded instructions, called descriptors. Multiple descriptors with different transfer sizes, and source and destination addresses have the option to trigger interrupts.</p>"},{"location":"linux-embedded/msgdma/msgdma/#msgdma-fpga-ip","title":"mSGDMA FPGA IP","text":"<p>The mSGDMA provides three configuration structures for handling data transfers: between the Avalon-MM to Avalon-MM, Avalon-MM to Avalon-ST, and Avalon-ST to Avalon-MM. The sub-core of the mSGDMA is instantiated automatically according to the structure configured for the mSGDMA use model. For more information on MSGDMA IP core please refer to https://www.intel.com/content/www/us/en/docs/programmable/683130/23-1/modular-scatter-gather-dma-core.html.</p>"},{"location":"linux-embedded/msgdma/msgdma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/dma/altera-msgdma.c</p>"},{"location":"linux-embedded/msgdma/msgdma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage multiple DMA channels provided by the MSGDMA IP core.</li> <li>Provides support for interrupt handling.</li> <li>Provides support for Scatter-gather DMA operation through a set of buffer descriptors.</li> <li>Data transfer to non-contiguous memory space.</li> </ul>"},{"location":"linux-embedded/msgdma/msgdma/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ALTERA_MSGDMA</p> <p></p>"},{"location":"linux-embedded/msgdma/msgdma/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/msgdma/msgdma/#example-designs","title":"Example Designs","text":"<p>Moified version of MSGDMA driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP and also the source code is available at https://github.com/altera-opensource/linux-socfpga/tree/socfpga-6.1.55-lts/drivers/net/ethernet/altera.</p> <p></p>"},{"location":"linux-embedded/msgdma/msgdma/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/nand/nand/","title":"NAND Flash Controller Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/nand/nand/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides a NAND Flash controller to interface with external NAND Flash memory in Intel system-on-a-chip (SoC) systems. External Flash memory can be used to store software, or as extra storage capacity for large applications or user data. For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"linux-embedded/nand/nand/#features","title":"Features","text":"<ul> <li>The triple-level cell (TLC) devices are supported only in parts that are compatible with the ONFI specification</li> <li>Supports three operation modes that make the controller easy to operate while also providing enough flexibility to be adapted to your project's needs.</li> <li>Supports DMA data transfer which optimizes the transfer rate for read and write operations using DMA primary and DMA secondary interfaces.</li> <li>Supports devices with page sizes up to 64 KB.</li> <li>Support up to 8 operation threads that can be executed in parallel.</li> <li>Provides data buffering where necessary in order to achieve maximum performance.</li> </ul>"},{"location":"linux-embedded/nand/nand/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mtd/nand/raw/cadence-nand-controller.c.</p>"},{"location":"linux-embedded/nand/nand/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialization and configuration of the NAND controller hardware.</li> <li>Determine the characteristics like page size and block size.</li> </ul>"},{"location":"linux-embedded/nand/nand/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MTD_NAND_CADENCE</p> <p></p>"},{"location":"linux-embedded/nand/nand/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/nand/nand/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/nand/nand/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/","title":"Ethernet 1588 PTP Time of Day Clock IP Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#introduction","title":"Introduction","text":"<p>The driver for the Ethernet 1588 PTP Time of Day Clock FPGA IP is used in the 1588 PTP Design examples provided by Altera. The Time of Day Clock FPGA IP is exposed as a PTP Hardware Clock (PHC) device to the Linux PTP stack to synchronize the system clock to its ToD information using <code>phc2sys</code> utility in the Linux PTP stack.</p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#time-of-day-clock-fpga-ip","title":"Time of Day Clock FPGA IP","text":"<p>The Time-of-day (TOD) Clock streams 96-bit and 64-bit time-of-day to one or more time stamping units in an IEEE 1588v2 solution. For information regarding this soft IP core, please refer to the Ethernet Design Example Components User Guide.</p> <p></p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_fpga_tod.c.</p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Registers PTP clock driver to kernel</li> <li>Calculates the ToD of clock offset adjustments</li> </ul>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_INTEL_FPGA_TOD</p> <p></p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the TOD:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#example-designs","title":"Example Designs","text":"<p>This driver is used in the Agilex 7 SoC F-Tile Design Example for 25GbE and 10GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/ptp_tod/ptp_emb_tod/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/qsfp/qsfp/","title":"QSFP Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/qsfp/qsfp/#introduction","title":"Introduction","text":"<p>The QSFP driver is responsible for interacting with the onboard QSFP module. It reads the QSFP Serial Electrically Erasable Programmable Read-Only Memory (SEEP) and controls the power and interrupt pins of the QSFP.</p>"},{"location":"linux-embedded/qsfp/qsfp/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/phy/qsfp.c.</p>"},{"location":"linux-embedded/qsfp/qsfp/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Registers QSFP driver to kernel.</li> <li>Reads the registers through the I2C bus and provide information to high level software stack.</li> </ul>"},{"location":"linux-embedded/qsfp/qsfp/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_QSFP</p> <p></p>"},{"location":"linux-embedded/qsfp/qsfp/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_10g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/qsfp/qsfp/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/qsfp/qsfp/#example-designs","title":"Example Designs","text":"<p>This driver is used in the Agilex 7 SoC F-Tile Design Example for 25GbE and 10GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/qsfp/qsfp/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/qspi/qspi/","title":"QSPI Driver for Hard Processor System (HPS)","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/qspi/qspi/#introduction","title":"Introduction","text":"<p>The Quad Serial Peripheral Interface (QSPI) driver manages the QSPI controller in the HPS.  The QSPI has the capability to access serial NOR Flash connected to the Secure Device Manager (SDM) QSPI. The QSPI controller supports standard SPI Flash devices as well as high-performance dual and quad SPI Flash devices. The QSPI controller module features are:</p> <ul> <li>SPIx1, SPIx2, or SPIx4 (QSPI) serial NOR flash devices</li> <li>Supported clock frequencies up to 166 MHz</li> <li>Direct access and indirect access modes</li> <li>Single I/O, dual I/O, or quad I/O instructions</li> <li>Up to four chip selects</li> <li>Configurable clock polarity and phase</li> <li>Programmable write-protected regions</li> <li>Programmable delays between transactions</li> </ul> <p>To find out more about the QSPI controller within the HPS please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual. </p>"},{"location":"linux-embedded/qspi/qspi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Initialize and configuration of the QSPI controller.</li> <li>Handles data transfer and address.</li> </ul>"},{"location":"linux-embedded/qspi/qspi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/spi/spi-cadence-quadspi.c.</p>"},{"location":"linux-embedded/qspi/qspi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SPI_CADENCE_QUADSPI</p> <p></p>"},{"location":"linux-embedded/qspi/qspi/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/qspi/qspi/#known-issues","title":"Known Issues","text":"<p>None kKnown</p>"},{"location":"linux-embedded/qspi/qspi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/reset_manager/reset_manager/","title":"Reset Manager Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/reset_manager/reset_manager/#introduction","title":"Introduction","text":"<p>The reset manager generates module reset signals based on reset requests from various sources in the HPS, and performs software writing to the module-reset control registers.</p> <p>The HPS contains multiple reset domains. Each reset domain can be reset independently. A reset can be initiated externally, internally, or through software.  For more information about the reset manager, please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/reset_manager/reset_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/reset/reset-simple.c</p>"},{"location":"linux-embedded/reset_manager/reset_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the system level reset.</li> <li>Support Assert and De-assert of the reset signal.</li> <li>Monitor the status of the reset signal.</li> </ul>"},{"location":"linux-embedded/reset_manager/reset_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_RESET_SIMPLE</p> <p></p>"},{"location":"linux-embedded/reset_manager/reset_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location for reset signal parameter:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p> <p>Also dt-bindings can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/include/dt-bindings/reset/altr%2Crst-mgr-agilex5.h</p>"},{"location":"linux-embedded/reset_manager/reset_manager/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/reset_manager/reset_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/","title":"SD-EMMC Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#introduction","title":"Introduction","text":"<p>The Secure Digital/Embedded Multimedia Card (SD/eMMC) driver supports the SD/eMMC controller in the Hard Processor System (HPS) which interfaces with external SD Flash cards, secure digital I/O (SDIO) devices, and eMMC storage devices.</p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mmc/host/sdhci-cadence.c</p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage SD/eMMC features such as configuration and reset and timeout clock frequency</li> <li>Supports SDMA and ADMA modes.</li> <li>Handles data transfer to/from the SD/eMMC.</li> </ul>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MMC_SDHCI_CADENCE</p> <p></p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the SD/eMMC:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga_agilex5-ES_RC/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/sd-emmc/sd-emmc/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/smmu/smmu/","title":"System Memory Management Unit (SMMU) Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/smmu/smmu/#introduction","title":"Introduction","text":"<p>SMMU converts virtual addresses to physical addresses for external peripheral devices. This allows multiple external devices to perform direct memory access (DMA) to the entire range of the system physical memory.</p> <p>As an example, certain peripheral devices limited to accessing only 24 bits of address space would now be able to access all 64 bits addresssing through the memory translation tables of the SMMU.</p> <p>The SDM SMMU is used solely by the FCS Cryptography feature. The accelerator like FCS_Crytpo sends a VA to SMMU and SMMU queries the PA from the page table.</p> <p>SMMU registers are configured through ARM Trusted firmware (ATF) BL31 SMC calls by the Crytography device drivers. The ATF performs default SMMU initializations of the stream IDs through the system manager and SMMU secure registers configuration during the boot-up process.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/smmu/smmu/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/iommu/arm/arm-smmu-v3</p>"},{"location":"linux-embedded/smmu/smmu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Queue manipulation, sizing</li> <li>Command queue locking or insertion</li> <li>Error reporting</li> <li>Updating Stream Table Entry</li> </ul>"},{"location":"linux-embedded/smmu/smmu/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ARM_SMMU_V3</p> <p></p>"},{"location":"linux-embedded/smmu/smmu/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the smmu:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga_agilex5-ES_RC/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/smmu/smmu/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/smmu/smmu/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/spi/spi/","title":"SPI Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex7, Agilex 5</p>"},{"location":"linux-embedded/spi/spi/#introduction","title":"Introduction","text":"<p>Serial master and serial slave controllers Enable serial communication with serial-master or serial-slave peripheral devices. Each SPI master has a maximum bit rate of 60 Mbps. Each SPI slave has a maximum bit rate of 33.33 Mbps. The DMA controller interface is integrated with the HPS DMA controller.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/spi/spi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/spi.</p>"},{"location":"linux-embedded/spi/spi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Handle the data transfer between connected devices over the SPI bus.</li> <li>Support the peripheral slave DMA.</li> </ul>"},{"location":"linux-embedded/spi/spi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SPI_ALTERA</p> <p></p>"},{"location":"linux-embedded/spi/spi/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the SPI:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/spi/spi/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/spi/spi/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/system_manager/system_manager/","title":"System Manager Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/system_manager/system_manager/#introduction","title":"Introduction","text":"<p>The system manager contains the memory-mapped control and status registers (CSRs) and logic to control system level functionality in a hard processor system (HPS).</p> <p>The system manager connects to different modules in the HPS such as a Direct memory access (DMA) controller, Microprocessor unit (MPU) system complex, NAND flash controller, Secure Digital/Embedded Multimedia Card (SD/eMMC) controller, or GPIO interface between HPS and other modules.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/system_manager/system_manager/#features","title":"Features","text":"<ul> <li>Provides memory-mapped control signals to other modules and peripherals</li> <li>Provides watchdogs stop functionality on debug requests.</li> <li>Provides software access to control and status signals of other HPS modules.</li> <li>Enables and disables HPS peripheral interfaces to the FPGA.</li> <li>Provides ten 32-bit registers to store handoff information between the preloader and the operating system.</li> </ul>"},{"location":"linux-embedded/system_manager/system_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Handle the probing and resource allocation.</li> <li>Provides API to perform read/write operations.</li> <li>Access the CSRs in the system manager to control and monitor various functions of modules.</li> </ul>"},{"location":"linux-embedded/system_manager/system_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/mfd/altera-sysmgr.c.</p>"},{"location":"linux-embedded/system_manager/system_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_MFD_ALTERA_SYSMGR</p> <p></p>"},{"location":"linux-embedded/system_manager/system_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/system_manager/system_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/system_manager/system_manager/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/uart/uart/","title":"UART Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Agilex 5</p>"},{"location":"linux-embedded/uart/uart/#introduction","title":"Introduction","text":"<p>The Hard Processor System (HPS) provides two UART controllers for asynchronous serial communication.</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/uart/uart/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/tty/serial/8250/8250_dw.c.</p>"},{"location":"linux-embedded/uart/uart/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Probing and resource allocation as well as memory mapping.</li> <li>It provides the support for busy detect interrupt.</li> </ul>"},{"location":"linux-embedded/uart/uart/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SERIAL_8250_DW</p> <p></p>"},{"location":"linux-embedded/uart/uart/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the uart:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/uart/uart/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/uart/uart/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/","title":"USB 2.0 OTG Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 7, Agilex 5</p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) provides a USB On-The-Go (OTG) controller that supports both device and host functions. The controller is fully compliant with the On The Go and Embedded Host Supplement to the USB Revision 1.3 and Revision 2.0 Specification. The controller can be programmed for both device and host functions to support data movement over the USB protocol</p> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/dwc2</p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Provides basic services for accessing and managing the hardware.</li> <li>Enable support for Host and peripheral mode.</li> <li>Handle control and data transfers between the USB host and connected USB peripherals.</li> </ul>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_USB_DWC2</p> <p></p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the usb2_0_otg:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"linux-embedded/usb2_0_otg/usb_2_0_otg/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/usb3_1/usb3_1/","title":"USB 3.1 Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"linux-embedded/usb3_1/usb3_1/#introduction","title":"Introduction","text":"<p>The HPS provides a single instance of a USB 3.1 Gen 1 controller that supports both device and host functions for high-speed applications. The general use cases of USB 3.1 are for the HPS system to support all USB devices such as:</p> <ul> <li>Portable electronic devices</li> <li>High-bandwidth applications like audio and video.</li> <li>Debug trace applications</li> </ul> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"linux-embedded/usb3_1/usb3_1/#usb-31-glue-driver","title":"USB 3.1 Glue Driver","text":"<p><code>drivers/usb/dwc3/dwc3-of-simple.c</code> is a USB glue driver for the <code>dw3-agilex-edge.c</code> component depicted in the diagram below. This glue driver is used to control dynamic mode switching.</p> <p></p>"},{"location":"linux-embedded/usb3_1/usb3_1/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/drivers/usb/dwc3/dwc3-of-simple.c</p>"},{"location":"linux-embedded/usb3_1/usb3_1/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>It provides a reference to the Clock which is required by the rest of the interfaces.</li> </ul>"},{"location":"linux-embedded/usb3_1/usb3_1/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_USB_DWC3</p> <p></p>"},{"location":"linux-embedded/usb3_1/usb3_1/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the usb3_1:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-6.1.55-lts/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/usb3_1/usb3_1/#known-issues","title":"Known Issues","text":"<ul> <li>Currently dynamic mode switching is not supported</li> <li>Real-time detection of USB-C slave devices not supported</li> </ul>"},{"location":"linux-embedded/usb3_1/usb3_1/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/","title":"Watchdog Timers Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Device Supported: Agilex 5</p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#introduction","title":"Introduction","text":"<p>The watchdog timers are peripherals you can use to recover from system lockup that might be caused by software or system related issues. The hard processor system (HPS) provides five programmable watchdog timers, which are connected to the level 4 (L4) peripheral bus.</p> <p>Each watchdog timer consists of a slave interface for control and status register (CSR) access, a register block, and a 32-bit down counter that operates on the slave interface clock (l4_sys_free_clk). A pause input, driven by the system manager, optionally pauses the counter when a CPU is being debugged.The watchdog timer drives an interrupt request to the MPU and a reset request to the reset manager.</p> <p>For more information please refer to the Agilex 5 Hard Processor System Technical Reference Manual.</p> <p></p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/watchdog/dw_wdt.c.</p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Allows configuration of the watchdog timer timeout period, specifying the duration after which the watchdog will trigger a system reset if not reset by the software</li> <li>Initializes the watchdog timer hardware during system boot, setting up the necessary registers and configurations to enable watchdog functionality.</li> <li>Handles interrupts generated by the watchdog timer hardware, allowing the system to respond appropriately to watchdog events, such as timer expiration.</li> </ul>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_DW_WATCHDOG</p> <p></p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm64/boot/dts/intel/socfpga_agilex5.dtsi</p> <p></p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/watchdog_timers/watchdog_timers/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/","title":"Zarlink Clock Synchronizer Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 7</p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#introduction","title":"Introduction","text":"<p>The Microchip\u00ae Zarlink ZL30733 3-Channel SyncE &amp; 1588 Network Synchronizer takes charge of frequency synchronization, monitors reference clock quality, manages reference clock switching, and provides holdover functionality for SyncE and PTP1588 support. It has support for multiple reference clocks and can be used to generate the outputs. The device is constantly monitoring the quality of the reference clocks and it switches to an alternative clock source when the measured period of the current reference signal is incorrect, or if it has excessive jitter.</p> <p>I2C based zl30733</p> <pre><code>graph TD;\n    A[intel_freq_control.c]--&gt;B[intel_freq_ctrl_common_i2c.c];\n    A[intel_freq_control.c]--&gt;C[intel_freq_ctrl_zl30733_i2c.c];</code></pre> <p>SPI based zl30793</p> <pre><code>graph TD;\n    A[intel_freq_control.c]--&gt;B[intel_freq_ctrl_common_spi.c];\n    A[intel_freq_control.c]--&gt;C[intel_freq_ctrl_zl30793_spi.c];</code></pre>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#zarlink-chip-information","title":"Zarlink chip information","text":"<p>For Microchip\u00ae Zarlink ZL30733 documentation please refer to https://www.microchip.com/en-us/product/zl30733 and https://www.microchip.com/en-us/product/zl30793.</p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <ul> <li>General Frequency control driver</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_control.c</p> <ul> <li>I2C based ZL30733 support</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_zl30733_i2c.c</p> <ul> <li>I2C based common api for frequency control</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_common_i2c.c</p> <ul> <li>SPI based zl30793 support</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_zl30793_spi.c</p> <ul> <li>SPI based common api for frequency control</li> </ul> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/drivers/net/ethernet/altera/intel_freq_ctrl_common_spi.c</p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Support frequency synchronization, monitor reference clock quality, manage reference clock switching.</li> <li>Provides holdover functionality for SyncE and PTP1588 support.</li> </ul>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/linux-socfpga/blob/socfpga-5.15.90-lts-ftile-1588ptp/arch/arm64/boot/dts/intel/fm87_ftile_25g_2port_ptp.dtsi</p> <p></p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#example-designs","title":"Example Designs","text":"<p>Zarlink driver is used in the Agilex 7 SoC F-Tile Design Example for 25/10 GbE with IEEE1588PTP.</p> <p></p>"},{"location":"linux-embedded/zarlink_clock_synchronizer/zarlink_clock_synchronizer/#notices-disclaimers","title":"Notices &amp; Disclaimers","text":"<p>Altera\u00ae Corporation technologies may require enabled hardware, software or service activation. No product or component can be absolutely secure.  Performance varies by use, configuration and other factors. Your costs and results may vary.  You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Altera or Intel products described herein. You agree to grant Altera Corporation a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein. No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document, with the sole exception that you may publish an unmodified copy. You may create software implementations based on this document and in compliance with the foregoing that are intended to execute on the Altera or Intel product(s) referenced in this document. No rights are granted to create modifications or derivatives of this document. The products described may contain design defects or errors known as errata which may cause the product to deviate from published specifications.  Current characterized errata are available on request. Altera disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade. You are responsible for safety of the overall system, including compliance with applicable safety-related requirements or standards.  \u00a9 Altera Corporation.  Altera, the Altera logo, and other Altera marks are trademarks of Altera Corporation.  Other names and brands may be claimed as the property of others. </p> <p>OpenCL and the OpenCL logo are trademarks of Apple Inc. used by permission of the Khronos Group\u2122. </p>"},{"location":"sw-tools-list/host-attach-tools/","title":"Host Attach Software Tools","text":"<p>The table below provides a comprehensive list of host software tools available for Altera 7 FPGAs. These utilities are part of the  called Open Programmable Acceleration Engine (OPAE) software development kit which is part of the Open FPGA Stack (OFS) software framework.  More documentation on OPAE and OFS can be found here.</p> <p>You can use the filter fields to narrow your search.</p> Utility Supported Devices Description fpgaconf Agilex 7 FPGA Configuration fpgad Agilex 7 FPGA Diagnostics fpgainfo Agilex 7 FPGA Card Information fpgaport Agilex 7 FPGA Port Information fpgasupdate Agilex 7 FPGA Secure Update host_exerciser Agilex 7 Host Interface Exerciser hssi Agilex 7 HE-HSSI Controller hssi_ethernet Agilex 7 HSSI/Ethernet Statistics hssi_loopback Agilex 7 HSSI Loopback hssimac Agilex 7 HSSI MAC mem_tg Agilex 7 Memory Traffic Generator mmlink Agilex 7 Memory Mapped Link ofs.uio Agilex 7 OFS DFL UIO opae.io Agilex 7 OFS DFL OPAE IO opaeuio Agilex 7 OFS OPAE User IO opaevfio Agilex 7 OFS DFL Virt IO pac_hssi_config Agilex 7 Programmable Acceleration Card HSSI Configuration packager Agilex 7 AFU Packager pcie_device Agilex 7 PCIe Device rsu Agilex 7 Remote System Update (RSU) userclk Agilex 7 User Clock Control vabtool Agilex 7 Vendor Authorized Boot Tool"},{"location":"zephyr-embedded/clock_manager/clock_manager/","title":"Clock Manager Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) clock generation is centralized in the clock manager. The clock manager is responsible for providing software-programmable clock control to configure all clocks generated in the HPS. Clocks are organized in clock groups. A clock group is a set of clock signals that originate from the same clock source which may be synchronous to each other. The clock manager has two phase-locked loop (PLL) clock group where the clock source is a common PLL voltage-controlled oscillator (VCO). A clock group that is independent and asynchronous to other clocks may only have a single clock, also known as a clock slice. Peripheral clocks are a group of independent clock slices.</p> <p></p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/clock_control/clock_control_agilex5.c.</p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supply clock to each HPS peripheral as configured in the boot loader and provide an API to retrieve the clock for each peripheral.</li> <li>Clock Manager will be initialized only one time during boot up by FSBL (ATF BL2) based on external user settings stored in HPS handoff data in bitstream.</li> </ul>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_CLOCK_CONTROL</p> <p></p> <p>CONFIG_CLOCK_CONTROL_AGILEX5</p> <p></p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p> <p>A clock manager node will be added in device tree.  Then, the peripheral can associate the clock manager in device tree so that the peripheral driver code can retrieve the clock frequency from clock manager. One such example is shown below.</p> <p></p>"},{"location":"zephyr-embedded/clock_manager/clock_manager/#known-issues","title":"Known Issues","text":"<p>None Known. </p>"},{"location":"zephyr-embedded/dma/dma/","title":"DMA Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: No</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/dma/dma/#introduction","title":"Introduction","text":"<p>DMA Controller controls the transfer of data between I/O devices and memory without CPU involvement. DMA controller can access the memory directly for reading and writing. This helps to enhance the performance of the cores to do some other operations, as the data transfers are handled by the DMA controller.</p> <p>The hard processor system (HPS) provides two DMA Controllers based on the Synopsis-Designware IP.</p> <p>For more information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/dma/dma/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/drivers/dma/dma_dw_axi.c.</p>"},{"location":"zephyr-embedded/dma/dma/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Driver supports scatter-gather list.</li> <li>Driver can be configured for one of the possible three use cases.     * Memory to Memory Transfer     * Device to Memory Transfer     * Memory to Device Transfer</li> <li>Each DMA controller can support up to four channels for DMA transfer.</li> <li>Driver supports DMA transfer suspend.</li> <li>Driver supports DMA transfer resume.</li> <li>Driver supports to stop active DMA transfer.</li> </ul>"},{"location":"zephyr-embedded/dma/dma/#kernel-configurations","title":"Kernel Configurations","text":""},{"location":"zephyr-embedded/dma/dma/#device-tree","title":"Device Tree","text":"<p>Device Tree location to configure DMA is</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <pre><code>dma0: dma@10DB0000 {\ncompatible = \"snps,dw-axi-dma\";\n#dma-cells = &lt;2&gt;;\nreg = &lt;0x10DB0000 0x1000&gt;;\ninterrupt-parent = &lt;&amp;gic&gt;;\ninterrupts = &lt;GIC_SPI 81 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 82 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 83 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;,\n         &lt;GIC_SPI 84 IRQ_TYPE_LEVEL\n         IRQ_DEFAULT_PRIORITY&gt;;\ndma-channels = &lt;4&gt;;\nresets = &lt;&amp;reset RSTMGR_DMA_RSTLINE&gt;;\nstatus = \"disabled\";\n};\n</code></pre>"},{"location":"zephyr-embedded/dma/dma/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/dma/mem_to_mem/.</p> <p>The most relevant files are:</p> <ol> <li>Project yml -&gt; sample.yml:</li> </ol> <pre><code> 1 sample:\n 2   name: DMA\n 3   description: DMA Driver sample application\n 4 common:\n 5   tags:\n 6     - drivers\n 7     - dma\n 8 tests:\n 9   sample.drivers.dma.mem_to_mem:\n10     build_only: true\n11     harness: console\n12     integration_platforms:\n13       - intel_socfpga_agilex5_socdk\n14     harness_config:\n15       type: multi_line\n16       ordered: true\n17       regex:\n18         - \"Sample application for Memory to Memory transfer using dma controller\"\n19         - \"Successfully transferred\"\n20         - \"Sample application for dma transfer complete\"\n21     filter: DT_HAS_SNPS_DESIGNWARE_DMA_ENABLED\n22     depends_on: dma\n</code></pre> <ol> <li> <p>Config overlay -&gt; prj.conf: <pre><code>  1 CONFIG_DMA=y\n  2 CONFIG_LOG=y\n</code></pre></p> </li> <li> <p>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</p> </li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (c) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 &amp;dma0 {\n  8         status = \"okay\";\n  9 };\n</code></pre> 4. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/dma/mem_to_mem/src/main.c.</p>"},{"location":"zephyr-embedded/dma/dma/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/dma/mem_to_mem/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/dma/dma/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n[00:00:00.125,000] &lt;inf&gt; clock_control_agilex5: Intel Agilex5 clock driver initialized!\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nSample application for Memory to Memory transfer using dma controller\ndma@10DB0000: Successfully transferred 10 blocks of size:200 channel:1\nSample application for dma transfer complete\n</code></pre>"},{"location":"zephyr-embedded/dma/dma/#known-issues","title":"Known Issues","text":"<p>None Known. </p>"},{"location":"zephyr-embedded/gpio/gpio/","title":"General Purpose I/O Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Not Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/gpio/gpio/#introduction","title":"Introduction","text":"<p>General Purpose Input/Output (GPIO) Controller provides the low-level configuration through software or hardware to control the actual general purpose IO cells/pads present in the HPS.  The below diagram represents block diagram of the GPIO controller connected with other components in the system.</p> <p></p> <p>Two GPIO module instances present in HPS and each having support of 24 GPIO ports. Only Port A of GPIO Controller is configured. All the design contained of this document is referred from \u201cSynopsys GPIO Databook\u201d.</p> <p>Functional Modes:</p> <ul> <li>Software Control Mode: In the software control mode, the port direction is set by writing to the corresponding port control register of a GPIO pin. These port control registers are memory mapped.</li> <li>Hardware Control Mode : If a signal is configured for hardware control, an external auxiliary hardware-signal controls the direction of the port. For the SM, Auxiliary H/W support is not enabled.</li> </ul> <p>For More information please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/gpio/gpio/#features","title":"Features","text":"<ul> <li>Digital debounce</li> <li>Configurable interrupt mode</li> <li>Up to 48 dedicated I/O pins</li> </ul>"},{"location":"zephyr-embedded/gpio/gpio/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/drivers/gpio/gpio_intel_socfpga.c.</p>"},{"location":"zephyr-embedded/gpio/gpio/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>GPIO Pin configure as input or output.</li> <li>GPIO Port/Pin set value using mask.</li> <li>GPIO Port/Pin get value using mask.</li> <li>GPIO Port/Pin toggle using mask.</li> </ul>"},{"location":"zephyr-embedded/gpio/gpio/#kernel-configurations","title":"Kernel Configurations","text":"<p>No additional Kernel configurations needed to enable GPIO driver functionality.</p>"},{"location":"zephyr-embedded/gpio/gpio/#device-tree","title":"Device Tree","text":"<p>Example Device tree location:</p> <p>https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/gpio/gpio/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/basic/blinky.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: Blinky Sample\n 3 tests:\n 4   sample.basic.blinky:\n 5     tags:\n 6       - LED\n 7       - gpio\n 8     filter: dt_enabled_alias_with_parent_compat(\"led0\", \"gpio-leds\")\n 9     depends_on: gpio\n10     harness: led\n11     integration_platforms:\n12       - frdm_k64f\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code>CONFIG_GPIO=y\n</code></pre> <ol> <li>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 #include &lt;dt-bindings/gpio/gpio.h&gt;\n  8 \n  9 / {\n 10         aliases {\n 11                 led0 = &amp;myled0;\n 12         };\n 13 \n 14         leds {\n 15                 compatible = \"gpio-leds\";\n 16                 myled0: led_0 {\n 17                         gpios = &lt;&amp;gpio1 19 GPIO_ACTIVE_HIGH&gt;;\n 18                 };\n 19         };\n 20 };\n 21 \n 22 &amp;gpio1 {\n 23         status = \"okay\";\n 24 };\n</code></pre> 4. Agilex\u2122 5 specific board configuration -&gt;  intel_socfpga_agilex5_socdk.conf  <pre><code>  1 # Copyright (c) 2023, Intel Corporation.\n  2 # SPDX-License-Identifier: Apache-2.0\n  3 \n  4 CONFIG_STDOUT_CONSOLE=y\n  5 CONFIG_PRINTK=y\n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/basic/blinky.</p>"},{"location":"zephyr-embedded/gpio/gpio/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/basic/blinky  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/gpio/gpio/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nGPIO blinky application started\nGPIO toggle started for 10 times\nGPIO blinky Application completed!!!\n</code></pre>"},{"location":"zephyr-embedded/gpio/gpio/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/gpio/gpio/#other-consideration","title":"Other Consideration","text":"<p>Pinmux configuration should be in GPIO mode to use respective IO functionality.</p>"},{"location":"zephyr-embedded/psci/psci/","title":"Power State Coordination Interface (PSCI) driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/psci/psci/#introduction","title":"Introduction","text":"<p>Power State Coordination Interface (PSCI) is an Arm\u00ae standard that describes a software interface for power management between and operating system and supervisory firmware. Refer to Arm PSCI Platform Design Document for the PSCI interface specification.</p> <p>The following diagram shows the interaction between Zephyr/OS and Secure Monitor firmware ATF BL31 for PSCI interface.</p> <p></p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/psci/psci/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/pm_cpu_ops/pm_cpu_ops_psci.c</p>"},{"location":"zephyr-embedded/psci/psci/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>This driver provides the cold and warm reset functionality.</li> <li>This driver/module also provides a shell interface via which user can issue cold/warm reset commands.</li> </ul>"},{"location":"zephyr-embedded/psci/psci/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_PM_CPU_OPS</p> <p></p> <p>CONFIG_PM_CPU_OPS_PSCI</p> <p></p>"},{"location":"zephyr-embedded/psci/psci/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the PSCI:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/psci/psci/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/qspi/qspi/","title":"QSPI Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/qspi/qspi/#introduction","title":"Introduction","text":"<p>The HPS has the capability to access serial NOR Flash connected to the SDM quad serial peripheral interface (SPI). The quad SPI flash controller supports standard SPI Flash devices as well as high-performance dual and quad SPI Flash devices.</p> <p>On power up, the SDM owns the QSPI controller. For the HPS to use the QSPI controller, the HPS must request ownership from the SDM.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>QSPI driver (Polling-based mechanism - Upstreamed): https://github.com/zephyrprojectrtos/zephyr/blob/main/drivers/flash/flash_cadence_qspi_nor.c</p> <p>QSPI driver (with Interrupt-based mechanism \u2013 Not yet Upstreamed): https://github.com/altera-opensource/zephyrsocfpga/blob/socfpga_rel_23.4/drivers/flash/flash_cadence_qspi_nor.c</p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supported Operations: Read, Write, Erase</li> </ul>"},{"location":"zephyr-embedded/qspi/qspi/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_FLASH</p> <p></p> <p>CONFIG_FLASH_CAD_QSPI_NOR</p> <p></p> <p>CONFIG_FLASH_PAGE_LAYOUT</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the QSPI: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/qspi/qspi/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/soc_flash_qspi.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <p>```   1  sample:   2   description: Cadence QSPI Driver sample application.   3   name: cdns_qspi_nor   4 tests:   5   sample.drivers.flash.soc_flash_qspi:   6     platform_allow:   7       - intel_socfpga_agilex5_socdk   8     integration_platforms:   9       - intel_socfpga_agilex5_socdk  10     tags:  11       - flash  12       - cdns  13     harness: console  14     harness_config:  15       fixture: external_flash  16       type: multi_line  17       ordered: true</p> <p>```</p> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <p><pre><code>  1 # Copyright (c) 2023, Intel Corporation.\n  2 # SPDX-License-Identifier: Apache-2.0\n  3 \n  4 # Misc\n  5 CONFIG_HEAP_MEM_POOL_SIZE=363840\n  6 \n  7 # Enable Flash\n  8 CONFIG_FLASH=y\n  9 CONFIG_FLASH_PAGE_LAYOUT=y\n 10 CONFIG_LOG=y\n</code></pre> 4. Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay <pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  * SPDX-License-Identifier: Apache-2.0\n  4  */\n  5\n  6 /* The overlay file should be used to enable any\n  7  * dts nodes required by this application for this\n  8  * board.\n  9  */\n 10\n 11 / {\n 12         aliases {\n 13                 qspi = &amp;qspi;\n 14         };\n 15 };\n 16\n 17 &amp;qspi {\n 18         status = \"okay\";\n 19 };\n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/soc_flash_qspi/src/main.c.</p>"},{"location":"zephyr-embedded/qspi/qspi/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/soc_flash_qspi/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/qspi/qspi/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n[00:00:00.219,000] &lt;inf&gt; clock_control_agilex5: Intel Agilex5 clock driver initialized!\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: Initializing Qspi\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: QSPI Capacity: 10000000\n[00:00:00.000,000] &lt;inf&gt; flash_cadence_ll: Flash size: 268435456 Bytes\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nQSPI flash driver test sample\nQSPI flash device block size = 100\nQSPI flash number of pages = 100000\nQSPI flash driver block size 100\nThe Page size of 100\nQSPI flash driver data erase successful....\nQSPI flash driver write completed....\nQSPI flash driver read completed....\nQSPI flash driver read verified\nQSPI flash driver data erase successful....\nQSPI flash driver read verified after erase....\nQSPI flash driver test sample completed....\n</code></pre>"},{"location":"zephyr-embedded/qspi/qspi/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/","title":"Reset Manager for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#introduction","title":"Introduction","text":"<p>The Reset Manager generates individual module reset signals. Each module takes its module reset signal from the Reset Manager and conditions it to match the reset requirements of that module. The reset controller is designed to work with the SDM, which acts as the software-controlled master reset for the HPS. </p> <p>The following diagram shows the Reset Manager connectivity with Agilex5 HPS.</p> <p></p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/commits/main/drivers/reset/reset_intel_socfpga.c.</p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Reset manager provides the capability to reset (bring it out of reset state) each peripheral in the system separately.</li> <li>It provides API to assert, de-assert, and toggle the reset line of each peripheral.</li> </ul>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_RESET</p> <p></p> <p>CONFIG_RESET_INTEL_SOCFPGA</p> <p></p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the Reset manager IP:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/reset_manager/reset_manager/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/seu/seu/","title":"Seu","text":"<p>Single Error Upset (SEU) Driver for Hard Processor System</p> <p>Last updated: September 03, 2024 </p> <p>Upstream Status: In Progress</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/seu/seu/#introduction","title":"Introduction","text":"<p>The SEU driver is meticulously crafted to fulfill a dual purpose within its operational framework. Its primary function lies in promptly detecting and reporting single event upsets errors to users. Additionally, this subsystem offers a streamlined mechanism for the deliberate insertion of errors.</p> <p>For more information, please refer to the Agilex5 SEU Mitigation.</p>"},{"location":"zephyr-embedded/seu/seu/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/pull/67097.</p>"},{"location":"zephyr-embedded/seu/seu/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Supports user register/unregister callback</li> <li>Support inject ECC error</li> <li>Support injects single/multibit errors</li> </ul>"},{"location":"zephyr-embedded/seu/seu/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SEU</p> <p></p> <p>CONFIG_SEU_INTEL_SOCFPGA</p> <p></p> <p>CONFIG_SEU_MAX_CLIENT</p> <p></p> <p>CONFIG_ MAX_TIMEOUT_MSECS</p> <p></p>"},{"location":"zephyr-embedded/seu/seu/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the SEU is at https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi.</p> <p></p>"},{"location":"zephyr-embedded/seu/seu/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"zephyr-embedded/smp/smp/","title":"SMP (Symmetric Multi-Processing) support for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/smp/smp/#introduction","title":"Introduction","text":"<p>SMP (Symmetric Multi-Processing) refers to running operating system on multiple CPU cores. Zephyr kernel supports SMP which can turn on and off the non-boot cores (aka secondary cores).</p> <p>Zephyr sends \u201cCPU_ON\u201d and \u201cCPU_OFF\u201d functions via PSCI SMC to ATF BL31 to turn on and off individual core. Zephyr supports CPU hot plug which provides public API and command line to turn on and off the individual core including both boot and non-boot cores during runtime. </p> <p>The below diagram shows HPS SMP flow (CPU_ON and CPU_OFF) supported by Zephyr:</p> <p>For More information please refer to the Intel Agilex 5 Hard Processor System Technical Reference Manual.</p>"},{"location":"zephyr-embedded/smp/smp/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/arch/arm64/core/smp.c</p>"},{"location":"zephyr-embedded/smp/smp/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Bring up secondary cores; power-on, initialize the secondary cores and make them ready to run as part of multi-core boot system.</li> </ul>"},{"location":"zephyr-embedded/smp/smp/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_SMP</p> <p></p> <p>CONFIG_MP_MAX_NUM_CPUS=4</p> <p></p>"},{"location":"zephyr-embedded/smp/smp/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the smp:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/smp/smp/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/timer/timer/","title":"General Purpose Timer Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/timer/timer/#introduction","title":"Introduction","text":"<p>The hard processor system (HPS) provides four 32-bit general-purpose timers. The timer generates an interrupt when the 32-bit binary count-down timer reaches zero.</p> <p>Each timer can operate in one-shot mode (alarm mode) or periodic mode.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/counter/counter_dw_timer.c.</p>"},{"location":"zephyr-embedded/timer/timer/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>The timer can be configured to run as a one-shot timer(alarm).</li> <li>The timer can be configured to run as a periodic timer.</li> <li>Run timer in free running mode.</li> <li>Stop Timer.</li> </ul>"},{"location":"zephyr-embedded/timer/timer/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_COUNTER_SNPS_DW</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the timer:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/timer/timer/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/counter/alarm.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: Counter RTC Driver Sample\n 3 tests:\n 4   sample.drivers.counter.alarm:\n 5     tags:\n 6       - drivers\n 7       - counter\n 8     harness: console\n 9     platform_allow:\n10       - nucleo_f746zg\n       .....   \n27       - stm32h573i_dk\n28     integration_platforms:\n29       - nucleo_f746zg\n30     harness_config:\n31       type: multi_line\n32       ordered: true\n33       regex:\n34         - \"Counter alarm sample\"\n35         - \"Set alarm in 2 sec\"\n36         - \"!!! Alarm !!!\"\n37         - \"Now: [2|3]\"\n38     depends_on: counter\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code> 1 CONFIG_PRINTK=y\n 2 CONFIG_COUNTER=y                     \n</code></pre> <ol> <li>Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay:</li> </ol> <p><pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6 \n  7 &amp;timer0 {\n  8         status = \"okay\";\n  9 };\n</code></pre> 4. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/counter/alarm/src/main.c.</p>"},{"location":"zephyr-embedded/timer/timer/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/counter/alarm  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/timer/timer/#output","title":"Output","text":"<pre><code>NOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nCounter alarm sample\n\nSet alarm in 2 sec (200000000 ticks)\n!!! Alarm !!!\nNow: 1\nSet alarm in 4 sec (400000000 ticks)\n</code></pre>"},{"location":"zephyr-embedded/timer/timer/#known-issues","title":"Known Issues","text":"<p>None known</p>"},{"location":"zephyr-embedded/uart/uart/","title":"UART Driver for Hard Processor System","text":"<p>Last updated: September 03, 2024 </p> <p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/uart/uart/#introduction","title":"Introduction","text":"<p>Universal Asynchronous Receiver/Transmitter (UART) that is part of the hardened Hard Processor System (HPS) of the FPGA performs parallel to serial data conversion from HPS CPU to device or serial-to-parallel data conversion from device to HPS CPU. The UART controllers are based on an industry standard 16550 UART controller.</p> <p>The below diagram represents block diagram of the UART controller connected with other components in the system.</p> <p></p> <p>Functional blocks:</p> <ul> <li>Slave interface: connects to APB bus.</li> <li>Register block: responsible for the main UART functionality including control, status, and interrupt generation.</li> <li>FIFO block: responsible for FIFO control and storage.</li> <li>Baud block generator: produces the transmitter and receiver baud clock along with the output reference clock signal.</li> <li>Serial transmitter: converts the parallel data-written to the UART-into serial form and adds all additional bits, as specified by the control register, for transmission. These serial data referred to as a character.</li> <li>Serial receiver: converts the serial data character-specified by the control register-receive in the UART to parallel form. This block controls, parity, framing and line break detection errors.</li> </ul> <p>For More information please refer to the following link:</p> <p>Agilex 5 Hard Processor System Technical Reference Manual</p>"},{"location":"zephyr-embedded/uart/uart/#features","title":"Features","text":"<ul> <li>Programmable character properties, such as number of data bits per character, optional parity bits, and number of stop bits.</li> <li>Automatic hardware flow control as per the 16750 standards.</li> <li>128-byte transmit and receive FIFO buffers.</li> <li>Transmit Holding Register Empty (THRE) interrupt mode.</li> <li>DMA controller handshaking interface.</li> <li>Parity error detection, Framing error detection and, Line break detection.</li> <li>Prioritized interrupt identification with different interrupt types.</li> </ul>"},{"location":"zephyr-embedded/uart/uart/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/commits/main/drivers/serial/uart_ns16550.c.</p>"},{"location":"zephyr-embedded/uart/uart/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Manage the asynchronous communication between HPS CPU and device, and vice versa.</li> <li>Supports Full Duplex communication and Polling/Interrupt based mechanism for data transfer. </li> <li>Supports 16 bytes FIFO with automatic hardware flow control (RTS and CTS lines).</li> </ul>"},{"location":"zephyr-embedded/uart/uart/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_UART_NS16550</p> <p></p> <p>CONFIG_UART_INTERRUPT_DRIVEN</p> <p></p> <p>CONFIG_UART_NS16550_ACCESS_WORD_ONLY</p> <p></p>"},{"location":"zephyr-embedded/uart/uart/#device-tree","title":"Device Tree","text":"<p>Example Device tree location to configure the uart:</p> <p>https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/uart/uart/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/uart/echo_bot.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <pre><code> 1 sample:\n 2   name: UART driver sample\n 3 tests:\n 4   sample.drivers.uart:\n 5     integration_platforms:\n 6       - qemu_x86\n 7     tags:\n 8       - serial\n 9       - uart\n10     filter: CONFIG_SERIAL and\n11             CONFIG_UART_INTERRUPT_DRIVEN and\n12             dt_chosen_enabled(\"zephyr,shell-uart\")\n13     harness: keyboard\n</code></pre> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <pre><code>  1 CONFIG_SERIAL=y\n  2 CONFIG_UART_INTERRUPT_DRIVEN=y\n</code></pre> <ol> <li>Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/uart/echo_bot/src/main.c.</li> </ol>"},{"location":"zephyr-embedded/uart/uart/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/uart/echo_bot/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/uart/uart/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nHello! I'm your echo bot.\nTell me something and press enter:\nEcho: hello there\n</code></pre>"},{"location":"zephyr-embedded/uart/uart/#known-issues","title":"Known Issues","text":"<p>None Known</p>"},{"location":"zephyr-embedded/watchdog/watchdog/","title":"Watchdog Timer Driver for Hard Processor System","text":"<p>Upstream Status: Upstreamed</p> <p>Devices supported: Agilex 5</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#introduction","title":"Introduction","text":"<p>The watchdog timer is used mainly to recover from system lockup that might be caused by software or system-related issues. </p> <p>The hard processor system (HPS) provides five Watchdog Timers based on synopsis designware.</p> <p>For more information, please refer to the following link: Agilex 5 Hard Processor System Technical Reference Manual</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-sources","title":"Driver Sources","text":"<p>The source code for this driver can be found at https://github.com/zephyrproject-rtos/zephyr/blob/main/drivers/watchdog/wdt_dw.c.</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-capabilities","title":"Driver Capabilities","text":"<ul> <li>Watchdog can be enabled/disabled in driver initialization when zephyr boots through Kconfig option.</li> <li>Enable/Disable watchdog interrupt when the timer expires.</li> <li>Watchdog Timers counts down from a preset value to zero, then performs one of the following user-configurable operations:     * Generates a system reset.     * Generates an interrupt, restarts the timer, and if the timer is not cleared before a second timeout occurs, generates a system reset Driver can be configured for one of the possible three use cases.</li> </ul>"},{"location":"zephyr-embedded/watchdog/watchdog/#kernel-configurations","title":"Kernel Configurations","text":"<p>CONFIG_ WDT_DW</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#device-tree","title":"Device Tree","text":"<p>Device tree location to configure the Watchdog:https://github.com/zephyrproject-rtos/zephyr/blob/main/dts/arm64/intel/intel_socfpga_agilex5.dtsi</p> <p></p>"},{"location":"zephyr-embedded/watchdog/watchdog/#driver-sample","title":"Driver Sample","text":"<p>The source code for the driver sample can be found at: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/watchdog.</p> <p>The most relevant files are: 1. Project yml -&gt; sample.yml:</p> <p>```   1 sample:   2   name: Watchdog Driver Sample   3 common:   4   tags:   5     - drivers   6     - watchdog   7   harness: console   8   harness_config:   9     type: multi_line  10     ordered: true  11     regex:  12       - \"Watchdog sample application\"  13       - \"Feeding watchdog...\"  14       - \"Waiting for reset...\"  15       - \"Watchdog sample application\"  16   depends_on: watchdog</p> <p>```</p> <ol> <li>Config overlay -&gt; prj.conf:</li> </ol> <p><pre><code>  1 CONFIG_LOG=y\n  2 CONFIG_LOG_MODE_IMMEDIATE=y\n  3 CONFIG_WDT_LOG_LEVEL_DBG=y\n  4 CONFIG_WATCHDOG=y\n  5 CONFIG_WDT_DISABLE_AT_BOOT=n\n</code></pre> 3. Specific board config -&gt; intel_socfpga_agilex5_socdk.conf  <pre><code>  1 CONFIG_WDT_DW_RESET_MODE=2\n  2 CONFIG_WDT_DW_PAUSE_BY_DBG=y\n</code></pre> 4. Device tree overlay -&gt; intel_socfpga_agilex5_socdk.overlay <pre><code>  1 /*\n  2  * Copyright (C) 2023 Intel Corporation\n  3  *\n  4  * SPDX-License-Identifier: Apache-2.0\n  5  */\n  6\n  7 / {\n  8         aliases {\n  9                 watchdog0 = &amp;watchdog0;\n 10         };\n 11 };\n 12\n 13 &amp;watchdog0 {\n 14         interrupt-parent = &lt;&amp;gic&gt;;\n 15         interrupts = &lt;GIC_SPI 117 IRQ_TYPE_LEVEL\n 16                         IRQ_DEFAULT_PRIORITY&gt;;\n 17         status = \"okay\";\n 18 };             \n</code></pre> 5. Source code: https://github.com/altera-opensource/zephyr-socfpga/blob/socfpga_rel_23.4/samples/drivers/watchdog/src/main.c.</p>"},{"location":"zephyr-embedded/watchdog/watchdog/#steps-to-build","title":"Steps to build","text":"<ol> <li>Execute the following commands: <pre><code>rm -rf agilex5\nwest build -b intel_socfpga_agilex5_socdk samples/drivers/watchdog/  -d agilex5\n</code></pre></li> </ol>"},{"location":"zephyr-embedded/watchdog/watchdog/#output","title":"Output","text":"<pre><code>NOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nWatchdog sample application\nAttempting to test pre-reset callback\nFeeding watchdog 5 times\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nWaiting for reset...\nHandled things..ready to reset\nNOTICE:  return = 0 Hz\nNOTICE:  mmc_clk = 200000000 Hz\nNOTICE:  SDMMC boot\nNOTICE:  BL2: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL2: Built : 18:22:43, Jul  2 2024\nNOTICE:  BL2: Booting BL31\nNOTICE:  BL31: Boot Core = 0\nNOTICE:  BL31: CPU ID = 81000000\nNOTICE:  BL31: v2.9.1(release):QPDS23.4_REL_GSRD_PR\nNOTICE:  BL31: Built : 18:22:43, Jul  2 2024\n*** Booting Zephyr OS build 33d4a115fbed ***\nSecondary CPU core 1 (MPID:0x100) is up\nSecondary CPU core 2 (MPID:0x200) is up\nSecondary CPU core 3 (MPID:0x300) is up\nWatchdog sample application\nAttempting to test pre-reset callback\nFeeding watchdog 5 times\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nFeeding watchdog...\nWaiting for reset...\n</code></pre>"},{"location":"zephyr-embedded/watchdog/watchdog/#known-issues","title":"Known Issues","text":"<p>None known</p>"}]}